# id;timestamp;commentText;codeText;commentWords;codeWords
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1531179852;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1531910483;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1532069817;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1532685069;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533063033;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533143718;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533295538;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533547893;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533738061;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,method,handle,handle,struct,getter,method,handles,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533815246;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name)___        if (getter != null) {_            return getter__        }__        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic getter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,getter,painless,lookup,lookup,runtime,getter,method,handle,receiver,class,name,if,getter,null,return,getter,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,getter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1544203947;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name)___        if (getter != null) {_            return getter__        }__        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic getter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,getter,painless,lookup,lookup,runtime,getter,method,handle,receiver,class,name,if,getter,null,return,getter,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,getter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1544544188;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name)___        if (getter != null) {_            return getter__        }__        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic getter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,getter,painless,lookup,lookup,runtime,getter,method,handle,receiver,class,name,if,getter,null,return,getter,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,getter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1544565998;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name)___        if (getter != null) {_            return getter__        }__        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic getter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,getter,painless,lookup,lookup,runtime,getter,method,handle,receiver,class,name,if,getter,null,return,getter,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,getter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1531179852;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.getJavaClassFromPainlessType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType, implMethod.owner.name,_                implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,get,java,class,from,painless,type,interface,class,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,impl,method,owner,name,impl,method,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1531910483;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.getJavaClassFromPainlessType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType,_                PainlessLookupUtility.anyTypeToPainlessTypeName(implMethod.target), implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,get,java,class,from,painless,type,interface,class,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,painless,lookup,utility,any,type,to,painless,type,name,impl,method,target,impl,method,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1532069817;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.getJavaClassFromPainlessType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType,_                PainlessLookupUtility.typeToCanonicalTypeName(implMethod.target), implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,get,java,class,from,painless,type,interface,class,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,impl,method,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1532685069;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.getJavaClassFromPainlessType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType,_                PainlessLookupUtility.typeToCanonicalTypeName(implMethod.target), implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,get,java,class,from,painless,type,interface,class,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,impl,method,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1533063033;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.getJavaClassFromPainlessType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType,_                PainlessLookupUtility.typeToCanonicalTypeName(implMethod.target), implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,get,java,class,from,painless,type,interface,class,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,impl,method,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1533143718;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.getJavaClassFromPainlessType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.typeParameters.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType,_                PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_                implMethod.javaMethod.getName(), receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,get,java,class,from,painless,type,interface,class,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,                                         Class<?> receiverClass, String name) throws Throwable;1533295538;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, String interfaceClass,_                                        Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.lookupPainlessClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.typeParameters.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, methodHandlesLookup, interfaceType,_                PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_                implMethod.javaMethod.getName(), receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,painless,method,interface,method,painless,lookup,lookup,painless,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,receiver,class
Def -> public static int listIndexNormalize(final List<?> value, int index);1524684173;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1529076503;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1531179852;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1531910483;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1532069817;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1532685069;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1533063033;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1533143718;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1533295538;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1533547893;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1533738061;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1533815246;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1544203947;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1544544188;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> public static int listIndexNormalize(final List<?> value, int index);1544565998;"Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.;public static int listIndexNormalize(final List<?> value, int index) {_        return index >= 0 ? index : value.size() + index__    };normalizes,the,idnex,into,a,code,list,by,flipping,negative,indexes,around,so,they,are,from,the,end,of,the,list;public,static,int,list,index,normalize,final,list,value,int,index,return,index,0,index,value,size,index
Def -> static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name);1524684173;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param definition the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            Struct struct = definition.RuntimeClassToStruct(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = definition.RuntimeClassToStruct(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,definition,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,definition,definition,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,struct,struct,definition,runtime,class,to,struct,clazz,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,definition,runtime,class,to,struct,iface,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name);1529076503;Looks up handle for a dynamic field getter (field load)_<p>_A dynamic field load for variable {@code x} of type {@code def} looks like:_{@code y = x.field}_<p>_The following field loads are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces._<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces._<li>The {@code length} field of an array._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted getter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching getter._<p>_@param definition the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            Struct struct = definition.RuntimeClassToStruct(clazz)___            if (struct != null) {_                MethodHandle handle = struct.getters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = definition.RuntimeClassToStruct(iface)___                if (struct != null) {_                    MethodHandle handle = struct.getters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (receiverClass.isArray() && "length".equals(name)) {_            _            return arrayLengthGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_GET, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_GET, 1, index)__            } catch (NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,getter,field,load,p,a,dynamic,field,load,for,variable,code,x,of,type,code,def,looks,like,code,y,x,field,p,the,following,field,loads,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,get,field,from,receiver,s,class,superclasses,interfaces,li,whitelisted,method,named,code,is,field,from,receiver,s,class,superclasses,interfaces,li,the,code,length,field,of,an,array,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,getter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,getter,p,param,definition,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,getter,definition,definition,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,struct,struct,definition,runtime,class,to,struct,clazz,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,definition,runtime,class,to,struct,iface,if,struct,null,method,handle,handle,struct,getters,get,name,if,handle,null,return,handle,if,receiver,class,is,array,length,equals,name,return,array,length,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1524684173;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1529076503;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1531179852;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1531910483;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1532069817;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1532685069;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1533063033;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1533143718;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1533295538;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1533547893;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1533738061;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1533815246;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1544203947;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1544544188;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> @SuppressWarnings("unchecked")     static <T extends Throwable> void rethrow(Throwable t) throws T;1544565998;Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:;@SuppressWarnings("unchecked")_    static <T extends Throwable> void rethrow(Throwable t) throws T {_        throw (T) t__    };hack,to,rethrow,unknown,exceptions,from,link,method,handle,invoke,exact;suppress,warnings,unchecked,static,t,extends,throwable,void,rethrow,throwable,t,throws,t,throw,t,t
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable;1533547893;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {_         Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__         PainlessMethod interfaceMethod = painlessLookup.lookupPainlessClass(interfaceType).functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.typeParameters.size()__         PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup,_                interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_                implMethod.javaMethod.getName(), receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,painless,method,interface,method,painless,lookup,lookup,painless,class,interface,type,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,receiver,class
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable;1533738061;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {_        Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType)__        if (interfaceMethod == null) {_            throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__        }_        int arity = interfaceMethod.typeParameters.size()__        PainlessMethod implMethod = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__        return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup,_                interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_                implMethod.javaMethod.getName(), 1)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,painless,method,interface,method,painless,lookup,lookup,functional,interface,painless,method,interface,type,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,return,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,1
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable;1533815246;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {_        Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__        if (interfaceType == null) {_            throw new IllegalArgumentException("type [" + interfaceClass + "] not found")__        }_        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType)__        if (interfaceMethod == null) {_            throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__        }_        int arity = interfaceMethod.typeParameters.size()__        PainlessMethod implMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)__        if (implMethod == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__        return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup,_            interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_            implMethod.javaMethod.getName(), 1)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,if,interface,type,null,throw,new,illegal,argument,exception,type,interface,class,not,found,painless,method,interface,method,painless,lookup,lookup,functional,interface,painless,method,interface,type,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,impl,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,return,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,1
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable;1544203947;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {_        Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__        if (interfaceType == null) {_            throw new IllegalArgumentException("type [" + interfaceClass + "] not found")__        }_        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType)__        if (interfaceMethod == null) {_            throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__        }_        int arity = interfaceMethod.typeParameters.size()__        PainlessMethod implMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)__        if (implMethod == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__        return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup,_            interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_            implMethod.javaMethod.getName(), 1)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,if,interface,type,null,throw,new,illegal,argument,exception,type,interface,class,not,found,painless,method,interface,method,painless,lookup,lookup,functional,interface,painless,method,interface,type,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,impl,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,return,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,1
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable;1544544188;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {_        Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__        if (interfaceType == null) {_            throw new IllegalArgumentException("type [" + interfaceClass + "] not found")__        }_        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType)__        if (interfaceMethod == null) {_            throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__        }_        int arity = interfaceMethod.typeParameters.size()__        PainlessMethod implMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)__        if (implMethod == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__        return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup,_            interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_            implMethod.javaMethod.getName(), 1)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,if,interface,type,null,throw,new,illegal,argument,exception,type,interface,class,not,found,painless,method,interface,method,painless,lookup,lookup,functional,interface,painless,method,interface,type,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,impl,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,return,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,1
Def -> static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable;1544565998;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {_        Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass)__        if (interfaceType == null) {_            throw new IllegalArgumentException("type [" + interfaceClass + "] not found")__        }_        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType)__        if (interfaceMethod == null) {_            throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__        }_        int arity = interfaceMethod.typeParameters.size()__        PainlessMethod implMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)__        if (implMethod == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__        return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup,_            interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass),_            implMethod.javaMethod.getName(), 1)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,class,interface,type,painless,lookup,canonical,type,name,to,type,interface,class,if,interface,type,null,throw,new,illegal,argument,exception,type,interface,class,not,found,painless,method,interface,method,painless,lookup,lookup,functional,interface,painless,method,interface,type,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,type,parameters,size,painless,method,impl,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,impl,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,return,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,painless,lookup,utility,type,to,canonical,type,name,impl,method,target,class,impl,method,java,method,get,name,1
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1524684173;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1529076503;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1531179852;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1531910483;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1532069817;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1532685069;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1533063033;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1533143718;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1533295538;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1533547893;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1533738061;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1533815246;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1544203947;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1544544188;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupIndexNormalize(Class<?> receiverClass);1544565998;Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support_negative offsets._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index_to use with array loads and array stores;static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_INDEX_NORMALIZE__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_INDEX_NORMALIZE__        }_        throw new IllegalArgumentException("Attempting to address a non-array-like type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,normalize,the,index,into,an,array,this,is,what,makes,lists,and,arrays,stored,in,code,def,support,negative,offsets,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,returns,the,normalized,index,to,use,with,array,loads,and,array,stores;static,method,handle,lookup,index,normalize,class,receiver,class,if,receiver,class,is,array,return,array,index,normalize,helper,array,index,normalizer,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,like,type,receiver,class,get,canonical,name,as,an,array
Def -> static Method lookupMethodInternal(Definition definition, Class<?> receiverClass, String name, int arity);1524684173;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params definition the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static Method lookupMethodInternal(Definition definition, Class<?> receiverClass, String name, int arity) {_        Definition.MethodKey key = new Definition.MethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            Struct struct = definition.RuntimeClassToStruct(clazz)___            if (struct != null) {_                Method method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = definition.RuntimeClassToStruct(iface)___                if (struct != null) {_                    Method method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,definition,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,method,lookup,method,internal,definition,definition,class,receiver,class,string,name,int,arity,definition,method,key,key,new,definition,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,struct,struct,definition,runtime,class,to,struct,clazz,if,struct,null,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,definition,runtime,class,to,struct,iface,if,struct,null,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static Method lookupMethodInternal(Definition definition, Class<?> receiverClass, String name, int arity);1529076503;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params definition the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static Method lookupMethodInternal(Definition definition, Class<?> receiverClass, String name, int arity) {_        Definition.MethodKey key = new Definition.MethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            Struct struct = definition.RuntimeClassToStruct(clazz)___            if (struct != null) {_                Method method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = definition.RuntimeClassToStruct(iface)___                if (struct != null) {_                    Method method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,definition,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,method,lookup,method,internal,definition,definition,class,receiver,class,string,name,int,arity,definition,method,key,key,new,definition,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,struct,struct,definition,runtime,class,to,struct,clazz,if,struct,null,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,definition,runtime,class,to,struct,iface,if,struct,null,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1531179852;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        PainlessMethodKey key = new PainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,painless,method,key,key,new,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1531910483;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1532069817;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1532685069;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1533063033;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1533143718;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1533295538;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1533547893;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity);1533738061;Looks up method entry for a dynamic method call._<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns the matching method._<p>_@params painlessLookup the whitelist_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param arity arity of method_@return matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found.;static PainlessMethod lookupMethodInternal(PainlessLookup painlessLookup, Class<?> receiverClass, String name, int arity) {_        String key = PainlessLookupUtility.buildPainlessMethodKey(name, arity)__        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                PainlessMethod method = struct.methods.get(key)__                if (method != null) {_                    return method__                }_            }__            for (Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    PainlessMethod method = struct.methods.get(key)__                    if (method != null) {_                        return method__                    }_                }_            }_        }__        throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with [" + arity + "] arguments " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,method,entry,for,a,dynamic,method,call,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,the,matching,method,p,params,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,arity,arity,of,method,return,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found;static,painless,method,lookup,method,internal,painless,lookup,painless,lookup,class,receiver,class,string,name,int,arity,string,key,painless,lookup,utility,build,painless,method,key,name,arity,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,for,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,painless,method,method,struct,methods,get,key,if,method,null,return,method,throw,new,illegal,argument,exception,unable,to,find,dynamic,method,name,with,arity,arguments,for,class,receiver,class,get,canonical,name
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1524684173;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1529076503;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1531179852;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1531910483;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1532069817;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1532685069;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1533063033;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1533143718;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1533295538;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1533547893;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1533738061;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1533815246;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1544203947;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1544544188;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> public static Object mapIndexNormalize(final Map<?, ?> value, Object index);1544565998;"Normalizes" the index into a {@code Map} by making no change to the index.;public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {_        return index__    };normalizes,the,index,into,a,code,map,by,making,no,change,to,the,index;public,static,object,map,index,normalize,final,map,value,object,index,return,index
Def -> static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name);1524684173;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param definition the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            Struct struct = definition.RuntimeClassToStruct(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = definition.RuntimeClassToStruct(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,definition,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,definition,definition,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,struct,struct,definition,runtime,class,to,struct,clazz,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,definition,runtime,class,to,struct,iface,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name);1529076503;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param definition the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            Struct struct = definition.RuntimeClassToStruct(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = definition.RuntimeClassToStruct(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,definition,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,definition,definition,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,struct,struct,definition,runtime,class,to,struct,clazz,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,definition,runtime,class,to,struct,iface,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1524684173;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1529076503;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1531179852;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1531910483;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1532069817;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1532685069;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1533063033;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1533143718;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1533295538;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1533547893;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1533738061;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1533815246;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1544203947;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1544544188;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayStore(Class<?> receiverClass);1544565998;Returns a method handle to do an array store._@param receiverClass Class of the array to store the value in_@return a MethodHandle that accepts the receiver as first argument, the index as second argument,_and the value to set as 3rd argument. Return value is undefined and should be ignored.;static MethodHandle lookupArrayStore(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementSetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_PUT__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_SET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,store,param,receiver,class,class,of,the,array,to,store,the,value,in,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,and,the,value,to,set,as,3rd,argument,return,value,is,undefined,and,should,be,ignored;static,method,handle,lookup,array,store,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,setter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> private static MethodHandle lookupReferenceInternal(Definition definition, Lookup lookup,             Definition.Type clazz, String type, String call, Class<?>... captures)             throws Throwable;1524684173;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(Definition definition, Lookup lookup,_            Definition.Type clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             Method interfaceMethod = clazz.struct.functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                                                    "to [" + clazz.name + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = lookup.findStaticGetter(lookup.lookupClass(),_                                                                 getUserFunctionHandleFieldName(call, arity),_                                                                 MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz.clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz.clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = new FunctionRef(definition, clazz.clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             lookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz.clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,definition,definition,lookup,lookup,definition,type,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,method,interface,method,clazz,struct,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,clazz,name,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,lookup,find,static,getter,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,clazz,interface,method,call,handle,type,captures,length,else,ref,new,function,ref,definition,clazz,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(Definition definition, Lookup lookup,             Definition.Type clazz, String type, String call, Class<?>... captures)             throws Throwable;1529076503;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(Definition definition, Lookup lookup,_            Definition.Type clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             Method interfaceMethod = clazz.struct.functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                                                    "to [" + clazz.name + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = lookup.findStaticGetter(lookup.lookupClass(),_                                                                 getUserFunctionHandleFieldName(call, arity),_                                                                 MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz.clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz.clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = new FunctionRef(definition, clazz.clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             lookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz.clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,definition,definition,lookup,lookup,definition,type,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,method,interface,method,clazz,struct,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,clazz,name,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,lookup,find,static,getter,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,clazz,interface,method,call,handle,type,captures,length,else,ref,new,function,ref,definition,clazz,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,clazz,captures
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1531179852;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.arguments.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookup.ClassToName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,class,to,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1531910483;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.arguments.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.anyTypeToPainlessTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,any,type,to,painless,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1532069817;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.arguments.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1532685069;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.arguments.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1533063033;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.arguments.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1533143718;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,                                      Class<?> receiverClass, String name, Object args[]) throws Throwable;1533295538;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType,_                                     Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1531179852;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1531910483;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1532069817;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setters.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setters.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,setters,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1532685069;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533063033;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533143718;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.getPainlessStructFromJavaClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,get,painless,struct,from,java,class,clazz,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,get,painless,struct,from,java,class,iface,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533295538;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533547893;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533738061;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        for (Class<?> clazz = receiverClass_ clazz != null_ clazz = clazz.getSuperclass()) {_            PainlessClass struct = painlessLookup.lookupPainlessClass(clazz)___            if (struct != null) {_                MethodHandle handle = struct.setterMethodHandles.get(name)__                if (handle != null) {_                    return handle__                }_            }__            for (final Class<?> iface : clazz.getInterfaces()) {_                struct = painlessLookup.lookupPainlessClass(iface)___                if (struct != null) {_                    MethodHandle handle = struct.setterMethodHandles.get(name)__                    if (handle != null) {_                        return handle__                    }_                }_            }_        }_        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException( "Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException("Unable to find dynamic field [" + name + "] " +_                                           "for class [" + receiverClass.getCanonicalName() + "].")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,for,class,clazz,receiver,class,clazz,null,clazz,clazz,get,superclass,painless,class,struct,painless,lookup,lookup,painless,class,clazz,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,for,final,class,iface,clazz,get,interfaces,struct,painless,lookup,lookup,painless,class,iface,if,struct,null,method,handle,handle,struct,setter,method,handles,get,name,if,handle,null,return,handle,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,unable,to,find,dynamic,field,name,for,class,receiver,class,get,canonical,name
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1533815246;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name)___        if (setter != null) {_            return setter__        }__        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic getter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,setter,painless,lookup,lookup,runtime,setter,method,handle,receiver,class,name,if,setter,null,return,setter,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,getter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1544203947;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name)___        if (setter != null) {_            return setter__        }__        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic setter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,setter,painless,lookup,lookup,runtime,setter,method,handle,receiver,class,name,if,setter,null,return,setter,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,setter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1544544188;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name)___        if (setter != null) {_            return setter__        }__        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic setter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,setter,painless,lookup,lookup,runtime,setter,method,handle,receiver,class,name,if,setter,null,return,setter,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,setter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name);1544565998;Looks up handle for a dynamic field setter (field store)_<p>_A dynamic field store for variable {@code x} of type {@code def} looks like:_{@code x.field = y}_<p>_The following field stores are allowed:_<ul>_<li>Whitelisted {@code field} from receiver's class or any superclasses._<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces._<li>The value corresponding to a map key named {@code field} when the receiver is a Map._<li>The value in a list at element {@code field} (integer) when the receiver is a List._</ul>_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted setter. If one is not found, it throws an exception._Otherwise it returns a handle to the matching setter._<p>_@param painlessLookup the whitelist_@param receiverClass Class of the object to retrieve the field from._@param name Name of the field._@return pointer to matching field. never returns null._@throws IllegalArgumentException if no matching whitelisted field was found.;static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {_        _        MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name)___        if (setter != null) {_            return setter__        }__        _        if (Map.class.isAssignableFrom(receiverClass)) {_            _            _            return MethodHandles.insertArguments(MAP_PUT, 1, name)__        } else if (List.class.isAssignableFrom(receiverClass)) {_            _            _            _            try {_                int index = Integer.parseInt(name)__                return MethodHandles.insertArguments(LIST_SET, 1, index)__            } catch (final NumberFormatException exception) {_                throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].")__            }_        }__        throw new IllegalArgumentException(_                "dynamic setter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found")__    };looks,up,handle,for,a,dynamic,field,setter,field,store,p,a,dynamic,field,store,for,variable,code,x,of,type,code,def,looks,like,code,x,field,y,p,the,following,field,stores,are,allowed,ul,li,whitelisted,code,field,from,receiver,s,class,or,any,superclasses,li,whitelisted,method,named,code,set,field,from,receiver,s,class,superclasses,interfaces,li,the,value,corresponding,to,a,map,key,named,code,field,when,the,receiver,is,a,map,li,the,value,in,a,list,at,element,code,field,integer,when,the,receiver,is,a,list,ul,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,setter,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,setter,p,param,painless,lookup,the,whitelist,param,receiver,class,class,of,the,object,to,retrieve,the,field,from,param,name,name,of,the,field,return,pointer,to,matching,field,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,field,was,found;static,method,handle,lookup,setter,painless,lookup,painless,lookup,class,receiver,class,string,name,method,handle,setter,painless,lookup,lookup,runtime,setter,method,handle,receiver,class,name,if,setter,null,return,setter,if,map,class,is,assignable,from,receiver,class,return,method,handles,insert,arguments,1,name,else,if,list,class,is,assignable,from,receiver,class,try,int,index,integer,parse,int,name,return,method,handles,insert,arguments,1,index,catch,final,number,format,exception,exception,throw,new,illegal,argument,exception,illegal,list,shortcut,value,name,throw,new,illegal,argument,exception,dynamic,setter,type,to,canonical,type,name,receiver,class,name,not,found
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1524684173;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1529076503;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1531179852;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1531910483;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1532069817;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1532685069;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1533063033;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1533143718;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> public static String getUserFunctionHandleFieldName(String name, int arity);1533295538;gets the field name used to lookup up the MethodHandle for a function.;public static String getUserFunctionHandleFieldName(String name, int arity) {_         return "handle$" + name + "$" + arity__     };gets,the,field,name,used,to,lookup,up,the,method,handle,for,a,function;public,static,string,get,user,function,handle,field,name,string,name,int,arity,return,handle,name,arity
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1524684173;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1529076503;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1531179852;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1531910483;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1532069817;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1532685069;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1533063033;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1533143718;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1533295538;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1533547893;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1533738061;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1533815246;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1544203947;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1544544188;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupIterator(Class<?> receiverClass);1544565998;Returns a method handle to do iteration (for enhanced for loop)_@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, returns iterator;static MethodHandle lookupIterator(Class<?> receiverClass) {_        if (Iterable.class.isAssignableFrom(receiverClass)) {_            return ITERATOR__        } else if (receiverClass.isArray()) {_            return ArrayIteratorHelper.newIterator(receiverClass)__        } else {_            throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]")__        }_    };returns,a,method,handle,to,do,iteration,for,enhanced,for,loop,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,returns,iterator;static,method,handle,lookup,iterator,class,receiver,class,if,iterable,class,is,assignable,from,receiver,class,return,iterator,else,if,receiver,class,is,array,return,array,iterator,helper,new,iterator,receiver,class,else,throw,new,illegal,argument,exception,cannot,iterate,over,receiver,class,get,canonical,name
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])             throws Throwable;1533547893;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])_            throws Throwable {__         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      localMethods,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              localMethods,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,local,methods,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])             throws Throwable;1533738061;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])_            throws Throwable {__         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(painlessLookup, receiverClass, name, numArguments - 1).methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = lookupMethodInternal(painlessLookup, receiverClass, name, arity)__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      localMethods,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      numCaptures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     Class<?> captures[] = new Class<?>[numCaptures]__                     for (int capture = 0_ capture < captures.length_ capture++) {_                         captures[capture] = callSiteType.parameterType(i + 1 + capture)__                     }_                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              localMethods,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,painless,lookup,receiver,class,name,num,arguments,1,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,lookup,method,internal,painless,lookup,receiver,class,name,arity,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,type,call,num,captures,else,if,signature,char,at,0,d,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,local,methods,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])             throws Throwable;1533815246;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])_            throws Throwable {__         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             PainlessMethod painlessMethod =  painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, numArguments - 1)___             if (painlessMethod == null) {_                 throw new IllegalArgumentException("dynamic method " +_                         "[" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + (numArguments - 1) + "] not found")__             }__             return painlessMethod.methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)___        if (method == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      localMethods,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      numCaptures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     Class<?> captures[] = new Class<?>[numCaptures]__                     for (int capture = 0_ capture < captures.length_ capture++) {_                         captures[capture] = callSiteType.parameterType(i + 1 + capture)__                     }_                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              localMethods,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,painless,method,painless,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,num,arguments,1,if,painless,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,num,arguments,1,not,found,return,painless,method,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,type,call,num,captures,else,if,signature,char,at,0,d,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,local,methods,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])             throws Throwable;1544203947;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])_            throws Throwable {__         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             PainlessMethod painlessMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, numArguments - 1)___             if (painlessMethod == null) {_                 throw new IllegalArgumentException("dynamic method " +_                         "[" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + (numArguments - 1) + "] not found")__             }__             return painlessMethod.methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)___        if (method == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      localMethods,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      numCaptures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     Class<?> captures[] = new Class<?>[numCaptures]__                     for (int capture = 0_ capture < captures.length_ capture++) {_                         captures[capture] = callSiteType.parameterType(i + 1 + capture)__                     }_                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              localMethods,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,painless,method,painless,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,num,arguments,1,if,painless,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,num,arguments,1,not,found,return,painless,method,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,type,call,num,captures,else,if,signature,char,at,0,d,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,local,methods,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])             throws Throwable;1544544188;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])_            throws Throwable {__         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             PainlessMethod painlessMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, numArguments - 1)___             if (painlessMethod == null) {_                 throw new IllegalArgumentException("dynamic method " +_                         "[" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + (numArguments - 1) + "] not found")__             }__             return painlessMethod.methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)___        if (method == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      localMethods,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      numCaptures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     Class<?> captures[] = new Class<?>[numCaptures]__                     for (int capture = 0_ capture < captures.length_ capture++) {_                         captures[capture] = callSiteType.parameterType(i + 1 + capture)__                     }_                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              localMethods,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,painless,method,painless,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,num,arguments,1,if,painless,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,num,arguments,1,not,found,return,painless,method,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,type,call,num,captures,else,if,signature,char,at,0,d,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,local,methods,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])             throws Throwable;1544565998;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param painlessLookup the whitelist_@param methodHandlesLookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object args[])_            throws Throwable {__         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             PainlessMethod painlessMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, numArguments - 1)___             if (painlessMethod == null) {_                 throw new IllegalArgumentException("dynamic method " +_                         "[" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + (numArguments - 1) + "] not found")__             }__             return painlessMethod.methodHandle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         PainlessMethod method = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity)___        if (method == null) {_            throw new IllegalArgumentException(_                    "dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found")__        }__         MethodHandle handle = method.methodHandle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 MethodHandle filter__                 Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced)__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(painlessLookup,_                                                      localMethods,_                                                      methodHandlesLookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      numCaptures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     Class<?> captures[] = new Class<?>[numCaptures]__                     for (int capture = 0_ capture < captures.length_ capture++) {_                         captures[capture] = callSiteType.parameterType(i + 1 + capture)__                     }_                     MethodType nestedType = MethodType.methodType(interfaceType, captures)__                     CallSite nested = DefBootstrap.bootstrap(painlessLookup,_                                                              localMethods,_                                                              methodHandlesLookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              PainlessLookupUtility.typeToCanonicalTypeName(interfaceType))__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,painless,lookup,the,whitelist,param,method,handles,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,painless,method,painless,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,num,arguments,1,if,painless,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,num,arguments,1,not,found,return,painless,method,method,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,painless,method,method,painless,lookup,lookup,runtime,painless,method,receiver,class,name,arity,if,method,null,throw,new,illegal,argument,exception,dynamic,method,type,to,canonical,type,name,receiver,class,name,arity,not,found,method,handle,handle,method,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,method,handle,filter,class,interface,type,method,type,parameters,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,painless,lookup,local,methods,method,handles,lookup,interface,type,type,call,num,captures,else,if,signature,char,at,0,d,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,type,nested,type,method,type,method,type,interface,type,captures,call,site,nested,def,bootstrap,bootstrap,painless,lookup,local,methods,method,handles,lookup,call,nested,type,0,def,bootstrap,reference,painless,lookup,utility,type,to,canonical,type,name,interface,type,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1524684173;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1529076503;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1531179852;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1531910483;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1532069817;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1532685069;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1533063033;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1533143718;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1533295538;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1533547893;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1533738061;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1533815246;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1544203947;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1544544188;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle arrayLengthGetter(Class<?> arrayType);1544565998;Returns an array length getter MethodHandle for the given array type;static MethodHandle arrayLengthGetter(Class<?> arrayType) {_        if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {_            try {_                return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType)__            } catch (Throwable t) {_                rethrow(t)__                throw new AssertionError(t)__            }_        } else {_            return ArrayLengthHelper.arrayLengthGetter(arrayType)__        }_    };returns,an,array,length,getter,method,handle,for,the,given,array,type;static,method,handle,array,length,getter,class,array,type,if,null,try,return,method,handle,invoke,exact,array,type,catch,throwable,t,rethrow,t,throw,new,assertion,error,t,else,return,array,length,helper,array,length,getter,array,type
Def -> static MethodHandle lookupMethod(Definition definition, Lookup lookup, MethodType callSiteType,              Class<?> receiverClass, String name, Object args[]) throws Throwable;1524684173;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param definition the whitelist_@param lookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(Definition definition, Lookup lookup, MethodType callSiteType,_             Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(definition, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         Method method = lookupMethodInternal(definition, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Definition.Type interfaceType = definition.ClassToType(method.arguments.get(i - 1 - replaced))__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(definition,_                                                      lookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType.clazz, captures)__                     CallSite nested = DefBootstrap.bootstrap(definition,_                                                              lookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              interfaceType.name)__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,definition,the,whitelist,param,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,definition,definition,lookup,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,definition,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,method,method,lookup,method,internal,definition,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,definition,type,interface,type,definition,class,to,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,definition,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,clazz,captures,call,site,nested,def,bootstrap,bootstrap,definition,lookup,call,nested,type,0,def,bootstrap,reference,interface,type,name,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupMethod(Definition definition, Lookup lookup, MethodType callSiteType,              Class<?> receiverClass, String name, Object args[]) throws Throwable;1529076503;Looks up handle for a dynamic method call, with lambda replacement_<p>_A dynamic method call for variable {@code x} of type {@code def} looks like:_{@code x.method(args...)}_<p>_This method traverses {@code recieverClass}'s class hierarchy (including interfaces)_until it finds a matching whitelisted method. If one is not found, it throws an exception._Otherwise it returns a handle to the matching method._<p>_@param definition the whitelist_@param lookup caller's lookup_@param callSiteType callsite's type_@param receiverClass Class of the object to invoke the method on._@param name Name of the method._@param args bootstrap args passed to callsite_@return pointer to matching method to invoke. never returns null._@throws IllegalArgumentException if no matching whitelisted method was found._@throws Throwable if a method reference cannot be converted to an functional interface;static MethodHandle lookupMethod(Definition definition, Lookup lookup, MethodType callSiteType,_             Class<?> receiverClass, String name, Object args[]) throws Throwable {_         String recipeString = (String) args[0]__         int numArguments = callSiteType.parameterCount()__         _         if (recipeString.isEmpty()) {_             return lookupMethodInternal(definition, receiverClass, name, numArguments - 1).handle__         }__         _         BitSet lambdaArgs = new BitSet(recipeString.length())__         for (int i = 0_ i < recipeString.length()_ i++) {_             lambdaArgs.set(recipeString.charAt(i))__         }__         _         _         int arity = callSiteType.parameterCount() - 1__         int upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             if (lambdaArgs.get(i - 1)) {_                 String signature = (String) args[upTo++]__                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1))__                 arity -= numCaptures__             }_         }__         _         _         Method method = lookupMethodInternal(definition, receiverClass, name, arity)__         MethodHandle handle = method.handle___         int replaced = 0__         upTo = 1__         for (int i = 1_ i < numArguments_ i++) {_             _             if (lambdaArgs.get(i - 1)) {_                 _                 String signature = (String) args[upTo++]__                 int separator = signature.lastIndexOf('.')__                 int separator2 = signature.indexOf(',')__                 String type = signature.substring(1, separator)__                 String call = signature.substring(separator+1, separator2)__                 int numCaptures = Integer.parseInt(signature.substring(separator2+1))__                 Class<?> captures[] = new Class<?>[numCaptures]__                 for (int capture = 0_ capture < captures.length_ capture++) {_                     captures[capture] = callSiteType.parameterType(i + 1 + capture)__                 }_                 MethodHandle filter__                 Definition.Type interfaceType = definition.ClassToType(method.arguments.get(i - 1 - replaced))__                 if (signature.charAt(0) == 'S') {_                     _                     _                     filter = lookupReferenceInternal(definition,_                                                      lookup,_                                                      interfaceType,_                                                      type,_                                                      call,_                                                      captures)__                 } else if (signature.charAt(0) == 'D') {_                     _                     _                     _                     MethodType nestedType = MethodType.methodType(interfaceType.clazz, captures)__                     CallSite nested = DefBootstrap.bootstrap(definition,_                                                              lookup,_                                                              call,_                                                              nestedType,_                                                              0,_                                                              DefBootstrap.REFERENCE,_                                                              interfaceType.name)__                     filter = nested.dynamicInvoker()__                 } else {_                     throw new AssertionError()__                 }_                 _                 filter = MethodHandles.dropArguments(filter, 0, String.class)__                 handle = MethodHandles.collectArguments(handle, i, filter)__                 i += numCaptures__                 replaced += numCaptures__             }_         }__         return handle__     };looks,up,handle,for,a,dynamic,method,call,with,lambda,replacement,p,a,dynamic,method,call,for,variable,code,x,of,type,code,def,looks,like,code,x,method,args,p,this,method,traverses,code,reciever,class,s,class,hierarchy,including,interfaces,until,it,finds,a,matching,whitelisted,method,if,one,is,not,found,it,throws,an,exception,otherwise,it,returns,a,handle,to,the,matching,method,p,param,definition,the,whitelist,param,lookup,caller,s,lookup,param,call,site,type,callsite,s,type,param,receiver,class,class,of,the,object,to,invoke,the,method,on,param,name,name,of,the,method,param,args,bootstrap,args,passed,to,callsite,return,pointer,to,matching,method,to,invoke,never,returns,null,throws,illegal,argument,exception,if,no,matching,whitelisted,method,was,found,throws,throwable,if,a,method,reference,cannot,be,converted,to,an,functional,interface;static,method,handle,lookup,method,definition,definition,lookup,lookup,method,type,call,site,type,class,receiver,class,string,name,object,args,throws,throwable,string,recipe,string,string,args,0,int,num,arguments,call,site,type,parameter,count,if,recipe,string,is,empty,return,lookup,method,internal,definition,receiver,class,name,num,arguments,1,handle,bit,set,lambda,args,new,bit,set,recipe,string,length,for,int,i,0,i,recipe,string,length,i,lambda,args,set,recipe,string,char,at,i,int,arity,call,site,type,parameter,count,1,int,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,num,captures,integer,parse,int,signature,substring,signature,index,of,1,arity,num,captures,method,method,lookup,method,internal,definition,receiver,class,name,arity,method,handle,handle,method,handle,int,replaced,0,up,to,1,for,int,i,1,i,num,arguments,i,if,lambda,args,get,i,1,string,signature,string,args,up,to,int,separator,signature,last,index,of,int,separator2,signature,index,of,string,type,signature,substring,1,separator,string,call,signature,substring,separator,1,separator2,int,num,captures,integer,parse,int,signature,substring,separator2,1,class,captures,new,class,num,captures,for,int,capture,0,capture,captures,length,capture,captures,capture,call,site,type,parameter,type,i,1,capture,method,handle,filter,definition,type,interface,type,definition,class,to,type,method,arguments,get,i,1,replaced,if,signature,char,at,0,s,filter,lookup,reference,internal,definition,lookup,interface,type,type,call,captures,else,if,signature,char,at,0,d,method,type,nested,type,method,type,method,type,interface,type,clazz,captures,call,site,nested,def,bootstrap,bootstrap,definition,lookup,call,nested,type,0,def,bootstrap,reference,interface,type,name,filter,nested,dynamic,invoker,else,throw,new,assertion,error,filter,method,handles,drop,arguments,filter,0,string,class,handle,method,handles,collect,arguments,handle,i,filter,i,num,captures,replaced,num,captures,return,handle
Def -> static MethodHandle lookupReference(Definition definition, Lookup lookup, String interfaceClass,             Class<?> receiverClass, String name) throws Throwable;1524684173;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(Definition definition, Lookup lookup, String interfaceClass,_            Class<?> receiverClass, String name) throws Throwable {_         Definition.Type interfaceType = definition.getType(interfaceClass)__         Method interfaceMethod = interfaceType.struct.functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         Method implMethod = lookupMethodInternal(definition, receiverClass, name, arity)__        return lookupReferenceInternal(definition, lookup, interfaceType, implMethod.owner.name,_                implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,definition,definition,lookup,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,definition,type,interface,type,definition,get,type,interface,class,method,interface,method,interface,type,struct,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,method,impl,method,lookup,method,internal,definition,receiver,class,name,arity,return,lookup,reference,internal,definition,lookup,interface,type,impl,method,owner,name,impl,method,name,receiver,class
Def -> static MethodHandle lookupReference(Definition definition, Lookup lookup, String interfaceClass,             Class<?> receiverClass, String name) throws Throwable;1529076503;Returns an implementation of interfaceClass that calls receiverClass.name_<p>_This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,_so we simply need to lookup the matching implementation method based on receiver type.;static MethodHandle lookupReference(Definition definition, Lookup lookup, String interfaceClass,_            Class<?> receiverClass, String name) throws Throwable {_         Definition.Type interfaceType = definition.getType(interfaceClass)__         Method interfaceMethod = interfaceType.struct.functionalMethod__         if (interfaceMethod == null) {_             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface")__         }_         int arity = interfaceMethod.arguments.size()__         Method implMethod = lookupMethodInternal(definition, receiverClass, name, arity)__        return lookupReferenceInternal(definition, lookup, interfaceType, implMethod.owner.name,_                implMethod.name, receiverClass)__     };returns,an,implementation,of,interface,class,that,calls,receiver,class,name,p,this,is,just,like,lambda,meta,factory,only,with,a,dynamic,type,the,interface,type,is,known,so,we,simply,need,to,lookup,the,matching,implementation,method,based,on,receiver,type;static,method,handle,lookup,reference,definition,definition,lookup,lookup,string,interface,class,class,receiver,class,string,name,throws,throwable,definition,type,interface,type,definition,get,type,interface,class,method,interface,method,interface,type,struct,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,class,interface,class,is,not,a,functional,interface,int,arity,interface,method,arguments,size,method,impl,method,lookup,method,internal,definition,receiver,class,name,arity,return,lookup,reference,internal,definition,lookup,interface,type,impl,method,owner,name,impl,method,name,receiver,class
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1531179852;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                                                    "to [" + PainlessLookup.ClassToName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = new FunctionRef(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,class,to,name,clazz,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,new,function,ref,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1531910483;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                         "to [" + PainlessLookupUtility.anyTypeToPainlessTypeName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = new FunctionRef(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,utility,any,type,to,painless,type,name,clazz,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,new,function,ref,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1532069817;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                         "to [" + PainlessLookupUtility.typeToCanonicalTypeName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = new FunctionRef(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,utility,type,to,canonical,type,name,clazz,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,new,function,ref,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1532685069;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                         "to [" + PainlessLookupUtility.typeToCanonicalTypeName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = new FunctionRef(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,utility,type,to,canonical,type,name,clazz,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,new,function,ref,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1533063033;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                         "to [" + PainlessLookupUtility.typeToCanonicalTypeName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.arguments.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.name +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = FunctionRef.resolveFromLookup(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,utility,type,to,canonical,type,name,clazz,not,a,functional,interface,int,arity,interface,method,arguments,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,function,ref,resolve,from,lookup,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1533143718;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.getPainlessStructFromJavaClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                         "to [" + PainlessLookupUtility.typeToCanonicalTypeName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.typeParameters.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.javaMethod.getName() +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = FunctionRef.resolveFromLookup(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,get,painless,struct,from,java,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,utility,type,to,canonical,type,name,clazz,not,a,functional,interface,int,arity,interface,method,type,parameters,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,java,method,get,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,function,ref,resolve,from,lookup,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,                                                         Class<?> clazz, String type, String call, Class<?>... captures)             throws Throwable;1533295538;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, MethodHandles.Lookup methodHandlesLookup,_                                                        Class<?> clazz, String type, String call, Class<?>... captures)_            throws Throwable {_         final FunctionRef ref__         if ("this".equals(type)) {_             _             PainlessMethod interfaceMethod = painlessLookup.lookupPainlessClass(clazz).functionalMethod__             if (interfaceMethod == null) {_                 throw new IllegalArgumentException("Cannot convert function reference [" + type + "::" + call + "] " +_                         "to [" + PainlessLookupUtility.typeToCanonicalTypeName(clazz) + "], not a functional interface")__             }_             int arity = interfaceMethod.typeParameters.size() + captures.length__             final MethodHandle handle__             try {_                 MethodHandle accessor = methodHandlesLookup.findStaticGetter(methodHandlesLookup.lookupClass(),_                                                                              getUserFunctionHandleFieldName(call, arity),_                                                                              MethodHandle.class)__                 handle = (MethodHandle)accessor.invokeExact()__             } catch (NoSuchFieldException | IllegalAccessException e) {_                 _                 _                 if (call.contains("$")) {_                     throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.javaMethod.getName() +_                                                        "] in [" + clazz + "]")__                 }_                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.")__             }_             ref = new FunctionRef(clazz, interfaceMethod, call, handle.type(), captures.length)__         } else {_             _             ref = FunctionRef.resolveFromLookup(painlessLookup, clazz, type, call, captures.length)__         }_         final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_             methodHandlesLookup,_             ref.interfaceMethodName,_             ref.factoryMethodType,_             ref.interfaceMethodType,_             ref.delegateClassName,_             ref.delegateInvokeType,_             ref.delegateMethodName,_             ref.delegateMethodType,_             ref.isDelegateInterface ? 1 : 0_         )__         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, captures))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,class,captures,throws,throwable,final,function,ref,ref,if,this,equals,type,painless,method,interface,method,painless,lookup,lookup,painless,class,clazz,functional,method,if,interface,method,null,throw,new,illegal,argument,exception,cannot,convert,function,reference,type,call,to,painless,lookup,utility,type,to,canonical,type,name,clazz,not,a,functional,interface,int,arity,interface,method,type,parameters,size,captures,length,final,method,handle,handle,try,method,handle,accessor,method,handles,lookup,find,static,getter,method,handles,lookup,lookup,class,get,user,function,handle,field,name,call,arity,method,handle,class,handle,method,handle,accessor,invoke,exact,catch,no,such,field,exception,illegal,access,exception,e,if,call,contains,throw,new,illegal,argument,exception,incorrect,number,of,parameters,for,interface,method,java,method,get,name,in,clazz,throw,new,illegal,argument,exception,unknown,call,call,with,arity,arguments,ref,new,function,ref,clazz,interface,method,call,handle,type,captures,length,else,ref,function,ref,resolve,from,lookup,painless,lookup,clazz,type,call,captures,length,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,captures
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable;1533738061;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {_        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures)__        final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_            methodHandlesLookup,_            ref.interfaceMethodName,_            ref.factoryMethodType,_            ref.interfaceMethodType,_            ref.delegateClassName,_            ref.delegateInvokeType,_            ref.delegateMethodName,_            ref.delegateMethodType,_            ref.isDelegateInterface ? 1 : 0_        )__        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,int,captures,throws,throwable,final,function,ref,ref,function,ref,create,painless,lookup,local,methods,null,clazz,type,call,captures,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,ref,factory,method,type,parameter,array
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable;1533815246;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {_        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures)__        final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_            methodHandlesLookup,_            ref.interfaceMethodName,_            ref.factoryMethodType,_            ref.interfaceMethodType,_            ref.delegateClassName,_            ref.delegateInvokeType,_            ref.delegateMethodName,_            ref.delegateMethodType,_            ref.isDelegateInterface ? 1 : 0_        )__        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,int,captures,throws,throwable,final,function,ref,ref,function,ref,create,painless,lookup,local,methods,null,clazz,type,call,captures,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,ref,factory,method,type,parameter,array
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable;1544203947;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {_        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures)__        final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_            methodHandlesLookup,_            ref.interfaceMethodName,_            ref.factoryMethodType,_            ref.interfaceMethodType,_            ref.delegateClassName,_            ref.delegateInvokeType,_            ref.delegateMethodName,_            ref.delegateMethodType,_            ref.isDelegateInterface ? 1 : 0_        )__        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,int,captures,throws,throwable,final,function,ref,ref,function,ref,create,painless,lookup,local,methods,null,clazz,type,call,captures,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,ref,factory,method,type,parameter,array
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable;1544544188;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {_        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures)__        final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_            methodHandlesLookup,_            ref.interfaceMethodName,_            ref.factoryMethodType,_            ref.interfaceMethodType,_            ref.delegateClassName,_            ref.delegateInvokeType,_            ref.delegateMethodName,_            ref.delegateMethodType,_            ref.isDelegateInterface ? 1 : 0_        )__        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,int,captures,throws,throwable,final,function,ref,ref,function,ref,create,painless,lookup,local,methods,null,clazz,type,call,captures,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,ref,factory,method,type,parameter,array
Def -> private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,             MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable;1544565998;Returns a method handle to an implementation of clazz, given method reference signature.;private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods,_            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {_        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures)__        final CallSite callSite = LambdaBootstrap.lambdaBootstrap(_            methodHandlesLookup,_            ref.interfaceMethodName,_            ref.factoryMethodType,_            ref.interfaceMethodType,_            ref.delegateClassName,_            ref.delegateInvokeType,_            ref.delegateMethodName,_            ref.delegateMethodType,_            ref.isDelegateInterface ? 1 : 0_        )__        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()))__     };returns,a,method,handle,to,an,implementation,of,clazz,given,method,reference,signature;private,static,method,handle,lookup,reference,internal,painless,lookup,painless,lookup,map,string,local,method,local,methods,method,handles,lookup,method,handles,lookup,class,clazz,string,type,string,call,int,captures,throws,throwable,final,function,ref,ref,function,ref,create,painless,lookup,local,methods,null,clazz,type,call,captures,final,call,site,call,site,lambda,bootstrap,lambda,bootstrap,method,handles,lookup,ref,interface,method,name,ref,factory,method,type,ref,interface,method,type,ref,delegate,class,name,ref,delegate,invoke,type,ref,delegate,method,name,ref,delegate,method,type,ref,is,delegate,interface,1,0,return,call,site,dynamic,invoker,as,type,method,type,method,type,clazz,ref,factory,method,type,parameter,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1524684173;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1529076503;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1531179852;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1531910483;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1532069817;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1532685069;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1533063033;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1533143718;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1533295538;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1533547893;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1533738061;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1533815246;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1544203947;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1544544188;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
Def -> static MethodHandle lookupArrayLoad(Class<?> receiverClass);1544565998;Returns a method handle to do an array load._@param receiverClass Class of the array to load the value from_@return a MethodHandle that accepts the receiver as first argument, the index as second argument._It returns the loaded value.;static MethodHandle lookupArrayLoad(Class<?> receiverClass) {_        if (receiverClass.isArray()) {_            return MethodHandles.arrayElementGetter(receiverClass)__        } else if (Map.class.isAssignableFrom(receiverClass)) {_            _            return MAP_GET__        } else if (List.class.isAssignableFrom(receiverClass)) {_            return LIST_GET__        }_        throw new IllegalArgumentException("Attempting to address a non-array type " +_                                           "[" + receiverClass.getCanonicalName() + "] as an array.")__    };returns,a,method,handle,to,do,an,array,load,param,receiver,class,class,of,the,array,to,load,the,value,from,return,a,method,handle,that,accepts,the,receiver,as,first,argument,the,index,as,second,argument,it,returns,the,loaded,value;static,method,handle,lookup,array,load,class,receiver,class,if,receiver,class,is,array,return,method,handles,array,element,getter,receiver,class,else,if,map,class,is,assignable,from,receiver,class,return,else,if,list,class,is,assignable,from,receiver,class,return,throw,new,illegal,argument,exception,attempting,to,address,a,non,array,type,receiver,class,get,canonical,name,as,an,array
