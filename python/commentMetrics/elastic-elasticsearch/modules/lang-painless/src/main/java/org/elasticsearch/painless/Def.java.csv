commented;modifiers;parameterAmount;loc;comment;code
false;static;1;1;;static int getArrayLength(final boolean[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final byte[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final short[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final int[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final long[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final char[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final float[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final double[] array) {     return array.length. }
false;static;1;1;;static int getArrayLength(final Object[] array) {     return array.length. }
false;static;1;8;;static MethodHandle arrayLengthGetter(Class<?> arrayType) {     if (!arrayType.isArray()) {         throw new IllegalArgumentException("type must be an array").     }     return (ARRAY_TYPE_MH_MAPPING.containsKey(arrayType)) ? ARRAY_TYPE_MH_MAPPING.get(arrayType) : OBJECT_ARRAY_MH.asType(OBJECT_ARRAY_MH.type().changeParameterType(0, arrayType)). }
true;static;1;4;/**  * Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:  */ ;/**  * Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}:  */ @SuppressWarnings("unchecked") static <T extends Throwable> void rethrow(Throwable t) throws T {     throw (T) t. }
true;static;1;12;/**  * Returns an array length getter MethodHandle for the given array type  */ ;/**  * Returns an array length getter MethodHandle for the given array type  */ static MethodHandle arrayLengthGetter(Class<?> arrayType) {     if (JAVA9_ARRAY_LENGTH_MH_FACTORY != null) {         try {             return (MethodHandle) JAVA9_ARRAY_LENGTH_MH_FACTORY.invokeExact(arrayType).         } catch (Throwable t) {             rethrow(t).             throw new AssertionError(t).         }     } else {         return ArrayLengthHelper.arrayLengthGetter(arrayType).     } }
true;static;7;102;/**  * Looks up handle for a dynamic method call, with lambda replacement  * <p>  * A dynamic method call for variable {@code x} of type {@code def} looks like:  * {@code x.method(args...)}  * <p>  * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)  * until it finds a matching whitelisted method. If one is not found, it throws an exception.  * Otherwise it returns a handle to the matching method.  * <p>  * @param painlessLookup the whitelist  * @param methodHandlesLookup caller's lookup  * @param callSiteType callsite's type  * @param receiverClass Class of the object to invoke the method on.  * @param name Name of the method.  * @param args bootstrap args passed to callsite  * @return pointer to matching method to invoke. never returns null.  * @throws IllegalArgumentException if no matching whitelisted method was found.  * @throws Throwable if a method reference cannot be converted to an functional interface  */ ;/**  * Looks up handle for a dynamic method call, with lambda replacement  * <p>  * A dynamic method call for variable {@code x} of type {@code def} looks like:  * {@code x.method(args...)}  * <p>  * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)  * until it finds a matching whitelisted method. If one is not found, it throws an exception.  * Otherwise it returns a handle to the matching method.  * <p>  * @param painlessLookup the whitelist  * @param methodHandlesLookup caller's lookup  * @param callSiteType callsite's type  * @param receiverClass Class of the object to invoke the method on.  * @param name Name of the method.  * @param args bootstrap args passed to callsite  * @return pointer to matching method to invoke. never returns null.  * @throws IllegalArgumentException if no matching whitelisted method was found.  * @throws Throwable if a method reference cannot be converted to an functional interface  */ static MethodHandle lookupMethod(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods, MethodHandles.Lookup methodHandlesLookup, MethodType callSiteType, Class<?> receiverClass, String name, Object[] args) throws Throwable {     String recipeString = (String) args[0].     int numArguments = callSiteType.parameterCount().     // simple case: no lambdas     if (recipeString.isEmpty()) {         PainlessMethod painlessMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, numArguments - 1).         if (painlessMethod == null) {             throw new IllegalArgumentException("dynamic method " + "[" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + (numArguments - 1) + "] not found").         }         return painlessMethod.methodHandle.     }     // convert recipe string to a bitset for convenience (the code below should be refactored...)     BitSet lambdaArgs = new BitSet(recipeString.length()).     for (int i = 0. i < recipeString.length(). i++) {         lambdaArgs.set(recipeString.charAt(i)).     }     // otherwise: first we have to compute the "real" arity. This is because we have extra arguments:     // e.g. f(a, g(x), b, h(y), i()) looks like f(a, g, x, b, h, y, i).     int arity = callSiteType.parameterCount() - 1.     int upTo = 1.     for (int i = 1. i < numArguments. i++) {         if (lambdaArgs.get(i - 1)) {             String signature = (String) args[upTo++].             int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',') + 1)).             arity -= numCaptures.         }     }     // lookup the method with the proper arity, then we know everything (e.g. interface types of parameters).     // based on these we can finally link any remaining lambdas that were deferred.     PainlessMethod method = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity).     if (method == null) {         throw new IllegalArgumentException("dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found").     }     MethodHandle handle = method.methodHandle.     int replaced = 0.     upTo = 1.     for (int i = 1. i < numArguments. i++) {         // its a functional reference, replace the argument with an impl         if (lambdaArgs.get(i - 1)) {             // decode signature of form 'type.call,2'             String signature = (String) args[upTo++].             int separator = signature.lastIndexOf('.').             int separator2 = signature.indexOf(',').             String type = signature.substring(1, separator).             String call = signature.substring(separator + 1, separator2).             int numCaptures = Integer.parseInt(signature.substring(separator2 + 1)).             MethodHandle filter.             Class<?> interfaceType = method.typeParameters.get(i - 1 - replaced).             if (signature.charAt(0) == 'S') {                 // the implementation is strongly typed, now that we know the interface type,                 // we have everything.                 filter = lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup, interfaceType, type, call, numCaptures).             } else if (signature.charAt(0) == 'D') {                 // the interface type is now known, but we need to get the implementation.                 // this is dynamically based on the receiver type (and cached separately, underneath                 // this cache). It won't blow up since we never nest here (just references)                 Class<?>[] captures = new Class<?>[numCaptures].                 for (int capture = 0. capture < captures.length. capture++) {                     captures[capture] = callSiteType.parameterType(i + 1 + capture).                 }                 MethodType nestedType = MethodType.methodType(interfaceType, captures).                 CallSite nested = DefBootstrap.bootstrap(painlessLookup, localMethods, methodHandlesLookup, call, nestedType, 0, DefBootstrap.REFERENCE, PainlessLookupUtility.typeToCanonicalTypeName(interfaceType)).                 filter = nested.dynamicInvoker().             } else {                 throw new AssertionError().             }             // the filter now ignores the signature (placeholder) on the stack             filter = MethodHandles.dropArguments(filter, 0, String.class).             handle = MethodHandles.collectArguments(handle, i, filter).             i += numCaptures.             replaced += numCaptures.         }     }     return handle. }
true;static;6;21;/**  * Returns an implementation of interfaceClass that calls receiverClass.name  * <p>  * This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,  * so we simply need to lookup the matching implementation method based on receiver type.  */ ;/**  * Returns an implementation of interfaceClass that calls receiverClass.name  * <p>  * This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,  * so we simply need to lookup the matching implementation method based on receiver type.  */ static MethodHandle lookupReference(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods, MethodHandles.Lookup methodHandlesLookup, String interfaceClass, Class<?> receiverClass, String name) throws Throwable {     Class<?> interfaceType = painlessLookup.canonicalTypeNameToType(interfaceClass).     if (interfaceType == null) {         throw new IllegalArgumentException("type [" + interfaceClass + "] not found").     }     PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType).     if (interfaceMethod == null) {         throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface").     }     int arity = interfaceMethod.typeParameters.size().     PainlessMethod implMethod = painlessLookup.lookupRuntimePainlessMethod(receiverClass, name, arity).     if (implMethod == null) {         throw new IllegalArgumentException("dynamic method [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "/" + arity + "] not found").     }     return lookupReferenceInternal(painlessLookup, localMethods, methodHandlesLookup, interfaceType, PainlessLookupUtility.typeToCanonicalTypeName(implMethod.targetClass), implMethod.javaMethod.getName(), 1). }
true;private,static;7;16;/**  * Returns a method handle to an implementation of clazz, given method reference signature.  */ ;/**  * Returns a method handle to an implementation of clazz, given method reference signature.  */ private static MethodHandle lookupReferenceInternal(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods, MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {     final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures).     final CallSite callSite = LambdaBootstrap.lambdaBootstrap(methodHandlesLookup, ref.interfaceMethodName, ref.factoryMethodType, ref.interfaceMethodType, ref.delegateClassName, ref.delegateInvokeType, ref.delegateMethodName, ref.delegateMethodType, ref.isDelegateInterface ? 1 : 0).     return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray())). }
true;static;3;31;/**  * Looks up handle for a dynamic field getter (field load)  * <p>  * A dynamic field load for variable {@code x} of type {@code def} looks like:  * {@code y = x.field}  * <p>  * The following field loads are allowed:  * <ul>  *   <li>Whitelisted {@code field} from receiver's class or any superclasses.  *   <li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces.  *   <li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces.  *   <li>The {@code length} field of an array.  *   <li>The value corresponding to a map key named {@code field} when the receiver is a Map.  *   <li>The value in a list at element {@code field} (integer) when the receiver is a List.  * </ul>  * <p>  * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)  * until it finds a matching whitelisted getter. If one is not found, it throws an exception.  * Otherwise it returns a handle to the matching getter.  * <p>  * @param painlessLookup the whitelist  * @param receiverClass Class of the object to retrieve the field from.  * @param name Name of the field.  * @return pointer to matching field. never returns null.  * @throws IllegalArgumentException if no matching whitelisted field was found.  */ ;/**  * Looks up handle for a dynamic field getter (field load)  * <p>  * A dynamic field load for variable {@code x} of type {@code def} looks like:  * {@code y = x.field}  * <p>  * The following field loads are allowed:  * <ul>  *   <li>Whitelisted {@code field} from receiver's class or any superclasses.  *   <li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces.  *   <li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces.  *   <li>The {@code length} field of an array.  *   <li>The value corresponding to a map key named {@code field} when the receiver is a Map.  *   <li>The value in a list at element {@code field} (integer) when the receiver is a List.  * </ul>  * <p>  * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)  * until it finds a matching whitelisted getter. If one is not found, it throws an exception.  * Otherwise it returns a handle to the matching getter.  * <p>  * @param painlessLookup the whitelist  * @param receiverClass Class of the object to retrieve the field from.  * @param name Name of the field.  * @return pointer to matching field. never returns null.  * @throws IllegalArgumentException if no matching whitelisted field was found.  */ static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {     // first try whitelist     MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name).     if (getter != null) {         return getter.     }     // special case: arrays, maps, and lists     if (receiverClass.isArray() && "length".equals(name)) {         // arrays expose .length as a read-only getter         return arrayLengthGetter(receiverClass).     } else if (Map.class.isAssignableFrom(receiverClass)) {         // wire 'key' as a parameter, its a constant in painless         return MethodHandles.insertArguments(MAP_GET, 1, name).     } else if (List.class.isAssignableFrom(receiverClass)) {         // parsing the same integer millions of times!         try {             int index = Integer.parseInt(name).             return MethodHandles.insertArguments(LIST_GET, 1, index).         } catch (NumberFormatException exception) {             throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].").         }     }     throw new IllegalArgumentException("dynamic getter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found"). }
true;static;3;28;/**  * Looks up handle for a dynamic field setter (field store)  * <p>  * A dynamic field store for variable {@code x} of type {@code def} looks like:  * {@code x.field = y}  * <p>  * The following field stores are allowed:  * <ul>  *   <li>Whitelisted {@code field} from receiver's class or any superclasses.  *   <li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces.  *   <li>The value corresponding to a map key named {@code field} when the receiver is a Map.  *   <li>The value in a list at element {@code field} (integer) when the receiver is a List.  * </ul>  * <p>  * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)  * until it finds a matching whitelisted setter. If one is not found, it throws an exception.  * Otherwise it returns a handle to the matching setter.  * <p>  * @param painlessLookup the whitelist  * @param receiverClass Class of the object to retrieve the field from.  * @param name Name of the field.  * @return pointer to matching field. never returns null.  * @throws IllegalArgumentException if no matching whitelisted field was found.  */ ;/**  * Looks up handle for a dynamic field setter (field store)  * <p>  * A dynamic field store for variable {@code x} of type {@code def} looks like:  * {@code x.field = y}  * <p>  * The following field stores are allowed:  * <ul>  *   <li>Whitelisted {@code field} from receiver's class or any superclasses.  *   <li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces.  *   <li>The value corresponding to a map key named {@code field} when the receiver is a Map.  *   <li>The value in a list at element {@code field} (integer) when the receiver is a List.  * </ul>  * <p>  * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)  * until it finds a matching whitelisted setter. If one is not found, it throws an exception.  * Otherwise it returns a handle to the matching setter.  * <p>  * @param painlessLookup the whitelist  * @param receiverClass Class of the object to retrieve the field from.  * @param name Name of the field.  * @return pointer to matching field. never returns null.  * @throws IllegalArgumentException if no matching whitelisted field was found.  */ static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {     // first try whitelist     MethodHandle setter = painlessLookup.lookupRuntimeSetterMethodHandle(receiverClass, name).     if (setter != null) {         return setter.     }     // special case: maps, and lists     if (Map.class.isAssignableFrom(receiverClass)) {         // wire 'key' as a parameter, its a constant in painless         return MethodHandles.insertArguments(MAP_PUT, 1, name).     } else if (List.class.isAssignableFrom(receiverClass)) {         // parsing the same integer millions of times!         try {             int index = Integer.parseInt(name).             return MethodHandles.insertArguments(LIST_SET, 1, index).         } catch (final NumberFormatException exception) {             throw new IllegalArgumentException("Illegal list shortcut value [" + name + "].").         }     }     throw new IllegalArgumentException("dynamic setter [" + typeToCanonicalTypeName(receiverClass) + ", " + name + "] not found"). }
true;static;1;12;/**  * Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support  * negative offsets.  * @param receiverClass Class of the array to store the value in  * @return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index  *   to use with array loads and array stores  */ ;/**  * Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support  * negative offsets.  * @param receiverClass Class of the array to store the value in  * @return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index  *   to use with array loads and array stores  */ static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {     if (receiverClass.isArray()) {         return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass).     } else if (Map.class.isAssignableFrom(receiverClass)) {         // noop so that mymap[key] doesn't do funny things with negative keys         return MAP_INDEX_NORMALIZE.     } else if (List.class.isAssignableFrom(receiverClass)) {         return LIST_INDEX_NORMALIZE.     }     throw new IllegalArgumentException("Attempting to address a non-array-like type " + "[" + receiverClass.getCanonicalName() + "] as an array."). }
true;static;1;12;/**  * Returns a method handle to do an array store.  * @param receiverClass Class of the array to store the value in  * @return a MethodHandle that accepts the receiver as first argument, the index as second argument,  *   and the value to set as 3rd argument. Return value is undefined and should be ignored.  */ ;/**  * Returns a method handle to do an array store.  * @param receiverClass Class of the array to store the value in  * @return a MethodHandle that accepts the receiver as first argument, the index as second argument,  *   and the value to set as 3rd argument. Return value is undefined and should be ignored.  */ static MethodHandle lookupArrayStore(Class<?> receiverClass) {     if (receiverClass.isArray()) {         return MethodHandles.arrayElementSetter(receiverClass).     } else if (Map.class.isAssignableFrom(receiverClass)) {         // maps allow access like mymap[key]         return MAP_PUT.     } else if (List.class.isAssignableFrom(receiverClass)) {         return LIST_SET.     }     throw new IllegalArgumentException("Attempting to address a non-array type " + "[" + receiverClass.getCanonicalName() + "] as an array."). }
true;static;1;12;/**  * Returns a method handle to do an array load.  * @param receiverClass Class of the array to load the value from  * @return a MethodHandle that accepts the receiver as first argument, the index as second argument.  *   It returns the loaded value.  */ ;/**  * Returns a method handle to do an array load.  * @param receiverClass Class of the array to load the value from  * @return a MethodHandle that accepts the receiver as first argument, the index as second argument.  *   It returns the loaded value.  */ static MethodHandle lookupArrayLoad(Class<?> receiverClass) {     if (receiverClass.isArray()) {         return MethodHandles.arrayElementGetter(receiverClass).     } else if (Map.class.isAssignableFrom(receiverClass)) {         // maps allow access like mymap[key]         return MAP_GET.     } else if (List.class.isAssignableFrom(receiverClass)) {         return LIST_GET.     }     throw new IllegalArgumentException("Attempting to address a non-array type " + "[" + receiverClass.getCanonicalName() + "] as an array."). }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Boolean next() {     return array[index++]. }
false;static;1;7;;static Iterator<Boolean> iterator(final boolean[] array) {     return new Iterator<Boolean>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Boolean next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Byte next() {     return array[index++]. }
false;static;1;7;;static Iterator<Byte> iterator(final byte[] array) {     return new Iterator<Byte>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Byte next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Short next() {     return array[index++]. }
false;static;1;7;;static Iterator<Short> iterator(final short[] array) {     return new Iterator<Short>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Short next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Integer next() {     return array[index++]. }
false;static;1;7;;static Iterator<Integer> iterator(final int[] array) {     return new Iterator<Integer>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Integer next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Long next() {     return array[index++]. }
false;static;1;7;;static Iterator<Long> iterator(final long[] array) {     return new Iterator<Long>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Long next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Character next() {     return array[index++]. }
false;static;1;7;;static Iterator<Character> iterator(final char[] array) {     return new Iterator<Character>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Character next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Float next() {     return array[index++]. }
false;static;1;7;;static Iterator<Float> iterator(final float[] array) {     return new Iterator<Float>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Float next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Double next() {     return array[index++]. }
false;static;1;7;;static Iterator<Double> iterator(final double[] array) {     return new Iterator<Double>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Double next() {             return array[index++].         }     }. }
false;public;0;1;;@Override public boolean hasNext() {     return index < array.length. }
false;public;0;1;;@Override public Object next() {     return array[index++]. }
false;static;1;7;;static Iterator<Object> iterator(final Object[] array) {     return new Iterator<Object>() {          int index = 0.          @Override         public boolean hasNext() {             return index < array.length.         }          @Override         public Object next() {             return array[index++].         }     }. }
false;static;1;8;;static MethodHandle newIterator(Class<?> arrayType) {     if (!arrayType.isArray()) {         throw new IllegalArgumentException("type must be an array").     }     return (ARRAY_TYPE_MH_MAPPING.containsKey(arrayType)) ? ARRAY_TYPE_MH_MAPPING.get(arrayType) : OBJECT_ARRAY_MH.asType(OBJECT_ARRAY_MH.type().changeParameterType(0, arrayType)). }
true;static;1;9;/**  * Returns a method handle to do iteration (for enhanced for loop)  * @param receiverClass Class of the array to load the value from  * @return a MethodHandle that accepts the receiver as first argument, returns iterator  */ ;/**  * Returns a method handle to do iteration (for enhanced for loop)  * @param receiverClass Class of the array to load the value from  * @return a MethodHandle that accepts the receiver as first argument, returns iterator  */ static MethodHandle lookupIterator(Class<?> receiverClass) {     if (Iterable.class.isAssignableFrom(receiverClass)) {         return ITERATOR.     } else if (receiverClass.isArray()) {         return ArrayIteratorHelper.newIterator(receiverClass).     } else {         throw new IllegalArgumentException("Cannot iterate over [" + receiverClass.getCanonicalName() + "]").     } }
false;public,static;1;8;;// Conversion methods for def to primitive types. public static boolean defToboolean(final Object value) {     if (value instanceof Boolean) {         return (boolean) value.     } else {         throw new ClassCastException("cannot cast def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to boolean").     } }
false;public,static;1;8;;public static byte defTobyteImplicit(final Object value) {     if (value instanceof Byte) {         return (byte) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to byte").     } }
false;public,static;1;10;;public static short defToshortImplicit(final Object value) {     if (value instanceof Byte) {         return (byte) value.     } else if (value instanceof Short) {         return (short) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to short").     } }
false;public,static;1;8;;public static char defTocharImplicit(final Object value) {     if (value instanceof Character) {         return (char) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to char").     } }
false;public,static;1;14;;public static int defTointImplicit(final Object value) {     if (value instanceof Byte) {         return (byte) value.     } else if (value instanceof Short) {         return (short) value.     } else if (value instanceof Character) {         return (char) value.     } else if (value instanceof Integer) {         return (int) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to int").     } }
false;public,static;1;17;;public static long defTolongImplicit(final Object value) {     if (value instanceof Byte) {         return (byte) value.     } else if (value instanceof Short) {         return (short) value.     } else if (value instanceof Character) {         return (char) value.     } else if (value instanceof Integer) {         return (int) value.     } else if (value instanceof Long) {         return (long) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to long").     } }
false;public,static;1;19;;public static float defTofloatImplicit(final Object value) {     if (value instanceof Byte) {         return (byte) value.     } else if (value instanceof Short) {         return (short) value.     } else if (value instanceof Character) {         return (char) value.     } else if (value instanceof Integer) {         return (int) value.     } else if (value instanceof Long) {         return (long) value.     } else if (value instanceof Float) {         return (float) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to float").     } }
false;public,static;1;19;;public static double defTodoubleImplicit(final Object value) {     if (value instanceof Byte) {         return (byte) value.     } else if (value instanceof Short) {         return (short) value.     } else if (value instanceof Character) {         return (char) value.     } else if (value instanceof Integer) {         return (int) value.     } else if (value instanceof Long) {         return (long) value.     } else if (value instanceof Float) {         return (float) value.     } else if (value instanceof Double) {         return (double) value.     } else {         throw new ClassCastException("cannot implicitly cast def [" + value.getClass().getCanonicalName() + "] to double").     } }
false;public,static;1;16;;public static byte defTobyteExplicit(final Object value) {     if (value instanceof Character) {         return (byte) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).byteValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to byte").     } }
false;public,static;1;16;;public static short defToshortExplicit(final Object value) {     if (value instanceof Character) {         return (short) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).shortValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to short").     } }
false;public,static;1;16;;public static char defTocharExplicit(final Object value) {     if (value instanceof Character) {         return (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return (char) ((Number) value).intValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to char").     } }
false;public,static;1;16;;public static int defTointExplicit(final Object value) {     if (value instanceof Character) {         return (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).intValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to int").     } }
false;public,static;1;16;;public static long defTolongExplicit(final Object value) {     if (value instanceof Character) {         return (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).longValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to long").     } }
false;public,static;1;16;;public static float defTofloatExplicit(final Object value) {     if (value instanceof Character) {         return (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).floatValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to float").     } }
false;public,static;1;16;;public static double defTodoubleExplicit(final Object value) {     if (value instanceof Character) {         return (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).doubleValue().     } else {         throw new ClassCastException("cannot explicitly cast def [" + value.getClass().getCanonicalName() + "] to double").     } }
false;public,static;1;11;;// Conversion methods for def to boxed types. public static Boolean defToBoolean(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Boolean) {         return (Boolean) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Boolean.class.getCanonicalName()).     } }
false;public,static;1;11;;public static Byte defToByteImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Byte) {         return (Byte) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Byte.class.getCanonicalName()).     } }
false;public,static;1;13;;public static Short defToShortImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Byte) {         return (short) (byte) value.     } else if (value instanceof Short) {         return (Short) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Short.class.getCanonicalName()).     } }
false;public,static;1;11;;public static Character defToCharacterImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (Character) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Character.class.getCanonicalName()).     } }
false;public,static;1;17;;public static Integer defToIntegerImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Byte) {         return (int) (byte) value.     } else if (value instanceof Short) {         return (int) (short) value.     } else if (value instanceof Character) {         return (int) (char) value.     } else if (value instanceof Integer) {         return (Integer) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Integer.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Long defToLongImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Byte) {         return (long) (byte) value.     } else if (value instanceof Short) {         return (long) (short) value.     } else if (value instanceof Character) {         return (long) (char) value.     } else if (value instanceof Integer) {         return (long) (int) value.     } else if (value instanceof Long) {         return (Long) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Long.class.getCanonicalName()).     } }
false;public,static;1;21;;public static Float defToFloatImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Byte) {         return (float) (byte) value.     } else if (value instanceof Short) {         return (float) (short) value.     } else if (value instanceof Character) {         return (float) (char) value.     } else if (value instanceof Integer) {         return (float) (int) value.     } else if (value instanceof Long) {         return (float) (long) value.     } else if (value instanceof Float) {         return (Float) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " + Float.class.getCanonicalName()).     } }
false;public,static;1;22;;public static Double defToDoubleImplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Byte) {         return (double) (byte) value.     } else if (value instanceof Short) {         return (double) (short) value.     } else if (value instanceof Character) {         return (double) (char) value.     } else if (value instanceof Integer) {         return (double) (int) value.     } else if (value instanceof Long) {         return (double) (long) value.     } else if (value instanceof Float) {         return (double) (float) value.     } else if (value instanceof Double) {         return (Double) value.     } else {         throw new ClassCastException("cannot implicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Double.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Byte defToByteExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (byte) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).byteValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Byte.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Short defToShortExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (short) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).shortValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Short.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Character defToCharacterExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (Character) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return (char) ((Number) value).intValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Character.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Integer defToIntegerExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (int) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).intValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Integer.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Long defToLongExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (long) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).longValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Long.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Float defToFloatExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (float) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).floatValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Float.class.getCanonicalName()).     } }
false;public,static;1;19;;public static Double defToDoubleExplicit(final Object value) {     if (value == null) {         return null.     } else if (value instanceof Character) {         return (double) (char) value.     } else if (value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {         return ((Number) value).doubleValue().     } else {         throw new ClassCastException("cannot explicitly cast " + "def [" + value.getClass().getCanonicalName() + "] to " + Double.class.getCanonicalName()).     } }
true;public,static;2;3;/**  * "Normalizes" the index into a {@code Map} by making no change to the index.  */ ;/**  * "Normalizes" the index into a {@code Map} by making no change to the index.  */ public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {     return index. }
true;public,static;2;3;/**  * "Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.  */ ;/**  * "Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list.  */ public static int listIndexNormalize(final List<?> value, int index) {     return index >= 0 ? index : value.size() + index. }
false;static;2;1;;static int normalizeIndex(final boolean[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final byte[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final short[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final int[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final long[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final char[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final float[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final double[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;2;1;;static int normalizeIndex(final Object[] array, final int index) {     return index >= 0 ? index : index + array.length. }
false;static;1;8;;static MethodHandle arrayIndexNormalizer(Class<?> arrayType) {     if (!arrayType.isArray()) {         throw new IllegalArgumentException("type must be an array").     }     return (ARRAY_TYPE_MH_MAPPING.containsKey(arrayType)) ? ARRAY_TYPE_MH_MAPPING.get(arrayType) : OBJECT_ARRAY_MH.asType(OBJECT_ARRAY_MH.type().changeParameterType(0, arrayType)). }
