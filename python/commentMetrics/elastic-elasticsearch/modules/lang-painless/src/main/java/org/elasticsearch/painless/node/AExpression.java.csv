commented;modifiers;parameterAmount;loc;comment;code
true;;1;97;/**  * Inserts {@link ECast} nodes into the tree for implicit casts.  Also replaces  * nodes with the constant variable set to a non-null value with {@link EConstant}.  * @return The new child node for the parent node calling this method.  */ ;/**  * Inserts {@link ECast} nodes into the tree for implicit casts.  Also replaces  * nodes with the constant variable set to a non-null value with {@link EConstant}.  * @return The new child node for the parent node calling this method.  */ AExpression cast(Locals locals) {     PainlessCast cast = AnalyzerCaster.getLegalCast(location, actual, expected, explicit, internal).     if (cast == null) {         if (constant == null || this instanceof EConstant) {             return this.         } else {             // For the case where a cast is not required but a             // constant is set, an EConstant replaces this node             // with the constant copied from this node.  Note that             // for constants output data does not need to be copied             // from this node because the output data for the EConstant             // will already be the same.             EConstant econstant = new EConstant(location, constant).             econstant.analyze(locals).             if (!expected.equals(econstant.actual)) {                 throw createError(new IllegalStateException("Illegal tree structure.")).             }             return econstant.         }     } else {         if (constant == null) {             // For the case where a cast is required and a constant is not set.             // Modify the tree to add an ECast between this node and its parent.             // The output data from this node is copied to the ECast for             // further reads done by the parent.             ECast ecast = new ECast(location, this, cast).             ecast.statement = statement.             ecast.actual = expected.             ecast.isNull = isNull.             return ecast.         } else {             if (PainlessLookupUtility.isConstantType(expected)) {                 // For the case where a cast is required, a constant is set,                 // and the constant can be immediately cast to the expected type.                 // An EConstant replaces this node with the constant cast appropriately                 // from the constant value defined by this node.  Note that                 // for constants output data does not need to be copied                 // from this node because the output data for the EConstant                 // will already be the same.                 constant = AnalyzerCaster.constCast(location, constant, cast).                 EConstant econstant = new EConstant(location, constant).                 econstant.analyze(locals).                 if (!expected.equals(econstant.actual)) {                     throw createError(new IllegalStateException("Illegal tree structure.")).                 }                 return econstant.             } else if (this instanceof EConstant) {                 // For the case where a cast is required, a constant is set,                 // the constant cannot be immediately cast to the expected type,                 // and this node is already an EConstant.  Modify the tree to add                 // an ECast between this node and its parent.  Note that                 // for constants output data does not need to be copied                 // from this node because the output data for the EConstant                 // will already be the same.                 ECast ecast = new ECast(location, this, cast).                 ecast.actual = expected.                 return ecast.             } else {                 // For the case where a cast is required, a constant is set,                 // the constant cannot be immediately cast to the expected type,                 // and this node is not an EConstant.  Replace this node with                 // an Econstant node copying the constant from this node.                 // Modify the tree to add an ECast between the EConstant node                 // and its parent.  Note that for constants output data does not                 // need to be copied from this node because the output data for                 // the EConstant will already be the same.                 EConstant econstant = new EConstant(location, constant).                 econstant.analyze(locals).                 if (!actual.equals(econstant.actual)) {                     throw createError(new IllegalStateException("Illegal tree structure.")).                 }                 ECast ecast = new ECast(location, econstant, cast).                 ecast.actual = expected.                 return ecast.             }         }     } }
