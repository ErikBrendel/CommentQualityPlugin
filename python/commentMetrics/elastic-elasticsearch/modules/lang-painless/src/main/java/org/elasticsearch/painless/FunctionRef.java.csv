commented;modifiers;parameterAmount;loc;comment;code
true;public,static;7;152;/**  * Creates a new FunctionRef which will resolve {@code type::call} from the whitelist.  * @param painlessLookup the whitelist against which this script is being compiled  * @param localMethods user-defined and synthetic methods generated directly on the script class  * @param location the character number within the script at compile-time  * @param targetClass functional interface type to implement.  * @param typeName the left hand side of a method reference expression  * @param methodName the right hand side of a method reference expression  * @param numberOfCaptures number of captured arguments  */ ;/**  * Creates a new FunctionRef which will resolve {@code type::call} from the whitelist.  * @param painlessLookup the whitelist against which this script is being compiled  * @param localMethods user-defined and synthetic methods generated directly on the script class  * @param location the character number within the script at compile-time  * @param targetClass functional interface type to implement.  * @param typeName the left hand side of a method reference expression  * @param methodName the right hand side of a method reference expression  * @param numberOfCaptures number of captured arguments  */ public static FunctionRef create(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods, Location location, Class<?> targetClass, String typeName, String methodName, int numberOfCaptures) {     Objects.requireNonNull(painlessLookup).     Objects.requireNonNull(targetClass).     Objects.requireNonNull(typeName).     Objects.requireNonNull(methodName).     String targetClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass).     PainlessMethod interfaceMethod.     try {         interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(targetClass).         if (interfaceMethod == null) {             throw new IllegalArgumentException("cannot convert function reference [" + typeName + "::" + methodName + "] " + "to a non-functional interface [" + targetClassName + "]").         }         String interfaceMethodName = interfaceMethod.javaMethod.getName().         MethodType interfaceMethodType = interfaceMethod.methodType.dropParameterTypes(0, 1).         String delegateClassName.         boolean isDelegateInterface.         int delegateInvokeType.         String delegateMethodName.         MethodType delegateMethodType.         Class<?> delegateMethodReturnType.         List<Class<?>> delegateMethodParameters.         int interfaceTypeParametersSize = interfaceMethod.typeParameters.size().         if ("this".equals(typeName)) {             Objects.requireNonNull(localMethods).             if (numberOfCaptures < 0) {                 throw new IllegalStateException("internal error").             }             String localMethodKey = Locals.buildLocalMethodKey(methodName, numberOfCaptures + interfaceTypeParametersSize).             LocalMethod localMethod = localMethods.get(localMethodKey).             if (localMethod == null) {                 throw new IllegalArgumentException("function reference [this::" + localMethodKey + "] " + "matching [" + targetClassName + ", " + interfaceMethodName + "/" + interfaceTypeParametersSize + "] " + "not found" + (localMethodKey.contains("$") ? " due to an incorrect number of arguments" : "")).             }             delegateClassName = CLASS_NAME.             isDelegateInterface = false.             delegateInvokeType = H_INVOKESTATIC.             delegateMethodName = localMethod.name.             delegateMethodType = localMethod.methodType.             delegateMethodReturnType = localMethod.returnType.             delegateMethodParameters = localMethod.typeParameters.         } else if ("new".equals(methodName)) {             if (numberOfCaptures != 0) {                 throw new IllegalStateException("internal error").             }             PainlessConstructor painlessConstructor = painlessLookup.lookupPainlessConstructor(typeName, interfaceTypeParametersSize).             if (painlessConstructor == null) {                 throw new IllegalArgumentException("function reference [" + typeName + "::new/" + interfaceTypeParametersSize + "] " + "matching [" + targetClassName + ", " + interfaceMethodName + "/" + interfaceTypeParametersSize + "] " + "not found").             }             delegateClassName = painlessConstructor.javaConstructor.getDeclaringClass().getName().             isDelegateInterface = false.             delegateInvokeType = H_NEWINVOKESPECIAL.             delegateMethodName = PainlessLookupUtility.CONSTRUCTOR_NAME.             delegateMethodType = painlessConstructor.methodType.             delegateMethodReturnType = painlessConstructor.javaConstructor.getDeclaringClass().             delegateMethodParameters = painlessConstructor.typeParameters.         } else {             if (numberOfCaptures != 0 && numberOfCaptures != 1) {                 throw new IllegalStateException("internal error").             }             boolean captured = numberOfCaptures == 1.             PainlessMethod painlessMethod = painlessLookup.lookupPainlessMethod(typeName, true, methodName, interfaceTypeParametersSize).             if (painlessMethod == null) {                 painlessMethod = painlessLookup.lookupPainlessMethod(typeName, false, methodName, captured ? interfaceTypeParametersSize : interfaceTypeParametersSize - 1).                 if (painlessMethod == null) {                     throw new IllegalArgumentException("function reference " + "[" + typeName + "::" + methodName + "/" + interfaceTypeParametersSize + "] " + "matching [" + targetClassName + ", " + interfaceMethodName + "/" + interfaceTypeParametersSize + "] " + "not found").                 }             } else if (captured) {                 throw new IllegalStateException("internal error").             }             delegateClassName = painlessMethod.javaMethod.getDeclaringClass().getName().             isDelegateInterface = painlessMethod.javaMethod.getDeclaringClass().isInterface().             if (Modifier.isStatic(painlessMethod.javaMethod.getModifiers())) {                 delegateInvokeType = H_INVOKESTATIC.             } else if (isDelegateInterface) {                 delegateInvokeType = H_INVOKEINTERFACE.             } else {                 delegateInvokeType = H_INVOKEVIRTUAL.             }             delegateMethodName = painlessMethod.javaMethod.getName().             delegateMethodType = painlessMethod.methodType.             delegateMethodReturnType = painlessMethod.returnType.             if (delegateMethodType.parameterList().size() > painlessMethod.typeParameters.size()) {                 delegateMethodParameters = new ArrayList<>(painlessMethod.typeParameters).                 delegateMethodParameters.add(0, delegateMethodType.parameterType(0)).             } else {                 delegateMethodParameters = painlessMethod.typeParameters.             }         }         if (location != null) {             for (int typeParameter = 0. typeParameter < interfaceTypeParametersSize. ++typeParameter) {                 Class<?> from = interfaceMethod.typeParameters.get(typeParameter).                 Class<?> to = delegateMethodParameters.get(numberOfCaptures + typeParameter).                 AnalyzerCaster.getLegalCast(location, from, to, false, true).             }             if (interfaceMethod.returnType != void.class) {                 AnalyzerCaster.getLegalCast(location, delegateMethodReturnType, interfaceMethod.returnType, false, true).             }         }         MethodType factoryMethodType = MethodType.methodType(targetClass, delegateMethodType.dropParameterTypes(numberOfCaptures, delegateMethodType.parameterCount())).         delegateMethodType = delegateMethodType.dropParameterTypes(0, numberOfCaptures).         return new FunctionRef(interfaceMethodName, interfaceMethodType, delegateClassName, isDelegateInterface, delegateInvokeType, delegateMethodName, delegateMethodType, factoryMethodType).     } catch (IllegalArgumentException iae) {         if (location != null) {             throw location.createError(iae).         }         throw iae.     } }
