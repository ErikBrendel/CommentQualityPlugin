commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public Class<?> javaClassNameToClass(String javaClassName) {     return javaClassNamesToClasses.get(javaClassName). }
false;public;1;5;;public boolean isValidCanonicalClassName(String canonicalClassName) {     Objects.requireNonNull(canonicalClassName).     return DEF_CLASS_NAME.equals(canonicalClassName) || canonicalClassNamesToClasses.containsKey(canonicalClassName). }
false;public;1;5;;public Class<?> canonicalTypeNameToType(String canonicalTypeName) {     Objects.requireNonNull(canonicalTypeName).     return PainlessLookupUtility.canonicalTypeNameToType(canonicalTypeName, canonicalClassNamesToClasses). }
false;public;0;3;;public Set<Class<?>> getClasses() {     return classesToPainlessClasses.keySet(). }
false;public;1;3;;public PainlessClass lookupPainlessClass(Class<?> targetClass) {     return classesToPainlessClasses.get(targetClass). }
false;public;2;11;;public PainlessConstructor lookupPainlessConstructor(String targetCanonicalClassName, int constructorArity) {     Objects.requireNonNull(targetCanonicalClassName).     Class<?> targetClass = canonicalTypeNameToType(targetCanonicalClassName).     if (targetClass == null) {         return null.     }     return lookupPainlessConstructor(targetClass, constructorArity). }
false;public;2;18;;public PainlessConstructor lookupPainlessConstructor(Class<?> targetClass, int constructorArity) {     Objects.requireNonNull(targetClass).     PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass).     String painlessConstructorKey = buildPainlessConstructorKey(constructorArity).     if (targetPainlessClass == null) {         return null.     }     PainlessConstructor painlessConstructor = targetPainlessClass.constructors.get(painlessConstructorKey).     if (painlessConstructor == null) {         return null.     }     return painlessConstructor. }
false;public;4;11;;public PainlessMethod lookupPainlessMethod(String targetCanonicalClassName, boolean isStatic, String methodName, int methodArity) {     Objects.requireNonNull(targetCanonicalClassName).     Class<?> targetClass = canonicalTypeNameToType(targetCanonicalClassName).     if (targetClass == null) {         return null.     }     return lookupPainlessMethod(targetClass, isStatic, methodName, methodArity). }
false;public;4;19;;public PainlessMethod lookupPainlessMethod(Class<?> targetClass, boolean isStatic, String methodName, int methodArity) {     Objects.requireNonNull(targetClass).     Objects.requireNonNull(methodName).     if (targetClass.isPrimitive()) {         targetClass = typeToBoxedType(targetClass).     }     PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass).     String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity).     if (targetPainlessClass == null) {         return null.     }     return isStatic ? targetPainlessClass.staticMethods.get(painlessMethodKey) : targetPainlessClass.methods.get(painlessMethodKey). }
false;public;3;11;;public PainlessField lookupPainlessField(String targetCanonicalClassName, boolean isStatic, String fieldName) {     Objects.requireNonNull(targetCanonicalClassName).     Class<?> targetClass = canonicalTypeNameToType(targetCanonicalClassName).     if (targetClass == null) {         return null.     }     return lookupPainlessField(targetClass, isStatic, fieldName). }
false;public;3;21;;public PainlessField lookupPainlessField(Class<?> targetClass, boolean isStatic, String fieldName) {     Objects.requireNonNull(targetClass).     Objects.requireNonNull(fieldName).     PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass).     String painlessFieldKey = buildPainlessFieldKey(fieldName).     if (targetPainlessClass == null) {         return null.     }     PainlessField painlessField = isStatic ? targetPainlessClass.staticFields.get(painlessFieldKey) : targetPainlessClass.fields.get(painlessFieldKey).     if (painlessField == null) {         return null.     }     return painlessField. }
false;public;2;7;;public PainlessMethod lookupImportedPainlessMethod(String methodName, int arity) {     Objects.requireNonNull(methodName).     String painlessMethodKey = buildPainlessMethodKey(methodName, arity).     return painlessMethodKeysToImportedPainlessMethods.get(painlessMethodKey). }
false;public;2;7;;public PainlessClassBinding lookupPainlessClassBinding(String methodName, int arity) {     Objects.requireNonNull(methodName).     String painlessMethodKey = buildPainlessMethodKey(methodName, arity).     return painlessMethodKeysToPainlessClassBindings.get(painlessMethodKey). }
false;public;2;7;;public PainlessInstanceBinding lookupPainlessInstanceBinding(String methodName, int arity) {     Objects.requireNonNull(methodName).     String painlessMethodKey = buildPainlessMethodKey(methodName, arity).     return painlessMethodKeysToPainlessInstanceBindings.get(painlessMethodKey). }
false;public;1;9;;public PainlessMethod lookupFunctionalInterfacePainlessMethod(Class<?> targetClass) {     PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetClass).     if (targetPainlessClass == null) {         return null.     }     return targetPainlessClass.functionalInterfaceMethod. }
false;public;3;10;;public PainlessMethod lookupRuntimePainlessMethod(Class<?> originalTargetClass, String methodName, int methodArity) {     Objects.requireNonNull(originalTargetClass).     Objects.requireNonNull(methodName).     String painlessMethodKey = buildPainlessMethodKey(methodName, methodArity).     Function<PainlessClass, PainlessMethod> objectLookup = targetPainlessClass -> targetPainlessClass.runtimeMethods.get(painlessMethodKey).     return lookupRuntimePainlessObject(originalTargetClass, objectLookup). }
false;public;2;8;;public MethodHandle lookupRuntimeGetterMethodHandle(Class<?> originalTargetClass, String getterName) {     Objects.requireNonNull(originalTargetClass).     Objects.requireNonNull(getterName).     Function<PainlessClass, MethodHandle> objectLookup = targetPainlessClass -> targetPainlessClass.getterMethodHandles.get(getterName).     return lookupRuntimePainlessObject(originalTargetClass, objectLookup). }
false;public;2;8;;public MethodHandle lookupRuntimeSetterMethodHandle(Class<?> originalTargetClass, String setterName) {     Objects.requireNonNull(originalTargetClass).     Objects.requireNonNull(setterName).     Function<PainlessClass, MethodHandle> objectLookup = targetPainlessClass -> targetPainlessClass.setterMethodHandles.get(setterName).     return lookupRuntimePainlessObject(originalTargetClass, objectLookup). }
false;private;2;37;;private <T> T lookupRuntimePainlessObject(Class<?> originalTargetClass, Function<PainlessClass, T> objectLookup) {     Class<?> currentTargetClass = originalTargetClass.     while (currentTargetClass != null) {         PainlessClass targetPainlessClass = classesToPainlessClasses.get(currentTargetClass).         if (targetPainlessClass != null) {             T painlessObject = objectLookup.apply(targetPainlessClass).             if (painlessObject != null) {                 return painlessObject.             }         }         currentTargetClass = currentTargetClass.getSuperclass().     }     currentTargetClass = originalTargetClass.     while (currentTargetClass != null) {         for (Class<?> targetInterface : currentTargetClass.getInterfaces()) {             PainlessClass targetPainlessClass = classesToPainlessClasses.get(targetInterface).             if (targetPainlessClass != null) {                 T painlessObject = objectLookup.apply(targetPainlessClass).                 if (painlessObject != null) {                     return painlessObject.                 }             }         }         currentTargetClass = currentTargetClass.getSuperclass().     }     return null. }
