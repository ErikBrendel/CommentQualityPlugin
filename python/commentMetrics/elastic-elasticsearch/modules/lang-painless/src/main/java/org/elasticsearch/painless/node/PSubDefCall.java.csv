commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;@Override void extractVariables(Set<String> variables) {     throw createError(new IllegalStateException("Illegal tree structure.")). }
false;;1;30;;@Override void analyze(Locals locals) {     recipe = new StringBuilder().     int totalCaptures = 0.     for (int argument = 0. argument < arguments.size(). ++argument) {         AExpression expression = arguments.get(argument).         expression.internal = true.         expression.analyze(locals).         if (expression instanceof ILambda) {             ILambda lambda = (ILambda) expression.             pointers.add(lambda.getPointer()).             // encode this parameter as a deferred reference             char ch = (char) (argument + totalCaptures).             recipe.append(ch).             totalCaptures += lambda.getCaptureCount().         }         if (expression.actual == void.class) {             throw createError(new IllegalArgumentException("Argument(s) cannot be of [void] type when calling method [" + name + "].")).         }         expression.expected = expression.actual.         arguments.set(argument, expression.cast(locals)).     }     actual = expected == null || explicit ? def.class : expected. }
false;;2;29;;@Override void write(MethodWriter writer, Globals globals) {     writer.writeDebugInfo(location).     List<Type> parameterTypes = new ArrayList<>().     // first parameter is the receiver, we never know its type: always Object     parameterTypes.add(org.objectweb.asm.Type.getType(Object.class)).     // append each argument     for (AExpression argument : arguments) {         parameterTypes.add(MethodWriter.getType(argument.actual)).         if (argument instanceof ILambda) {             ILambda lambda = (ILambda) argument.             Collections.addAll(parameterTypes, lambda.getCaptures()).         }         argument.write(writer, globals).     }     // create method type from return value and arguments     Type methodType = Type.getMethodType(MethodWriter.getType(actual), parameterTypes.toArray(new Type[0])).     List<Object> args = new ArrayList<>().     args.add(recipe.toString()).     args.addAll(pointers).     writer.invokeDefCall(name, methodType, DefBootstrap.METHOD_CALL, args.toArray()). }
false;public;0;4;;@Override public String toString() {     return singleLineToStringWithOptionalArgs(arguments, prefix, name). }
