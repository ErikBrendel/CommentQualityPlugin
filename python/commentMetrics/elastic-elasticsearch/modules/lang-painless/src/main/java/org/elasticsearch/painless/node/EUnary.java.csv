commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;@Override void extractVariables(Set<String> variables) {     child.extractVariables(variables). }
false;;1;16;;@Override void analyze(Locals locals) {     originallyExplicit = explicit.     if (operation == Operation.NOT) {         analyzeNot(locals).     } else if (operation == Operation.BWNOT) {         analyzeBWNot(locals).     } else if (operation == Operation.ADD) {         analyzerAdd(locals).     } else if (operation == Operation.SUB) {         analyzerSub(locals).     } else {         throw createError(new IllegalStateException("Illegal tree structure.")).     } }
false;;1;11;;void analyzeNot(Locals variables) {     child.expected = boolean.class.     child.analyze(variables).     child = child.cast(variables).     if (child.constant != null) {         constant = !(boolean) child.constant.     }     actual = boolean.class. }
false;;1;29;;void analyzeBWNot(Locals variables) {     child.analyze(variables).     promote = AnalyzerCaster.promoteNumeric(child.actual, false).     if (promote == null) {         throw createError(new ClassCastException("Cannot apply not [~] to type " + "[" + PainlessLookupUtility.typeToCanonicalTypeName(child.actual) + "].")).     }     child.expected = promote.     child = child.cast(variables).     if (child.constant != null) {         if (promote == int.class) {             constant = ~(int) child.constant.         } else if (promote == long.class) {             constant = ~(long) child.constant.         } else {             throw createError(new IllegalStateException("Illegal tree structure.")).         }     }     if (promote == def.class && expected != null) {         actual = expected.     } else {         actual = promote.     } }
false;;1;33;;void analyzerAdd(Locals variables) {     child.analyze(variables).     promote = AnalyzerCaster.promoteNumeric(child.actual, true).     if (promote == null) {         throw createError(new ClassCastException("Cannot apply positive [+] to type " + "[" + PainlessLookupUtility.typeToJavaType(child.actual) + "].")).     }     child.expected = promote.     child = child.cast(variables).     if (child.constant != null) {         if (promote == int.class) {             constant = +(int) child.constant.         } else if (promote == long.class) {             constant = +(long) child.constant.         } else if (promote == float.class) {             constant = +(float) child.constant.         } else if (promote == double.class) {             constant = +(double) child.constant.         } else {             throw createError(new IllegalStateException("Illegal tree structure.")).         }     }     if (promote == def.class && expected != null) {         actual = expected.     } else {         actual = promote.     } }
false;;1;33;;void analyzerSub(Locals variables) {     child.analyze(variables).     promote = AnalyzerCaster.promoteNumeric(child.actual, true).     if (promote == null) {         throw createError(new ClassCastException("Cannot apply negative [-] to type " + "[" + PainlessLookupUtility.typeToJavaType(child.actual) + "].")).     }     child.expected = promote.     child = child.cast(variables).     if (child.constant != null) {         if (promote == int.class) {             constant = -(int) child.constant.         } else if (promote == long.class) {             constant = -(long) child.constant.         } else if (promote == float.class) {             constant = -(float) child.constant.         } else if (promote == double.class) {             constant = -(double) child.constant.         } else {             throw createError(new IllegalStateException("Illegal tree structure.")).         }     }     if (promote == def.class && expected != null) {         actual = expected.     } else {         actual = promote.     } }
false;;2;62;;@Override void write(MethodWriter writer, Globals globals) {     writer.writeDebugInfo(location).     if (operation == Operation.NOT) {         Label fals = new Label().         Label end = new Label().         child.write(writer, globals).         writer.ifZCmp(Opcodes.IFEQ, fals).         writer.push(false).         writer.goTo(end).         writer.mark(fals).         writer.push(true).         writer.mark(end).     } else {         child.write(writer, globals).         // Def calls adopt the wanted return value. If there was a narrowing cast,         // we need to flag that so that it's done at runtime.         int defFlags = 0.         if (originallyExplicit) {             defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST.         }         Type actualType = MethodWriter.getType(actual).         Type childType = MethodWriter.getType(child.actual).         if (operation == Operation.BWNOT) {             if (promote == def.class) {                 org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType).                 writer.invokeDefCall("not", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags).             } else {                 if (promote == int.class) {                     writer.push(-1).                 } else if (promote == long.class) {                     writer.push(-1L).                 } else {                     throw createError(new IllegalStateException("Illegal tree structure.")).                 }                 writer.math(MethodWriter.XOR, actualType).             }         } else if (operation == Operation.SUB) {             if (promote == def.class) {                 org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType).                 writer.invokeDefCall("neg", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags).             } else {                 writer.math(MethodWriter.NEG, actualType).             }         } else if (operation == Operation.ADD) {             if (promote == def.class) {                 org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType).                 writer.invokeDefCall("plus", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags).             }         } else {             throw createError(new IllegalStateException("Illegal tree structure.")).         }     } }
false;public;0;4;;@Override public String toString() {     return singleLineToString(operation.symbol, child). }
