commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;@Override void extractVariables(Set<String> variables) {     prefix.extractVariables(variables). }
false;;1;63;;@Override void analyze(Locals locals) {     prefix.analyze(locals).     prefix.expected = prefix.actual.     prefix = prefix.cast(locals).     if (prefix.actual.isArray()) {         sub = new PSubArrayLength(location, PainlessLookupUtility.typeToCanonicalTypeName(prefix.actual), value).     } else if (prefix.actual == def.class) {         sub = new PSubDefField(location, value).     } else {         PainlessField field = locals.getPainlessLookup().lookupPainlessField(prefix.actual, prefix instanceof EStatic, value).         if (field == null) {             PainlessMethod getter.             PainlessMethod setter.             getter = locals.getPainlessLookup().lookupPainlessMethod(prefix.actual, false, "get" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0).             if (getter == null) {                 getter = locals.getPainlessLookup().lookupPainlessMethod(prefix.actual, false, "is" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0).             }             setter = locals.getPainlessLookup().lookupPainlessMethod(prefix.actual, false, "set" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0).             if (getter != null || setter != null) {                 sub = new PSubShortcut(location, value, PainlessLookupUtility.typeToCanonicalTypeName(prefix.actual), getter, setter).             } else {                 EConstant index = new EConstant(location, value).                 index.analyze(locals).                 if (Map.class.isAssignableFrom(prefix.actual)) {                     sub = new PSubMapShortcut(location, prefix.actual, index).                 }                 if (List.class.isAssignableFrom(prefix.actual)) {                     sub = new PSubListShortcut(location, prefix.actual, index).                 }             }             if (sub == null) {                 throw createError(new IllegalArgumentException("field [" + typeToCanonicalTypeName(prefix.actual) + ", " + value + "] not found")).             }         } else {             sub = new PSubField(location, field).         }     }     if (nullSafe) {         sub = new PSubNullSafeField(location, sub).     }     sub.write = write.     sub.read = read.     sub.expected = expected.     sub.explicit = explicit.     sub.analyze(locals).     actual = sub.actual. }
false;;2;5;;@Override void write(MethodWriter writer, Globals globals) {     prefix.write(writer, globals).     sub.write(writer, globals). }
false;;0;4;;@Override boolean isDefOptimized() {     return sub.isDefOptimized(). }
false;;1;5;;@Override void updateActual(Class<?> actual) {     sub.updateActual(actual).     this.actual = actual. }
false;;0;4;;@Override int accessElementCount() {     return sub.accessElementCount(). }
false;;2;5;;@Override void setup(MethodWriter writer, Globals globals) {     prefix.write(writer, globals).     sub.setup(writer, globals). }
false;;2;4;;@Override void load(MethodWriter writer, Globals globals) {     sub.load(writer, globals). }
false;;2;4;;@Override void store(MethodWriter writer, Globals globals) {     sub.store(writer, globals). }
false;public;0;7;;@Override public String toString() {     if (nullSafe) {         return singleLineToString("nullSafe", prefix, value).     }     return singleLineToString(prefix, value). }
