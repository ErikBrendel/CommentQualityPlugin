# id;timestamp;commentText;codeText;commentWords;codeWords
PainlessLookupUtility -> public static Class<?> javaTypeToType(Class<?> javaType);1532069817;Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an_object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an_identity function.;public static Class<?> javaTypeToType(Class<?> javaType) {_        Objects.requireNonNull(javaType)___        if (javaType.isArray()) {_            Class<?> javaTypeComponent = javaType.getComponentType()__            int arrayDimensions = 1___            while (javaTypeComponent.isArray()) {_                javaTypeComponent = javaTypeComponent.getComponentType()__                ++arrayDimensions__            }__            if (javaTypeComponent == Object.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (javaType == Object.class) {_            return def.class__        }__        return javaType__    };converts,a,java,type,to,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,an,object,class,or,object,array,the,returned,type,will,be,the,equivalent,def,class,or,def,array,otherwise,this,behaves,as,an,identity,function;public,static,class,java,type,to,type,class,java,type,objects,require,non,null,java,type,if,java,type,is,array,class,java,type,component,java,type,get,component,type,int,array,dimensions,1,while,java,type,component,is,array,java,type,component,java,type,component,get,component,type,array,dimensions,if,java,type,component,object,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,def,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,java,type,object,class,return,def,class,return,java,type
PainlessLookupUtility -> public static Class<?> javaTypeToType(Class<?> javaType);1532434432;Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an_object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an_identity function.;public static Class<?> javaTypeToType(Class<?> javaType) {_        Objects.requireNonNull(javaType)___        if (javaType.isArray()) {_            Class<?> javaTypeComponent = javaType.getComponentType()__            int arrayDimensions = 1___            while (javaTypeComponent.isArray()) {_                javaTypeComponent = javaTypeComponent.getComponentType()__                ++arrayDimensions__            }__            if (javaTypeComponent == Object.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (javaType == Object.class) {_            return def.class__        }__        return javaType__    };converts,a,java,type,to,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,an,object,class,or,object,array,the,returned,type,will,be,the,equivalent,def,class,or,def,array,otherwise,this,behaves,as,an,identity,function;public,static,class,java,type,to,type,class,java,type,objects,require,non,null,java,type,if,java,type,is,array,class,java,type,component,java,type,get,component,type,int,array,dimensions,1,while,java,type,component,is,array,java,type,component,java,type,component,get,component,type,array,dimensions,if,java,type,component,object,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,def,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,java,type,object,class,return,def,class,return,java,type
PainlessLookupUtility -> public static Class<?> javaTypeToType(Class<?> javaType);1533063033;Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an_object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an_identity function.;public static Class<?> javaTypeToType(Class<?> javaType) {_        Objects.requireNonNull(javaType)___        if (javaType.isArray()) {_            Class<?> javaTypeComponent = javaType.getComponentType()__            int arrayDimensions = 1___            while (javaTypeComponent.isArray()) {_                javaTypeComponent = javaTypeComponent.getComponentType()__                ++arrayDimensions__            }__            if (javaTypeComponent == Object.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (javaType == Object.class) {_            return def.class__        }__        return javaType__    };converts,a,java,type,to,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,an,object,class,or,object,array,the,returned,type,will,be,the,equivalent,def,class,or,def,array,otherwise,this,behaves,as,an,identity,function;public,static,class,java,type,to,type,class,java,type,objects,require,non,null,java,type,if,java,type,is,array,class,java,type,component,java,type,get,component,type,int,array,dimensions,1,while,java,type,component,is,array,java,type,component,java,type,component,get,component,type,array,dimensions,if,java,type,component,object,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,def,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,java,type,object,class,return,def,class,return,java,type
PainlessLookupUtility -> public static Class<?> javaTypeToType(Class<?> javaType);1533815246;Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an_object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an_identity function.;public static Class<?> javaTypeToType(Class<?> javaType) {_        Objects.requireNonNull(javaType)___        if (javaType.isArray()) {_            Class<?> javaTypeComponent = javaType.getComponentType()__            int arrayDimensions = 1___            while (javaTypeComponent.isArray()) {_                javaTypeComponent = javaTypeComponent.getComponentType()__                ++arrayDimensions__            }__            if (javaTypeComponent == Object.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (javaType == Object.class) {_            return def.class__        }__        return javaType__    };converts,a,java,type,to,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,an,object,class,or,object,array,the,returned,type,will,be,the,equivalent,def,class,or,def,array,otherwise,this,behaves,as,an,identity,function;public,static,class,java,type,to,type,class,java,type,objects,require,non,null,java,type,if,java,type,is,array,class,java,type,component,java,type,get,component,type,int,array,dimensions,1,while,java,type,component,is,array,java,type,component,java,type,component,get,component,type,array,dimensions,if,java,type,component,object,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,def,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,java,type,object,class,return,def,class,return,java,type
PainlessLookupUtility -> public static Class<?> javaTypeToType(Class<?> javaType);1534434117;Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an_object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an_identity function.;public static Class<?> javaTypeToType(Class<?> javaType) {_        Objects.requireNonNull(javaType)___        if (javaType.isArray()) {_            Class<?> javaTypeComponent = javaType.getComponentType()__            int arrayDimensions = 1___            while (javaTypeComponent.isArray()) {_                javaTypeComponent = javaTypeComponent.getComponentType()__                ++arrayDimensions__            }__            if (javaTypeComponent == Object.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (javaType == Object.class) {_            return def.class__        }__        return javaType__    };converts,a,java,type,to,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,an,object,class,or,object,array,the,returned,type,will,be,the,equivalent,def,class,or,def,array,otherwise,this,behaves,as,an,identity,function;public,static,class,java,type,to,type,class,java,type,objects,require,non,null,java,type,if,java,type,is,array,class,java,type,component,java,type,get,component,type,int,array,dimensions,1,while,java,type,component,is,array,java,type,component,java,type,component,get,component,type,array,dimensions,if,java,type,component,object,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,def,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,java,type,object,class,return,def,class,return,java,type
PainlessLookupUtility -> public static Class<?> javaTypeToType(Class<?> javaType);1543266328;Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an_object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an_identity function.;public static Class<?> javaTypeToType(Class<?> javaType) {_        Objects.requireNonNull(javaType)___        if (javaType.isArray()) {_            Class<?> javaTypeComponent = javaType.getComponentType()__            int arrayDimensions = 1___            while (javaTypeComponent.isArray()) {_                javaTypeComponent = javaTypeComponent.getComponentType()__                ++arrayDimensions__            }__            if (javaTypeComponent == Object.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (javaType == Object.class) {_            return def.class__        }__        return javaType__    };converts,a,java,type,to,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,an,object,class,or,object,array,the,returned,type,will,be,the,equivalent,def,class,or,def,array,otherwise,this,behaves,as,an,identity,function;public,static,class,java,type,to,type,class,java,type,objects,require,non,null,java,type,if,java,type,is,array,class,java,type,component,java,type,get,component,type,int,array,dimensions,1,while,java,type,component,is,array,java,type,component,java,type,component,get,component,type,array,dimensions,if,java,type,component,object,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,def,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,java,type,object,class,return,def,class,return,java,type
PainlessLookupUtility -> public static Class<?> typeToBoxedType(Class<?> type);1532069817;Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToBoxedType(Class<?> type) {_        if (type == boolean.class) {_            return Boolean.class__        } else if (type == byte.class) {_            return Byte.class__        } else if (type == short.class) {_            return Short.class__        } else if (type == char.class) {_            return Character.class__        } else if (type == int.class) {_            return Integer.class__        } else if (type == long.class) {_            return Long.class__        } else if (type == float.class) {_            return Float.class__        } else if (type == double.class) {_            return Double.class__        }__        return type__    };converts,a,type,to,its,boxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,boxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,char,class,return,character,class,else,if,type,int,class,return,integer,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToBoxedType(Class<?> type);1532434432;Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToBoxedType(Class<?> type) {_        if (type == boolean.class) {_            return Boolean.class__        } else if (type == byte.class) {_            return Byte.class__        } else if (type == short.class) {_            return Short.class__        } else if (type == char.class) {_            return Character.class__        } else if (type == int.class) {_            return Integer.class__        } else if (type == long.class) {_            return Long.class__        } else if (type == float.class) {_            return Float.class__        } else if (type == double.class) {_            return Double.class__        }__        return type__    };converts,a,type,to,its,boxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,boxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,char,class,return,character,class,else,if,type,int,class,return,integer,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToBoxedType(Class<?> type);1533063033;Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToBoxedType(Class<?> type) {_        if (type == boolean.class) {_            return Boolean.class__        } else if (type == byte.class) {_            return Byte.class__        } else if (type == short.class) {_            return Short.class__        } else if (type == char.class) {_            return Character.class__        } else if (type == int.class) {_            return Integer.class__        } else if (type == long.class) {_            return Long.class__        } else if (type == float.class) {_            return Float.class__        } else if (type == double.class) {_            return Double.class__        }__        return type__    };converts,a,type,to,its,boxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,boxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,char,class,return,character,class,else,if,type,int,class,return,integer,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToBoxedType(Class<?> type);1533815246;Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToBoxedType(Class<?> type) {_        if (type == boolean.class) {_            return Boolean.class__        } else if (type == byte.class) {_            return Byte.class__        } else if (type == short.class) {_            return Short.class__        } else if (type == char.class) {_            return Character.class__        } else if (type == int.class) {_            return Integer.class__        } else if (type == long.class) {_            return Long.class__        } else if (type == float.class) {_            return Float.class__        } else if (type == double.class) {_            return Double.class__        }__        return type__    };converts,a,type,to,its,boxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,boxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,char,class,return,character,class,else,if,type,int,class,return,integer,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToBoxedType(Class<?> type);1534434117;Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToBoxedType(Class<?> type) {_        if (type == boolean.class) {_            return Boolean.class__        } else if (type == byte.class) {_            return Byte.class__        } else if (type == short.class) {_            return Short.class__        } else if (type == char.class) {_            return Character.class__        } else if (type == int.class) {_            return Integer.class__        } else if (type == long.class) {_            return Long.class__        } else if (type == float.class) {_            return Float.class__        } else if (type == double.class) {_            return Double.class__        }__        return type__    };converts,a,type,to,its,boxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,boxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,char,class,return,character,class,else,if,type,int,class,return,integer,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToBoxedType(Class<?> type);1543266328;Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToBoxedType(Class<?> type) {_        if (type == boolean.class) {_            return Boolean.class__        } else if (type == byte.class) {_            return Byte.class__        } else if (type == short.class) {_            return Short.class__        } else if (type == char.class) {_            return Character.class__        } else if (type == int.class) {_            return Integer.class__        } else if (type == long.class) {_            return Long.class__        } else if (type == float.class) {_            return Float.class__        } else if (type == double.class) {_            return Double.class__        }__        return type__    };converts,a,type,to,its,boxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,boxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,char,class,return,character,class,else,if,type,int,class,return,integer,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static boolean isConstantType(Class<?> type);1532069817;Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type_where {@code true} is returned if the type is a constant type and {@code false} otherwise.;public static boolean isConstantType(Class<?> type) {_        return type == boolean.class ||_               type == byte.class    ||_               type == short.class   ||_               type == char.class    ||_               type == int.class     ||_               type == long.class    ||_               type == float.class   ||_               type == double.class  ||_               type == String.class__    };checks,if,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,is,available,as,a,constant,type,where,code,true,is,returned,if,the,type,is,a,constant,type,and,code,false,otherwise;public,static,boolean,is,constant,type,class,type,return,type,boolean,class,type,byte,class,type,short,class,type,char,class,type,int,class,type,long,class,type,float,class,type,double,class,type,string,class
PainlessLookupUtility -> public static boolean isConstantType(Class<?> type);1532434432;Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type_where {@code true} is returned if the type is a constant type and {@code false} otherwise.;public static boolean isConstantType(Class<?> type) {_        return type == boolean.class ||_               type == byte.class    ||_               type == short.class   ||_               type == char.class    ||_               type == int.class     ||_               type == long.class    ||_               type == float.class   ||_               type == double.class  ||_               type == String.class__    };checks,if,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,is,available,as,a,constant,type,where,code,true,is,returned,if,the,type,is,a,constant,type,and,code,false,otherwise;public,static,boolean,is,constant,type,class,type,return,type,boolean,class,type,byte,class,type,short,class,type,char,class,type,int,class,type,long,class,type,float,class,type,double,class,type,string,class
PainlessLookupUtility -> public static boolean isConstantType(Class<?> type);1533063033;Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type_where {@code true} is returned if the type is a constant type and {@code false} otherwise.;public static boolean isConstantType(Class<?> type) {_        return type == boolean.class ||_               type == byte.class    ||_               type == short.class   ||_               type == char.class    ||_               type == int.class     ||_               type == long.class    ||_               type == float.class   ||_               type == double.class  ||_               type == String.class__    };checks,if,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,is,available,as,a,constant,type,where,code,true,is,returned,if,the,type,is,a,constant,type,and,code,false,otherwise;public,static,boolean,is,constant,type,class,type,return,type,boolean,class,type,byte,class,type,short,class,type,char,class,type,int,class,type,long,class,type,float,class,type,double,class,type,string,class
PainlessLookupUtility -> public static boolean isConstantType(Class<?> type);1533815246;Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type_where {@code true} is returned if the type is a constant type and {@code false} otherwise.;public static boolean isConstantType(Class<?> type) {_        return type == boolean.class ||_               type == byte.class    ||_               type == short.class   ||_               type == char.class    ||_               type == int.class     ||_               type == long.class    ||_               type == float.class   ||_               type == double.class  ||_               type == String.class__    };checks,if,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,is,available,as,a,constant,type,where,code,true,is,returned,if,the,type,is,a,constant,type,and,code,false,otherwise;public,static,boolean,is,constant,type,class,type,return,type,boolean,class,type,byte,class,type,short,class,type,char,class,type,int,class,type,long,class,type,float,class,type,double,class,type,string,class
PainlessLookupUtility -> public static boolean isConstantType(Class<?> type);1534434117;Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type_where {@code true} is returned if the type is a constant type and {@code false} otherwise.;public static boolean isConstantType(Class<?> type) {_        return type == boolean.class ||_               type == byte.class    ||_               type == short.class   ||_               type == char.class    ||_               type == int.class     ||_               type == long.class    ||_               type == float.class   ||_               type == double.class  ||_               type == String.class__    };checks,if,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,is,available,as,a,constant,type,where,code,true,is,returned,if,the,type,is,a,constant,type,and,code,false,otherwise;public,static,boolean,is,constant,type,class,type,return,type,boolean,class,type,byte,class,type,short,class,type,char,class,type,int,class,type,long,class,type,float,class,type,double,class,type,string,class
PainlessLookupUtility -> public static boolean isConstantType(Class<?> type);1543266328;Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type_where {@code true} is returned if the type is a constant type and {@code false} otherwise.;public static boolean isConstantType(Class<?> type) {_        return type == boolean.class ||_               type == byte.class    ||_               type == short.class   ||_               type == char.class    ||_               type == int.class     ||_               type == long.class    ||_               type == float.class   ||_               type == double.class  ||_               type == String.class__    };checks,if,a,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,is,available,as,a,constant,type,where,code,true,is,returned,if,the,type,is,a,constant,type,and,code,false,otherwise;public,static,boolean,is,constant,type,class,type,return,type,boolean,class,type,byte,class,type,short,class,type,char,class,type,int,class,type,long,class,type,float,class,type,double,class,type,string,class
PainlessLookupUtility -> public static Class<?> typeToJavaType(Class<?> type);1532069817;Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a_def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an_identity function.;public static Class<?> typeToJavaType(Class<?> type) {_        Objects.requireNonNull(type)___        if (type.isArray()) {_            Class<?> typeComponent = type.getComponentType()__            int arrayDimensions = 1___            while (typeComponent.isArray()) {_                typeComponent = typeComponent.getComponentType()__                ++arrayDimensions__            }__            if (typeComponent == def.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (type == def.class) {_            return Object.class__        }__        return type__    };converts,a,type,to,a,java,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,a,def,class,or,def,array,the,returned,type,will,be,the,equivalent,object,class,or,object,array,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,java,type,class,type,objects,require,non,null,type,if,type,is,array,class,type,component,type,get,component,type,int,array,dimensions,1,while,type,component,is,array,type,component,type,component,get,component,type,array,dimensions,if,type,component,def,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,object,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,type,def,class,return,object,class,return,type
PainlessLookupUtility -> public static Class<?> typeToJavaType(Class<?> type);1532434432;Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a_def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an_identity function.;public static Class<?> typeToJavaType(Class<?> type) {_        Objects.requireNonNull(type)___        if (type.isArray()) {_            Class<?> typeComponent = type.getComponentType()__            int arrayDimensions = 1___            while (typeComponent.isArray()) {_                typeComponent = typeComponent.getComponentType()__                ++arrayDimensions__            }__            if (typeComponent == def.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (type == def.class) {_            return Object.class__        }__        return type__    };converts,a,type,to,a,java,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,a,def,class,or,def,array,the,returned,type,will,be,the,equivalent,object,class,or,object,array,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,java,type,class,type,objects,require,non,null,type,if,type,is,array,class,type,component,type,get,component,type,int,array,dimensions,1,while,type,component,is,array,type,component,type,component,get,component,type,array,dimensions,if,type,component,def,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,object,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,type,def,class,return,object,class,return,type
PainlessLookupUtility -> public static Class<?> typeToJavaType(Class<?> type);1533063033;Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a_def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an_identity function.;public static Class<?> typeToJavaType(Class<?> type) {_        Objects.requireNonNull(type)___        if (type.isArray()) {_            Class<?> typeComponent = type.getComponentType()__            int arrayDimensions = 1___            while (typeComponent.isArray()) {_                typeComponent = typeComponent.getComponentType()__                ++arrayDimensions__            }__            if (typeComponent == def.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (type == def.class) {_            return Object.class__        }__        return type__    };converts,a,type,to,a,java,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,a,def,class,or,def,array,the,returned,type,will,be,the,equivalent,object,class,or,object,array,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,java,type,class,type,objects,require,non,null,type,if,type,is,array,class,type,component,type,get,component,type,int,array,dimensions,1,while,type,component,is,array,type,component,type,component,get,component,type,array,dimensions,if,type,component,def,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,object,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,type,def,class,return,object,class,return,type
PainlessLookupUtility -> public static Class<?> typeToJavaType(Class<?> type);1533815246;Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a_def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an_identity function.;public static Class<?> typeToJavaType(Class<?> type) {_        Objects.requireNonNull(type)___        if (type.isArray()) {_            Class<?> typeComponent = type.getComponentType()__            int arrayDimensions = 1___            while (typeComponent.isArray()) {_                typeComponent = typeComponent.getComponentType()__                ++arrayDimensions__            }__            if (typeComponent == def.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (type == def.class) {_            return Object.class__        }__        return type__    };converts,a,type,to,a,java,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,a,def,class,or,def,array,the,returned,type,will,be,the,equivalent,object,class,or,object,array,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,java,type,class,type,objects,require,non,null,type,if,type,is,array,class,type,component,type,get,component,type,int,array,dimensions,1,while,type,component,is,array,type,component,type,component,get,component,type,array,dimensions,if,type,component,def,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,object,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,type,def,class,return,object,class,return,type
PainlessLookupUtility -> public static Class<?> typeToJavaType(Class<?> type);1534434117;Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a_def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an_identity function.;public static Class<?> typeToJavaType(Class<?> type) {_        Objects.requireNonNull(type)___        if (type.isArray()) {_            Class<?> typeComponent = type.getComponentType()__            int arrayDimensions = 1___            while (typeComponent.isArray()) {_                typeComponent = typeComponent.getComponentType()__                ++arrayDimensions__            }__            if (typeComponent == def.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (type == def.class) {_            return Object.class__        }__        return type__    };converts,a,type,to,a,java,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,a,def,class,or,def,array,the,returned,type,will,be,the,equivalent,object,class,or,object,array,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,java,type,class,type,objects,require,non,null,type,if,type,is,array,class,type,component,type,get,component,type,int,array,dimensions,1,while,type,component,is,array,type,component,type,component,get,component,type,array,dimensions,if,type,component,def,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,object,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,type,def,class,return,object,class,return,type
PainlessLookupUtility -> public static Class<?> typeToJavaType(Class<?> type);1543266328;Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a_def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an_identity function.;public static Class<?> typeToJavaType(Class<?> type) {_        Objects.requireNonNull(type)___        if (type.isArray()) {_            Class<?> typeComponent = type.getComponentType()__            int arrayDimensions = 1___            while (typeComponent.isArray()) {_                typeComponent = typeComponent.getComponentType()__                ++arrayDimensions__            }__            if (typeComponent == def.class) {_                char[] arrayBraces = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')___                try {_                    return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + "_")__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        } else if (type == def.class) {_            return Object.class__        }__        return type__    };converts,a,type,to,a,java,type,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,where,if,a,type,is,a,def,class,or,def,array,the,returned,type,will,be,the,equivalent,object,class,or,object,array,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,java,type,class,type,objects,require,non,null,type,if,type,is,array,class,type,component,type,get,component,type,int,array,dimensions,1,while,type,component,is,array,type,component,type,component,get,component,type,array,dimensions,if,type,component,def,class,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,try,return,class,for,name,new,string,array,braces,l,object,class,get,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,else,if,type,def,class,return,object,class,return,type
PainlessLookupUtility -> public static String typesToCanonicalTypeNames(List<Class<?>> types);1532069817;Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the_documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list_of classes or a mixed list of classes and types to a list of canonical type names as a string as well.;public static String typesToCanonicalTypeNames(List<Class<?>> types) {_        StringBuilder typesStringBuilder = new StringBuilder("[")___        int anyTypesSize = types.size()__        int anyTypesIndex = 0___        for (Class<?> painlessType : types) {_            String canonicalTypeName = typeToCanonicalTypeName(painlessType)___            typesStringBuilder.append(canonicalTypeName)___            if (++anyTypesIndex < anyTypesSize) {_                typesStringBuilder.append(",")__            }_        }__        typesStringBuilder.append("]")___        return typesStringBuilder.toString()__    };converts,a,list,of,types,to,a,list,of,canonical,type,names,as,a,string,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,list,of,classes,or,a,mixed,list,of,classes,and,types,to,a,list,of,canonical,type,names,as,a,string,as,well;public,static,string,types,to,canonical,type,names,list,class,types,string,builder,types,string,builder,new,string,builder,int,any,types,size,types,size,int,any,types,index,0,for,class,painless,type,types,string,canonical,type,name,type,to,canonical,type,name,painless,type,types,string,builder,append,canonical,type,name,if,any,types,index,any,types,size,types,string,builder,append,types,string,builder,append,return,types,string,builder,to,string
PainlessLookupUtility -> public static String typesToCanonicalTypeNames(List<Class<?>> types);1532434432;Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the_documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list_of classes or a mixed list of classes and types to a list of canonical type names as a string as well.;public static String typesToCanonicalTypeNames(List<Class<?>> types) {_        StringBuilder typesStringBuilder = new StringBuilder("[")___        int anyTypesSize = types.size()__        int anyTypesIndex = 0___        for (Class<?> painlessType : types) {_            String canonicalTypeName = typeToCanonicalTypeName(painlessType)___            typesStringBuilder.append(canonicalTypeName)___            if (++anyTypesIndex < anyTypesSize) {_                typesStringBuilder.append(",")__            }_        }__        typesStringBuilder.append("]")___        return typesStringBuilder.toString()__    };converts,a,list,of,types,to,a,list,of,canonical,type,names,as,a,string,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,list,of,classes,or,a,mixed,list,of,classes,and,types,to,a,list,of,canonical,type,names,as,a,string,as,well;public,static,string,types,to,canonical,type,names,list,class,types,string,builder,types,string,builder,new,string,builder,int,any,types,size,types,size,int,any,types,index,0,for,class,painless,type,types,string,canonical,type,name,type,to,canonical,type,name,painless,type,types,string,builder,append,canonical,type,name,if,any,types,index,any,types,size,types,string,builder,append,types,string,builder,append,return,types,string,builder,to,string
PainlessLookupUtility -> public static String typesToCanonicalTypeNames(List<Class<?>> types);1533063033;Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the_documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list_of classes or a mixed list of classes and types to a list of canonical type names as a string as well.;public static String typesToCanonicalTypeNames(List<Class<?>> types) {_        StringBuilder typesStringBuilder = new StringBuilder("[")___        int anyTypesSize = types.size()__        int anyTypesIndex = 0___        for (Class<?> painlessType : types) {_            String canonicalTypeName = typeToCanonicalTypeName(painlessType)___            typesStringBuilder.append(canonicalTypeName)___            if (++anyTypesIndex < anyTypesSize) {_                typesStringBuilder.append(",")__            }_        }__        typesStringBuilder.append("]")___        return typesStringBuilder.toString()__    };converts,a,list,of,types,to,a,list,of,canonical,type,names,as,a,string,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,list,of,classes,or,a,mixed,list,of,classes,and,types,to,a,list,of,canonical,type,names,as,a,string,as,well;public,static,string,types,to,canonical,type,names,list,class,types,string,builder,types,string,builder,new,string,builder,int,any,types,size,types,size,int,any,types,index,0,for,class,painless,type,types,string,canonical,type,name,type,to,canonical,type,name,painless,type,types,string,builder,append,canonical,type,name,if,any,types,index,any,types,size,types,string,builder,append,types,string,builder,append,return,types,string,builder,to,string
PainlessLookupUtility -> public static String typesToCanonicalTypeNames(List<Class<?>> types);1533815246;Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the_documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list_of classes or a mixed list of classes and types to a list of canonical type names as a string as well.;public static String typesToCanonicalTypeNames(List<Class<?>> types) {_        StringBuilder typesStringBuilder = new StringBuilder("[")___        int anyTypesSize = types.size()__        int anyTypesIndex = 0___        for (Class<?> painlessType : types) {_            String canonicalTypeName = typeToCanonicalTypeName(painlessType)___            typesStringBuilder.append(canonicalTypeName)___            if (++anyTypesIndex < anyTypesSize) {_                typesStringBuilder.append(",")__            }_        }__        typesStringBuilder.append("]")___        return typesStringBuilder.toString()__    };converts,a,list,of,types,to,a,list,of,canonical,type,names,as,a,string,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,list,of,classes,or,a,mixed,list,of,classes,and,types,to,a,list,of,canonical,type,names,as,a,string,as,well;public,static,string,types,to,canonical,type,names,list,class,types,string,builder,types,string,builder,new,string,builder,int,any,types,size,types,size,int,any,types,index,0,for,class,painless,type,types,string,canonical,type,name,type,to,canonical,type,name,painless,type,types,string,builder,append,canonical,type,name,if,any,types,index,any,types,size,types,string,builder,append,types,string,builder,append,return,types,string,builder,to,string
PainlessLookupUtility -> public static String typesToCanonicalTypeNames(List<Class<?>> types);1534434117;Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the_documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list_of classes or a mixed list of classes and types to a list of canonical type names as a string as well.;public static String typesToCanonicalTypeNames(List<Class<?>> types) {_        StringBuilder typesStringBuilder = new StringBuilder("[")___        int anyTypesSize = types.size()__        int anyTypesIndex = 0___        for (Class<?> painlessType : types) {_            String canonicalTypeName = typeToCanonicalTypeName(painlessType)___            typesStringBuilder.append(canonicalTypeName)___            if (++anyTypesIndex < anyTypesSize) {_                typesStringBuilder.append(",")__            }_        }__        typesStringBuilder.append("]")___        return typesStringBuilder.toString()__    };converts,a,list,of,types,to,a,list,of,canonical,type,names,as,a,string,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,list,of,classes,or,a,mixed,list,of,classes,and,types,to,a,list,of,canonical,type,names,as,a,string,as,well;public,static,string,types,to,canonical,type,names,list,class,types,string,builder,types,string,builder,new,string,builder,int,any,types,size,types,size,int,any,types,index,0,for,class,painless,type,types,string,canonical,type,name,type,to,canonical,type,name,painless,type,types,string,builder,append,canonical,type,name,if,any,types,index,any,types,size,types,string,builder,append,types,string,builder,append,return,types,string,builder,to,string
PainlessLookupUtility -> public static String typesToCanonicalTypeNames(List<Class<?>> types);1543266328;Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the_documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list_of classes or a mixed list of classes and types to a list of canonical type names as a string as well.;public static String typesToCanonicalTypeNames(List<Class<?>> types) {_        StringBuilder typesStringBuilder = new StringBuilder("[")___        int anyTypesSize = types.size()__        int anyTypesIndex = 0___        for (Class<?> painlessType : types) {_            String canonicalTypeName = typeToCanonicalTypeName(painlessType)___            typesStringBuilder.append(canonicalTypeName)___            if (++anyTypesIndex < anyTypesSize) {_                typesStringBuilder.append(",")__            }_        }__        typesStringBuilder.append("]")___        return typesStringBuilder.toString()__    };converts,a,list,of,types,to,a,list,of,canonical,type,names,as,a,string,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,list,of,classes,or,a,mixed,list,of,classes,and,types,to,a,list,of,canonical,type,names,as,a,string,as,well;public,static,string,types,to,canonical,type,names,list,class,types,string,builder,types,string,builder,new,string,builder,int,any,types,size,types,size,int,any,types,index,0,for,class,painless,type,types,string,canonical,type,name,type,to,canonical,type,name,painless,type,types,string,builder,append,canonical,type,name,if,any,types,index,any,types,size,types,string,builder,append,types,string,builder,append,return,types,string,builder,to,string
PainlessLookupUtility -> public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses);1532069817;Converts a canonical type name to a type based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will_safely convert a canonical class name to a class as well.;public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {_        Objects.requireNonNull(canonicalTypeName)__        Objects.requireNonNull(canonicalClassNamesToClasses)___        Class<?> type = canonicalClassNamesToClasses.get(canonicalTypeName)___        if (type != null) {_            return type__        }__        int arrayDimensions = 0__        int arrayIndex = canonicalTypeName.indexOf('[')___        if (arrayIndex != -1) {_            int typeNameLength = canonicalTypeName.length()___            while (arrayIndex < typeNameLength) {_                if (canonicalTypeName.charAt(arrayIndex) == '[' &&_                    ++arrayIndex < typeNameLength  &&_                    canonicalTypeName.charAt(arrayIndex++) == ']') {_                    ++arrayDimensions__                } else {_                    throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__                }_            }__            canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('['))__            type = canonicalClassNamesToClasses.get(canonicalTypeName)___            char arrayBraces[] = new char[arrayDimensions]__            Arrays.fill(arrayBraces, '[')__            String javaTypeName = new String(arrayBraces)___            if (type == boolean.class) {_                javaTypeName += "Z"__            } else if (type == byte.class) {_                javaTypeName += "B"__            } else if (type == short.class) {_                javaTypeName += "S"__            } else if (type == char.class) {_                javaTypeName += "C"__            } else if (type == int.class) {_                javaTypeName += "I"__            } else if (type == long.class) {_                javaTypeName += "J"__            } else if (type == float.class) {_                javaTypeName += "F"__            } else if (type == double.class) {_                javaTypeName += "D"__            } else {_                javaTypeName += "L" + type.getName() + "_"__            }__            try {_                return Class.forName(javaTypeName)__            } catch (ClassNotFoundException cnfe) {_                throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found", cnfe)__            }_        }__        throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__    };converts,a,canonical,type,name,to,a,type,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,canonical,class,names,are,a,subset,of,canonical,type,names,this,method,will,safely,convert,a,canonical,class,name,to,a,class,as,well;public,static,class,canonical,type,name,to,type,string,canonical,type,name,map,string,class,canonical,class,names,to,classes,objects,require,non,null,canonical,type,name,objects,require,non,null,canonical,class,names,to,classes,class,type,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,return,type,int,array,dimensions,0,int,array,index,canonical,type,name,index,of,if,array,index,1,int,type,name,length,canonical,type,name,length,while,array,index,type,name,length,if,canonical,type,name,char,at,array,index,array,index,type,name,length,canonical,type,name,char,at,array,index,array,dimensions,else,throw,new,illegal,argument,exception,type,canonical,type,name,not,found,canonical,type,name,canonical,type,name,substring,0,canonical,type,name,index,of,type,canonical,class,names,to,classes,get,canonical,type,name,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,string,java,type,name,new,string,array,braces,if,type,boolean,class,java,type,name,z,else,if,type,byte,class,java,type,name,b,else,if,type,short,class,java,type,name,s,else,if,type,char,class,java,type,name,c,else,if,type,int,class,java,type,name,i,else,if,type,long,class,java,type,name,j,else,if,type,float,class,java,type,name,f,else,if,type,double,class,java,type,name,d,else,java,type,name,l,type,get,name,try,return,class,for,name,java,type,name,catch,class,not,found,exception,cnfe,throw,new,illegal,argument,exception,type,canonical,type,name,not,found,cnfe,throw,new,illegal,argument,exception,type,canonical,type,name,not,found
PainlessLookupUtility -> public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses);1532434432;Converts a canonical type name to a type based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will_safely convert a canonical class name to a class as well.;public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {_        Objects.requireNonNull(canonicalTypeName)__        Objects.requireNonNull(canonicalClassNamesToClasses)___        Class<?> type = canonicalClassNamesToClasses.get(canonicalTypeName)___        if (type != null) {_            return type__        }__        int arrayDimensions = 0__        int arrayIndex = canonicalTypeName.indexOf('[')___        if (arrayIndex != -1) {_            int typeNameLength = canonicalTypeName.length()___            while (arrayIndex < typeNameLength) {_                if (canonicalTypeName.charAt(arrayIndex) == '[' &&_                    ++arrayIndex < typeNameLength  &&_                    canonicalTypeName.charAt(arrayIndex++) == ']') {_                    ++arrayDimensions__                } else {_                    throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__                }_            }__            canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('['))__            type = canonicalClassNamesToClasses.get(canonicalTypeName)___            char arrayBraces[] = new char[arrayDimensions]__            Arrays.fill(arrayBraces, '[')__            String javaTypeName = new String(arrayBraces)___            if (type == boolean.class) {_                javaTypeName += "Z"__            } else if (type == byte.class) {_                javaTypeName += "B"__            } else if (type == short.class) {_                javaTypeName += "S"__            } else if (type == char.class) {_                javaTypeName += "C"__            } else if (type == int.class) {_                javaTypeName += "I"__            } else if (type == long.class) {_                javaTypeName += "J"__            } else if (type == float.class) {_                javaTypeName += "F"__            } else if (type == double.class) {_                javaTypeName += "D"__            } else {_                javaTypeName += "L" + type.getName() + "_"__            }__            try {_                return Class.forName(javaTypeName)__            } catch (ClassNotFoundException cnfe) {_                throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found", cnfe)__            }_        }__        throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__    };converts,a,canonical,type,name,to,a,type,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,canonical,class,names,are,a,subset,of,canonical,type,names,this,method,will,safely,convert,a,canonical,class,name,to,a,class,as,well;public,static,class,canonical,type,name,to,type,string,canonical,type,name,map,string,class,canonical,class,names,to,classes,objects,require,non,null,canonical,type,name,objects,require,non,null,canonical,class,names,to,classes,class,type,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,return,type,int,array,dimensions,0,int,array,index,canonical,type,name,index,of,if,array,index,1,int,type,name,length,canonical,type,name,length,while,array,index,type,name,length,if,canonical,type,name,char,at,array,index,array,index,type,name,length,canonical,type,name,char,at,array,index,array,dimensions,else,throw,new,illegal,argument,exception,type,canonical,type,name,not,found,canonical,type,name,canonical,type,name,substring,0,canonical,type,name,index,of,type,canonical,class,names,to,classes,get,canonical,type,name,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,string,java,type,name,new,string,array,braces,if,type,boolean,class,java,type,name,z,else,if,type,byte,class,java,type,name,b,else,if,type,short,class,java,type,name,s,else,if,type,char,class,java,type,name,c,else,if,type,int,class,java,type,name,i,else,if,type,long,class,java,type,name,j,else,if,type,float,class,java,type,name,f,else,if,type,double,class,java,type,name,d,else,java,type,name,l,type,get,name,try,return,class,for,name,java,type,name,catch,class,not,found,exception,cnfe,throw,new,illegal,argument,exception,type,canonical,type,name,not,found,cnfe,throw,new,illegal,argument,exception,type,canonical,type,name,not,found
PainlessLookupUtility -> public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses);1533063033;Converts a canonical type name to a type based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will_safely convert a canonical class name to a class as well.;public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {_        Objects.requireNonNull(canonicalTypeName)__        Objects.requireNonNull(canonicalClassNamesToClasses)___        Class<?> type = canonicalClassNamesToClasses.get(canonicalTypeName)___        if (type != null) {_            return type__        }__        int arrayDimensions = 0__        int arrayIndex = canonicalTypeName.indexOf('[')___        if (arrayIndex != -1) {_            int typeNameLength = canonicalTypeName.length()___            while (arrayIndex < typeNameLength) {_                if (canonicalTypeName.charAt(arrayIndex) == '[' &&_                    ++arrayIndex < typeNameLength  &&_                    canonicalTypeName.charAt(arrayIndex++) == ']') {_                    ++arrayDimensions__                } else {_                    throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__                }_            }__            canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('['))__            type = canonicalClassNamesToClasses.get(canonicalTypeName)___            char arrayBraces[] = new char[arrayDimensions]__            Arrays.fill(arrayBraces, '[')__            String javaTypeName = new String(arrayBraces)___            if (type == boolean.class) {_                javaTypeName += "Z"__            } else if (type == byte.class) {_                javaTypeName += "B"__            } else if (type == short.class) {_                javaTypeName += "S"__            } else if (type == char.class) {_                javaTypeName += "C"__            } else if (type == int.class) {_                javaTypeName += "I"__            } else if (type == long.class) {_                javaTypeName += "J"__            } else if (type == float.class) {_                javaTypeName += "F"__            } else if (type == double.class) {_                javaTypeName += "D"__            } else {_                javaTypeName += "L" + type.getName() + "_"__            }__            try {_                return Class.forName(javaTypeName)__            } catch (ClassNotFoundException cnfe) {_                throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found", cnfe)__            }_        }__        throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__    };converts,a,canonical,type,name,to,a,type,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,canonical,class,names,are,a,subset,of,canonical,type,names,this,method,will,safely,convert,a,canonical,class,name,to,a,class,as,well;public,static,class,canonical,type,name,to,type,string,canonical,type,name,map,string,class,canonical,class,names,to,classes,objects,require,non,null,canonical,type,name,objects,require,non,null,canonical,class,names,to,classes,class,type,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,return,type,int,array,dimensions,0,int,array,index,canonical,type,name,index,of,if,array,index,1,int,type,name,length,canonical,type,name,length,while,array,index,type,name,length,if,canonical,type,name,char,at,array,index,array,index,type,name,length,canonical,type,name,char,at,array,index,array,dimensions,else,throw,new,illegal,argument,exception,type,canonical,type,name,not,found,canonical,type,name,canonical,type,name,substring,0,canonical,type,name,index,of,type,canonical,class,names,to,classes,get,canonical,type,name,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,string,java,type,name,new,string,array,braces,if,type,boolean,class,java,type,name,z,else,if,type,byte,class,java,type,name,b,else,if,type,short,class,java,type,name,s,else,if,type,char,class,java,type,name,c,else,if,type,int,class,java,type,name,i,else,if,type,long,class,java,type,name,j,else,if,type,float,class,java,type,name,f,else,if,type,double,class,java,type,name,d,else,java,type,name,l,type,get,name,try,return,class,for,name,java,type,name,catch,class,not,found,exception,cnfe,throw,new,illegal,argument,exception,type,canonical,type,name,not,found,cnfe,throw,new,illegal,argument,exception,type,canonical,type,name,not,found
PainlessLookupUtility -> public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses);1533815246;Converts a canonical type name to a type based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will_safely convert a canonical class name to a class as well.;public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {_        Objects.requireNonNull(canonicalTypeName)__        Objects.requireNonNull(canonicalClassNamesToClasses)___        Class<?> type = canonicalClassNamesToClasses.get(canonicalTypeName)___        if (type != null) {_            return type__        }__        int arrayDimensions = 0__        int arrayIndex = canonicalTypeName.indexOf('[')___        if (arrayIndex != -1) {_            int typeNameLength = canonicalTypeName.length()___            while (arrayIndex < typeNameLength) {_                if (canonicalTypeName.charAt(arrayIndex) == '[' &&_                    ++arrayIndex < typeNameLength  &&_                    canonicalTypeName.charAt(arrayIndex++) == ']') {_                    ++arrayDimensions__                } else {_                    return null__                }_            }__            canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('['))__            type = canonicalClassNamesToClasses.get(canonicalTypeName)___            if (type != null) {_                char arrayBraces[] = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')__                String javaTypeName = new String(arrayBraces)___                if (type == boolean.class) {_                    javaTypeName += "Z"__                } else if (type == byte.class) {_                    javaTypeName += "B"__                } else if (type == short.class) {_                    javaTypeName += "S"__                } else if (type == char.class) {_                    javaTypeName += "C"__                } else if (type == int.class) {_                    javaTypeName += "I"__                } else if (type == long.class) {_                    javaTypeName += "J"__                } else if (type == float.class) {_                    javaTypeName += "F"__                } else if (type == double.class) {_                    javaTypeName += "D"__                } else {_                    javaTypeName += "L" + type.getName() + "_"__                }__                try {_                    return Class.forName(javaTypeName)__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        }__        return null__    };converts,a,canonical,type,name,to,a,type,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,canonical,class,names,are,a,subset,of,canonical,type,names,this,method,will,safely,convert,a,canonical,class,name,to,a,class,as,well;public,static,class,canonical,type,name,to,type,string,canonical,type,name,map,string,class,canonical,class,names,to,classes,objects,require,non,null,canonical,type,name,objects,require,non,null,canonical,class,names,to,classes,class,type,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,return,type,int,array,dimensions,0,int,array,index,canonical,type,name,index,of,if,array,index,1,int,type,name,length,canonical,type,name,length,while,array,index,type,name,length,if,canonical,type,name,char,at,array,index,array,index,type,name,length,canonical,type,name,char,at,array,index,array,dimensions,else,return,null,canonical,type,name,canonical,type,name,substring,0,canonical,type,name,index,of,type,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,string,java,type,name,new,string,array,braces,if,type,boolean,class,java,type,name,z,else,if,type,byte,class,java,type,name,b,else,if,type,short,class,java,type,name,s,else,if,type,char,class,java,type,name,c,else,if,type,int,class,java,type,name,i,else,if,type,long,class,java,type,name,j,else,if,type,float,class,java,type,name,f,else,if,type,double,class,java,type,name,d,else,java,type,name,l,type,get,name,try,return,class,for,name,java,type,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,return,null
PainlessLookupUtility -> public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses);1534434117;Converts a canonical type name to a type based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will_safely convert a canonical class name to a class as well.;public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {_        Objects.requireNonNull(canonicalTypeName)__        Objects.requireNonNull(canonicalClassNamesToClasses)___        Class<?> type = DEF_CLASS_NAME.equals(canonicalTypeName) ? def.class : canonicalClassNamesToClasses.get(canonicalTypeName)___        if (type != null) {_            return type__        }__        int arrayDimensions = 0__        int arrayIndex = canonicalTypeName.indexOf('[')___        if (arrayIndex != -1) {_            int typeNameLength = canonicalTypeName.length()___            while (arrayIndex < typeNameLength) {_                if (canonicalTypeName.charAt(arrayIndex) == '[' &&_                    ++arrayIndex < typeNameLength  &&_                    canonicalTypeName.charAt(arrayIndex++) == ']') {_                    ++arrayDimensions__                } else {_                    return null__                }_            }__            canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('['))__            type = DEF_CLASS_NAME.equals(canonicalTypeName) ? def.class : canonicalClassNamesToClasses.get(canonicalTypeName)___            if (type != null) {_                char arrayBraces[] = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')__                String javaTypeName = new String(arrayBraces)___                if (type == boolean.class) {_                    javaTypeName += "Z"__                } else if (type == byte.class) {_                    javaTypeName += "B"__                } else if (type == short.class) {_                    javaTypeName += "S"__                } else if (type == char.class) {_                    javaTypeName += "C"__                } else if (type == int.class) {_                    javaTypeName += "I"__                } else if (type == long.class) {_                    javaTypeName += "J"__                } else if (type == float.class) {_                    javaTypeName += "F"__                } else if (type == double.class) {_                    javaTypeName += "D"__                } else {_                    javaTypeName += "L" + type.getName() + "_"__                }__                try {_                    return Class.forName(javaTypeName)__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        }__        return null__    };converts,a,canonical,type,name,to,a,type,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,canonical,class,names,are,a,subset,of,canonical,type,names,this,method,will,safely,convert,a,canonical,class,name,to,a,class,as,well;public,static,class,canonical,type,name,to,type,string,canonical,type,name,map,string,class,canonical,class,names,to,classes,objects,require,non,null,canonical,type,name,objects,require,non,null,canonical,class,names,to,classes,class,type,equals,canonical,type,name,def,class,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,return,type,int,array,dimensions,0,int,array,index,canonical,type,name,index,of,if,array,index,1,int,type,name,length,canonical,type,name,length,while,array,index,type,name,length,if,canonical,type,name,char,at,array,index,array,index,type,name,length,canonical,type,name,char,at,array,index,array,dimensions,else,return,null,canonical,type,name,canonical,type,name,substring,0,canonical,type,name,index,of,type,equals,canonical,type,name,def,class,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,string,java,type,name,new,string,array,braces,if,type,boolean,class,java,type,name,z,else,if,type,byte,class,java,type,name,b,else,if,type,short,class,java,type,name,s,else,if,type,char,class,java,type,name,c,else,if,type,int,class,java,type,name,i,else,if,type,long,class,java,type,name,j,else,if,type,float,class,java,type,name,f,else,if,type,double,class,java,type,name,d,else,java,type,name,l,type,get,name,try,return,class,for,name,java,type,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,return,null
PainlessLookupUtility -> public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses);1543266328;Converts a canonical type name to a type based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will_safely convert a canonical class name to a class as well.;public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {_        Objects.requireNonNull(canonicalTypeName)__        Objects.requireNonNull(canonicalClassNamesToClasses)___        Class<?> type = DEF_CLASS_NAME.equals(canonicalTypeName) ? def.class : canonicalClassNamesToClasses.get(canonicalTypeName)___        if (type != null) {_            return type__        }__        int arrayDimensions = 0__        int arrayIndex = canonicalTypeName.indexOf('[')___        if (arrayIndex != -1) {_            int typeNameLength = canonicalTypeName.length()___            while (arrayIndex < typeNameLength) {_                if (canonicalTypeName.charAt(arrayIndex) == '[' &&_                    ++arrayIndex < typeNameLength  &&_                    canonicalTypeName.charAt(arrayIndex++) == ']') {_                    ++arrayDimensions__                } else {_                    return null__                }_            }__            canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('['))__            type = DEF_CLASS_NAME.equals(canonicalTypeName) ? def.class : canonicalClassNamesToClasses.get(canonicalTypeName)___            if (type != null) {_                char arrayBraces[] = new char[arrayDimensions]__                Arrays.fill(arrayBraces, '[')__                String javaTypeName = new String(arrayBraces)___                if (type == boolean.class) {_                    javaTypeName += "Z"__                } else if (type == byte.class) {_                    javaTypeName += "B"__                } else if (type == short.class) {_                    javaTypeName += "S"__                } else if (type == char.class) {_                    javaTypeName += "C"__                } else if (type == int.class) {_                    javaTypeName += "I"__                } else if (type == long.class) {_                    javaTypeName += "J"__                } else if (type == float.class) {_                    javaTypeName += "F"__                } else if (type == double.class) {_                    javaTypeName += "D"__                } else {_                    javaTypeName += "L" + type.getName() + "_"__                }__                try {_                    return Class.forName(javaTypeName)__                } catch (ClassNotFoundException cnfe) {_                    throw new IllegalStateException("internal error", cnfe)__                }_            }_        }__        return null__    };converts,a,canonical,type,name,to,a,type,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,canonical,class,names,are,a,subset,of,canonical,type,names,this,method,will,safely,convert,a,canonical,class,name,to,a,class,as,well;public,static,class,canonical,type,name,to,type,string,canonical,type,name,map,string,class,canonical,class,names,to,classes,objects,require,non,null,canonical,type,name,objects,require,non,null,canonical,class,names,to,classes,class,type,equals,canonical,type,name,def,class,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,return,type,int,array,dimensions,0,int,array,index,canonical,type,name,index,of,if,array,index,1,int,type,name,length,canonical,type,name,length,while,array,index,type,name,length,if,canonical,type,name,char,at,array,index,array,index,type,name,length,canonical,type,name,char,at,array,index,array,dimensions,else,return,null,canonical,type,name,canonical,type,name,substring,0,canonical,type,name,index,of,type,equals,canonical,type,name,def,class,canonical,class,names,to,classes,get,canonical,type,name,if,type,null,char,array,braces,new,char,array,dimensions,arrays,fill,array,braces,string,java,type,name,new,string,array,braces,if,type,boolean,class,java,type,name,z,else,if,type,byte,class,java,type,name,b,else,if,type,short,class,java,type,name,s,else,if,type,char,class,java,type,name,c,else,if,type,int,class,java,type,name,i,else,if,type,long,class,java,type,name,j,else,if,type,float,class,java,type,name,f,else,if,type,double,class,java,type,name,d,else,java,type,name,l,type,get,name,try,return,class,for,name,java,type,name,catch,class,not,found,exception,cnfe,throw,new,illegal,state,exception,internal,error,cnfe,return,null
PainlessLookupUtility -> public static String typeToCanonicalTypeName(Class<?> type);1532069817;Converts a type to a canonical type name based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class_to a canonical class name as well.;public static String typeToCanonicalTypeName(Class<?> type) {_        Objects.requireNonNull(type)___        String canonicalTypeName = type.getCanonicalName()___        if (canonicalTypeName.startsWith(def.class.getName())) {_            canonicalTypeName = canonicalTypeName.replace(def.class.getName(), DEF_TYPE_NAME)__        }__        return canonicalTypeName__    };converts,a,type,to,a,canonical,type,name,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,class,to,a,canonical,class,name,as,well;public,static,string,type,to,canonical,type,name,class,type,objects,require,non,null,type,string,canonical,type,name,type,get,canonical,name,if,canonical,type,name,starts,with,def,class,get,name,canonical,type,name,canonical,type,name,replace,def,class,get,name,return,canonical,type,name
PainlessLookupUtility -> public static String typeToCanonicalTypeName(Class<?> type);1532434432;Converts a type to a canonical type name based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class_to a canonical class name as well.;public static String typeToCanonicalTypeName(Class<?> type) {_        Objects.requireNonNull(type)___        String canonicalTypeName = type.getCanonicalName()___        if (canonicalTypeName.startsWith(def.class.getCanonicalName())) {_            canonicalTypeName = canonicalTypeName.replace(def.class.getCanonicalName(), DEF_CLASS_NAME)__        }__        return canonicalTypeName__    };converts,a,type,to,a,canonical,type,name,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,class,to,a,canonical,class,name,as,well;public,static,string,type,to,canonical,type,name,class,type,objects,require,non,null,type,string,canonical,type,name,type,get,canonical,name,if,canonical,type,name,starts,with,def,class,get,canonical,name,canonical,type,name,canonical,type,name,replace,def,class,get,canonical,name,return,canonical,type,name
PainlessLookupUtility -> public static String typeToCanonicalTypeName(Class<?> type);1533063033;Converts a type to a canonical type name based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class_to a canonical class name as well.;public static String typeToCanonicalTypeName(Class<?> type) {_        Objects.requireNonNull(type)___        String canonicalTypeName = type.getCanonicalName()___        if (canonicalTypeName.startsWith(def.class.getCanonicalName())) {_            canonicalTypeName = canonicalTypeName.replace(def.class.getCanonicalName(), DEF_CLASS_NAME)__        }__        return canonicalTypeName__    };converts,a,type,to,a,canonical,type,name,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,class,to,a,canonical,class,name,as,well;public,static,string,type,to,canonical,type,name,class,type,objects,require,non,null,type,string,canonical,type,name,type,get,canonical,name,if,canonical,type,name,starts,with,def,class,get,canonical,name,canonical,type,name,canonical,type,name,replace,def,class,get,canonical,name,return,canonical,type,name
PainlessLookupUtility -> public static String typeToCanonicalTypeName(Class<?> type);1533815246;Converts a type to a canonical type name based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class_to a canonical class name as well.;public static String typeToCanonicalTypeName(Class<?> type) {_        Objects.requireNonNull(type)___        String canonicalTypeName = type.getCanonicalName()___        if (canonicalTypeName == null) {_            canonicalTypeName = ANONYMOUS_CLASS_NAME__        } else if (canonicalTypeName.startsWith(def.class.getCanonicalName())) {_            canonicalTypeName = canonicalTypeName.replace(def.class.getCanonicalName(), DEF_CLASS_NAME)__        }__        return canonicalTypeName__    };converts,a,type,to,a,canonical,type,name,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,class,to,a,canonical,class,name,as,well;public,static,string,type,to,canonical,type,name,class,type,objects,require,non,null,type,string,canonical,type,name,type,get,canonical,name,if,canonical,type,name,null,canonical,type,name,else,if,canonical,type,name,starts,with,def,class,get,canonical,name,canonical,type,name,canonical,type,name,replace,def,class,get,canonical,name,return,canonical,type,name
PainlessLookupUtility -> public static String typeToCanonicalTypeName(Class<?> type);1534434117;Converts a type to a canonical type name based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class_to a canonical class name as well.;public static String typeToCanonicalTypeName(Class<?> type) {_        Objects.requireNonNull(type)___        String canonicalTypeName = type.getCanonicalName()___        if (canonicalTypeName == null) {_            canonicalTypeName = ANONYMOUS_CLASS_NAME__        } else if (canonicalTypeName.startsWith(def.class.getCanonicalName())) {_            canonicalTypeName = canonicalTypeName.replace(def.class.getCanonicalName(), DEF_CLASS_NAME)__        }__        return canonicalTypeName__    };converts,a,type,to,a,canonical,type,name,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,class,to,a,canonical,class,name,as,well;public,static,string,type,to,canonical,type,name,class,type,objects,require,non,null,type,string,canonical,type,name,type,get,canonical,name,if,canonical,type,name,null,canonical,type,name,else,if,canonical,type,name,starts,with,def,class,get,canonical,name,canonical,type,name,canonical,type,name,replace,def,class,get,canonical,name,return,canonical,type,name
PainlessLookupUtility -> public static String typeToCanonicalTypeName(Class<?> type);1543266328;Converts a type to a canonical type name based on the terminology specified as part of the documentation for_{@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class_to a canonical class name as well.;public static String typeToCanonicalTypeName(Class<?> type) {_        Objects.requireNonNull(type)___        String canonicalTypeName = type.getCanonicalName()___        if (canonicalTypeName == null) {_            canonicalTypeName = ANONYMOUS_CLASS_NAME__        } else if (canonicalTypeName.startsWith(def.class.getCanonicalName())) {_            canonicalTypeName = canonicalTypeName.replace(def.class.getCanonicalName(), DEF_CLASS_NAME)__        }__        return canonicalTypeName__    };converts,a,type,to,a,canonical,type,name,based,on,the,terminology,specified,as,part,of,the,documentation,for,link,painless,lookup,utility,since,classes,are,a,subset,of,types,this,method,will,safely,convert,a,class,to,a,canonical,class,name,as,well;public,static,string,type,to,canonical,type,name,class,type,objects,require,non,null,type,string,canonical,type,name,type,get,canonical,name,if,canonical,type,name,null,canonical,type,name,else,if,canonical,type,name,starts,with,def,class,get,canonical,name,canonical,type,name,canonical,type,name,replace,def,class,get,canonical,name,return,canonical,type,name
PainlessLookupUtility -> public static String buildPainlessFieldKey(String fieldName);1532069817;Constructs a painless field key used to lookup painless fields from a painless class.;public static String buildPainlessFieldKey(String fieldName) {_        return fieldName__    };constructs,a,painless,field,key,used,to,lookup,painless,fields,from,a,painless,class;public,static,string,build,painless,field,key,string,field,name,return,field,name
PainlessLookupUtility -> public static String buildPainlessFieldKey(String fieldName);1532434432;Constructs a painless field key used to lookup painless fields from a painless class.;public static String buildPainlessFieldKey(String fieldName) {_        return fieldName__    };constructs,a,painless,field,key,used,to,lookup,painless,fields,from,a,painless,class;public,static,string,build,painless,field,key,string,field,name,return,field,name
PainlessLookupUtility -> public static String buildPainlessFieldKey(String fieldName);1533063033;Constructs a painless field key used to lookup painless fields from a painless class.;public static String buildPainlessFieldKey(String fieldName) {_        return fieldName__    };constructs,a,painless,field,key,used,to,lookup,painless,fields,from,a,painless,class;public,static,string,build,painless,field,key,string,field,name,return,field,name
PainlessLookupUtility -> public static String buildPainlessFieldKey(String fieldName);1533815246;Constructs a painless field key used to lookup painless fields from a painless class.;public static String buildPainlessFieldKey(String fieldName) {_        return fieldName__    };constructs,a,painless,field,key,used,to,lookup,painless,fields,from,a,painless,class;public,static,string,build,painless,field,key,string,field,name,return,field,name
PainlessLookupUtility -> public static String buildPainlessFieldKey(String fieldName);1534434117;Constructs a painless field key used to lookup painless fields from a painless class.;public static String buildPainlessFieldKey(String fieldName) {_        return fieldName__    };constructs,a,painless,field,key,used,to,lookup,painless,fields,from,a,painless,class;public,static,string,build,painless,field,key,string,field,name,return,field,name
PainlessLookupUtility -> public static String buildPainlessFieldKey(String fieldName);1543266328;Constructs a painless field key used to lookup painless fields from a painless class.;public static String buildPainlessFieldKey(String fieldName) {_        return fieldName__    };constructs,a,painless,field,key,used,to,lookup,painless,fields,from,a,painless,class;public,static,string,build,painless,field,key,string,field,name,return,field,name
PainlessLookupUtility -> public static void validateType(Class<?> type, Collection<Class<?>> classes);1532069817;Ensures a type exists based on the terminology specified as part of {@link PainlessLookupUtility}.  Throws an_{@link IllegalArgumentException} if the type does not exist.;public static void validateType(Class<?> type, Collection<Class<?>> classes) {_        String canonicalTypeName = typeToCanonicalTypeName(type)___        while (type.getComponentType() != null) {_            type = type.getComponentType()__        }__        if (classes.contains(type) == false) {_            throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__        }_    };ensures,a,type,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,throws,an,link,illegal,argument,exception,if,the,type,does,not,exist;public,static,void,validate,type,class,type,collection,class,classes,string,canonical,type,name,type,to,canonical,type,name,type,while,type,get,component,type,null,type,type,get,component,type,if,classes,contains,type,false,throw,new,illegal,argument,exception,type,canonical,type,name,not,found
PainlessLookupUtility -> public static void validateType(Class<?> type, Collection<Class<?>> classes);1532434432;Ensures a type exists based on the terminology specified as part of {@link PainlessLookupUtility}.  Throws an_{@link IllegalArgumentException} if the type does not exist.;public static void validateType(Class<?> type, Collection<Class<?>> classes) {_        String canonicalTypeName = typeToCanonicalTypeName(type)___        while (type.getComponentType() != null) {_            type = type.getComponentType()__        }__        if (classes.contains(type) == false) {_            throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__        }_    };ensures,a,type,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,throws,an,link,illegal,argument,exception,if,the,type,does,not,exist;public,static,void,validate,type,class,type,collection,class,classes,string,canonical,type,name,type,to,canonical,type,name,type,while,type,get,component,type,null,type,type,get,component,type,if,classes,contains,type,false,throw,new,illegal,argument,exception,type,canonical,type,name,not,found
PainlessLookupUtility -> public static void validateType(Class<?> type, Collection<Class<?>> classes);1533063033;Ensures a type exists based on the terminology specified as part of {@link PainlessLookupUtility}.  Throws an_{@link IllegalArgumentException} if the type does not exist.;public static void validateType(Class<?> type, Collection<Class<?>> classes) {_        String canonicalTypeName = typeToCanonicalTypeName(type)___        while (type.getComponentType() != null) {_            type = type.getComponentType()__        }__        if (classes.contains(type) == false) {_            throw new IllegalArgumentException("type [" + canonicalTypeName + "] not found")__        }_    };ensures,a,type,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,throws,an,link,illegal,argument,exception,if,the,type,does,not,exist;public,static,void,validate,type,class,type,collection,class,classes,string,canonical,type,name,type,to,canonical,type,name,type,while,type,get,component,type,null,type,type,get,component,type,if,classes,contains,type,false,throw,new,illegal,argument,exception,type,canonical,type,name,not,found
PainlessLookupUtility -> public static Class<?> typeToUnboxedType(Class<?> type);1532069817;Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToUnboxedType(Class<?> type) {_        if (type == Boolean.class) {_            return boolean.class__        } else if (type == Byte.class) {_            return byte.class__        } else if (type == Short.class) {_            return short.class__        } else if (type == Character.class) {_            return char.class__        } else if (type == Integer.class) {_            return int.class__        } else if (type == Long.class) {_            return long.class__        } else if (type == Float.class) {_            return float.class__        } else if (type == Double.class) {_            return double.class__        }__        return type__    };converts,a,type,to,its,unboxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,unboxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,character,class,return,char,class,else,if,type,integer,class,return,int,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToUnboxedType(Class<?> type);1532434432;Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToUnboxedType(Class<?> type) {_        if (type == Boolean.class) {_            return boolean.class__        } else if (type == Byte.class) {_            return byte.class__        } else if (type == Short.class) {_            return short.class__        } else if (type == Character.class) {_            return char.class__        } else if (type == Integer.class) {_            return int.class__        } else if (type == Long.class) {_            return long.class__        } else if (type == Float.class) {_            return float.class__        } else if (type == Double.class) {_            return double.class__        }__        return type__    };converts,a,type,to,its,unboxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,unboxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,character,class,return,char,class,else,if,type,integer,class,return,int,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToUnboxedType(Class<?> type);1533063033;Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToUnboxedType(Class<?> type) {_        if (type == Boolean.class) {_            return boolean.class__        } else if (type == Byte.class) {_            return byte.class__        } else if (type == Short.class) {_            return short.class__        } else if (type == Character.class) {_            return char.class__        } else if (type == Integer.class) {_            return int.class__        } else if (type == Long.class) {_            return long.class__        } else if (type == Float.class) {_            return float.class__        } else if (type == Double.class) {_            return double.class__        }__        return type__    };converts,a,type,to,its,unboxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,unboxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,character,class,return,char,class,else,if,type,integer,class,return,int,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToUnboxedType(Class<?> type);1533815246;Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToUnboxedType(Class<?> type) {_        if (type == Boolean.class) {_            return boolean.class__        } else if (type == Byte.class) {_            return byte.class__        } else if (type == Short.class) {_            return short.class__        } else if (type == Character.class) {_            return char.class__        } else if (type == Integer.class) {_            return int.class__        } else if (type == Long.class) {_            return long.class__        } else if (type == Float.class) {_            return float.class__        } else if (type == Double.class) {_            return double.class__        }__        return type__    };converts,a,type,to,its,unboxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,unboxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,character,class,return,char,class,else,if,type,integer,class,return,int,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToUnboxedType(Class<?> type);1534434117;Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToUnboxedType(Class<?> type) {_        if (type == Boolean.class) {_            return boolean.class__        } else if (type == Byte.class) {_            return byte.class__        } else if (type == Short.class) {_            return short.class__        } else if (type == Character.class) {_            return char.class__        } else if (type == Integer.class) {_            return int.class__        } else if (type == Long.class) {_            return long.class__        } else if (type == Float.class) {_            return float.class__        } else if (type == Double.class) {_            return double.class__        }__        return type__    };converts,a,type,to,its,unboxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,unboxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,character,class,return,char,class,else,if,type,integer,class,return,int,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static Class<?> typeToUnboxedType(Class<?> type);1543266328;Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of_{@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.;public static Class<?> typeToUnboxedType(Class<?> type) {_        if (type == Boolean.class) {_            return boolean.class__        } else if (type == Byte.class) {_            return byte.class__        } else if (type == Short.class) {_            return short.class__        } else if (type == Character.class) {_            return char.class__        } else if (type == Integer.class) {_            return int.class__        } else if (type == Long.class) {_            return long.class__        } else if (type == Float.class) {_            return float.class__        } else if (type == Double.class) {_            return double.class__        }__        return type__    };converts,a,type,to,its,unboxed,type,equivalent,if,one,exists,based,on,the,terminology,specified,as,part,of,link,painless,lookup,utility,otherwise,this,behaves,as,an,identity,function;public,static,class,type,to,unboxed,type,class,type,if,type,boolean,class,return,boolean,class,else,if,type,byte,class,return,byte,class,else,if,type,short,class,return,short,class,else,if,type,character,class,return,char,class,else,if,type,integer,class,return,int,class,else,if,type,long,class,return,long,class,else,if,type,float,class,return,float,class,else,if,type,double,class,return,double,class,return,type
PainlessLookupUtility -> public static String buildPainlessMethodKey(String methodName, int methodArity);1532069817;Constructs a painless method key used to lookup painless methods from a painless class.;public static String buildPainlessMethodKey(String methodName, int methodArity) {_        return methodName + "/" + methodArity__    };constructs,a,painless,method,key,used,to,lookup,painless,methods,from,a,painless,class;public,static,string,build,painless,method,key,string,method,name,int,method,arity,return,method,name,method,arity
PainlessLookupUtility -> public static String buildPainlessMethodKey(String methodName, int methodArity);1532434432;Constructs a painless method key used to lookup painless methods from a painless class.;public static String buildPainlessMethodKey(String methodName, int methodArity) {_        return methodName + "/" + methodArity__    };constructs,a,painless,method,key,used,to,lookup,painless,methods,from,a,painless,class;public,static,string,build,painless,method,key,string,method,name,int,method,arity,return,method,name,method,arity
PainlessLookupUtility -> public static String buildPainlessMethodKey(String methodName, int methodArity);1533063033;Constructs a painless method key used to lookup painless methods from a painless class.;public static String buildPainlessMethodKey(String methodName, int methodArity) {_        return methodName + "/" + methodArity__    };constructs,a,painless,method,key,used,to,lookup,painless,methods,from,a,painless,class;public,static,string,build,painless,method,key,string,method,name,int,method,arity,return,method,name,method,arity
PainlessLookupUtility -> public static String buildPainlessMethodKey(String methodName, int methodArity);1533815246;Constructs a painless method key used to lookup painless methods from a painless class.;public static String buildPainlessMethodKey(String methodName, int methodArity) {_        return methodName + "/" + methodArity__    };constructs,a,painless,method,key,used,to,lookup,painless,methods,from,a,painless,class;public,static,string,build,painless,method,key,string,method,name,int,method,arity,return,method,name,method,arity
PainlessLookupUtility -> public static String buildPainlessMethodKey(String methodName, int methodArity);1534434117;Constructs a painless method key used to lookup painless methods from a painless class.;public static String buildPainlessMethodKey(String methodName, int methodArity) {_        return methodName + "/" + methodArity__    };constructs,a,painless,method,key,used,to,lookup,painless,methods,from,a,painless,class;public,static,string,build,painless,method,key,string,method,name,int,method,arity,return,method,name,method,arity
PainlessLookupUtility -> public static String buildPainlessMethodKey(String methodName, int methodArity);1543266328;Constructs a painless method key used to lookup painless methods from a painless class.;public static String buildPainlessMethodKey(String methodName, int methodArity) {_        return methodName + "/" + methodArity__    };constructs,a,painless,method,key,used,to,lookup,painless,methods,from,a,painless,class;public,static,string,build,painless,method,key,string,method,name,int,method,arity,return,method,name,method,arity
PainlessLookupUtility -> public static String buildPainlessConstructorKey(int constructorArity);1533063033;Constructs a painless constructor key used to lookup painless constructors from a painless class.;public static String buildPainlessConstructorKey(int constructorArity) {_        return CONSTRUCTOR_NAME + "/" + constructorArity__    };constructs,a,painless,constructor,key,used,to,lookup,painless,constructors,from,a,painless,class;public,static,string,build,painless,constructor,key,int,constructor,arity,return,constructor,arity
PainlessLookupUtility -> public static String buildPainlessConstructorKey(int constructorArity);1533815246;Constructs a painless constructor key used to lookup painless constructors from a painless class.;public static String buildPainlessConstructorKey(int constructorArity) {_        return CONSTRUCTOR_NAME + "/" + constructorArity__    };constructs,a,painless,constructor,key,used,to,lookup,painless,constructors,from,a,painless,class;public,static,string,build,painless,constructor,key,int,constructor,arity,return,constructor,arity
PainlessLookupUtility -> public static String buildPainlessConstructorKey(int constructorArity);1534434117;Constructs a painless constructor key used to lookup painless constructors from a painless class.;public static String buildPainlessConstructorKey(int constructorArity) {_        return CONSTRUCTOR_NAME + "/" + constructorArity__    };constructs,a,painless,constructor,key,used,to,lookup,painless,constructors,from,a,painless,class;public,static,string,build,painless,constructor,key,int,constructor,arity,return,constructor,arity
PainlessLookupUtility -> public static String buildPainlessConstructorKey(int constructorArity);1543266328;Constructs a painless constructor key used to lookup painless constructors from a painless class.;public static String buildPainlessConstructorKey(int constructorArity) {_        return CONSTRUCTOR_NAME + "/" + constructorArity__    };constructs,a,painless,constructor,key,used,to,lookup,painless,constructors,from,a,painless,class;public,static,string,build,painless,constructor,key,int,constructor,arity,return,constructor,arity
