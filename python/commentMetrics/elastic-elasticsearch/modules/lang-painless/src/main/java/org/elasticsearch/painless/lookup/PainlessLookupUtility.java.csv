commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;64;/**  * Converts a canonical type name to a type based on the terminology specified as part of the documentation for  * {@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will  * safely convert a canonical class name to a class as well.  */ ;/**  * Converts a canonical type name to a type based on the terminology specified as part of the documentation for  * {@link PainlessLookupUtility}. Since canonical class names are a subset of canonical type names, this method will  * safely convert a canonical class name to a class as well.  */ public static Class<?> canonicalTypeNameToType(String canonicalTypeName, Map<String, Class<?>> canonicalClassNamesToClasses) {     Objects.requireNonNull(canonicalTypeName).     Objects.requireNonNull(canonicalClassNamesToClasses).     Class<?> type = DEF_CLASS_NAME.equals(canonicalTypeName) ? def.class : canonicalClassNamesToClasses.get(canonicalTypeName).     if (type != null) {         return type.     }     int arrayDimensions = 0.     int arrayIndex = canonicalTypeName.indexOf('[').     if (arrayIndex != -1) {         int typeNameLength = canonicalTypeName.length().         while (arrayIndex < typeNameLength) {             if (canonicalTypeName.charAt(arrayIndex) == '[' && ++arrayIndex < typeNameLength && canonicalTypeName.charAt(arrayIndex++) == ']') {                 ++arrayDimensions.             } else {                 return null.             }         }         canonicalTypeName = canonicalTypeName.substring(0, canonicalTypeName.indexOf('[')).         type = DEF_CLASS_NAME.equals(canonicalTypeName) ? def.class : canonicalClassNamesToClasses.get(canonicalTypeName).         if (type != null) {             char[] arrayBraces = new char[arrayDimensions].             Arrays.fill(arrayBraces, '[').             String javaTypeName = new String(arrayBraces).             if (type == boolean.class) {                 javaTypeName += "Z".             } else if (type == byte.class) {                 javaTypeName += "B".             } else if (type == short.class) {                 javaTypeName += "S".             } else if (type == char.class) {                 javaTypeName += "C".             } else if (type == int.class) {                 javaTypeName += "I".             } else if (type == long.class) {                 javaTypeName += "J".             } else if (type == float.class) {                 javaTypeName += "F".             } else if (type == double.class) {                 javaTypeName += "D".             } else {                 javaTypeName += "L" + type.getName() + ".".             }             try {                 return Class.forName(javaTypeName).             } catch (ClassNotFoundException cnfe) {                 throw new IllegalStateException("internal error", cnfe).             }         }     }     return null. }
true;public,static;1;13;/**  * Converts a type to a canonical type name based on the terminology specified as part of the documentation for  * {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class  * to a canonical class name as well.  */ ;/**  * Converts a type to a canonical type name based on the terminology specified as part of the documentation for  * {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a class  * to a canonical class name as well.  */ public static String typeToCanonicalTypeName(Class<?> type) {     Objects.requireNonNull(type).     String canonicalTypeName = type.getCanonicalName().     if (canonicalTypeName == null) {         canonicalTypeName = ANONYMOUS_CLASS_NAME.     } else if (canonicalTypeName.startsWith(def.class.getCanonicalName())) {         canonicalTypeName = canonicalTypeName.replace(def.class.getCanonicalName(), DEF_CLASS_NAME).     }     return canonicalTypeName. }
true;public,static;1;20;/**  * Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the  * documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list  * of classes or a mixed list of classes and types to a list of canonical type names as a string as well.  */ ;/**  * Converts a list of types to a list of canonical type names as a string based on the terminology specified as part of the  * documentation for {@link PainlessLookupUtility}. Since classes are a subset of types, this method will safely convert a list  * of classes or a mixed list of classes and types to a list of canonical type names as a string as well.  */ public static String typesToCanonicalTypeNames(List<Class<?>> types) {     StringBuilder typesStringBuilder = new StringBuilder("[").     int anyTypesSize = types.size().     int anyTypesIndex = 0.     for (Class<?> painlessType : types) {         String canonicalTypeName = typeToCanonicalTypeName(painlessType).         typesStringBuilder.append(canonicalTypeName).         if (++anyTypesIndex < anyTypesSize) {             typesStringBuilder.append(",").         }     }     typesStringBuilder.append("]").     return typesStringBuilder.toString(). }
true;public,static;1;28;/**  * Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an  * object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an  * identity function.  */ ;/**  * Converts a java type to a type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is an  * object class or object array, the returned type will be the equivalent def class or def array. Otherwise, this behaves as an  * identity function.  */ public static Class<?> javaTypeToType(Class<?> javaType) {     Objects.requireNonNull(javaType).     if (javaType.isArray()) {         Class<?> javaTypeComponent = javaType.getComponentType().         int arrayDimensions = 1.         while (javaTypeComponent.isArray()) {             javaTypeComponent = javaTypeComponent.getComponentType().             ++arrayDimensions.         }         if (javaTypeComponent == Object.class) {             char[] arrayBraces = new char[arrayDimensions].             Arrays.fill(arrayBraces, '[').             try {                 return Class.forName(new String(arrayBraces) + "L" + def.class.getName() + ".").             } catch (ClassNotFoundException cnfe) {                 throw new IllegalStateException("internal error", cnfe).             }         }     } else if (javaType == Object.class) {         return def.class.     }     return javaType. }
true;public,static;1;28;/**  * Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a  * def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an  * identity function.  */ ;/**  * Converts a type to a java type based on the terminology specified as part of {@link PainlessLookupUtility} where if a type is a  * def class or def array, the returned type will be the equivalent object class or object array. Otherwise, this behaves as an  * identity function.  */ public static Class<?> typeToJavaType(Class<?> type) {     Objects.requireNonNull(type).     if (type.isArray()) {         Class<?> typeComponent = type.getComponentType().         int arrayDimensions = 1.         while (typeComponent.isArray()) {             typeComponent = typeComponent.getComponentType().             ++arrayDimensions.         }         if (typeComponent == def.class) {             char[] arrayBraces = new char[arrayDimensions].             Arrays.fill(arrayBraces, '[').             try {                 return Class.forName(new String(arrayBraces) + "L" + Object.class.getName() + ".").             } catch (ClassNotFoundException cnfe) {                 throw new IllegalStateException("internal error", cnfe).             }         }     } else if (type == def.class) {         return Object.class.     }     return type. }
true;public,static;1;21;/**  * Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of  * {@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.  */ ;/**  * Converts a type  to its boxed type equivalent if one exists based on the terminology specified as part of  * {@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.  */ public static Class<?> typeToBoxedType(Class<?> type) {     if (type == boolean.class) {         return Boolean.class.     } else if (type == byte.class) {         return Byte.class.     } else if (type == short.class) {         return Short.class.     } else if (type == char.class) {         return Character.class.     } else if (type == int.class) {         return Integer.class.     } else if (type == long.class) {         return Long.class.     } else if (type == float.class) {         return Float.class.     } else if (type == double.class) {         return Double.class.     }     return type. }
true;public,static;1;21;/**  * Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of  * {@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.  */ ;/**  * Converts a type to its unboxed type equivalent if one exists based on the terminology specified as part of  * {@link PainlessLookupUtility}. Otherwise, this behaves as an identity function.  */ public static Class<?> typeToUnboxedType(Class<?> type) {     if (type == Boolean.class) {         return boolean.class.     } else if (type == Byte.class) {         return byte.class.     } else if (type == Short.class) {         return short.class.     } else if (type == Character.class) {         return char.class.     } else if (type == Integer.class) {         return int.class.     } else if (type == Long.class) {         return long.class.     } else if (type == Float.class) {         return float.class.     } else if (type == Double.class) {         return double.class.     }     return type. }
true;public,static;1;11;/**  * Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type  * where {@code true} is returned if the type is a constant type and {@code false} otherwise.  */ ;/**  * Checks if a type based on the terminology specified as part of {@link PainlessLookupUtility} is available as a constant type  * where {@code true} is returned if the type is a constant type and {@code false} otherwise.  */ public static boolean isConstantType(Class<?> type) {     return type == boolean.class || type == byte.class || type == short.class || type == char.class || type == int.class || type == long.class || type == float.class || type == double.class || type == String.class. }
true;public,static;1;3;/**  * Constructs a painless constructor key used to lookup painless constructors from a painless class.  */ ;/**  * Constructs a painless constructor key used to lookup painless constructors from a painless class.  */ public static String buildPainlessConstructorKey(int constructorArity) {     return CONSTRUCTOR_NAME + "/" + constructorArity. }
true;public,static;2;3;/**  * Constructs a painless method key used to lookup painless methods from a painless class.  */ ;/**  * Constructs a painless method key used to lookup painless methods from a painless class.  */ public static String buildPainlessMethodKey(String methodName, int methodArity) {     return methodName + "/" + methodArity. }
true;public,static;1;3;/**  * Constructs a painless field key used to lookup painless fields from a painless class.  */ ;/**  * Constructs a painless field key used to lookup painless fields from a painless class.  */ public static String buildPainlessFieldKey(String fieldName) {     return fieldName. }
