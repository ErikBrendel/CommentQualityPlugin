# id;timestamp;commentText;codeText;commentWords;codeWords
PainlessLookupBuilder -> private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz);1531910483;computes the functional interface method for a class, or returns null;private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz) {_        if (!clazz.clazz.isInterface()) {_            return null__        }_        _        _        boolean hasAnnotation = clazz.clazz.isAnnotationPresent(FunctionalInterface.class)__        List<java.lang.reflect.Method> methods = new ArrayList<>()__        for (java.lang.reflect.Method m : clazz.clazz.getMethods()) {_            _            if (m.isDefault()) {_                continue__            }_            _            if (Modifier.isStatic(m.getModifiers())) {_                continue__            }_            _            try {_                Object.class.getMethod(m.getName(), m.getParameterTypes())__                continue__            } catch (ReflectiveOperationException e) {_                _            }_            methods.add(m)__        }_        if (methods.size() != 1) {_            if (hasAnnotation) {_                throw new IllegalArgumentException("Class: " + clazz.name +_                    " is marked with FunctionalInterface but doesn't fit the bill: " + methods)__            }_            return null__        }_        _        java.lang.reflect.Method oneMethod = methods.get(0)__        PainlessMethod painless = clazz.methods.get(buildPainlessMethodKey(oneMethod.getName(), oneMethod.getParameterCount()))__        if (painless == null || painless.method.equals(org.objectweb.asm.commons.Method.getMethod(oneMethod)) == false) {_            throw new IllegalArgumentException("Class: " + clazz.name + " is functional but the functional " +_                "method is not whitelisted!")__        }_        return painless__    };computes,the,functional,interface,method,for,a,class,or,returns,null;private,painless,method,compute,functional,interface,method,painless,class,builder,clazz,if,clazz,clazz,is,interface,return,null,boolean,has,annotation,clazz,clazz,is,annotation,present,functional,interface,class,list,java,lang,reflect,method,methods,new,array,list,for,java,lang,reflect,method,m,clazz,clazz,get,methods,if,m,is,default,continue,if,modifier,is,static,m,get,modifiers,continue,try,object,class,get,method,m,get,name,m,get,parameter,types,continue,catch,reflective,operation,exception,e,methods,add,m,if,methods,size,1,if,has,annotation,throw,new,illegal,argument,exception,class,clazz,name,is,marked,with,functional,interface,but,doesn,t,fit,the,bill,methods,return,null,java,lang,reflect,method,one,method,methods,get,0,painless,method,painless,clazz,methods,get,build,painless,method,key,one,method,get,name,one,method,get,parameter,count,if,painless,null,painless,method,equals,org,objectweb,asm,commons,method,get,method,one,method,false,throw,new,illegal,argument,exception,class,clazz,name,is,functional,but,the,functional,method,is,not,whitelisted,return,painless
PainlessLookupBuilder -> private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz);1531937412;computes the functional interface method for a class, or returns null;private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz) {_        if (!clazz.clazz.isInterface()) {_            return null__        }_        _        _        boolean hasAnnotation = clazz.clazz.isAnnotationPresent(FunctionalInterface.class)__        List<java.lang.reflect.Method> methods = new ArrayList<>()__        for (java.lang.reflect.Method m : clazz.clazz.getMethods()) {_            _            if (m.isDefault()) {_                continue__            }_            _            if (Modifier.isStatic(m.getModifiers())) {_                continue__            }_            _            try {_                Object.class.getMethod(m.getName(), m.getParameterTypes())__                continue__            } catch (ReflectiveOperationException e) {_                _            }_            methods.add(m)__        }_        if (methods.size() != 1) {_            if (hasAnnotation) {_                throw new IllegalArgumentException("Class: " + clazz.name +_                    " is marked with FunctionalInterface but doesn't fit the bill: " + methods)__            }_            return null__        }_        _        java.lang.reflect.Method oneMethod = methods.get(0)__        PainlessMethod painless = clazz.methods.get(buildPainlessMethodKey(oneMethod.getName(), oneMethod.getParameterCount()))__        if (painless == null || painless.method.equals(org.objectweb.asm.commons.Method.getMethod(oneMethod)) == false) {_            throw new IllegalArgumentException("Class: " + clazz.name + " is functional but the functional " +_                "method is not whitelisted!")__        }_        return painless__    };computes,the,functional,interface,method,for,a,class,or,returns,null;private,painless,method,compute,functional,interface,method,painless,class,builder,clazz,if,clazz,clazz,is,interface,return,null,boolean,has,annotation,clazz,clazz,is,annotation,present,functional,interface,class,list,java,lang,reflect,method,methods,new,array,list,for,java,lang,reflect,method,m,clazz,clazz,get,methods,if,m,is,default,continue,if,modifier,is,static,m,get,modifiers,continue,try,object,class,get,method,m,get,name,m,get,parameter,types,continue,catch,reflective,operation,exception,e,methods,add,m,if,methods,size,1,if,has,annotation,throw,new,illegal,argument,exception,class,clazz,name,is,marked,with,functional,interface,but,doesn,t,fit,the,bill,methods,return,null,java,lang,reflect,method,one,method,methods,get,0,painless,method,painless,clazz,methods,get,build,painless,method,key,one,method,get,name,one,method,get,parameter,count,if,painless,null,painless,method,equals,org,objectweb,asm,commons,method,get,method,one,method,false,throw,new,illegal,argument,exception,class,clazz,name,is,functional,but,the,functional,method,is,not,whitelisted,return,painless
PainlessLookupBuilder -> private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz);1532069817;computes the functional interface method for a class, or returns null;private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz) {_        if (!clazz.clazz.isInterface()) {_            return null__        }_        _        _        boolean hasAnnotation = clazz.clazz.isAnnotationPresent(FunctionalInterface.class)__        List<java.lang.reflect.Method> methods = new ArrayList<>()__        for (java.lang.reflect.Method m : clazz.clazz.getMethods()) {_            _            if (m.isDefault()) {_                continue__            }_            _            if (Modifier.isStatic(m.getModifiers())) {_                continue__            }_            _            try {_                Object.class.getMethod(m.getName(), m.getParameterTypes())__                continue__            } catch (ReflectiveOperationException e) {_                _            }_            methods.add(m)__        }_        if (methods.size() != 1) {_            if (hasAnnotation) {_                throw new IllegalArgumentException("Class: " + clazz.name +_                    " is marked with FunctionalInterface but doesn't fit the bill: " + methods)__            }_            return null__        }_        _        java.lang.reflect.Method oneMethod = methods.get(0)__        PainlessMethod painless = clazz.methods.get(buildPainlessMethodKey(oneMethod.getName(), oneMethod.getParameterCount()))__        if (painless == null || painless.method.equals(org.objectweb.asm.commons.Method.getMethod(oneMethod)) == false) {_            throw new IllegalArgumentException("Class: " + clazz.name + " is functional but the functional " +_                "method is not whitelisted!")__        }_        return painless__    };computes,the,functional,interface,method,for,a,class,or,returns,null;private,painless,method,compute,functional,interface,method,painless,class,builder,clazz,if,clazz,clazz,is,interface,return,null,boolean,has,annotation,clazz,clazz,is,annotation,present,functional,interface,class,list,java,lang,reflect,method,methods,new,array,list,for,java,lang,reflect,method,m,clazz,clazz,get,methods,if,m,is,default,continue,if,modifier,is,static,m,get,modifiers,continue,try,object,class,get,method,m,get,name,m,get,parameter,types,continue,catch,reflective,operation,exception,e,methods,add,m,if,methods,size,1,if,has,annotation,throw,new,illegal,argument,exception,class,clazz,name,is,marked,with,functional,interface,but,doesn,t,fit,the,bill,methods,return,null,java,lang,reflect,method,one,method,methods,get,0,painless,method,painless,clazz,methods,get,build,painless,method,key,one,method,get,name,one,method,get,parameter,count,if,painless,null,painless,method,equals,org,objectweb,asm,commons,method,get,method,one,method,false,throw,new,illegal,argument,exception,class,clazz,name,is,functional,but,the,functional,method,is,not,whitelisted,return,painless
PainlessLookupBuilder -> private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz);1532434432;computes the functional interface method for a class, or returns null;private PainlessMethod computeFunctionalInterfaceMethod(PainlessClassBuilder clazz) {_        if (!clazz.clazz.isInterface()) {_            return null__        }_        _        _        boolean hasAnnotation = clazz.clazz.isAnnotationPresent(FunctionalInterface.class)__        List<java.lang.reflect.Method> methods = new ArrayList<>()__        for (java.lang.reflect.Method m : clazz.clazz.getMethods()) {_            _            if (m.isDefault()) {_                continue__            }_            _            if (Modifier.isStatic(m.getModifiers())) {_                continue__            }_            _            try {_                Object.class.getMethod(m.getName(), m.getParameterTypes())__                continue__            } catch (ReflectiveOperationException e) {_                _            }_            methods.add(m)__        }_        if (methods.size() != 1) {_            if (hasAnnotation) {_                throw new IllegalArgumentException("Class: " + clazz.name +_                    " is marked with FunctionalInterface but doesn't fit the bill: " + methods)__            }_            return null__        }_        _        java.lang.reflect.Method oneMethod = methods.get(0)__        PainlessMethod painless = clazz.methods.get(buildPainlessMethodKey(oneMethod.getName(), oneMethod.getParameterCount()))__        if (painless == null || painless.method.equals(org.objectweb.asm.commons.Method.getMethod(oneMethod)) == false) {_            throw new IllegalArgumentException("Class: " + clazz.name + " is functional but the functional " +_                "method is not whitelisted!")__        }_        return painless__    };computes,the,functional,interface,method,for,a,class,or,returns,null;private,painless,method,compute,functional,interface,method,painless,class,builder,clazz,if,clazz,clazz,is,interface,return,null,boolean,has,annotation,clazz,clazz,is,annotation,present,functional,interface,class,list,java,lang,reflect,method,methods,new,array,list,for,java,lang,reflect,method,m,clazz,clazz,get,methods,if,m,is,default,continue,if,modifier,is,static,m,get,modifiers,continue,try,object,class,get,method,m,get,name,m,get,parameter,types,continue,catch,reflective,operation,exception,e,methods,add,m,if,methods,size,1,if,has,annotation,throw,new,illegal,argument,exception,class,clazz,name,is,marked,with,functional,interface,but,doesn,t,fit,the,bill,methods,return,null,java,lang,reflect,method,one,method,methods,get,0,painless,method,painless,clazz,methods,get,build,painless,method,key,one,method,get,name,one,method,get,parameter,count,if,painless,null,painless,method,equals,org,objectweb,asm,commons,method,get,method,one,method,false,throw,new,illegal,argument,exception,class,clazz,name,is,functional,but,the,functional,method,is,not,whitelisted,return,painless
PainlessLookupBuilder -> private void addRuntimeClass(final PainlessClassBuilder struct);1531910483;Precomputes a more efficient structure for dynamic method/field access.;private void addRuntimeClass(final PainlessClassBuilder struct) {_        _        for (Map.Entry<String, PainlessMethod> method : struct.methods.entrySet()) {_            String name = method.getValue().name__            PainlessMethod m = method.getValue()___            if (m.arguments.size() == 0 &&_                name.startsWith("get") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            } else if (m.arguments.size() == 0 &&_                name.startsWith("is") &&_                name.length() > 2 &&_                Character.isUpperCase(name.charAt(2))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(2)))__                newName.append(name.substring(3))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            }__            if (m.arguments.size() == 1 &&_                name.startsWith("set") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.setters.putIfAbsent(newName.toString(), m.handle)__            }_        }__        _        for (Map.Entry<String, PainlessField> member : struct.members.entrySet()) {_            struct.getters.put(member.getKey(), member.getValue().getter)__            struct.setters.put(member.getKey(), member.getValue().setter)__        }_    };precomputes,a,more,efficient,structure,for,dynamic,method,field,access;private,void,add,runtime,class,final,painless,class,builder,struct,for,map,entry,string,painless,method,method,struct,methods,entry,set,string,name,method,get,value,name,painless,method,m,method,get,value,if,m,arguments,size,0,name,starts,with,get,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,getters,put,if,absent,new,name,to,string,m,handle,else,if,m,arguments,size,0,name,starts,with,is,name,length,2,character,is,upper,case,name,char,at,2,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,2,new,name,append,name,substring,3,struct,getters,put,if,absent,new,name,to,string,m,handle,if,m,arguments,size,1,name,starts,with,set,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,setters,put,if,absent,new,name,to,string,m,handle,for,map,entry,string,painless,field,member,struct,members,entry,set,struct,getters,put,member,get,key,member,get,value,getter,struct,setters,put,member,get,key,member,get,value,setter
PainlessLookupBuilder -> private void addRuntimeClass(final PainlessClassBuilder struct);1531937412;Precomputes a more efficient structure for dynamic method/field access.;private void addRuntimeClass(final PainlessClassBuilder struct) {_        _        for (Map.Entry<String, PainlessMethod> method : struct.methods.entrySet()) {_            String name = method.getValue().name__            PainlessMethod m = method.getValue()___            if (m.arguments.size() == 0 &&_                name.startsWith("get") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            } else if (m.arguments.size() == 0 &&_                name.startsWith("is") &&_                name.length() > 2 &&_                Character.isUpperCase(name.charAt(2))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(2)))__                newName.append(name.substring(3))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            }__            if (m.arguments.size() == 1 &&_                name.startsWith("set") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.setters.putIfAbsent(newName.toString(), m.handle)__            }_        }__        _        for (Map.Entry<String, PainlessField> member : struct.members.entrySet()) {_            struct.getters.put(member.getKey(), member.getValue().getter)__            struct.setters.put(member.getKey(), member.getValue().setter)__        }_    };precomputes,a,more,efficient,structure,for,dynamic,method,field,access;private,void,add,runtime,class,final,painless,class,builder,struct,for,map,entry,string,painless,method,method,struct,methods,entry,set,string,name,method,get,value,name,painless,method,m,method,get,value,if,m,arguments,size,0,name,starts,with,get,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,getters,put,if,absent,new,name,to,string,m,handle,else,if,m,arguments,size,0,name,starts,with,is,name,length,2,character,is,upper,case,name,char,at,2,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,2,new,name,append,name,substring,3,struct,getters,put,if,absent,new,name,to,string,m,handle,if,m,arguments,size,1,name,starts,with,set,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,setters,put,if,absent,new,name,to,string,m,handle,for,map,entry,string,painless,field,member,struct,members,entry,set,struct,getters,put,member,get,key,member,get,value,getter,struct,setters,put,member,get,key,member,get,value,setter
PainlessLookupBuilder -> private void addRuntimeClass(final PainlessClassBuilder struct);1532069817;Precomputes a more efficient structure for dynamic method/field access.;private void addRuntimeClass(final PainlessClassBuilder struct) {_        _        for (Map.Entry<String, PainlessMethod> method : struct.methods.entrySet()) {_            String name = method.getValue().name__            PainlessMethod m = method.getValue()___            if (m.arguments.size() == 0 &&_                name.startsWith("get") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            } else if (m.arguments.size() == 0 &&_                name.startsWith("is") &&_                name.length() > 2 &&_                Character.isUpperCase(name.charAt(2))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(2)))__                newName.append(name.substring(3))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            }__            if (m.arguments.size() == 1 &&_                name.startsWith("set") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.setters.putIfAbsent(newName.toString(), m.handle)__            }_        }__        _        for (Map.Entry<String, PainlessField> member : struct.members.entrySet()) {_            struct.getters.put(member.getKey(), member.getValue().getter)__            struct.setters.put(member.getKey(), member.getValue().setter)__        }_    };precomputes,a,more,efficient,structure,for,dynamic,method,field,access;private,void,add,runtime,class,final,painless,class,builder,struct,for,map,entry,string,painless,method,method,struct,methods,entry,set,string,name,method,get,value,name,painless,method,m,method,get,value,if,m,arguments,size,0,name,starts,with,get,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,getters,put,if,absent,new,name,to,string,m,handle,else,if,m,arguments,size,0,name,starts,with,is,name,length,2,character,is,upper,case,name,char,at,2,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,2,new,name,append,name,substring,3,struct,getters,put,if,absent,new,name,to,string,m,handle,if,m,arguments,size,1,name,starts,with,set,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,setters,put,if,absent,new,name,to,string,m,handle,for,map,entry,string,painless,field,member,struct,members,entry,set,struct,getters,put,member,get,key,member,get,value,getter,struct,setters,put,member,get,key,member,get,value,setter
PainlessLookupBuilder -> private void addRuntimeClass(final PainlessClassBuilder struct);1532434432;Precomputes a more efficient structure for dynamic method/field access.;private void addRuntimeClass(final PainlessClassBuilder struct) {_        _        for (Map.Entry<String, PainlessMethod> method : struct.methods.entrySet()) {_            String name = method.getValue().name__            PainlessMethod m = method.getValue()___            if (m.arguments.size() == 0 &&_                name.startsWith("get") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            } else if (m.arguments.size() == 0 &&_                name.startsWith("is") &&_                name.length() > 2 &&_                Character.isUpperCase(name.charAt(2))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(2)))__                newName.append(name.substring(3))__                struct.getters.putIfAbsent(newName.toString(), m.handle)__            }__            if (m.arguments.size() == 1 &&_                name.startsWith("set") &&_                name.length() > 3 &&_                Character.isUpperCase(name.charAt(3))) {_                StringBuilder newName = new StringBuilder()__                newName.append(Character.toLowerCase(name.charAt(3)))__                newName.append(name.substring(4))__                struct.setters.putIfAbsent(newName.toString(), m.handle)__            }_        }__        _        for (Map.Entry<String, PainlessField> member : struct.members.entrySet()) {_            struct.getters.put(member.getKey(), member.getValue().getter)__            struct.setters.put(member.getKey(), member.getValue().setter)__        }_    };precomputes,a,more,efficient,structure,for,dynamic,method,field,access;private,void,add,runtime,class,final,painless,class,builder,struct,for,map,entry,string,painless,method,method,struct,methods,entry,set,string,name,method,get,value,name,painless,method,m,method,get,value,if,m,arguments,size,0,name,starts,with,get,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,getters,put,if,absent,new,name,to,string,m,handle,else,if,m,arguments,size,0,name,starts,with,is,name,length,2,character,is,upper,case,name,char,at,2,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,2,new,name,append,name,substring,3,struct,getters,put,if,absent,new,name,to,string,m,handle,if,m,arguments,size,1,name,starts,with,set,name,length,3,character,is,upper,case,name,char,at,3,string,builder,new,name,new,string,builder,new,name,append,character,to,lower,case,name,char,at,3,new,name,append,name,substring,4,struct,setters,put,if,absent,new,name,to,string,m,handle,for,map,entry,string,painless,field,member,struct,members,entry,set,struct,getters,put,member,get,key,member,get,value,getter,struct,setters,put,member,get,key,member,get,value,setter
