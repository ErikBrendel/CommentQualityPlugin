commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The interface that the Painless script should implement.  */ ;/**  * The interface that the Painless script should implement.  */ public Class<?> getBaseClass() {     return baseClass. }
true;public;0;3;/**  * An asm method descriptor for the {@code execute} method.  */ ;/**  * An asm method descriptor for the {@code execute} method.  */ public org.objectweb.asm.commons.Method getExecuteMethod() {     return executeMethod. }
true;public;0;3;/**  * The Painless {@link Class} or the return type of the {@code execute} method. This is used to generate the appropriate  * return bytecode.  */ ;/**  * The Painless {@link Class} or the return type of the {@code execute} method. This is used to generate the appropriate  * return bytecode.  */ public Class<?> getExecuteMethodReturnType() {     return executeMethodReturnType. }
true;public;0;3;/**  * Painless {@link Class}s and names of the arguments to the {@code execute} method. The names are exposed to the Painless  * script.  */ ;/**  * Painless {@link Class}s and names of the arguments to the {@code execute} method. The names are exposed to the Painless  * script.  */ public List<MethodArgument> getExecuteArguments() {     return executeArguments. }
true;public;0;3;/**  * The {@code uses$varName} methods that must be implemented by Painless to complete implementing the interface.  */ ;/**  * The {@code uses$varName} methods that must be implemented by Painless to complete implementing the interface.  */ public List<org.objectweb.asm.commons.Method> getNeedsMethods() {     return needsMethods. }
true;public;0;3;/**  * The {@code getVarName} methods that must be implemented by Painless to complete implementing the interface.  */ ;/**  * The {@code getVarName} methods that must be implemented by Painless to complete implementing the interface.  */ public List<org.objectweb.asm.commons.Method> getGetMethods() {     return getMethods. }
true;public;0;3;/**  * The {@code getVarName} methods return types.  */ ;/**  * The {@code getVarName} methods return types.  */ public List<Class<?>> getGetReturns() {     return getReturns. }
false;public;0;3;;public Class<?> getClazz() {     return clazz. }
false;public;0;3;;public String getName() {     return name. }
false;private;3;5;;private MethodArgument methodArgument(PainlessLookup painlessLookup, Class<?> clazz, String argName) {     Class<?> defClass = definitionTypeForClass(painlessLookup, clazz, componentType -> "[" + argName + "] is of unknown type [" + componentType.getName() + ". Painless interfaces can only accept arguments that are of whitelisted types.").     return new MethodArgument(defClass, argName). }
false;private,static;3;15;;private static Class<?> definitionTypeForClass(PainlessLookup painlessLookup, Class<?> type, Function<Class<?>, String> unknownErrorMessageSource) {     type = PainlessLookupUtility.javaTypeToType(type).     Class<?> componentType = type.     while (componentType.isArray()) {         componentType = componentType.getComponentType().     }     if (componentType != def.class && painlessLookup.lookupPainlessClass(componentType) == null) {         throw new IllegalArgumentException(unknownErrorMessageSource.apply(componentType)).     }     return type. }
false;private,static;1;18;;private static String[] readArgumentNamesConstant(Class<?> iface) {     Field argumentNamesField.     try {         argumentNamesField = iface.getField("PARAMETERS").     } catch (NoSuchFieldException e) {         throw new IllegalArgumentException("Painless needs a constant [String[] PARAMETERS] on all interfaces it implements with the " + "names of the method arguments but [" + iface.getName() + "] doesn't have one.", e).     }     if (false == argumentNamesField.getType().equals(String[].class)) {         throw new IllegalArgumentException("Painless needs a constant [String[] PARAMETERS] on all interfaces it implements with the " + "names of the method arguments but [" + iface.getName() + "] doesn't have one.").     }     try {         return (String[]) argumentNamesField.get(null).     } catch (IllegalArgumentException | IllegalAccessException e) {         throw new IllegalArgumentException("Error trying to read [" + iface.getName() + "#ARGUMENTS]", e).     } }
