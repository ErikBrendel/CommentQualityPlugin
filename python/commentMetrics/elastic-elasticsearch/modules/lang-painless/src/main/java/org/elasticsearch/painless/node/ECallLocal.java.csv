commented;modifiers;parameterAmount;loc;comment;code
false;;1;6;;@Override void extractVariables(Set<String> variables) {     for (AExpression argument : arguments) {         argument.extractVariables(variables).     } }
false;;1;50;;@Override void analyze(Locals locals) {     localMethod = locals.getMethod(name, arguments.size()).     if (localMethod == null) {         importedMethod = locals.getPainlessLookup().lookupImportedPainlessMethod(name, arguments.size()).         if (importedMethod == null) {             classBinding = locals.getPainlessLookup().lookupPainlessClassBinding(name, arguments.size()).             if (classBinding == null) {                 instanceBinding = locals.getPainlessLookup().lookupPainlessInstanceBinding(name, arguments.size()).                 if (instanceBinding == null) {                     throw createError(new IllegalArgumentException("Unknown call [" + name + "] with [" + arguments.size() + "] arguments.")).                 }             }         }     }     List<Class<?>> typeParameters.     if (localMethod != null) {         typeParameters = new ArrayList<>(localMethod.typeParameters).         actual = localMethod.returnType.     } else if (importedMethod != null) {         typeParameters = new ArrayList<>(importedMethod.typeParameters).         actual = importedMethod.returnType.     } else if (classBinding != null) {         typeParameters = new ArrayList<>(classBinding.typeParameters).         actual = classBinding.returnType.     } else if (instanceBinding != null) {         typeParameters = new ArrayList<>(instanceBinding.typeParameters).         actual = instanceBinding.returnType.     } else {         throw new IllegalStateException("Illegal tree structure.").     }     for (int argument = 0. argument < arguments.size(). ++argument) {         AExpression expression = arguments.get(argument).         expression.expected = typeParameters.get(argument).         expression.internal = true.         expression.analyze(locals).         arguments.set(argument, expression.cast(locals)).     }     statement = true. }
false;;2;63;;@Override void write(MethodWriter writer, Globals globals) {     writer.writeDebugInfo(location).     if (localMethod != null) {         for (AExpression argument : arguments) {             argument.write(writer, globals).         }         writer.invokeStatic(CLASS_TYPE, new Method(localMethod.name, localMethod.methodType.toMethodDescriptorString())).     } else if (importedMethod != null) {         for (AExpression argument : arguments) {             argument.write(writer, globals).         }         writer.invokeStatic(Type.getType(importedMethod.targetClass), new Method(importedMethod.javaMethod.getName(), importedMethod.methodType.toMethodDescriptorString())).     } else if (classBinding != null) {         String name = globals.addClassBinding(classBinding.javaConstructor.getDeclaringClass()).         Type type = Type.getType(classBinding.javaConstructor.getDeclaringClass()).         int javaConstructorParameterCount = classBinding.javaConstructor.getParameterCount().         Label nonNull = new Label().         writer.loadThis().         writer.getField(CLASS_TYPE, name, type).         writer.ifNonNull(nonNull).         writer.loadThis().         writer.newInstance(type).         writer.dup().         for (int argument = 0. argument < javaConstructorParameterCount. ++argument) {             arguments.get(argument).write(writer, globals).         }         writer.invokeConstructor(type, Method.getMethod(classBinding.javaConstructor)).         writer.putField(CLASS_TYPE, name, type).         writer.mark(nonNull).         writer.loadThis().         writer.getField(CLASS_TYPE, name, type).         for (int argument = 0. argument < classBinding.javaMethod.getParameterCount(). ++argument) {             arguments.get(argument + javaConstructorParameterCount).write(writer, globals).         }         writer.invokeVirtual(type, Method.getMethod(classBinding.javaMethod)).     } else if (instanceBinding != null) {         String name = globals.addInstanceBinding(instanceBinding.targetInstance).         Type type = Type.getType(instanceBinding.targetInstance.getClass()).         writer.loadThis().         writer.getStatic(CLASS_TYPE, name, type).         for (int argument = 0. argument < instanceBinding.javaMethod.getParameterCount(). ++argument) {             arguments.get(argument).write(writer, globals).         }         writer.invokeVirtual(type, Method.getMethod(instanceBinding.javaMethod)).     } else {         throw new IllegalStateException("Illegal tree structure.").     } }
false;public;0;4;;@Override public String toString() {     return singleLineToStringWithOptionalArgs(arguments, name). }
