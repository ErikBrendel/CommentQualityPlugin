commented;modifiers;parameterAmount;loc;comment;code
false;;1;6;;@Override void extractVariables(Set<String> variables) {     for (AStatement statement : statements) {         statement.extractVariables(variables).     } }
false;;1;89;;@Override void analyze(Locals locals) {     Class<?> returnType.     List<String> actualParamTypeStrs.     PainlessMethod interfaceMethod.     // inspect the target first, set interface method if we know it.     if (expected == null) {         interfaceMethod = null.         // we don't know anything: treat as def         returnType = def.class.         // don't infer any types, replace any null types with def         actualParamTypeStrs = new ArrayList<>(paramTypeStrs.size()).         for (String type : paramTypeStrs) {             if (type == null) {                 actualParamTypeStrs.add("def").             } else {                 actualParamTypeStrs.add(type).             }         }     } else {         // we know the method statically, infer return type and any unknown/def types         interfaceMethod = locals.getPainlessLookup().lookupFunctionalInterfacePainlessMethod(expected).         if (interfaceMethod == null) {             throw createError(new IllegalArgumentException("Cannot pass lambda to " + "[" + PainlessLookupUtility.typeToCanonicalTypeName(expected) + "], not a functional interface")).         }         // check arity before we manipulate parameters         if (interfaceMethod.typeParameters.size() != paramTypeStrs.size())             throw new IllegalArgumentException("Incorrect number of parameters for [" + interfaceMethod.javaMethod.getName() + "] in [" + PainlessLookupUtility.typeToCanonicalTypeName(expected) + "]").         // for method invocation, its allowed to ignore the return value         if (interfaceMethod.returnType == void.class) {             returnType = def.class.         } else {             returnType = interfaceMethod.returnType.         }         // replace any null types with the actual type         actualParamTypeStrs = new ArrayList<>(paramTypeStrs.size()).         for (int i = 0. i < paramTypeStrs.size(). i++) {             String paramType = paramTypeStrs.get(i).             if (paramType == null) {                 actualParamTypeStrs.add(PainlessLookupUtility.typeToCanonicalTypeName(interfaceMethod.typeParameters.get(i))).             } else {                 actualParamTypeStrs.add(paramType).             }         }     }     // gather any variables used by the lambda body first.     Set<String> variables = new HashSet<>().     for (AStatement statement : statements) {         statement.extractVariables(variables).     }     // any of those variables defined in our scope need to be captured     captures = new ArrayList<>().     for (String variable : variables) {         if (locals.hasVariable(variable)) {             captures.add(locals.getVariable(location, variable)).         }     }     // prepend capture list to lambda's arguments     List<String> paramTypes = new ArrayList<>(captures.size() + actualParamTypeStrs.size()).     List<String> paramNames = new ArrayList<>(captures.size() + paramNameStrs.size()).     for (Variable var : captures) {         paramTypes.add(PainlessLookupUtility.typeToCanonicalTypeName(var.clazz)).         paramNames.add(var.name).     }     paramTypes.addAll(actualParamTypeStrs).     paramNames.addAll(paramNameStrs).     // desugar lambda body into a synthetic method     desugared = new SFunction(reserved, location, PainlessLookupUtility.typeToCanonicalTypeName(returnType), name, paramTypes, paramNames, statements, true).     desugared.generateSignature(locals.getPainlessLookup()).     desugared.analyze(Locals.newLambdaScope(locals.getProgramScope(), desugared.name, returnType, desugared.parameters, captures.size(), reserved.getMaxLoopCounter())).     // setup method reference to synthetic method     if (expected == null) {         ref = null.         actual = String.class.         defPointer = "Sthis." + name + "," + captures.size().     } else {         defPointer = null.         ref = FunctionRef.create(locals.getPainlessLookup(), locals.getMethods(), location, expected, "this", desugared.name, captures.size()).         actual = expected.     } }
false;;2;24;;@Override void write(MethodWriter writer, Globals globals) {     writer.writeDebugInfo(location).     if (ref != null) {         writer.writeDebugInfo(location).         // load captures         for (Variable capture : captures) {             writer.visitVarInsn(MethodWriter.getType(capture.clazz).getOpcode(Opcodes.ILOAD), capture.getSlot()).         }         writer.invokeLambdaCall(ref).     } else {         // placeholder         writer.push((String) null).         // load captures         for (Variable capture : captures) {             writer.visitVarInsn(MethodWriter.getType(capture.clazz).getOpcode(Opcodes.ILOAD), capture.getSlot()).         }     }     // add synthetic method to the queue to be written     globals.addSyntheticMethod(desugared). }
false;public;0;4;;@Override public String getPointer() {     return defPointer. }
false;public;0;8;;@Override public org.objectweb.asm.Type[] getCaptures() {     org.objectweb.asm.Type[] types = new org.objectweb.asm.Type[captures.size()].     for (int i = 0. i < types.length. i++) {         types[i] = MethodWriter.getType(captures.get(i).clazz).     }     return types. }
false;public;0;4;;@Override public String toString() {     return multilineToString(pairwiseToString(paramTypeStrs, paramNameStrs), statements). }
