commented;modifiers;parameterAmount;loc;comment;code
false;;1;5;;@Override void extractVariables(Set<String> variables) {     lhs.extractVariables(variables).     rhs.extractVariables(variables). }
false;;1;13;;@Override void analyze(Locals locals) {     analyzeLHS(locals).     analyzeIncrDecr().     if (operation != null) {         analyzeCompound(locals).     } else if (rhs != null) {         analyzeSimple(locals).     } else {         throw new IllegalStateException("Illegal tree structure.").     } }
false;private;1;11;;private void analyzeLHS(Locals locals) {     if (lhs instanceof AStoreable) {         AStoreable lhs = (AStoreable) this.lhs.         lhs.read = read.         lhs.write = true.         lhs.analyze(locals).     } else {         throw new IllegalArgumentException("Left-hand side cannot be assigned a value.").     } }
false;private;0;37;;private void analyzeIncrDecr() {     if (pre && post) {         throw createError(new IllegalStateException("Illegal tree structure.")).     } else if (pre || post) {         if (rhs != null) {             throw createError(new IllegalStateException("Illegal tree structure.")).         }         if (operation == Operation.INCR) {             if (lhs.actual == double.class) {                 rhs = new EConstant(location, 1D).             } else if (lhs.actual == float.class) {                 rhs = new EConstant(location, 1F).             } else if (lhs.actual == long.class) {                 rhs = new EConstant(location, 1L).             } else {                 rhs = new EConstant(location, 1).             }             operation = Operation.ADD.         } else if (operation == Operation.DECR) {             if (lhs.actual == double.class) {                 rhs = new EConstant(location, 1D).             } else if (lhs.actual == float.class) {                 rhs = new EConstant(location, 1F).             } else if (lhs.actual == long.class) {                 rhs = new EConstant(location, 1L).             } else {                 rhs = new EConstant(location, 1).             }             operation = Operation.SUB.         } else {             throw createError(new IllegalStateException("Illegal tree structure.")).         }     } }
false;private;1;72;;private void analyzeCompound(Locals locals) {     rhs.analyze(locals).     boolean shift = false.     if (operation == Operation.MUL) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, rhs.actual, true).     } else if (operation == Operation.DIV) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, rhs.actual, true).     } else if (operation == Operation.REM) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, rhs.actual, true).     } else if (operation == Operation.ADD) {         promote = AnalyzerCaster.promoteAdd(lhs.actual, rhs.actual).     } else if (operation == Operation.SUB) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, rhs.actual, true).     } else if (operation == Operation.LSH) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, false).         shiftDistance = AnalyzerCaster.promoteNumeric(rhs.actual, false).         shift = true.     } else if (operation == Operation.RSH) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, false).         shiftDistance = AnalyzerCaster.promoteNumeric(rhs.actual, false).         shift = true.     } else if (operation == Operation.USH) {         promote = AnalyzerCaster.promoteNumeric(lhs.actual, false).         shiftDistance = AnalyzerCaster.promoteNumeric(rhs.actual, false).         shift = true.     } else if (operation == Operation.BWAND) {         promote = AnalyzerCaster.promoteXor(lhs.actual, rhs.actual).     } else if (operation == Operation.XOR) {         promote = AnalyzerCaster.promoteXor(lhs.actual, rhs.actual).     } else if (operation == Operation.BWOR) {         promote = AnalyzerCaster.promoteXor(lhs.actual, rhs.actual).     } else {         throw createError(new IllegalStateException("Illegal tree structure.")).     }     if (promote == null || (shift && shiftDistance == null)) {         throw createError(new ClassCastException("Cannot apply compound assignment " + "[" + operation.symbol + "=] to types [" + lhs.actual + "] and [" + rhs.actual + "].")).     }     cat = operation == Operation.ADD && promote == String.class.     if (cat) {         if (rhs instanceof EBinary && ((EBinary) rhs).operation == Operation.ADD && rhs.actual == String.class) {             ((EBinary) rhs).cat = true.         }         rhs.expected = rhs.actual.     } else if (shift) {         if (promote == def.class) {             // shifts are promoted independently, but for the def type, we need object.             rhs.expected = promote.         } else if (shiftDistance == long.class) {             rhs.expected = int.class.             rhs.explicit = true.         } else {             rhs.expected = shiftDistance.         }     } else {         rhs.expected = promote.     }     rhs = rhs.cast(locals).     there = AnalyzerCaster.getLegalCast(location, lhs.actual, promote, false, false).     back = AnalyzerCaster.getLegalCast(location, promote, lhs.actual, true, false).     this.statement = true.     this.actual = read ? lhs.actual : void.class. }
false;private;1;24;;private void analyzeSimple(Locals locals) {     AStoreable lhs = (AStoreable) this.lhs.     // If the lhs node is a def optimized node we update the actual type to remove the need for a cast.     if (lhs.isDefOptimized()) {         rhs.analyze(locals).         if (rhs.actual == void.class) {             throw createError(new IllegalArgumentException("Right-hand side cannot be a [void] type for assignment.")).         }         rhs.expected = rhs.actual.         lhs.updateActual(rhs.actual).     // Otherwise, we must adapt the rhs type to the lhs type with a cast.     } else {         rhs.expected = lhs.actual.         rhs.analyze(locals).     }     rhs = rhs.cast(locals).     this.statement = true.     this.actual = read ? lhs.actual : void.class. }
true;;2;92;/**  * Handles writing byte code for variable/method chains for all given possibilities  * including String concatenation, compound assignment, regular assignment, and simple  * reads.  Includes proper duplication for chained assignments and assignments that are  * also read from.  */ ;/**  * Handles writing byte code for variable/method chains for all given possibilities  * including String concatenation, compound assignment, regular assignment, and simple  * reads.  Includes proper duplication for chained assignments and assignments that are  * also read from.  */ @Override void write(MethodWriter writer, Globals globals) {     writer.writeDebugInfo(location).     // For the case where the assignment represents a String concatenation     // we must, depending on the Java version, write a StringBuilder or     // track types going onto the stack.  This must be done before the     // lhs is read because we need the StringBuilder to be placed on the     // stack ahead of any potential concatenation arguments.     int catElementStackSize = 0.     if (cat) {         catElementStackSize = writer.writeNewStrings().     }     // Cast the lhs to a storeable to perform the necessary operations to store the rhs.     AStoreable lhs = (AStoreable) this.lhs.     // call the setup method on the lhs to prepare for a load/store operation     lhs.setup(writer, globals).     if (cat) {         // Handle the case where we are doing a compound assignment         // representing a String concatenation.         // dup the top element and insert it         writer.writeDup(lhs.accessElementCount(), catElementStackSize).         // before concat helper on stack         // read the current lhs's value         lhs.load(writer, globals).         // append the lhs's value using the StringBuilder         writer.writeAppendStrings(lhs.actual).         // write the bytecode for the rhs         rhs.write(writer, globals).         if (!(rhs instanceof EBinary) || !((EBinary) rhs).cat) {             // check to see if the rhs has already done a concatenation             // append the rhs's value since it's hasn't already             writer.writeAppendStrings(rhs.actual).         }         // put the value for string concat onto the stack         writer.writeToStrings().         // if necessary, cast the String to the lhs actual type         writer.writeCast(back).         if (lhs.read) {             // if this lhs is also read             writer.writeDup(MethodWriter.getType(lhs.actual).getSize(), lhs.accessElementCount()).         // from dup the value onto the stack         }         // store the lhs's value from the stack in its respective variable/field/array         lhs.store(writer, globals).     } else if (operation != null) {         // Handle the case where we are doing a compound assignment that         // does not represent a String concatenation.         // if necessary, dup the previous lhs's value         writer.writeDup(lhs.accessElementCount(), 0).         // to be both loaded from and stored to         // load the current lhs's value         lhs.load(writer, globals).         if (lhs.read && post) {             // dup the value if the lhs is also             writer.writeDup(MethodWriter.getType(lhs.actual).getSize(), lhs.accessElementCount()).         // read from and is a post increment         }         // if necessary cast the current lhs's value         writer.writeCast(there).         // to the promotion type between the lhs and rhs types         // write the bytecode for the rhs         rhs.write(writer, globals).         // write the operation instruction for compound assignment         if (promote == def.class) {             writer.writeDynamicBinaryInstruction(location, promote, def.class, def.class, operation, DefBootstrap.OPERATOR_COMPOUND_ASSIGNMENT).         } else {             writer.writeBinaryInstruction(location, promote, operation).         }         // if necessary cast the promotion type value back to the lhs's type         writer.writeCast(back).         if (lhs.read && !post) {             // dup the value if the lhs is also             writer.writeDup(MethodWriter.getType(lhs.actual).getSize(), lhs.accessElementCount()).         // read from and is not a post         // increment         }         // store the lhs's value from the stack in its respective variable/field/array         lhs.store(writer, globals).     } else {         // Handle the case for a simple write.         // write the bytecode for the rhs rhs         rhs.write(writer, globals).         if (lhs.read) {             // dup the value if the lhs             writer.writeDup(MethodWriter.getType(lhs.actual).getSize(), lhs.accessElementCount()).         // is also read from         }         // store the lhs's value from the stack in its respective variable/field/array         lhs.store(writer, globals).     } }
false;public;0;19;;@Override public String toString() {     List<Object> subs = new ArrayList<>().     subs.add(lhs).     if (rhs != null) {         // Make sure "=" is in the symbol so this is easy to read at a glance         subs.add(operation == null ? "=" : operation.symbol + "=").         subs.add(rhs).         return singleLineToString(subs).     }     subs.add(operation.symbol).     if (pre) {         subs.add("pre").     }     if (post) {         subs.add("post").     }     return singleLineToString(subs). }
