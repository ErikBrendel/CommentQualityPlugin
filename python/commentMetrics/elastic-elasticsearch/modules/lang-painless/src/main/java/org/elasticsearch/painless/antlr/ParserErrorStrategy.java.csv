commented;modifiers;parameterAmount;loc;comment;code
false;public;2;23;;@Override public void recover(final Parser recognizer, final RecognitionException re) {     final Token token = re.getOffendingToken().     String message.     if (token == null) {         message = "no parse token found.".     } else if (re instanceof InputMismatchException) {         message = "unexpected token [" + getTokenErrorDisplay(token) + "]" + " was expecting one of [" + re.getExpectedTokens().toString(recognizer.getVocabulary()) + "].".     } else if (re instanceof NoViableAltException) {         if (token.getType() == PainlessParser.EOF) {             message = "unexpected end of script.".         } else {             message = "invalid sequence of tokens near [" + getTokenErrorDisplay(token) + "].".         }     } else {         message = "unexpected token near [" + getTokenErrorDisplay(token) + "].".     }     Location location = new Location(sourceName, token == null ? -1 : token.getStartIndex()).     throw location.createError(new IllegalArgumentException(message, re)). }
false;public;1;9;;@Override public Token recoverInline(final Parser recognizer) throws RecognitionException {     final Token token = recognizer.getCurrentToken().     final String message = "unexpected token [" + getTokenErrorDisplay(token) + "]" + " was expecting one of [" + recognizer.getExpectedTokens().toString(recognizer.getVocabulary()) + "].".     Location location = new Location(sourceName, token.getStartIndex()).     throw location.createError(new IllegalArgumentException(message)). }
false;public;1;3;;@Override public void sync(final Parser recognizer) { }
