commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * @return The name of the script retrieved from a static variable generated  * during compilation of a Painless script.  */ ;/**  * @return The name of the script retrieved from a static variable generated  * during compilation of a Painless script.  */ String getName().
true;;0;1;/**  * @return The source for a script retrieved from a static variable generated  * during compilation of a Painless script.  */ ;/**  * @return The source for a script retrieved from a static variable generated  * during compilation of a Painless script.  */ String getSource().
true;;0;1;/**  * @return The {@link BitSet} tracking the boundaries for statements necessary  * for good exception messages.  */ ;/**  * @return The {@link BitSet} tracking the boundaries for statements necessary  * for good exception messages.  */ BitSet getStatements().
true;default;2;42;/**  * Adds stack trace and other useful information to exceptions thrown  * from a Painless script.  * @param t The throwable to build an exception around.  * @return The generated ScriptException.  */ ;/**  * Adds stack trace and other useful information to exceptions thrown  * from a Painless script.  * @param t The throwable to build an exception around.  * @return The generated ScriptException.  */ default ScriptException convertToScriptException(Throwable t, Map<String, List<String>> extraMetadata) {     // create a script stack: this is just the script portion     List<String> scriptStack = new ArrayList<>().     for (StackTraceElement element : t.getStackTrace()) {         if (WriterConstants.CLASS_NAME.equals(element.getClassName())) {             // found the script portion             int offset = element.getLineNumber().             if (offset == -1) {                 scriptStack.add("<<< unknown portion of script >>>").             } else {                 // offset is 1 based, line numbers must be!                 offset--.                 int startOffset = getPreviousStatement(offset).                 if (startOffset == -1) {                     // should never happen unless we hit exc in ctor prologue...                     assert false.                     startOffset = 0.                 }                 int endOffset = getNextStatement(startOffset).                 if (endOffset == -1) {                     endOffset = getSource().length().                 }                 // TODO: if this is still too long, truncate and use ellipses                 String snippet = getSource().substring(startOffset, endOffset).                 scriptStack.add(snippet).                 StringBuilder pointer = new StringBuilder().                 for (int i = startOffset. i < offset. i++) {                     pointer.append(' ').                 }                 pointer.append("^---- HERE").                 scriptStack.add(pointer.toString()).             }             break.         // but filter our own internal stacks (e.g. indy bootstrap)         } else if (!shouldFilter(element)) {             scriptStack.add(element.toString()).         }     }     ScriptException scriptException = new ScriptException("runtime error", t, scriptStack, getName(), PainlessScriptEngine.NAME).     for (Map.Entry<String, List<String>> entry : extraMetadata.entrySet()) {         scriptException.addMetadata(entry.getKey(), entry.getValue()).     }     return scriptException. }
true;default;1;5;/**  * returns true for methods that are part of the runtime  */ ;/**  * returns true for methods that are part of the runtime  */ default boolean shouldFilter(StackTraceElement element) {     return element.getClassName().startsWith("org.elasticsearch.painless.") || element.getClassName().startsWith("java.lang.invoke.") || element.getClassName().startsWith("sun.invoke."). }
true;default;1;3;/**  * Finds the start of the first statement boundary that is on or before {@code offset}. If one is not found, {@code -1} is returned.  */ ;/**  * Finds the start of the first statement boundary that is on or before {@code offset}. If one is not found, {@code -1} is returned.  */ default int getPreviousStatement(int offset) {     return getStatements().previousSetBit(offset). }
true;default;1;3;/**  * Finds the start of the first statement boundary that is after {@code offset}. If one is not found, {@code -1} is returned.  */ ;/**  * Finds the start of the first statement boundary that is after {@code offset}. If one is not found, {@code -1} is returned.  */ default int getNextStatement(int offset) {     return getStatements().nextSetBit(offset + 1). }
