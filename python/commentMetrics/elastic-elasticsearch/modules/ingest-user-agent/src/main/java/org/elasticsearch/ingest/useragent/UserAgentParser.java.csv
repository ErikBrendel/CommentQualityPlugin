commented;modifiers;parameterAmount;loc;comment;code
false;private;1;44;;private void init(InputStream regexStream) throws IOException {     // EMPTY is safe here because we don't use namedObject     XContentParser yamlParser = XContentFactory.xContent(XContentType.YAML).createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, regexStream).     XContentParser.Token token = yamlParser.nextToken().     if (token == XContentParser.Token.START_OBJECT) {         token = yamlParser.nextToken().         for (. token != null. token = yamlParser.nextToken()) {             if (token == XContentParser.Token.FIELD_NAME && yamlParser.currentName().equals("user_agent_parsers")) {                 List<Map<String, String>> parserConfigurations = readParserConfigurations(yamlParser).                 for (Map<String, String> map : parserConfigurations) {                     uaPatterns.add(new UserAgentSubpattern(compilePattern(map.get("regex"), map.get("regex_flag")), map.get("family_replacement"), map.get("v1_replacement"), map.get("v2_replacement"), map.get("v3_replacement"), map.get("v4_replacement"))).                 }             } else if (token == XContentParser.Token.FIELD_NAME && yamlParser.currentName().equals("os_parsers")) {                 List<Map<String, String>> parserConfigurations = readParserConfigurations(yamlParser).                 for (Map<String, String> map : parserConfigurations) {                     osPatterns.add(new UserAgentSubpattern(compilePattern(map.get("regex"), map.get("regex_flag")), map.get("os_replacement"), map.get("os_v1_replacement"), map.get("os_v2_replacement"), map.get("os_v3_replacement"), map.get("os_v4_replacement"))).                 }             } else if (token == XContentParser.Token.FIELD_NAME && yamlParser.currentName().equals("device_parsers")) {                 List<Map<String, String>> parserConfigurations = readParserConfigurations(yamlParser).                 for (Map<String, String> map : parserConfigurations) {                     devicePatterns.add(new UserAgentSubpattern(compilePattern(map.get("regex"), map.get("regex_flag")), map.get("device_replacement"), null, null, null, null)).                 }             }         }     }     if (uaPatterns.isEmpty() && osPatterns.isEmpty() && devicePatterns.isEmpty()) {         throw new ElasticsearchParseException("not a valid regular expression file").     } }
false;private;2;8;;private Pattern compilePattern(String regex, String regex_flag) {     // Only flag present in the current default regexes.yaml     if (regex_flag != null && regex_flag.equals("i")) {         return Pattern.compile(regex, Pattern.CASE_INSENSITIVE).     } else {         return Pattern.compile(regex).     } }
false;private;1;36;;private List<Map<String, String>> readParserConfigurations(XContentParser yamlParser) throws IOException {     List<Map<String, String>> patternList = new ArrayList<>().     XContentParser.Token token = yamlParser.nextToken().     if (token != XContentParser.Token.START_ARRAY) {         throw new ElasticsearchParseException("malformed regular expression file, should continue with 'array' after 'object'").     }     token = yamlParser.nextToken().     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("malformed regular expression file, expecting 'object'").     }     while (token == XContentParser.Token.START_OBJECT) {         token = yamlParser.nextToken().         if (token != XContentParser.Token.FIELD_NAME) {             throw new ElasticsearchParseException("malformed regular expression file, should continue with 'field_name' after 'array'").         }         Map<String, String> regexMap = new HashMap<>().         for (. token == XContentParser.Token.FIELD_NAME. token = yamlParser.nextToken()) {             String fieldName = yamlParser.currentName().             token = yamlParser.nextToken().             String fieldValue = yamlParser.text().             regexMap.put(fieldName, fieldValue).         }         patternList.add(regexMap).         token = yamlParser.nextToken().     }     return patternList. }
false;;0;3;;List<UserAgentSubpattern> getUaPatterns() {     return uaPatterns. }
false;;0;3;;List<UserAgentSubpattern> getOsPatterns() {     return osPatterns. }
false;;0;3;;List<UserAgentSubpattern> getDevicePatterns() {     return devicePatterns. }
false;;0;3;;String getName() {     return name. }
false;public;1;15;;public Details parse(String agentString) {     Details details = cache.get(name, agentString).     if (details == null) {         VersionedName userAgent = findMatch(uaPatterns, agentString).         VersionedName operatingSystem = findMatch(osPatterns, agentString).         VersionedName device = findMatch(devicePatterns, agentString).         details = new Details(userAgent, operatingSystem, device).         cache.put(name, agentString, details).     }     return details. }
false;private;2;12;;private VersionedName findMatch(List<UserAgentSubpattern> possiblePatterns, String agentString) {     VersionedName name.     for (UserAgentSubpattern pattern : possiblePatterns) {         name = pattern.match(agentString).         if (name != null) {             return name.         }     }     return null. }
false;public;1;46;;public VersionedName match(String agentString) {     String name = null, major = null, minor = null, patch = null, build = null.     Matcher matcher = pattern.matcher(agentString).     if (!matcher.find()) {         return null.     }     int groupCount = matcher.groupCount().     if (nameReplacement != null) {         if (nameReplacement.contains("$1") && groupCount >= 1 && matcher.group(1) != null) {             name = nameReplacement.replaceFirst("\\$1", Matcher.quoteReplacement(matcher.group(1))).         } else {             name = nameReplacement.         }     } else if (groupCount >= 1) {         name = matcher.group(1).     }     if (v1Replacement != null) {         major = v1Replacement.     } else if (groupCount >= 2) {         major = matcher.group(2).     }     if (v2Replacement != null) {         minor = v2Replacement.     } else if (groupCount >= 3) {         minor = matcher.group(3).     }     if (v3Replacement != null) {         patch = v3Replacement.     } else if (groupCount >= 4) {         patch = matcher.group(4).     }     if (v4Replacement != null) {         build = v4Replacement.     } else if (groupCount >= 5) {         build = matcher.group(5).     }     return name == null ? null : new VersionedName(name, major, minor, patch, build). }
