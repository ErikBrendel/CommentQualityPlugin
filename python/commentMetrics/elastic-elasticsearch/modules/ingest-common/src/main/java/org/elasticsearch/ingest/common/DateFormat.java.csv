commented;modifiers;parameterAmount;loc;comment;code
false;;3;4;;@Override Function<String, ZonedDateTime> getFunction(String format, ZoneId timezone, Locale locale) {     return (date) -> DateFormatters.from(DateFormatter.forPattern("iso8601").parse(date)).withZoneSameInstant(timezone). }
false;;3;4;;@Override Function<String, ZonedDateTime> getFunction(String format, ZoneId timezone, Locale locale) {     return date -> Instant.ofEpochMilli((long) (Double.parseDouble(date) * 1000.0)).atZone(timezone). }
false;;3;4;;@Override Function<String, ZonedDateTime> getFunction(String format, ZoneId timezone, Locale locale) {     return date -> Instant.ofEpochMilli(Long.parseLong(date)).atZone(timezone). }
false;;3;4;;@Override Function<String, ZonedDateTime> getFunction(String format, ZoneId timezone, Locale locale) {     return date -> Instant.ofEpochMilli(parseMillis(date)).atZone(timezone). }
false;private;1;9;;private long parseMillis(String date) {     if (date.startsWith("@")) {         date = date.substring(1).     }     long base = Long.parseLong(date.substring(1, 16), 16).     // 1356138046000     long rest = Long.parseLong(date.substring(16, 24), 16).     return ((base * 1000) - 10000) + (rest / 1000000). }
false;;3;39;;@Override Function<String, ZonedDateTime> getFunction(String format, ZoneId zoneId, Locale locale) {     // support the 6.x BWC compatible way of parsing java 8 dates     if (format.startsWith("8")) {         format = format.substring(1).     }     boolean isUtc = ZoneOffset.UTC.equals(zoneId).     int year = LocalDate.now(ZoneOffset.UTC).getYear().     DateFormatter dateFormatter = DateFormatter.forPattern(format).withLocale(locale).     // if UTC zone is set here, the the time zone specified in the format will be ignored, leading to wrong dates     if (isUtc == false) {         dateFormatter = dateFormatter.withZone(zoneId).     }     final DateFormatter formatter = dateFormatter.     return text -> {         TemporalAccessor accessor = formatter.parse(text).         // fill the rest of the date up with the parsed date         if (accessor.isSupported(ChronoField.YEAR) == false) {             ZonedDateTime newTime = Instant.EPOCH.atZone(ZoneOffset.UTC).withYear(year).             for (ChronoField field : FIELDS) {                 if (accessor.isSupported(field)) {                     newTime = newTime.with(field, accessor.get(field)).                 }             }             accessor = newTime.withZoneSameLocal(zoneId).         }         if (isUtc) {             return DateFormatters.from(accessor).withZoneSameInstant(ZoneOffset.UTC).         } else {             return DateFormatters.from(accessor).         }     }. }
false;abstract;3;1;;abstract Function<String, ZonedDateTime> getFunction(String format, ZoneId timezone, Locale locale).
false;static;1;14;;static DateFormat fromString(String format) {     switch(format) {         case "ISO8601":             return Iso8601.         case "UNIX":             return Unix.         case "UNIX_MS":             return UnixMs.         case "TAI64N":             return Tai64n.         default:             return Java.     } }
