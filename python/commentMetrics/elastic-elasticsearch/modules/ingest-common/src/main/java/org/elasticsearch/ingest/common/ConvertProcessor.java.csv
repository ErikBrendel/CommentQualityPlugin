commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public Object convert(Object value) {     try {         String strValue = value.toString().         if (strValue.startsWith("0x") || strValue.startsWith("-0x")) {             return Integer.decode(strValue).         }         return Integer.parseInt(strValue).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("unable to convert [" + value + "] to integer", e).     } }
false;public;1;12;;@Override public Object convert(Object value) {     try {         String strValue = value.toString().         if (strValue.startsWith("0x") || strValue.startsWith("-0x")) {             return Long.decode(strValue).         }         return Long.parseLong(strValue).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("unable to convert [" + value + "] to long", e).     } }
false;public;1;8;;@Override public Object convert(Object value) {     try {         return Double.parseDouble(value.toString()).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("unable to convert [" + value + "] to double", e).     } }
false;public;1;8;;@Override public Object convert(Object value) {     try {         return Float.parseFloat(value.toString()).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("unable to convert [" + value + "] to float", e).     } }
false;public;1;10;;@Override public Object convert(Object value) {     if (value.toString().equalsIgnoreCase("true")) {         return true.     } else if (value.toString().equalsIgnoreCase("false")) {         return false.     } else {         throw new IllegalArgumentException("[" + value + "] is not a boolean value, cannot convert to boolean").     } }
false;public;1;4;;@Override public Object convert(Object value) {     return value.toString(). }
false;public;1;22;;@Override public Object convert(Object value) {     if (!(value instanceof String)) {         return value.     }     try {         return BOOLEAN.convert(value).     } catch (IllegalArgumentException e) {     }     try {         return INTEGER.convert(value).     } catch (IllegalArgumentException e) {     }     try {         return LONG.convert(value).     } catch (IllegalArgumentException e) {     }     try {         return FLOAT.convert(value).     } catch (IllegalArgumentException e) {     }     try {         return DOUBLE.convert(value).     } catch (IllegalArgumentException e) {     }     return value. }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
false;public,abstract;1;1;;public abstract Object convert(Object value).
false;public,static;3;8;;public static Type fromString(String processorTag, String propertyName, String type) {     try {         return Type.valueOf(type.toUpperCase(Locale.ROOT)).     } catch (IllegalArgumentException e) {         throw newConfigurationException(TYPE, processorTag, propertyName, "type [" + type + "] not supported, cannot convert field.").     } }
false;;0;3;;String getField() {     return field. }
false;;0;3;;String getTargetField() {     return targetField. }
false;;0;3;;Type getConvertType() {     return convertType. }
false;;0;3;;boolean isIgnoreMissing() {     return ignoreMissing. }
false;public;1;24;;@Override public IngestDocument execute(IngestDocument document) {     Object oldValue = document.getFieldValue(field, Object.class, ignoreMissing).     Object newValue.     if (oldValue == null && ignoreMissing) {         return document.     } else if (oldValue == null) {         throw new IllegalArgumentException("Field [" + field + "] is null, cannot be converted to type [" + convertType + "]").     }     if (oldValue instanceof List) {         List<?> list = (List<?>) oldValue.         List<Object> newList = new ArrayList<>(list.size()).         for (Object value : list) {             newList.add(convertType.convert(value)).         }         newValue = newList.     } else {         newValue = convertType.convert(oldValue).     }     document.setFieldValue(targetField, newValue).     return document. }
false;public;0;4;;@Override public String getType() {     return TYPE. }
false;public;3;10;;@Override public ConvertProcessor create(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception {     String field = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, "field").     String typeProperty = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, "type").     String targetField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, "target_field", field).     Type convertType = Type.fromString(processorTag, "type", typeProperty).     boolean ignoreMissing = ConfigurationUtils.readBooleanProperty(TYPE, processorTag, config, "ignore_missing", false).     return new ConvertProcessor(processorTag, field, targetField, convertType, ignoreMissing). }
