commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Executes the script with the Ingest document in context.  *  * @param document The Ingest document passed into the script context under the "ctx" object.  */ ;/**  * Executes the script with the Ingest document in context.  *  * @param document The Ingest document passed into the script context under the "ctx" object.  */ @Override public IngestDocument execute(IngestDocument document) {     IngestScript.Factory factory = scriptService.compile(script, IngestScript.CONTEXT).     factory.newInstance(script.getParams()).execute(new DeprecationMap(document.getSourceAndMetadata(), DEPRECATIONS, "script_processor")).     CollectionUtils.ensureNoSelfReferences(document.getSourceAndMetadata(), "ingest script").     return document. }
false;public;0;4;;@Override public String getType() {     return TYPE. }
false;;0;3;;Script getScript() {     return script. }
false;public;3;21;;@Override public ScriptProcessor create(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception {     try (XContentBuilder builder = XContentBuilder.builder(JsonXContent.jsonXContent).map(config).         InputStream stream = BytesReference.bytes(builder).streamInput().         XContentParser parser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {         Script script = Script.parse(parser).         Arrays.asList("id", "source", "inline", "lang", "params", "options").forEach(config::remove).         // verify script is able to be compiled before successfully creating processor.         try {             scriptService.compile(script, IngestScript.CONTEXT).         } catch (ScriptException e) {             throw newConfigurationException(TYPE, processorTag, null, e).         }         return new ScriptProcessor(processorTag, script, scriptService).     } }
