commented;modifiers;parameterAmount;loc;comment;code
false;public;1;30;;@Override public IngestDocument execute(IngestDocument ingestDocument) throws Exception {     String fieldValue = ingestDocument.getFieldValue(matchField, String.class, ignoreMissing).     if (fieldValue == null && ignoreMissing) {         return ingestDocument.     } else if (fieldValue == null) {         throw new IllegalArgumentException("field [" + matchField + "] is null, cannot process it.").     }     Map<String, Object> matches = grok.captures(fieldValue).     if (matches == null) {         throw new IllegalArgumentException("Provided Grok expressions do not match field value: [" + fieldValue + "]").     }     matches.forEach(ingestDocument::setFieldValue).     if (traceMatch) {         if (matchPatterns.size() > 1) {             @SuppressWarnings("unchecked")             HashMap<String, String> matchMap = (HashMap<String, String>) ingestDocument.getFieldValue(PATTERN_MATCH_KEY, Object.class).             matchMap.keySet().stream().findFirst().ifPresent((index) -> {                 ingestDocument.setFieldValue(PATTERN_MATCH_KEY, index).             }).         } else {             ingestDocument.setFieldValue(PATTERN_MATCH_KEY, "0").         }     }     return ingestDocument. }
false;public;0;4;;@Override public String getType() {     return TYPE. }
false;;0;3;;Grok getGrok() {     return grok. }
false;;0;3;;boolean isIgnoreMissing() {     return ignoreMissing. }
false;;0;3;;String getMatchField() {     return matchField. }
false;;0;3;;List<String> getMatchPatterns() {     return matchPatterns. }
false;static;2;24;;static String combinePatterns(List<String> patterns, boolean traceMatch) {     String combinedPattern.     if (patterns.size() > 1) {         combinedPattern = "".         for (int i = 0. i < patterns.size(). i++) {             String pattern = patterns.get(i).             String valueWrap.             if (traceMatch) {                 valueWrap = "(?<" + PATTERN_MATCH_KEY + "." + i + ">" + pattern + ")".             } else {                 valueWrap = "(?:" + patterns.get(i) + ")".             }             if (combinedPattern.equals("")) {                 combinedPattern = valueWrap.             } else {                 combinedPattern = combinedPattern + "|" + valueWrap.             }         }     } else {         combinedPattern = patterns.get(0).     }     return combinedPattern. }
false;public;3;26;;@Override public GrokProcessor create(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception {     String matchField = ConfigurationUtils.readStringProperty(TYPE, processorTag, config, "field").     List<String> matchPatterns = ConfigurationUtils.readList(TYPE, processorTag, config, "patterns").     boolean traceMatch = ConfigurationUtils.readBooleanProperty(TYPE, processorTag, config, "trace_match", false).     boolean ignoreMissing = ConfigurationUtils.readBooleanProperty(TYPE, processorTag, config, "ignore_missing", false).     if (matchPatterns.isEmpty()) {         throw newConfigurationException(TYPE, processorTag, "patterns", "List of patterns must not be empty").     }     Map<String, String> customPatternBank = ConfigurationUtils.readOptionalMap(TYPE, processorTag, config, "pattern_definitions").     Map<String, String> patternBank = new HashMap<>(builtinPatterns).     if (customPatternBank != null) {         patternBank.putAll(customPatternBank).     }     try {         return new GrokProcessor(processorTag, patternBank, matchPatterns, matchField, traceMatch, ignoreMissing, threadWatchdog).     } catch (Exception e) {         throw newConfigurationException(TYPE, processorTag, "patterns", "Invalid regex pattern found in: " + matchPatterns + ". " + e.getMessage()).     } }
