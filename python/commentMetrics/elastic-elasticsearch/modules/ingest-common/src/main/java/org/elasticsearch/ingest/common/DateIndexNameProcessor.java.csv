commented;modifiers;parameterAmount;loc;comment;code
false;public;1;43;;@Override public IngestDocument execute(IngestDocument ingestDocument) throws Exception {     // Date can be specified as a string or long:     Object obj = ingestDocument.getFieldValue(field, Object.class).     String date = null.     if (obj != null) {         // Not use Objects.toString(...) here, because null gets changed to "null" which may confuse some date parsers         date = obj.toString().     }     ZonedDateTime dateTime = null.     Exception lastException = null.     for (Function<String, ZonedDateTime> dateParser : dateFormats) {         try {             dateTime = dateParser.apply(date).         } catch (Exception e) {             // try the next parser and keep track of the exceptions             lastException = ExceptionsHelper.useOrSuppress(lastException, e).         }     }     if (dateTime == null) {         throw new IllegalArgumentException("unable to parse date [" + date + "]", lastException).     }     String indexNamePrefix = ingestDocument.renderTemplate(indexNamePrefixTemplate).     String indexNameFormat = ingestDocument.renderTemplate(indexNameFormatTemplate).     String dateRounding = ingestDocument.renderTemplate(dateRoundingTemplate).     DateFormatter formatter = DateFormatter.forPattern(indexNameFormat).     // use UTC instead of Z is string representation of UTC, so behaviour is the same between 6.x and 7     String zone = timezone.equals(ZoneOffset.UTC) ? "UTC" : timezone.getId().     StringBuilder builder = new StringBuilder().append('<').append(indexNamePrefix).append('{').append(formatter.format(dateTime)).append("||/").append(dateRounding).append('{').append(indexNameFormat).append('|').append(zone).append('}').append('}').append('>').     String dynamicIndexName = builder.toString().     ingestDocument.setFieldValue(IngestDocument.MetaData.INDEX.getFieldName(), dynamicIndexName).     return ingestDocument. }
false;public;0;4;;@Override public String getType() {     return TYPE. }
false;;0;3;;String getField() {     return field. }
false;;0;3;;TemplateScript.Factory getIndexNamePrefixTemplate() {     return indexNamePrefixTemplate. }
false;;0;3;;TemplateScript.Factory getDateRoundingTemplate() {     return dateRoundingTemplate. }
false;;0;3;;TemplateScript.Factory getIndexNameFormatTemplate() {     return indexNameFormatTemplate. }
false;;0;3;;ZoneId getTimezone() {     return timezone. }
false;;0;3;;List<Function<String, ZonedDateTime>> getDateFormats() {     return dateFormats. }
false;public;3;37;;@Override public DateIndexNameProcessor create(Map<String, Processor.Factory> registry, String tag, Map<String, Object> config) throws Exception {     String localeString = ConfigurationUtils.readOptionalStringProperty(TYPE, tag, config, "locale").     String timezoneString = ConfigurationUtils.readOptionalStringProperty(TYPE, tag, config, "timezone").     ZoneId timezone = timezoneString == null ? ZoneOffset.UTC : ZoneId.of(timezoneString).     Locale locale = Locale.ENGLISH.     if (localeString != null) {         try {             locale = (new Locale.Builder()).setLanguageTag(localeString).build().         } catch (IllformedLocaleException e) {             throw new IllegalArgumentException("Invalid language tag specified: " + localeString).         }     }     List<String> dateFormatStrings = ConfigurationUtils.readOptionalList(TYPE, tag, config, "date_formats").     if (dateFormatStrings == null) {         dateFormatStrings = Collections.singletonList("yyyy-MM-dd'T'HH:mm:ss.SSSXX").     }     List<Function<String, ZonedDateTime>> dateFormats = new ArrayList<>(dateFormatStrings.size()).     for (String format : dateFormatStrings) {         DateFormat dateFormat = DateFormat.fromString(format).         dateFormats.add(dateFormat.getFunction(format, timezone, locale)).     }     String field = ConfigurationUtils.readStringProperty(TYPE, tag, config, "field").     String indexNamePrefix = ConfigurationUtils.readStringProperty(TYPE, tag, config, "index_name_prefix", "").     TemplateScript.Factory indexNamePrefixTemplate = ConfigurationUtils.compileTemplate(TYPE, tag, "index_name_prefix", indexNamePrefix, scriptService).     String dateRounding = ConfigurationUtils.readStringProperty(TYPE, tag, config, "date_rounding").     TemplateScript.Factory dateRoundingTemplate = ConfigurationUtils.compileTemplate(TYPE, tag, "date_rounding", dateRounding, scriptService).     String indexNameFormat = ConfigurationUtils.readStringProperty(TYPE, tag, config, "index_name_format", "yyyy-MM-dd").     TemplateScript.Factory indexNameFormatTemplate = ConfigurationUtils.compileTemplate(TYPE, tag, "index_name_format", indexNameFormat, scriptService).     return new DateIndexNameProcessor(tag, field, dateFormats, timezone, indexNamePrefixTemplate, dateRoundingTemplate, indexNameFormatTemplate). }
