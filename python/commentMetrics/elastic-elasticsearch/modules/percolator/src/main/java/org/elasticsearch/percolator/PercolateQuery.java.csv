commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public Query rewrite(IndexReader reader) throws IOException {     Query rewritten = candidateMatchesQuery.rewrite(reader).     if (rewritten != candidateMatchesQuery) {         return new PercolateQuery(name, queryStore, documents, rewritten, percolatorIndexSearcher, nonNestedDocsFilter, verifiedMatchesQuery).     } else {         return this.     } }
false;public;1;3;;@Override public void extractTerms(Set<Term> set) { }
false;public;2;21;;@Override public Explanation explain(LeafReaderContext leafReaderContext, int docId) throws IOException {     Scorer scorer = scorer(leafReaderContext).     if (scorer != null) {         TwoPhaseIterator twoPhaseIterator = scorer.twoPhaseIterator().         int result = twoPhaseIterator.approximation().advance(docId).         if (result == docId) {             if (twoPhaseIterator.matches()) {                 if (scoreMode.needsScores()) {                     CheckedFunction<Integer, Query, IOException> percolatorQueries = queryStore.getQueries(leafReaderContext).                     Query query = percolatorQueries.apply(docId).                     Explanation detail = percolatorIndexSearcher.explain(query, 0).                     return Explanation.match(scorer.score(), "PercolateQuery", detail).                 } else {                     return Explanation.match(scorer.score(), "PercolateQuery").                 }             }         }     }     return Explanation.noMatch("PercolateQuery"). }
false;public;0;4;;@Override public float score() throws IOException {     return 0f. }
false;;1;21;;boolean matchDocId(int docId) throws IOException {     // the MemoryIndex verification.     if (verifiedDocsBits.get(docId)) {         return true.     }     Query query = percolatorQueries.apply(docId).     if (query == null) {         return false.     }     if (nonNestedDocsFilter != null) {         query = new BooleanQuery.Builder().add(query, Occur.MUST).add(nonNestedDocsFilter, Occur.FILTER).build().     }     return Lucene.exists(percolatorIndexSearcher, query). }
false;;1;21;;@Override boolean matchDocId(int docId) throws IOException {     Query query = percolatorQueries.apply(docId).     if (query != null) {         if (nonNestedDocsFilter != null) {             query = new BooleanQuery.Builder().add(query, Occur.MUST).add(nonNestedDocsFilter, Occur.FILTER).build().         }         TopDocs topDocs = percolatorIndexSearcher.search(query, 1).         if (topDocs.scoreDocs.length > 0) {             score = topDocs.scoreDocs[0].score.             return true.         } else {             return false.         }     } else {         return false.     } }
false;public;0;4;;@Override public float score() throws IOException {     return score. }
false;public;1;74;;@Override public Scorer scorer(LeafReaderContext leafReaderContext) throws IOException {     final Scorer approximation = candidateMatchesWeight.scorer(leafReaderContext).     if (approximation == null) {         return null.     }     final CheckedFunction<Integer, Query, IOException> percolatorQueries = queryStore.getQueries(leafReaderContext).     if (scoreMode.needsScores()) {         return new BaseScorer(this, approximation) {              float score.              @Override             boolean matchDocId(int docId) throws IOException {                 Query query = percolatorQueries.apply(docId).                 if (query != null) {                     if (nonNestedDocsFilter != null) {                         query = new BooleanQuery.Builder().add(query, Occur.MUST).add(nonNestedDocsFilter, Occur.FILTER).build().                     }                     TopDocs topDocs = percolatorIndexSearcher.search(query, 1).                     if (topDocs.scoreDocs.length > 0) {                         score = topDocs.scoreDocs[0].score.                         return true.                     } else {                         return false.                     }                 } else {                     return false.                 }             }              @Override             public float score() throws IOException {                 return score.             }         }.     } else {         ScorerSupplier verifiedDocsScorer = verifiedMatchesWeight.scorerSupplier(leafReaderContext).         Bits verifiedDocsBits = Lucene.asSequentialAccessBits(leafReaderContext.reader().maxDoc(), verifiedDocsScorer).         return new BaseScorer(this, approximation) {              @Override             public float score() throws IOException {                 return 0f.             }              boolean matchDocId(int docId) throws IOException {                 // the MemoryIndex verification.                 if (verifiedDocsBits.get(docId)) {                     return true.                 }                 Query query = percolatorQueries.apply(docId).                 if (query == null) {                     return false.                 }                 if (nonNestedDocsFilter != null) {                     query = new BooleanQuery.Builder().add(query, Occur.MUST).add(nonNestedDocsFilter, Occur.FILTER).build().                 }                 return Lucene.exists(percolatorIndexSearcher, query).             }         }.     } }
false;public;1;6;;@Override public boolean isCacheable(LeafReaderContext ctx) {     // cache it or compound queries that wrap it.     return false. }
false;public;3;114;;@Override public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {     final Weight verifiedMatchesWeight = verifiedMatchesQuery.createWeight(searcher, ScoreMode.COMPLETE_NO_SCORES, boost).     final Weight candidateMatchesWeight = candidateMatchesQuery.createWeight(searcher, ScoreMode.COMPLETE_NO_SCORES, boost).     return new Weight(this) {          @Override         public void extractTerms(Set<Term> set) {         }          @Override         public Explanation explain(LeafReaderContext leafReaderContext, int docId) throws IOException {             Scorer scorer = scorer(leafReaderContext).             if (scorer != null) {                 TwoPhaseIterator twoPhaseIterator = scorer.twoPhaseIterator().                 int result = twoPhaseIterator.approximation().advance(docId).                 if (result == docId) {                     if (twoPhaseIterator.matches()) {                         if (scoreMode.needsScores()) {                             CheckedFunction<Integer, Query, IOException> percolatorQueries = queryStore.getQueries(leafReaderContext).                             Query query = percolatorQueries.apply(docId).                             Explanation detail = percolatorIndexSearcher.explain(query, 0).                             return Explanation.match(scorer.score(), "PercolateQuery", detail).                         } else {                             return Explanation.match(scorer.score(), "PercolateQuery").                         }                     }                 }             }             return Explanation.noMatch("PercolateQuery").         }          @Override         public Scorer scorer(LeafReaderContext leafReaderContext) throws IOException {             final Scorer approximation = candidateMatchesWeight.scorer(leafReaderContext).             if (approximation == null) {                 return null.             }             final CheckedFunction<Integer, Query, IOException> percolatorQueries = queryStore.getQueries(leafReaderContext).             if (scoreMode.needsScores()) {                 return new BaseScorer(this, approximation) {                      float score.                      @Override                     boolean matchDocId(int docId) throws IOException {                         Query query = percolatorQueries.apply(docId).                         if (query != null) {                             if (nonNestedDocsFilter != null) {                                 query = new BooleanQuery.Builder().add(query, Occur.MUST).add(nonNestedDocsFilter, Occur.FILTER).build().                             }                             TopDocs topDocs = percolatorIndexSearcher.search(query, 1).                             if (topDocs.scoreDocs.length > 0) {                                 score = topDocs.scoreDocs[0].score.                                 return true.                             } else {                                 return false.                             }                         } else {                             return false.                         }                     }                      @Override                     public float score() throws IOException {                         return score.                     }                 }.             } else {                 ScorerSupplier verifiedDocsScorer = verifiedMatchesWeight.scorerSupplier(leafReaderContext).                 Bits verifiedDocsBits = Lucene.asSequentialAccessBits(leafReaderContext.reader().maxDoc(), verifiedDocsScorer).                 return new BaseScorer(this, approximation) {                      @Override                     public float score() throws IOException {                         return 0f.                     }                      boolean matchDocId(int docId) throws IOException {                         // the MemoryIndex verification.                         if (verifiedDocsBits.get(docId)) {                             return true.                         }                         Query query = percolatorQueries.apply(docId).                         if (query == null) {                             return false.                         }                         if (nonNestedDocsFilter != null) {                             query = new BooleanQuery.Builder().add(query, Occur.MUST).add(nonNestedDocsFilter, Occur.FILTER).build().                         }                         return Lucene.exists(percolatorIndexSearcher, query).                     }                 }.             }         }          @Override         public boolean isCacheable(LeafReaderContext ctx) {             // cache it or compound queries that wrap it.             return false.         }     }. }
false;;0;3;;String getName() {     return name. }
false;;0;3;;IndexSearcher getPercolatorIndexSearcher() {     return percolatorIndexSearcher. }
false;;0;3;;boolean excludesNestedDocs() {     return nonNestedDocsFilter != null. }
false;;0;3;;List<BytesReference> getDocuments() {     return documents. }
false;;0;3;;QueryStore getQueryStore() {     return queryStore. }
false;;0;3;;Query getCandidateMatchesQuery() {     return candidateMatchesQuery. }
false;;0;3;;Query getVerifiedMatchesQuery() {     return verifiedMatchesQuery. }
true;public;1;4;// this risk neglectable. ;// Comparing identity here to avoid being cached // Note that in theory if the same instance gets used multiple times it could still get cached, // however since we create a new query instance each time we this query this shouldn't happen and thus // this risk neglectable. @Override public boolean equals(Object o) {     return this == o. }
true;public;0;4;// Computing hashcode based on identity to avoid caching. ;// Computing hashcode based on identity to avoid caching. @Override public int hashCode() {     return System.identityHashCode(this). }
false;public;1;10;;@Override public String toString(String s) {     StringBuilder sources = new StringBuilder().     for (BytesReference document : documents) {         sources.append(document.utf8ToString()).         sources.append('\n').     }     return "PercolateQuery{document_sources={" + sources + "},inner={" + candidateMatchesQuery.toString(s) + "}}". }
false;public;0;8;;@Override public long ramBytesUsed() {     long ramUsed = 0L.     for (BytesReference document : documents) {         ramUsed += document.ramBytesUsed().     }     return ramUsed. }
false;;1;1;;CheckedFunction<Integer, Query, IOException> getQueries(LeafReaderContext ctx) throws IOException.
false;public,final;0;4;;@Override public final DocIdSetIterator iterator() {     return TwoPhaseIterator.asDocIdSetIterator(twoPhaseIterator()). }
false;public;0;4;;@Override public boolean matches() throws IOException {     return matchDocId(approximation.docID()). }
false;public;0;4;;@Override public float matchCost() {     return MATCH_COST. }
false;public,final;0;14;;@Override public final TwoPhaseIterator twoPhaseIterator() {     return new TwoPhaseIterator(approximation.iterator()) {          @Override         public boolean matches() throws IOException {             return matchDocId(approximation.docID()).         }          @Override         public float matchCost() {             return MATCH_COST.         }     }. }
false;public,final;0;4;;@Override public final int docID() {     return approximation.docID(). }
false;abstract;1;1;;abstract boolean matchDocId(int docId) throws IOException.
false;public;1;4;;@Override public float getMaxScore(int upTo) throws IOException {     return Float.MAX_VALUE. }
