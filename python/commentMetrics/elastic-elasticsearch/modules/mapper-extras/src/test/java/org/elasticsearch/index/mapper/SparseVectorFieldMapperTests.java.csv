commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Before public void setup() throws Exception {     IndexService indexService = createIndex("test-index").     DocumentMapperParser parser = indexService.mapperService().documentMapperParser().     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("_doc").startObject("properties").startObject("my-sparse-vector").field("type", "sparse_vector").endObject().endObject().endObject().endObject()).     mapper = parser.parse("_doc", new CompressedXContent(mapping)). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return pluginList(MapperExtrasPlugin.class). }
false;public;0;37;;public void testDefaults() throws Exception {     int[] indexedDims = { 65535, 50, 2 }.     float[] indexedValues = { 0.5f, 1800f, -34567.11f }.     ParsedDocument doc1 = mapper.parse(new SourceToParse("test-index", "_doc", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("my-sparse-vector").field(Integer.toString(indexedDims[0]), indexedValues[0]).field(Integer.toString(indexedDims[1]), indexedValues[1]).field(Integer.toString(indexedDims[2]), indexedValues[2]).endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc1.rootDoc().getFields("my-sparse-vector").     assertEquals(1, fields.length).     assertThat(fields[0], Matchers.instanceOf(BinaryDocValuesField.class)).     // assert that after decoding the indexed values are equal to expected     // the same as indexed but sorted     int[] expectedDims = { 2, 50, 65535 }.     // the same as indexed but sorted by their dimensions     float[] expectedValues = { -34567.11f, 1800f, 0.5f }.     // assert that after decoding the indexed dims and values are equal to expected     BytesRef vectorBR = ((BinaryDocValuesField) fields[0]).binaryValue().     int[] decodedDims = VectorEncoderDecoder.decodeSparseVectorDims(vectorBR).     assertArrayEquals("Decoded sparse vector dimensions are not equal to the indexed ones.", expectedDims, decodedDims).     float[] decodedValues = VectorEncoderDecoder.decodeSparseVector(vectorBR).     assertArrayEquals("Decoded sparse vector values are not equal to the indexed ones.", expectedValues, decodedValues, 0.001f). }
false;public;0;61;;public void testErrors() {     // 1. test for an error on negative dimension     MapperParsingException e = expectThrows(MapperParsingException.class, () -> {         mapper.parse(new SourceToParse("test-index", "_doc", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("my-sparse-vector").field(Integer.toString(-50), 100f).endObject().endObject()), XContentType.JSON)).     }).     assertThat(e.getCause(), instanceOf(IllegalArgumentException.class)).     assertThat(e.getCause().getMessage(), containsString("dimension number must be a non-negative integer value not exceeding [65535], got [-50]")).     // 2. test for an error on a dimension greater than MAX_DIMS_NUMBER     e = expectThrows(MapperParsingException.class, () -> {         mapper.parse(new SourceToParse("test-index", "_doc", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("my-sparse-vector").field(Integer.toString(70000), 100f).endObject().endObject()), XContentType.JSON)).     }).     assertThat(e.getCause(), instanceOf(IllegalArgumentException.class)).     assertThat(e.getCause().getMessage(), containsString("dimension number must be a non-negative integer value not exceeding [65535], got [70000]")).     // 3. test for an error on a wrong formatted dimension     e = expectThrows(MapperParsingException.class, () -> {         mapper.parse(new SourceToParse("test-index", "_doc", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("my-sparse-vector").field("WrongDim123", 100f).endObject().endObject()), XContentType.JSON)).     }).     assertThat(e.getCause(), instanceOf(IllegalArgumentException.class)).     assertThat(e.getCause().getMessage(), containsString("dimensions should be integers represented as strings, but got [WrongDim123]")).     // 4. test for an error on a wrong format for the map of dims to values     e = expectThrows(MapperParsingException.class, () -> {         mapper.parse(new SourceToParse("test-index", "_doc", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("my-sparse-vector").startArray(Integer.toString(10)).value(10f).value(100f).endArray().endObject().endObject()), XContentType.JSON)).     }).     assertThat(e.getCause(), instanceOf(IllegalArgumentException.class)).     assertThat(e.getCause().getMessage(), containsString("takes an object that maps a dimension number to a float, but got unexpected token [START_ARRAY]")). }
