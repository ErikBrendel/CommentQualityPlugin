commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;7;;@Override protected void initializeAdditionalMappings(MapperService mapperService) throws IOException {     mapperService.merge("_doc", new CompressedXContent(Strings.toString(PutMappingRequest.buildFromSimplifiedDef("_doc", "my_feature_field", "type=rank_feature", "my_negative_feature_field", "type=rank_feature,positive_score_impact=false", "my_feature_vector_field", "type=rank_features"))), MapperService.MergeReason.MAPPING_UPDATE). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return Collections.singleton(MapperExtrasPlugin.class). }
false;protected;0;33;;@Override protected RankFeatureQueryBuilder doCreateTestQueryBuilder() {     ScoreFunction function.     boolean mayUseNegativeField = true.     switch(random().nextInt(3)) {         case 0:             mayUseNegativeField = false.             function = new ScoreFunction.Log(1 + randomFloat()).             break.         case 1:             if (randomBoolean()) {                 function = new ScoreFunction.Saturation().             } else {                 function = new ScoreFunction.Saturation(randomFloat()).             }             break.         case 2:             function = new ScoreFunction.Sigmoid(randomFloat(), randomFloat()).             break.         default:             throw new AssertionError().     }     List<String> fields = new ArrayList<>().     fields.add("my_feature_field").     fields.add("unmapped_field").     fields.add("my_feature_vector_field.feature").     if (mayUseNegativeField) {         fields.add("my_negative_feature_field").     }     final String field = randomFrom(fields).     return new RankFeatureQueryBuilder(field, function). }
false;protected;3;5;;@Override protected void doAssertLuceneQuery(RankFeatureQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     Class<?> expectedClass = FeatureField.newSaturationQuery("", "", 1, 1).getClass().     assertThat(query, either(instanceOf(MatchNoDocsQuery.class)).or(instanceOf(expectedClass))). }
false;public;0;9;;public void testDefaultScoreFunction() throws IOException {     String query = "{\n" + "    \"rank_feature\" : {\n" + "        \"field\": \"my_feature_field\"\n" + "    }\n" + "}".     Query parsedQuery = parseQuery(query).toQuery(createShardContext()).     assertEquals(FeatureField.newSaturationQuery("_feature", "my_feature_field"), parsedQuery). }
false;public;0;10;;public void testIllegalField() throws IOException {     String query = "{\n" + "    \"rank_feature\" : {\n" + "        \"field\": \"" + STRING_FIELD_NAME + "\"\n" + "    }\n" + "}".     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> parseQuery(query).toQuery(createShardContext())).     assertEquals("[rank_feature] query only works on [rank_feature] fields and features of [rank_features] fields, not [text]", e.getMessage()). }
false;public;0;14;;public void testIllegalCombination() throws IOException {     String query = "{\n" + "    \"rank_feature\" : {\n" + "        \"field\": \"my_negative_feature_field\",\n" + "        \"log\" : {\n" + "            \"scaling_factor\": 4.5\n" + "        }\n" + "    }\n" + "}".     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> parseQuery(query).toQuery(createShardContext())).     assertEquals("Cannot use the [log] function with a field that has a negative score impact as it would trigger negative scores", e.getMessage()). }
