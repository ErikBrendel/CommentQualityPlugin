commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SparseVectorFieldType fieldType() {     return (SparseVectorFieldType) super.fieldType(). }
false;public;1;7;;@Override public SparseVectorFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new SparseVectorFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;5;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     SparseVectorFieldMapper.Builder builder = new SparseVectorFieldMapper.Builder(name).     return builder. }
false;public;0;3;;public SparseVectorFieldType clone() {     return new SparseVectorFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;2;5;;@Override public DocValueFormat docValueFormat(String format, ZoneId timeZone) {     throw new UnsupportedOperationException("Field [" + name() + "] of type [" + typeName() + "] doesn't support docvalue_fields or aggregations"). }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new DocValuesFieldExistsQuery(name()). }
false;public;1;4;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     return new VectorDVIndexFieldData.Builder(false). }
false;public;2;5;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new UnsupportedOperationException("Field [" + name() + "] of type [" + typeName() + "] doesn't support queries"). }
false;protected;0;4;;@Override protected SparseVectorFieldMapper clone() {     return (SparseVectorFieldMapper) super.clone(). }
false;public;0;4;;@Override public SparseVectorFieldType fieldType() {     return (SparseVectorFieldType) super.fieldType(). }
false;public;1;46;;@Override public void parse(ParseContext context) throws IOException {     if (context.externalValueSet()) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] can't be used in multi-fields").     }     ensureExpectedToken(Token.START_OBJECT, context.parser().currentToken(), context.parser()::getTokenLocation).     int[] dims = new int[0].     float[] values = new float[0].     int dimCount = 0.     int dim = 0.     float value.     for (Token token = context.parser().nextToken(). token != Token.END_OBJECT. token = context.parser().nextToken()) {         if (token == Token.FIELD_NAME) {             try {                 dim = Integer.parseInt(context.parser().currentName()).                 if (dim < 0 || dim > MAX_DIMS_NUMBER) {                     throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "]'s dimension number " + "must be a non-negative integer value not exceeding [" + MAX_DIMS_NUMBER + "], got [" + dim + "]").                 }             } catch (NumberFormatException e) {                 throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "]'s dimensions should be " + "integers represented as strings, but got [" + context.parser().currentName() + "]", e).             }         } else if (token == Token.VALUE_NUMBER) {             value = context.parser().floatValue(true).             if (dims.length <= dimCount) {                 // ensure arrays have enough capacity                 values = ArrayUtil.grow(values, dimCount + 1).                 dims = ArrayUtil.grow(dims, dimCount + 1).             }             dims[dimCount] = dim.             values[dimCount] = value.             dimCount++.             if (dimCount >= MAX_DIMS_COUNT) {                 throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] has exceeded the maximum allowed number of dimensions of :[" + MAX_DIMS_COUNT + "]").             }         } else {             throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] takes an object that maps a dimension number to a float, " + "but got unexpected token [" + token + "]").         }     }     BytesRef br = VectorEncoderDecoder.encodeSparseVector(dims, values, dimCount).     BinaryDocValuesField field = new BinaryDocValuesField(fieldType().name(), br).     context.doc().addWithKey(fieldType().name(), field). }
false;protected;2;4;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) {     throw new AssertionError("parse is implemented directly"). }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
