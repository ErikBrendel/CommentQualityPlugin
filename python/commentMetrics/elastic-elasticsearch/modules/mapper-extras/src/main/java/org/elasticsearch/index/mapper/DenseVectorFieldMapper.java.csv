commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public DenseVectorFieldType fieldType() {     return (DenseVectorFieldType) super.fieldType(). }
false;public;1;7;;@Override public DenseVectorFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new DenseVectorFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;5;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     DenseVectorFieldMapper.Builder builder = new DenseVectorFieldMapper.Builder(name).     return builder. }
false;public;0;3;;public DenseVectorFieldType clone() {     return new DenseVectorFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;2;5;;@Override public DocValueFormat docValueFormat(String format, ZoneId timeZone) {     throw new UnsupportedOperationException("Field [" + name() + "] of type [" + typeName() + "] doesn't support docvalue_fields or aggregations"). }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new DocValuesFieldExistsQuery(name()). }
false;public;1;4;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     return new VectorDVIndexFieldData.Builder(true). }
false;public;2;5;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new UnsupportedOperationException("Field [" + name() + "] of type [" + typeName() + "] doesn't support queries"). }
false;protected;0;4;;@Override protected DenseVectorFieldMapper clone() {     return (DenseVectorFieldMapper) super.clone(). }
false;public;0;4;;@Override public DenseVectorFieldType fieldType() {     return (DenseVectorFieldType) super.fieldType(). }
false;public;1;36;;@Override public void parse(ParseContext context) throws IOException {     if (context.externalValueSet()) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] can't be used in multi-fields").     }     // encode array of floats as array of integers and store into buf     // this code is here and not int the VectorEncoderDecoder so not to create extra arrays     byte[] buf = new byte[0].     int offset = 0.     int dim = 0.     for (Token token = context.parser().nextToken(). token != Token.END_ARRAY. token = context.parser().nextToken()) {         ensureExpectedToken(Token.VALUE_NUMBER, token, context.parser()::getTokenLocation).         float value = context.parser().floatValue(true).         if (buf.length < (offset + INT_BYTES)) {             buf = ArrayUtil.grow(buf, (offset + INT_BYTES)).         }         int intValue = Float.floatToIntBits(value).         buf[offset] = (byte) (intValue >> 24).         buf[offset + 1] = (byte) (intValue >> 16).         buf[offset + 2] = (byte) (intValue >> 8).         buf[offset + 3] = (byte) intValue.         offset += INT_BYTES.         dim++.         if (dim >= MAX_DIMS_COUNT) {             throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] has exceeded the maximum allowed number of dimensions of :[" + MAX_DIMS_COUNT + "]").         }     }     BinaryDocValuesField field = new BinaryDocValuesField(fieldType().name(), new BytesRef(buf, 0, offset)).     if (context.doc().getByKey(fieldType().name()) != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] doesn't not support indexing multiple values for the same field in the same document").     }     context.doc().addWithKey(fieldType().name(), field). }
false;protected;2;4;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) {     throw new AssertionError("parse is implemented directly"). }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
