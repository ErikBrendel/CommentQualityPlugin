commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;6;/**  * Calculate a dot product between a query's dense vector and documents' dense vectors  *  * @param queryVector the query vector parsed as {@code List<Number>} from json  * @param dvs VectorScriptDocValues representing encoded documents' vectors  */ ;// **************FUNCTIONS FOR DENSE VECTORS /**  * Calculate a dot product between a query's dense vector and documents' dense vectors  *  * @param queryVector the query vector parsed as {@code List<Number>} from json  * @param dvs VectorScriptDocValues representing encoded documents' vectors  */ public static double dotProduct(List<Number> queryVector, VectorScriptDocValues.DenseVectorScriptDocValues dvs) {     BytesRef value = dvs.getEncodedValue().     if (value == null)         return 0.     float[] docVector = VectorEncoderDecoder.decodeDenseVector(value).     return intDotProduct(queryVector, docVector). }
false;public;1;15;;public double cosineSimilarity(VectorScriptDocValues.DenseVectorScriptDocValues dvs) {     BytesRef value = dvs.getEncodedValue().     if (value == null)         return 0.     float[] docVector = VectorEncoderDecoder.decodeDenseVector(value).     // calculate docVector magnitude     double dotProduct = 0f.     for (int dim = 0. dim < docVector.length. dim++) {         dotProduct += (double) docVector[dim] * docVector[dim].     }     final double docVectorMagnitude = Math.sqrt(dotProduct).     double docQueryDotProduct = intDotProduct(queryVector, docVector).     return docQueryDotProduct / (docVectorMagnitude * queryVectorMagnitude). }
false;private,static;2;11;;private static double intDotProduct(List<Number> v1, float[] v2) {     int dims = Math.min(v1.size(), v2.length).     double v1v2DotProduct = 0.     int dim = 0.     Iterator<Number> v1Iter = v1.iterator().     while (dim < dims) {         v1v2DotProduct += v1Iter.next().doubleValue() * v2[dim].         dim++.     }     return v1v2DotProduct. }
false;public;1;7;;public double dotProductSparse(VectorScriptDocValues.SparseVectorScriptDocValues dvs) {     BytesRef value = dvs.getEncodedValue().     if (value == null)         return 0.     int[] docDims = VectorEncoderDecoder.decodeSparseVectorDims(value).     float[] docValues = VectorEncoderDecoder.decodeSparseVector(value).     return intDotProductSparse(queryValues, queryDims, docValues, docDims). }
false;public;1;16;;public double cosineSimilaritySparse(VectorScriptDocValues.SparseVectorScriptDocValues dvs) {     BytesRef value = dvs.getEncodedValue().     if (value == null)         return 0.     int[] docDims = VectorEncoderDecoder.decodeSparseVectorDims(value).     float[] docValues = VectorEncoderDecoder.decodeSparseVector(value).     // calculate docVector magnitude     double dotProduct = 0.     for (float docValue : docValues) {         dotProduct += (double) docValue * docValue.     }     final double docVectorMagnitude = Math.sqrt(dotProduct).     double docQueryDotProduct = intDotProductSparse(queryValues, queryDims, docValues, docDims).     return docQueryDotProduct / (docVectorMagnitude * queryVectorMagnitude). }
false;private,static;4;18;;private static double intDotProductSparse(double[] v1Values, int[] v1Dims, float[] v2Values, int[] v2Dims) {     double v1v2DotProduct = 0.     int v1Index = 0.     int v2Index = 0.     // find common dimensions among vectors v1 and v2 and calculate dotProduct based on common dimensions     while (v1Index < v1Values.length && v2Index < v2Values.length) {         if (v1Dims[v1Index] == v2Dims[v2Index]) {             v1v2DotProduct += v1Values[v1Index] * v2Values[v2Index].             v1Index++.             v2Index++.         } else if (v1Dims[v1Index] > v2Dims[v2Index]) {             v2Index++.         } else {             v1Index++.         }     }     return v1v2DotProduct. }
