commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder ignoreMalformed(boolean ignoreMalformed) {     this.ignoreMalformed = ignoreMalformed.     return builder. }
false;public;1;5;;@Override public Builder indexOptions(IndexOptions indexOptions) {     throw new MapperParsingException("index_options not allowed in field [" + name + "] of type [" + builder.fieldType().typeName() + "]"). }
false;protected;1;9;;protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {     if (ignoreMalformed != null) {         return new Explicit<>(ignoreMalformed, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false).     }     return Defaults.IGNORE_MALFORMED. }
false;public;1;4;;public Builder coerce(boolean coerce) {     this.coerce = coerce.     return builder. }
false;public;1;5;;public Builder scalingFactor(double scalingFactor) {     ((ScaledFloatFieldType) fieldType).setScalingFactor(scalingFactor).     scalingFactorSet = true.     return this. }
false;protected;1;9;;protected Explicit<Boolean> coerce(BuilderContext context) {     if (coerce != null) {         return new Explicit<>(coerce, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(COERCE_SETTING.get(context.indexSettings()), false).     }     return Defaults.COERCE. }
false;public;1;9;;@Override public ScaledFloatFieldMapper build(BuilderContext context) {     if (scalingFactorSet == false) {         throw new IllegalArgumentException("Field [" + name + "] misses required parameter [scaling_factor]").     }     setupFieldType(context).     return new ScaledFloatFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;28;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(name).     TypeParsers.parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("null_value")) {             if (propNode == null) {                 throw new MapperParsingException("Property [null_value] cannot be null.").             }             builder.nullValue(ScaledFloatFieldMapper.parse(propNode)).             iterator.remove().         } else if (propName.equals("ignore_malformed")) {             builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + ".ignore_malformed")).             iterator.remove().         } else if (propName.equals("coerce")) {             builder.coerce(XContentMapValues.nodeBooleanValue(propNode, name + ".coerce")).             iterator.remove().         } else if (propName.equals("scaling_factor")) {             builder.scalingFactor(ScaledFloatFieldMapper.parse(propNode)).             iterator.remove().         }     }     return builder. }
false;public;0;3;;public double getScalingFactor() {     return scalingFactor. }
false;public;1;4;;public void setScalingFactor(double scalingFactor) {     checkIfFrozen().     this.scalingFactor = scalingFactor. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new ScaledFloatFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;2;7;;@Override public void checkCompatibility(MappedFieldType other, List<String> conflicts) {     super.checkCompatibility(other, conflicts).     if (scalingFactor != ((ScaledFloatFieldType) other).getScalingFactor()) {         conflicts.add("mapper [" + name() + "] has different [scaling_factor] values").     } }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;10;;@Override public Query termQuery(Object value, QueryShardContext context) {     failIfNotIndexed().     long scaledValue = Math.round(scale(value)).     Query query = NumberFieldMapper.NumberType.LONG.termQuery(name(), scaledValue).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;2;14;;@Override public Query termsQuery(List<?> values, QueryShardContext context) {     failIfNotIndexed().     List<Long> scaledValues = new ArrayList<>(values.size()).     for (Object value : values) {         long scaledValue = Math.round(scale(value)).         scaledValues.add(scaledValue).     }     Query query = NumberFieldMapper.NumberType.LONG.termsQuery(name(), Collections.unmodifiableList(scaledValues)).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;5;25;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {     failIfNotIndexed().     Long lo = null.     if (lowerTerm != null) {         double dValue = scale(lowerTerm).         if (includeLower == false) {             dValue = Math.nextUp(dValue).         }         lo = Math.round(Math.ceil(dValue)).     }     Long hi = null.     if (upperTerm != null) {         double dValue = scale(upperTerm).         if (includeUpper == false) {             dValue = Math.nextDown(dValue).         }         hi = Math.round(Math.floor(dValue)).     }     Query query = NumberFieldMapper.NumberType.LONG.rangeQuery(name(), lo, hi, true, true, hasDocValues()).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;5;8;;@Override public IndexFieldData<?> build(IndexSettings indexSettings, MappedFieldType fieldType, IndexFieldDataCache cache, CircuitBreakerService breakerService, MapperService mapperService) {     final IndexNumericFieldData scaledValues = (IndexNumericFieldData) new DocValuesIndexFieldData.Builder().numericType(IndexNumericFieldData.NumericType.LONG).build(indexSettings, fieldType, cache, breakerService, mapperService).     return new ScaledFloatIndexFieldData(scaledValues, scalingFactor). }
false;public;1;14;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new IndexFieldData.Builder() {          @Override         public IndexFieldData<?> build(IndexSettings indexSettings, MappedFieldType fieldType, IndexFieldDataCache cache, CircuitBreakerService breakerService, MapperService mapperService) {             final IndexNumericFieldData scaledValues = (IndexNumericFieldData) new DocValuesIndexFieldData.Builder().numericType(IndexNumericFieldData.NumericType.LONG).build(indexSettings, fieldType, cache, breakerService, mapperService).             return new ScaledFloatIndexFieldData(scaledValues, scalingFactor).         }     }. }
false;public;1;7;;@Override public Object valueForDisplay(Object value) {     if (value == null) {         return null.     }     return ((Number) value).longValue() / scalingFactor. }
false;public;2;12;;@Override public DocValueFormat docValueFormat(String format, ZoneId timeZone) {     if (timeZone != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones").     }     if (format == null) {         return DocValueFormat.RAW.     } else {         return new DocValueFormat.Decimal(format).     } }
false;public;1;7;;@Override public boolean equals(Object o) {     if (super.equals(o) == false) {         return false.     }     return scalingFactor == ((ScaledFloatFieldType) o).scalingFactor. }
false;public;0;4;;@Override public int hashCode() {     return 31 * super.hashCode() + Double.hashCode(scalingFactor). }
true;private;1;3;/**  * Parses input value and multiplies it with the scaling factor.  * Uses the round-trip of creating a {@link BigDecimal} from the stringified {@code double}  * input to ensure intuitively exact floating point operations.  * (e.g. for a scaling factor of 100, JVM behaviour results in {@code 79.99D * 100 ==> 7998.99..} compared to  * {@code scale(79.99) ==> 7999})  * @param input Input value to parse floating point num from  * @return Scaled value  */ ;/**  * Parses input value and multiplies it with the scaling factor.  * Uses the round-trip of creating a {@link BigDecimal} from the stringified {@code double}  * input to ensure intuitively exact floating point operations.  * (e.g. for a scaling factor of 100, JVM behaviour results in {@code 79.99D * 100 ==> 7998.99..} compared to  * {@code scale(79.99) ==> 7999})  * @param input Input value to parse floating point num from  * @return Scaled value  */ private double scale(Object input) {     return new BigDecimal(Double.toString(parse(input))).multiply(BigDecimal.valueOf(scalingFactor)).doubleValue(). }
false;public;0;4;;@Override public ScaledFloatFieldType fieldType() {     return (ScaledFloatFieldType) super.fieldType(). }
false;protected;0;4;;@Override protected String contentType() {     return fieldType.typeName(). }
false;protected;0;4;;@Override protected ScaledFloatFieldMapper clone() {     return (ScaledFloatFieldMapper) super.clone(). }
false;protected;2;58;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     XContentParser parser = context.parser().     Object value.     Number numericValue = null.     if (context.externalValueSet()) {         value = context.externalValue().     } else if (parser.currentToken() == Token.VALUE_NULL) {         value = null.     } else if (coerce.value() && parser.currentToken() == Token.VALUE_STRING && parser.textLength() == 0) {         value = null.     } else {         try {             numericValue = parse(parser, coerce.value()).         } catch (IllegalArgumentException e) {             if (ignoreMalformed.value()) {                 return.             } else {                 throw e.             }         }         value = numericValue.     }     if (value == null) {         value = fieldType().nullValue().     }     if (value == null) {         return.     }     if (numericValue == null) {         numericValue = parse(value).     }     double doubleValue = numericValue.doubleValue().     if (Double.isFinite(doubleValue) == false) {         if (ignoreMalformed.value()) {             return.         } else {             // since we encode to a long, we have no way to carry NaNs and infinities             throw new IllegalArgumentException("[scaled_float] only supports finite values, but got [" + doubleValue + "]").         }     }     long scaledValue = Math.round(doubleValue * fieldType().getScalingFactor()).     boolean indexed = fieldType().indexOptions() != IndexOptions.NONE.     boolean docValued = fieldType().hasDocValues().     boolean stored = fieldType().stored().     fields.addAll(NumberFieldMapper.NumberType.LONG.createFields(fieldType().name(), scaledValue, indexed, docValued, stored)).     if (docValued == false && (indexed || stored)) {         createFieldNamesField(context, fields).     } }
false;protected;1;11;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     ScaledFloatFieldMapper other = (ScaledFloatFieldMapper) mergeWith.     if (other.ignoreMalformed.explicit()) {         this.ignoreMalformed = other.ignoreMalformed.     }     if (other.coerce.explicit()) {         this.coerce = other.coerce.     } }
false;protected;3;17;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     builder.field("scaling_factor", fieldType().getScalingFactor()).     if (includeDefaults || ignoreMalformed.explicit()) {         builder.field("ignore_malformed", ignoreMalformed.value()).     }     if (includeDefaults || coerce.explicit()) {         builder.field("coerce", coerce.value()).     }     if (includeDefaults || fieldType().nullValue() != null) {         builder.field("null_value", fieldType().nullValue()).     } }
false;static;1;3;;static Double parse(Object value) {     return objectToDouble(value). }
false;private,static;2;3;;private static Double parse(XContentParser parser, boolean coerce) throws IOException {     return parser.doubleValue(coerce). }
true;private,static;1;13;/**  * Converts an Object to a double by checking it against known types first  */ ;/**  * Converts an Object to a double by checking it against known types first  */ private static double objectToDouble(Object value) {     double doubleValue.     if (value instanceof Number) {         doubleValue = ((Number) value).doubleValue().     } else if (value instanceof BytesRef) {         doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString()).     } else {         doubleValue = Double.parseDouble(value.toString()).     }     return doubleValue. }
false;public;0;4;;@Override public String getFieldName() {     return scaledFieldData.getFieldName(). }
false;public;1;4;;@Override public AtomicNumericFieldData load(LeafReaderContext context) {     return new ScaledFloatLeafFieldData(scaledFieldData.load(context), scalingFactor). }
false;public;1;4;;@Override public AtomicNumericFieldData loadDirect(LeafReaderContext context) throws Exception {     return new ScaledFloatLeafFieldData(scaledFieldData.loadDirect(context), scalingFactor). }
false;public;4;5;;@Override public SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {     final XFieldComparatorSource source = new DoubleValuesComparatorSource(this, missingValue, sortMode, nested).     return new SortField(getFieldName(), source, reverse). }
false;public;0;4;;@Override public void clear() {     scaledFieldData.clear(). }
false;public;0;4;;@Override public Index index() {     return scaledFieldData.index(). }
false;public;0;7;;@Override public NumericType getNumericType() {     /**      * {@link ScaledFloatLeafFieldData#getDoubleValues()} transforms the raw long values in `scaled` floats.      */     return NumericType.DOUBLE. }
false;public;0;4;;@Override public ScriptDocValues.Doubles getScriptValues() {     return new ScriptDocValues.Doubles(getDoubleValues()). }
false;public;0;4;;@Override public SortedBinaryDocValues getBytesValues() {     return FieldData.toString(getDoubleValues()). }
false;public;0;4;;@Override public long ramBytesUsed() {     return scaledFieldData.ramBytesUsed(). }
false;public;0;4;;@Override public void close() {     scaledFieldData.close(). }
false;public;0;4;;@Override public SortedNumericDocValues getLongValues() {     return FieldData.castToLong(getDoubleValues()). }
false;public;1;4;;@Override public boolean advanceExact(int target) throws IOException {     return values.advanceExact(target). }
false;public;0;4;;@Override public double nextValue() throws IOException {     return values.nextValue() * scalingFactorInverse. }
false;public;0;4;;@Override public int docValueCount() {     return values.docValueCount(). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return singleValues.advanceExact(doc). }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return singleValues.longValue() * scalingFactorInverse. }
false;public;0;35;;@Override public SortedNumericDoubleValues getDoubleValues() {     final SortedNumericDocValues values = scaledFieldData.getLongValues().     final NumericDocValues singleValues = DocValues.unwrapSingleton(values).     if (singleValues != null) {         return FieldData.singleton(new NumericDoubleValues() {              @Override             public boolean advanceExact(int doc) throws IOException {                 return singleValues.advanceExact(doc).             }              @Override             public double doubleValue() throws IOException {                 return singleValues.longValue() * scalingFactorInverse.             }         }).     } else {         return new SortedNumericDoubleValues() {              @Override             public boolean advanceExact(int target) throws IOException {                 return values.advanceExact(target).             }              @Override             public double nextValue() throws IOException {                 return values.nextValue() * scalingFactorInverse.             }              @Override             public int docValueCount() {                 return values.docValueCount().             }         }.     } }
