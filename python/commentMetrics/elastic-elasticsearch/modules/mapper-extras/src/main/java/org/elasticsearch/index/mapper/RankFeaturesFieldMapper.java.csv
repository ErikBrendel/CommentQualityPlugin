commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public RankFeaturesFieldType fieldType() {     return (RankFeaturesFieldType) super.fieldType(). }
false;public;1;7;;@Override public RankFeaturesFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new RankFeaturesFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;5;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     RankFeaturesFieldMapper.Builder builder = new RankFeaturesFieldMapper.Builder(name).     return builder. }
false;public;0;3;;public RankFeaturesFieldType clone() {     return new RankFeaturesFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     throw new UnsupportedOperationException("[rank_features] fields do not support [exists] queries"). }
false;public;1;4;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     throw new UnsupportedOperationException("[rank_features] fields do not support sorting, scripting or aggregating"). }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new UnsupportedOperationException("Queries on [rank_features] fields are not supported"). }
false;protected;0;4;;@Override protected RankFeaturesFieldMapper clone() {     return (RankFeaturesFieldMapper) super.clone(). }
false;public;0;4;;@Override public RankFeaturesFieldType fieldType() {     return (RankFeaturesFieldType) super.fieldType(). }
false;public;1;31;;@Override public void parse(ParseContext context) throws IOException {     if (context.externalValueSet()) {         throw new IllegalArgumentException("[rank_features] fields can't be used in multi-fields").     }     if (context.parser().currentToken() != Token.START_OBJECT) {         throw new IllegalArgumentException("[rank_features] fields must be json objects, expected a START_OBJECT but got: " + context.parser().currentToken()).     }     String feature = null.     for (Token token = context.parser().nextToken(). token != Token.END_OBJECT. token = context.parser().nextToken()) {         if (token == Token.FIELD_NAME) {             feature = context.parser().currentName().         } else if (token == Token.VALUE_NULL) {         // ignore feature, this is consistent with numeric fields         } else if (token == Token.VALUE_NUMBER || token == Token.VALUE_STRING) {             final String key = name() + "." + feature.             float value = context.parser().floatValue(true).             if (context.doc().getByKey(key) != null) {                 throw new IllegalArgumentException("[rank_features] fields do not support indexing multiple values for the same " + "rank feature [" + key + "] in the same document").             }             context.doc().addWithKey(key, new FeatureField(name(), feature, value)).         } else {             throw new IllegalArgumentException("[rank_features] fields take hashes that map a feature to a strictly positive " + "float, but got unexpected token " + token).         }     } }
false;protected;2;4;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     throw new AssertionError("parse is implemented directly"). }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
