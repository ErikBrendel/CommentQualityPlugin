commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;17;;@BeforeClass public static void loadDatabaseReaders() throws IOException {     // the corresponding file appears to be still in use and Windows cannot delete it.     if (Constants.WINDOWS) {         return.     }     final Path geoIpDir = createTempDir().     final Path configDir = createTempDir().     final Path geoIpConfigDir = configDir.resolve("ingest-geoip").     Files.createDirectories(geoIpConfigDir).     copyDatabaseFiles(geoIpDir).     databaseReaders = IngestGeoIpPlugin.loadDatabaseReaders(geoIpDir, geoIpConfigDir). }
false;public,static;0;14;;@AfterClass public static void closeDatabaseReaders() throws IOException {     // the corresponding file appears to be still in use and Windows cannot delete it.     if (Constants.WINDOWS) {         return.     }     for (DatabaseReaderLazyLoader reader : databaseReaders.values()) {         reader.close().     }     databaseReaders = null. }
false;public;0;18;;public void testBuildDefaults() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     String processorTag = randomAlphaOfLength(10).     GeoIpProcessor processor = factory.create(null, processorTag, config).     assertThat(processor.getTag(), equalTo(processorTag)).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getTargetField(), equalTo("geoip")).     assertThat(processor.getDatabaseType(), equalTo("GeoLite2-City")).     assertThat(processor.getProperties(), sameInstance(GeoIpProcessor.Factory.DEFAULT_CITY_PROPERTIES)).     assertFalse(processor.isIgnoreMissing()). }
false;public;0;19;;public void testSetIgnoreMissing() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("ignore_missing", true).     String processorTag = randomAlphaOfLength(10).     GeoIpProcessor processor = factory.create(null, processorTag, config).     assertThat(processor.getTag(), equalTo(processorTag)).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getTargetField(), equalTo("geoip")).     assertThat(processor.getDatabaseType(), equalTo("GeoLite2-City")).     assertThat(processor.getProperties(), sameInstance(GeoIpProcessor.Factory.DEFAULT_CITY_PROPERTIES)).     assertTrue(processor.isIgnoreMissing()). }
false;public;0;20;;public void testCountryBuildDefaults() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-Country.mmdb").     String processorTag = randomAlphaOfLength(10).     GeoIpProcessor processor = factory.create(null, processorTag, config).     assertThat(processor.getTag(), equalTo(processorTag)).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getTargetField(), equalTo("geoip")).     assertThat(processor.getDatabaseType(), equalTo("GeoLite2-Country")).     assertThat(processor.getProperties(), sameInstance(GeoIpProcessor.Factory.DEFAULT_COUNTRY_PROPERTIES)).     assertFalse(processor.isIgnoreMissing()). }
false;public;0;20;;public void testAsnBuildDefaults() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-ASN.mmdb").     String processorTag = randomAlphaOfLength(10).     GeoIpProcessor processor = factory.create(null, processorTag, config).     assertThat(processor.getTag(), equalTo(processorTag)).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getTargetField(), equalTo("geoip")).     assertThat(processor.getDatabaseType(), equalTo("GeoLite2-ASN")).     assertThat(processor.getProperties(), sameInstance(GeoIpProcessor.Factory.DEFAULT_ASN_PROPERTIES)).     assertFalse(processor.isIgnoreMissing()). }
false;public;0;13;;public void testBuildTargetField() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("target_field", "_field").     GeoIpProcessor processor = factory.create(null, null, config).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getTargetField(), equalTo("_field")).     assertFalse(processor.isIgnoreMissing()). }
false;public;0;15;;public void testBuildDbFile() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-Country.mmdb").     GeoIpProcessor processor = factory.create(null, null, config).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getTargetField(), equalTo("geoip")).     assertThat(processor.getDatabaseType(), equalTo("GeoLite2-Country")).     assertThat(processor.getProperties(), sameInstance(GeoIpProcessor.Factory.DEFAULT_COUNTRY_PROPERTIES)).     assertFalse(processor.isIgnoreMissing()). }
false;public;0;16;;public void testBuildWithCountryDbAndAsnFields() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-Country.mmdb").     EnumSet<GeoIpProcessor.Property> asnOnlyProperties = EnumSet.copyOf(GeoIpProcessor.Property.ALL_ASN_PROPERTIES).     asnOnlyProperties.remove(GeoIpProcessor.Property.IP).     String asnProperty = RandomPicks.randomFrom(Randomness.get(), asnOnlyProperties).toString().     config.put("properties", Collections.singletonList(asnProperty)).     Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)).     assertThat(e.getMessage(), equalTo("[properties] illegal property value [" + asnProperty + "]. valid values are [IP, COUNTRY_ISO_CODE, COUNTRY_NAME, CONTINENT_NAME]")). }
false;public;0;16;;public void testBuildWithAsnDbAndCityFields() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-ASN.mmdb").     EnumSet<GeoIpProcessor.Property> cityOnlyProperties = EnumSet.copyOf(GeoIpProcessor.Property.ALL_CITY_PROPERTIES).     cityOnlyProperties.remove(GeoIpProcessor.Property.IP).     String cityProperty = RandomPicks.randomFrom(Randomness.get(), cityOnlyProperties).toString().     config.put("properties", Collections.singletonList(cityProperty)).     Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)).     assertThat(e.getMessage(), equalTo("[properties] illegal property value [" + cityProperty + "]. valid values are [IP, ASN, ORGANIZATION_NAME]")). }
false;public;0;12;;public void testBuildNonExistingDbFile() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "does-not-exist.mmdb").     Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)).     assertThat(e.getMessage(), equalTo("[database_file] database file [does-not-exist.mmdb] doesn't exist")). }
false;public;0;26;;public void testBuildFields() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Set<GeoIpProcessor.Property> properties = EnumSet.noneOf(GeoIpProcessor.Property.class).     List<String> fieldNames = new ArrayList<>().     int counter = 0.     int numFields = scaledRandomIntBetween(1, GeoIpProcessor.Property.values().length).     for (GeoIpProcessor.Property property : GeoIpProcessor.Property.ALL_CITY_PROPERTIES) {         properties.add(property).         fieldNames.add(property.name().toLowerCase(Locale.ROOT)).         if (++counter >= numFields) {             break.         }     }     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("properties", fieldNames).     GeoIpProcessor processor = factory.create(null, null, config).     assertThat(processor.getField(), equalTo("_field")).     assertThat(processor.getProperties(), equalTo(properties)).     assertFalse(processor.isIgnoreMissing()). }
false;public;0;19;;public void testBuildIllegalFieldOption() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     Map<String, Object> config1 = new HashMap<>().     config1.put("field", "_field").     config1.put("properties", Collections.singletonList("invalid")).     Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config1)).     assertThat(e.getMessage(), equalTo("[properties] illegal property value [invalid]. valid values are [IP, COUNTRY_ISO_CODE, " + "COUNTRY_NAME, CONTINENT_NAME, REGION_ISO_CODE, REGION_NAME, CITY_NAME, TIMEZONE, LOCATION]")).     Map<String, Object> config2 = new HashMap<>().     config2.put("field", "_field").     config2.put("properties", "invalid").     e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config2)).     assertThat(e.getMessage(), equalTo("[properties] property isn't a list, but of type [java.lang.String]")). }
false;public;0;55;;public void testLazyLoading() throws Exception {     // This test uses a MappedByteBuffer which will keep the file mappings active until it is garbage-collected.     // As a consequence, the corresponding file appears to be still in use and Windows cannot delete it.     assumeFalse("windows deletion behavior is asinine", Constants.WINDOWS).     final Path geoIpDir = createTempDir().     final Path configDir = createTempDir().     final Path geoIpConfigDir = configDir.resolve("ingest-geoip").     Files.createDirectories(geoIpConfigDir).     copyDatabaseFiles(geoIpDir).     // Loading another database reader instances, because otherwise we can't test lazy loading as the     // database readers used at class level are reused between tests. (we want to keep that otherwise running this     // test will take roughly 4 times more time)     Map<String, DatabaseReaderLazyLoader> databaseReaders = IngestGeoIpPlugin.loadDatabaseReaders(geoIpDir, geoIpConfigDir).     GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     for (DatabaseReaderLazyLoader lazyLoader : databaseReaders.values()) {         assertNull(lazyLoader.databaseReader.get()).     }     final Map<String, Object> field = Collections.singletonMap("_field", "1.1.1.1").     final IngestDocument document = new IngestDocument("index", "type", "id", "routing", 1L, VersionType.EXTERNAL, field).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-City.mmdb").     final GeoIpProcessor city = factory.create(null, "_tag", config).     // these are lazy loaded until first use so we expect null here     assertNull(databaseReaders.get("GeoLite2-City.mmdb").databaseReader.get()).     city.execute(document).     // the first ingest should trigger a database load     assertNotNull(databaseReaders.get("GeoLite2-City.mmdb").databaseReader.get()).     config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-Country.mmdb").     final GeoIpProcessor country = factory.create(null, "_tag", config).     // these are lazy loaded until first use so we expect null here     assertNull(databaseReaders.get("GeoLite2-Country.mmdb").databaseReader.get()).     country.execute(document).     // the first ingest should trigger a database load     assertNotNull(databaseReaders.get("GeoLite2-Country.mmdb").databaseReader.get()).     config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoLite2-ASN.mmdb").     final GeoIpProcessor asn = factory.create(null, "_tag", config).     // these are lazy loaded until first use so we expect null here     assertNull(databaseReaders.get("GeoLite2-ASN.mmdb").databaseReader.get()).     asn.execute(document).     // the first ingest should trigger a database load     assertNotNull(databaseReaders.get("GeoLite2-ASN.mmdb").databaseReader.get()). }
false;public;0;34;;public void testLoadingCustomDatabase() throws IOException {     final Path geoIpDir = createTempDir().     final Path configDir = createTempDir().     final Path geoIpConfigDir = configDir.resolve("ingest-geoip").     Files.createDirectories(geoIpConfigDir).     copyDatabaseFiles(geoIpDir).     // fake the GeoIP2-City database     copyDatabaseFile(geoIpConfigDir, "GeoLite2-City.mmdb").     Files.move(geoIpConfigDir.resolve("GeoLite2-City.mmdb"), geoIpConfigDir.resolve("GeoIP2-City.mmdb")).     /*          * Loading another database reader instances, because otherwise we can't test lazy loading as the database readers used at class          * level are reused between tests. (we want to keep that otherwise running this test will take roughly 4 times more time).          */     final Map<String, DatabaseReaderLazyLoader> databaseReaders = IngestGeoIpPlugin.loadDatabaseReaders(geoIpDir, geoIpConfigDir).     final GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)).     for (DatabaseReaderLazyLoader lazyLoader : databaseReaders.values()) {         assertNull(lazyLoader.databaseReader.get()).     }     final Map<String, Object> field = Collections.singletonMap("_field", "1.1.1.1").     final IngestDocument document = new IngestDocument("index", "type", "id", "routing", 1L, VersionType.EXTERNAL, field).     Map<String, Object> config = new HashMap<>().     config.put("field", "_field").     config.put("database_file", "GeoIP2-City.mmdb").     final GeoIpProcessor city = factory.create(null, "_tag", config).     // these are lazy loaded until first use so we expect null here     assertNull(databaseReaders.get("GeoIP2-City.mmdb").databaseReader.get()).     city.execute(document).     // the first ingest should trigger a database load     assertNotNull(databaseReaders.get("GeoIP2-City.mmdb").databaseReader.get()). }
false;public;0;14;;public void testDatabaseNotExistsInDir() throws IOException {     final Path geoIpDir = createTempDir().     final Path configDir = createTempDir().     final Path geoIpConfigDir = configDir.resolve("ingest-geoip").     if (randomBoolean()) {         Files.createDirectories(geoIpConfigDir).     }     copyDatabaseFiles(geoIpDir).     final String databaseFilename = randomFrom(IngestGeoIpPlugin.DEFAULT_DATABASE_FILENAMES).     Files.delete(geoIpDir.resolve(databaseFilename)).     final IOException e = expectThrows(IOException.class, () -> IngestGeoIpPlugin.loadDatabaseReaders(geoIpDir, geoIpConfigDir)).     assertThat(e, hasToString(containsString("expected database [" + databaseFilename + "] to exist in [" + geoIpDir + "]"))). }
false;public;0;12;;public void testDatabaseExistsInConfigDir() throws IOException {     final Path geoIpDir = createTempDir().     final Path configDir = createTempDir().     final Path geoIpConfigDir = configDir.resolve("ingest-geoip").     Files.createDirectories(geoIpConfigDir).     copyDatabaseFiles(geoIpDir).     final String databaseFilename = randomFrom(IngestGeoIpPlugin.DEFAULT_DATABASE_FILENAMES).     copyDatabaseFile(geoIpConfigDir, databaseFilename).     final IOException e = expectThrows(IOException.class, () -> IngestGeoIpPlugin.loadDatabaseReaders(geoIpDir, geoIpConfigDir)).     assertThat(e, hasToString(containsString("expected database [" + databaseFilename + "] to not exist in [" + geoIpConfigDir + "]"))). }
false;private,static;2;5;;private static void copyDatabaseFile(final Path path, final String databaseFilename) throws IOException {     Files.copy(new ByteArrayInputStream(StreamsUtils.copyToBytesFromClasspath("/" + databaseFilename)), path.resolve(databaseFilename)). }
false;private,static;1;5;;private static void copyDatabaseFiles(final Path path) throws IOException {     for (final String databaseFilename : IngestGeoIpPlugin.DEFAULT_DATABASE_FILENAMES) {         copyDatabaseFile(path, databaseFilename).     } }
