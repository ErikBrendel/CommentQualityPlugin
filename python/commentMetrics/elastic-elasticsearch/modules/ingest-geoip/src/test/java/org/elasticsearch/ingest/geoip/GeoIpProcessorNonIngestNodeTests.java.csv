commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<Setting<?>> getSettings() {     return Collections.singletonList(Setting.simpleString("ingest.geoip.database_path", Setting.Property.NodeScope)). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(IngestGeoIpPlugin.class, IngestGeoIpSettingsPlugin.class). }
false;protected;1;23;;@Override protected Settings nodeSettings(final int nodeOrdinal) {     final Path databasePath = createTempDir().     try {         Files.createDirectories(databasePath).         Files.copy(new ByteArrayInputStream(StreamsUtils.copyToBytesFromClasspath("/GeoLite2-City.mmdb")), databasePath.resolve("GeoLite2-City.mmdb")).         Files.copy(new ByteArrayInputStream(StreamsUtils.copyToBytesFromClasspath("/GeoLite2-Country.mmdb")), databasePath.resolve("GeoLite2-Country.mmdb")).         Files.copy(new ByteArrayInputStream(StreamsUtils.copyToBytesFromClasspath("/GeoLite2-ASN.mmdb")), databasePath.resolve("GeoLite2-ASN.mmdb")).     } catch (final IOException e) {         throw new UncheckedIOException(e).     }     return Settings.builder().put("ingest.geoip.database_path", databasePath).put("node.ingest", false).put(super.nodeSettings(nodeOrdinal)).build(). }
true;public;0;69;/**  * This test shows that we do not load the geo-IP databases on non-ingest nodes, and only load on ingest nodes on first use.  *  * @throws IOException if an I/O exception occurs building the JSON  */ ;/**  * This test shows that we do not load the geo-IP databases on non-ingest nodes, and only load on ingest nodes on first use.  *  * @throws IOException if an I/O exception occurs building the JSON  */ public void testLazyLoading() throws IOException {     assumeFalse("https://github.com/elastic/elasticsearch/issues/37342", Constants.WINDOWS).     final BytesReference bytes.     try (XContentBuilder builder = JsonXContent.contentBuilder()) {         builder.startObject().         {             builder.field("description", "test").             builder.startArray("processors").             {                 builder.startObject().                 {                     builder.startObject("geoip").                     {                         builder.field("field", "ip").                         builder.field("target_field", "ip-city").                         builder.field("database_file", "GeoLite2-City.mmdb").                     }                     builder.endObject().                 }                 builder.endObject().                 builder.startObject().                 {                     builder.startObject("geoip").                     {                         builder.field("field", "ip").                         builder.field("target_field", "ip-country").                         builder.field("database_file", "GeoLite2-Country.mmdb").                     }                     builder.endObject().                 }                 builder.endObject().                 builder.startObject().                 {                     builder.startObject("geoip").                     {                         builder.field("field", "ip").                         builder.field("target_field", "ip-asn").                         builder.field("database_file", "GeoLite2-ASN.mmdb").                     }                     builder.endObject().                 }                 builder.endObject().             }             builder.endArray().         }         builder.endObject().         bytes = BytesReference.bytes(builder).     }     assertAcked(client().admin().cluster().putPipeline(new PutPipelineRequest("geoip", bytes, XContentType.JSON)).actionGet()).     // the geo-IP databases should not be loaded on any nodes as they are all non-ingest nodes     Arrays.stream(internalCluster().getNodeNames()).forEach(node -> assertDatabaseLoadStatus(node, false)).     // start an ingest node     final String ingestNode = internalCluster().startNode(Settings.builder().put("node.ingest", true).build()).     internalCluster().getInstance(IngestService.class, ingestNode).     // the geo-IP database should not be loaded yet as we have no indexed any documents using a pipeline that has a geo-IP processor     assertDatabaseLoadStatus(ingestNode, false).     final IndexRequest indexRequest = new IndexRequest("index", "_doc").     indexRequest.setPipeline("geoip").     indexRequest.source(Collections.singletonMap("ip", "1.1.1.1")).     final IndexResponse indexResponse = client().index(indexRequest).actionGet().     assertThat(indexResponse.status(), equalTo(RestStatus.CREATED)).     // now the geo-IP database should be loaded on the ingest node     assertDatabaseLoadStatus(ingestNode, true).     // the geo-IP database should still not be loaded on the non-ingest nodes     Arrays.stream(internalCluster().getNodeNames()).filter(node -> node.equals(ingestNode) == false).forEach(node -> assertDatabaseLoadStatus(node, false)). }
false;private;2;11;;private void assertDatabaseLoadStatus(final String node, final boolean loaded) {     final IngestService ingestService = internalCluster().getInstance(IngestService.class, node).     final GeoIpProcessor.Factory factory = (GeoIpProcessor.Factory) ingestService.getProcessorFactories().get("geoip").     for (final DatabaseReaderLazyLoader loader : factory.databaseReaders().values()) {         if (loaded) {             assertNotNull(loader.databaseReader.get()).         } else {             assertNull(loader.databaseReader.get()).         }     } }
