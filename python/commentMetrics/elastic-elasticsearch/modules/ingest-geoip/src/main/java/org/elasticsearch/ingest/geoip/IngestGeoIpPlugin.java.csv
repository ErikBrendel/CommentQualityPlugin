commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<Setting<?>> getSettings() {     return Arrays.asList(CACHE_SIZE). }
false;public;1;15;;@Override public Map<String, Processor.Factory> getProcessors(Processor.Parameters parameters) {     if (databaseReaders != null) {         throw new IllegalStateException("getProcessors called twice for geoip plugin!!").     }     final Path geoIpDirectory = getGeoIpDirectory(parameters).     final Path geoIpConfigDirectory = parameters.env.configFile().resolve("ingest-geoip").     long cacheSize = CACHE_SIZE.get(parameters.env.settings()).     try {         databaseReaders = loadDatabaseReaders(geoIpDirectory, geoIpConfigDirectory).     } catch (IOException e) {         throw new RuntimeException(e).     }     return Collections.singletonMap(GeoIpProcessor.TYPE, new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(cacheSize))). }
true;private;1;10;/*      * In GeoIpProcessorNonIngestNodeTests, ingest-geoip is loaded on the classpath. This means that the plugin is never unbundled into a      * directory where the database files would live. Therefore, we have to copy these database files ourselves. To do this, we need the      * ability to specify where those database files would go. We do this by adding a plugin that registers ingest.geoip.database_path as      * an actual setting. Otherwise, in production code, this setting is not registered and the database path is not configurable.      */ ;/*      * In GeoIpProcessorNonIngestNodeTests, ingest-geoip is loaded on the classpath. This means that the plugin is never unbundled into a      * directory where the database files would live. Therefore, we have to copy these database files ourselves. To do this, we need the      * ability to specify where those database files would go. We do this by adding a plugin that registers ingest.geoip.database_path as      * an actual setting. Otherwise, in production code, this setting is not registered and the database path is not configurable.      */ @SuppressForbidden(reason = "PathUtils#get") private Path getGeoIpDirectory(Processor.Parameters parameters) {     final Path geoIpDirectory.     if (parameters.env.settings().get("ingest.geoip.database_path") == null) {         geoIpDirectory = parameters.env.modulesFile().resolve("ingest-geoip").     } else {         geoIpDirectory = PathUtils.get(parameters.env.settings().get("ingest.geoip.database_path")).     }     return geoIpDirectory. }
false;static;2;31;;static Map<String, DatabaseReaderLazyLoader> loadDatabaseReaders(Path geoIpDirectory, Path geoIpConfigDirectory) throws IOException {     assertDatabaseExistence(geoIpDirectory, true).     assertDatabaseExistence(geoIpConfigDirectory, false).     final boolean loadDatabaseOnHeap = Booleans.parseBoolean(System.getProperty("es.geoip.load_db_on_heap", "false")).     final Map<String, DatabaseReaderLazyLoader> databaseReaders = new HashMap<>().     // load the default databases     for (final String databaseFilename : DEFAULT_DATABASE_FILENAMES) {         final Path databasePath = geoIpDirectory.resolve(databaseFilename).         final DatabaseReaderLazyLoader loader = createLoader(databasePath, loadDatabaseOnHeap).         databaseReaders.put(databaseFilename, loader).     }     // load any custom databases     if (Files.exists(geoIpConfigDirectory)) {         try (Stream<Path> databaseFiles = Files.list(geoIpConfigDirectory)) {             PathMatcher pathMatcher = geoIpConfigDirectory.getFileSystem().getPathMatcher("glob:**.mmdb").             // Use iterator instead of forEach otherwise IOException needs to be caught twice...             Iterator<Path> iterator = databaseFiles.iterator().             while (iterator.hasNext()) {                 Path databasePath = iterator.next().                 if (Files.isRegularFile(databasePath) && pathMatcher.matches(databasePath)) {                     String databaseFileName = databasePath.getFileName().toString().                     final DatabaseReaderLazyLoader loader = createLoader(databasePath, loadDatabaseOnHeap).                     databaseReaders.put(databaseFileName, loader).                 }             }         }     }     return Collections.unmodifiableMap(databaseReaders). }
false;private,static;2;13;;private static DatabaseReaderLazyLoader createLoader(Path databasePath, boolean loadDatabaseOnHeap) {     return new DatabaseReaderLazyLoader(databasePath, () -> {         DatabaseReader.Builder builder = createDatabaseBuilder(databasePath).withCache(NoCache.getInstance()).         if (loadDatabaseOnHeap) {             builder.fileMode(Reader.FileMode.MEMORY).         } else {             builder.fileMode(Reader.FileMode.MEMORY_MAPPED).         }         return builder.build().     }). }
false;private,static;2;8;;private static void assertDatabaseExistence(final Path path, final boolean exists) throws IOException {     for (final String database : DEFAULT_DATABASE_FILENAMES) {         if (Files.exists(path.resolve(database)) != exists) {             final String message = "expected database [" + database + "] to " + (exists ? "" : "not ") + "exist in [" + path + "]".             throw new IOException(message).         }     } }
false;private,static;1;4;;@SuppressForbidden(reason = "Maxmind API requires java.io.File") private static DatabaseReader.Builder createDatabaseBuilder(Path databasePath) {     return new DatabaseReader.Builder(databasePath.toFile()). }
false;public;0;6;;@Override public void close() throws IOException {     if (databaseReaders != null) {         IOUtils.close(databaseReaders.values()).     } }
false;;3;13;;<T extends AbstractResponse> T putIfAbsent(InetAddress ip, Class<T> responseType, Function<InetAddress, AbstractResponse> retrieveFunction) {     // can't use cache.computeIfAbsent due to the elevated permissions for the jackson (run via the cache loader)     CacheKey<T> cacheKey = new CacheKey<>(ip, responseType).     // intentionally non-locking for simplicity...it's OK if we re-put the same key/value in the cache during a race condition.     AbstractResponse response = cache.get(cacheKey).     if (response == null) {         response = retrieveFunction.apply(ip).         cache.put(cacheKey, response).     }     return responseType.cast(response). }
true;;2;4;// only useful for testing ;// only useful for testing <T extends AbstractResponse> T get(InetAddress ip, Class<T> responseType) {     CacheKey<T> cacheKey = new CacheKey<>(ip, responseType).     return responseType.cast(cache.get(cacheKey)). }
true;public;1;8;// generated ;// generated @Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     CacheKey<?> cacheKey = (CacheKey<?>) o.     return Objects.equals(ip, cacheKey.ip) && Objects.equals(responseType, cacheKey.responseType). }
true;public;0;4;// generated ;// generated @Override public int hashCode() {     return Objects.hash(ip, responseType). }
