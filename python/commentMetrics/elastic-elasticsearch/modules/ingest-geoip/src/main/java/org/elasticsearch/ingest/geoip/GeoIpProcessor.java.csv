commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;boolean isIgnoreMissing() {     return ignoreMissing. }
false;public;1;42;;@Override public IngestDocument execute(IngestDocument ingestDocument) throws IOException {     String ip = ingestDocument.getFieldValue(field, String.class, ignoreMissing).     if (ip == null && ignoreMissing) {         return ingestDocument.     } else if (ip == null) {         throw new IllegalArgumentException("field [" + field + "] is null, cannot extract geoip information.").     }     final InetAddress ipAddress = InetAddresses.forString(ip).     Map<String, Object> geoData.     String databaseType = lazyLoader.getDatabaseType().     if (databaseType.endsWith(CITY_DB_SUFFIX)) {         try {             geoData = retrieveCityGeoData(ipAddress).         } catch (AddressNotFoundRuntimeException e) {             geoData = Collections.emptyMap().         }     } else if (databaseType.endsWith(COUNTRY_DB_SUFFIX)) {         try {             geoData = retrieveCountryGeoData(ipAddress).         } catch (AddressNotFoundRuntimeException e) {             geoData = Collections.emptyMap().         }     } else if (databaseType.endsWith(ASN_DB_SUFFIX)) {         try {             geoData = retrieveAsnGeoData(ipAddress).         } catch (AddressNotFoundRuntimeException e) {             geoData = Collections.emptyMap().         }     } else {         throw new ElasticsearchParseException("Unsupported database type [" + lazyLoader.getDatabaseType() + "]", new IllegalStateException()).     }     if (geoData.isEmpty() == false) {         ingestDocument.setFieldValue(targetField, geoData).     }     return ingestDocument. }
false;public;0;4;;@Override public String getType() {     return TYPE. }
false;;0;3;;String getField() {     return field. }
false;;0;3;;String getTargetField() {     return targetField. }
false;;0;3;;String getDatabaseType() throws IOException {     return lazyLoader.getDatabaseType(). }
false;;0;3;;Set<Property> getProperties() {     return properties. }
false;private;1;85;;private Map<String, Object> retrieveCityGeoData(InetAddress ipAddress) {     SpecialPermission.check().     CityResponse response = AccessController.doPrivileged((PrivilegedAction<CityResponse>) () -> cache.putIfAbsent(ipAddress, CityResponse.class, ip -> {         try {             return lazyLoader.get().city(ip).         } catch (AddressNotFoundException e) {             throw new AddressNotFoundRuntimeException(e).         } catch (Exception e) {             throw new RuntimeException(e).         }     })).     Country country = response.getCountry().     City city = response.getCity().     Location location = response.getLocation().     Continent continent = response.getContinent().     Subdivision subdivision = response.getMostSpecificSubdivision().     Map<String, Object> geoData = new HashMap<>().     for (Property property : this.properties) {         switch(property) {             case IP:                 geoData.put("ip", NetworkAddress.format(ipAddress)).                 break.             case COUNTRY_ISO_CODE:                 String countryIsoCode = country.getIsoCode().                 if (countryIsoCode != null) {                     geoData.put("country_iso_code", countryIsoCode).                 }                 break.             case COUNTRY_NAME:                 String countryName = country.getName().                 if (countryName != null) {                     geoData.put("country_name", countryName).                 }                 break.             case CONTINENT_NAME:                 String continentName = continent.getName().                 if (continentName != null) {                     geoData.put("continent_name", continentName).                 }                 break.             case REGION_ISO_CODE:                 // ISO 3166-2 code for country subdivisions.                 // See iso.org/iso-3166-country-codes.html                 String countryIso = country.getIsoCode().                 String subdivisionIso = subdivision.getIsoCode().                 if (countryIso != null && subdivisionIso != null) {                     String regionIsoCode = countryIso + "-" + subdivisionIso.                     geoData.put("region_iso_code", regionIsoCode).                 }                 break.             case REGION_NAME:                 String subdivisionName = subdivision.getName().                 if (subdivisionName != null) {                     geoData.put("region_name", subdivisionName).                 }                 break.             case CITY_NAME:                 String cityName = city.getName().                 if (cityName != null) {                     geoData.put("city_name", cityName).                 }                 break.             case TIMEZONE:                 String locationTimeZone = location.getTimeZone().                 if (locationTimeZone != null) {                     geoData.put("timezone", locationTimeZone).                 }                 break.             case LOCATION:                 Double latitude = location.getLatitude().                 Double longitude = location.getLongitude().                 if (latitude != null && longitude != null) {                     Map<String, Object> locationObject = new HashMap<>().                     locationObject.put("lat", latitude).                     locationObject.put("lon", longitude).                     geoData.put("location", locationObject).                 }                 break.         }     }     return geoData. }
false;private;1;44;;private Map<String, Object> retrieveCountryGeoData(InetAddress ipAddress) {     SpecialPermission.check().     CountryResponse response = AccessController.doPrivileged((PrivilegedAction<CountryResponse>) () -> cache.putIfAbsent(ipAddress, CountryResponse.class, ip -> {         try {             return lazyLoader.get().country(ip).         } catch (AddressNotFoundException e) {             throw new AddressNotFoundRuntimeException(e).         } catch (Exception e) {             throw new RuntimeException(e).         }     })).     Country country = response.getCountry().     Continent continent = response.getContinent().     Map<String, Object> geoData = new HashMap<>().     for (Property property : this.properties) {         switch(property) {             case IP:                 geoData.put("ip", NetworkAddress.format(ipAddress)).                 break.             case COUNTRY_ISO_CODE:                 String countryIsoCode = country.getIsoCode().                 if (countryIsoCode != null) {                     geoData.put("country_iso_code", countryIsoCode).                 }                 break.             case COUNTRY_NAME:                 String countryName = country.getName().                 if (countryName != null) {                     geoData.put("country_name", countryName).                 }                 break.             case CONTINENT_NAME:                 String continentName = continent.getName().                 if (continentName != null) {                     geoData.put("continent_name", continentName).                 }                 break.         }     }     return geoData. }
false;private;1;36;;private Map<String, Object> retrieveAsnGeoData(InetAddress ipAddress) {     SpecialPermission.check().     AsnResponse response = AccessController.doPrivileged((PrivilegedAction<AsnResponse>) () -> cache.putIfAbsent(ipAddress, AsnResponse.class, ip -> {         try {             return lazyLoader.get().asn(ip).         } catch (AddressNotFoundException e) {             throw new AddressNotFoundRuntimeException(e).         } catch (Exception e) {             throw new RuntimeException(e).         }     })).     Integer asn = response.getAutonomousSystemNumber().     String organization_name = response.getAutonomousSystemOrganization().     Map<String, Object> geoData = new HashMap<>().     for (Property property : this.properties) {         switch(property) {             case IP:                 geoData.put("ip", NetworkAddress.format(ipAddress)).                 break.             case ASN:                 if (asn != null) {                     geoData.put("asn", asn).                 }                 break.             case ORGANIZATION_NAME:                 if (organization_name != null) {                     geoData.put("organization_name", organization_name).                 }                 break.         }     }     return geoData. }
false;;0;3;;Map<String, DatabaseReaderLazyLoader> databaseReaders() {     return Collections.unmodifiableMap(databaseReaders). }
false;public;3;45;;@Override public GeoIpProcessor create(final Map<String, Processor.Factory> registry, final String processorTag, final Map<String, Object> config) throws IOException {     String ipField = readStringProperty(TYPE, processorTag, config, "field").     String targetField = readStringProperty(TYPE, processorTag, config, "target_field", "geoip").     String databaseFile = readStringProperty(TYPE, processorTag, config, "database_file", "GeoLite2-City.mmdb").     List<String> propertyNames = readOptionalList(TYPE, processorTag, config, "properties").     boolean ignoreMissing = readBooleanProperty(TYPE, processorTag, config, "ignore_missing", false).     DatabaseReaderLazyLoader lazyLoader = databaseReaders.get(databaseFile).     if (lazyLoader == null) {         throw newConfigurationException(TYPE, processorTag, "database_file", "database file [" + databaseFile + "] doesn't exist").     }     final String databaseType = lazyLoader.getDatabaseType().     final Set<Property> properties.     if (propertyNames != null) {         Set<Property> modifiableProperties = EnumSet.noneOf(Property.class).         for (String fieldName : propertyNames) {             try {                 modifiableProperties.add(Property.parseProperty(databaseType, fieldName)).             } catch (IllegalArgumentException e) {                 throw newConfigurationException(TYPE, processorTag, "properties", e.getMessage()).             }         }         properties = Collections.unmodifiableSet(modifiableProperties).     } else {         if (databaseType.endsWith(CITY_DB_SUFFIX)) {             properties = DEFAULT_CITY_PROPERTIES.         } else if (databaseType.endsWith(COUNTRY_DB_SUFFIX)) {             properties = DEFAULT_COUNTRY_PROPERTIES.         } else if (databaseType.endsWith(ASN_DB_SUFFIX)) {             properties = DEFAULT_ASN_PROPERTIES.         } else {             throw newConfigurationException(TYPE, processorTag, "database_file", "Unsupported database type [" + databaseType + "]").         }     }     return new GeoIpProcessor(processorTag, ipField, lazyLoader, targetField, properties, ignoreMissing, cache). }
false;public,static;2;21;;public static Property parseProperty(String databaseType, String value) {     Set<Property> validProperties = EnumSet.noneOf(Property.class).     if (databaseType.endsWith(CITY_DB_SUFFIX)) {         validProperties = ALL_CITY_PROPERTIES.     } else if (databaseType.endsWith(COUNTRY_DB_SUFFIX)) {         validProperties = ALL_COUNTRY_PROPERTIES.     } else if (databaseType.endsWith(ASN_DB_SUFFIX)) {         validProperties = ALL_ASN_PROPERTIES.     }     try {         Property property = valueOf(value.toUpperCase(Locale.ROOT)).         if (validProperties.contains(property) == false) {             throw new IllegalArgumentException("invalid").         }         return property.     } catch (IllegalArgumentException e) {         throw new IllegalArgumentException("illegal property value [" + value + "]. valid values are " + Arrays.toString(validProperties.toArray())).     } }
