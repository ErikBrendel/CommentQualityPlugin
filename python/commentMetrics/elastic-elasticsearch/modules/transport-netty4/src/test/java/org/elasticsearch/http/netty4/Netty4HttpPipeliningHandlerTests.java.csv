commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@After public void tearDown() throws Exception {     waitingRequests.keySet().forEach(this::finishRequest).     shutdownExecutorService().     super.tearDown(). }
false;private;1;4;;private CountDownLatch finishRequest(String url) {     waitingRequests.get(url).countDown().     return finishingRequests.get(url). }
false;private;0;10;;private void shutdownExecutorService() throws InterruptedException {     if (!handlerService.isShutdown()) {         handlerService.shutdown().         handlerService.awaitTermination(10, TimeUnit.SECONDS).     }     if (!eventLoopService.isShutdown()) {         eventLoopService.shutdown().         eventLoopService.awaitTermination(10, TimeUnit.SECONDS).     } }
false;public;0;26;;public void testThatPipeliningWorksWithFastSerializedRequests() throws InterruptedException {     final int numberOfRequests = randomIntBetween(2, 128).     final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new Netty4HttpPipeliningHandler(logger, numberOfRequests), new WorkEmulatorHandler()).     for (int i = 0. i < numberOfRequests. i++) {         embeddedChannel.writeInbound(createHttpRequest("/" + String.valueOf(i))).     }     final List<CountDownLatch> latches = new ArrayList<>().     for (final String url : waitingRequests.keySet()) {         latches.add(finishRequest(url)).     }     for (final CountDownLatch latch : latches) {         latch.await().     }     embeddedChannel.flush().     for (int i = 0. i < numberOfRequests. i++) {         assertReadHttpMessageHasContent(embeddedChannel, String.valueOf(i)).     }     assertTrue(embeddedChannel.isOpen()). }
false;public;0;29;;public void testThatPipeliningWorksWhenSlowRequestsInDifferentOrder() throws InterruptedException {     final int numberOfRequests = randomIntBetween(2, 128).     final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new Netty4HttpPipeliningHandler(logger, numberOfRequests), new WorkEmulatorHandler()).     for (int i = 0. i < numberOfRequests. i++) {         embeddedChannel.writeInbound(createHttpRequest("/" + String.valueOf(i))).     }     // random order execution     final List<String> urls = new ArrayList<>(waitingRequests.keySet()).     Randomness.shuffle(urls).     final List<CountDownLatch> latches = new ArrayList<>().     for (final String url : urls) {         latches.add(finishRequest(url)).     }     for (final CountDownLatch latch : latches) {         latch.await().     }     embeddedChannel.flush().     for (int i = 0. i < numberOfRequests. i++) {         assertReadHttpMessageHasContent(embeddedChannel, String.valueOf(i)).     }     assertTrue(embeddedChannel.isOpen()). }
false;public;0;27;;public void testThatPipeliningClosesConnectionWithTooManyEvents() throws InterruptedException {     final int numberOfRequests = randomIntBetween(2, 128).     final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new Netty4HttpPipeliningHandler(logger, numberOfRequests), new WorkEmulatorHandler()).     for (int i = 0. i < 1 + numberOfRequests + 1. i++) {         embeddedChannel.writeInbound(createHttpRequest("/" + Integer.toString(i))).     }     final List<CountDownLatch> latches = new ArrayList<>().     final List<Integer> requests = IntStream.range(1, numberOfRequests + 1).boxed().collect(Collectors.toList()).     Randomness.shuffle(requests).     for (final Integer request : requests) {         latches.add(finishRequest(request.toString())).     }     for (final CountDownLatch latch : latches) {         latch.await().     }     finishRequest(Integer.toString(numberOfRequests + 1)).await().     embeddedChannel.flush().     assertFalse(embeddedChannel.isOpen()). }
false;public;0;34;;public void testPipeliningRequestsAreReleased() throws InterruptedException {     final int numberOfRequests = 10.     final EmbeddedChannel embeddedChannel = new EmbeddedChannel(new Netty4HttpPipeliningHandler(logger, numberOfRequests + 1)).     for (int i = 0. i < numberOfRequests. i++) {         embeddedChannel.writeInbound(createHttpRequest("/" + i)).     }     HttpPipelinedRequest<FullHttpRequest> inbound.     ArrayList<HttpPipelinedRequest<FullHttpRequest>> requests = new ArrayList<>().     while ((inbound = embeddedChannel.readInbound()) != null) {         requests.add(inbound).     }     ArrayList<ChannelPromise> promises = new ArrayList<>().     for (int i = 1. i < requests.size(). ++i) {         ChannelPromise promise = embeddedChannel.newPromise().         promises.add(promise).         HttpPipelinedRequest<FullHttpRequest> pipelinedRequest = requests.get(i).         Netty4HttpRequest nioHttpRequest = new Netty4HttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()).         Netty4HttpResponse resp = nioHttpRequest.createResponse(RestStatus.OK, BytesArray.EMPTY).         embeddedChannel.writeAndFlush(resp, promise).     }     for (ChannelPromise promise : promises) {         assertFalse(promise.isDone()).     }     embeddedChannel.close().syncUninterruptibly().     for (ChannelPromise promise : promises) {         assertTrue(promise.isDone()).         assertTrue(promise.cause() instanceof ClosedChannelException).     } }
false;private;2;7;;private void assertReadHttpMessageHasContent(EmbeddedChannel embeddedChannel, String expectedContent) {     FullHttpResponse response = (FullHttpResponse) embeddedChannel.outboundMessages().poll().     assertNotNull("Expected response to exist, maybe you did not wait long enough?", response).     assertNotNull("Expected response to have content " + expectedContent, response.content()).     String data = new String(ByteBufUtil.getBytes(response.content()), StandardCharsets.UTF_8).     assertThat(data, is(expectedContent)). }
false;private;1;3;;private FullHttpRequest createHttpRequest(String uri) {     return new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, uri). }
false;protected;2;4;;@Override protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {     QUEUE_URI.add(request.uri()). }
false;protected;2;34;;@Override protected void channelRead0(final ChannelHandlerContext ctx, HttpPipelinedRequest<FullHttpRequest> pipelinedRequest) {     LastHttpContent request = pipelinedRequest.getRequest().     final QueryStringDecoder decoder.     if (request instanceof FullHttpRequest) {         decoder = new QueryStringDecoder(((FullHttpRequest) request).uri()).     } else {         decoder = new QueryStringDecoder(AggregateUrisAndHeadersHandler.QUEUE_URI.poll()).     }     final String uri = decoder.path().replace("/", "").     final BytesReference content = new BytesArray(uri.getBytes(StandardCharsets.UTF_8)).     Netty4HttpRequest nioHttpRequest = new Netty4HttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()).     Netty4HttpResponse httpResponse = nioHttpRequest.createResponse(RestStatus.OK, content).     httpResponse.addHeader(CONTENT_LENGTH.toString(), Integer.toString(content.length())).     final CountDownLatch waitingLatch = new CountDownLatch(1).     waitingRequests.put(uri, waitingLatch).     final CountDownLatch finishingLatch = new CountDownLatch(1).     finishingRequests.put(uri, finishingLatch).     handlerService.submit(() -> {         try {             waitingLatch.await(1000, TimeUnit.SECONDS).             final ChannelPromise promise = ctx.newPromise().             eventLoopService.submit(() -> {                 ctx.write(httpResponse, promise).                 finishingLatch.countDown().             }).         } catch (InterruptedException e) {             fail(e.toString()).         }     }). }
