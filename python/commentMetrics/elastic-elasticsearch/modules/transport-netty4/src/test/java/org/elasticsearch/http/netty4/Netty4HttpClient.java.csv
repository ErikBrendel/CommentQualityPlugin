commented;modifiers;parameterAmount;loc;comment;code
false;static;1;7;;static Collection<String> returnHttpResponseBodies(Collection<FullHttpResponse> responses) {     List<String> list = new ArrayList<>(responses.size()).     for (FullHttpResponse response : responses) {         list.add(response.content().toString(StandardCharsets.UTF_8)).     }     return list. }
false;static;1;7;;static Collection<String> returnOpaqueIds(Collection<FullHttpResponse> responses) {     List<String> list = new ArrayList<>(responses.size()).     for (HttpResponse response : responses) {         list.add(response.headers().get(Task.X_OPAQUE_ID)).     }     return list. }
false;public;2;10;;public Collection<FullHttpResponse> get(SocketAddress remoteAddress, String... uris) throws InterruptedException {     Collection<HttpRequest> requests = new ArrayList<>(uris.length).     for (int i = 0. i < uris.length. i++) {         final HttpRequest httpRequest = new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, uris[i]).         httpRequest.headers().add(HOST, "localhost").         httpRequest.headers().add("X-Opaque-ID", String.valueOf(i)).         requests.add(httpRequest).     }     return sendRequests(remoteAddress, requests). }
false;public,final;2;5;;// Safe not because it doesn't do anything with the type parameters but because it won't leak them into other methods. @SafeVarargs public final Collection<FullHttpResponse> post(SocketAddress remoteAddress, Tuple<String, CharSequence>... urisAndBodies) throws InterruptedException {     return processRequestsWithBody(HttpMethod.POST, remoteAddress, urisAndBodies). }
false;public,final;2;5;;public final FullHttpResponse post(SocketAddress remoteAddress, FullHttpRequest httpRequest) throws InterruptedException {     Collection<FullHttpResponse> responses = sendRequests(remoteAddress, Collections.singleton(httpRequest)).     assert responses.size() == 1 : "expected 1 and only 1 http response".     return responses.iterator().next(). }
false;public,final;2;5;;// Safe not because it doesn't do anything with the type parameters but because it won't leak them into other methods. @SafeVarargs public final Collection<FullHttpResponse> put(SocketAddress remoteAddress, Tuple<String, CharSequence>... urisAndBodies) throws InterruptedException {     return processRequestsWithBody(HttpMethod.PUT, remoteAddress, urisAndBodies). }
false;private;3;13;;private Collection<FullHttpResponse> processRequestsWithBody(HttpMethod method, SocketAddress remoteAddress, Tuple<String, CharSequence>... urisAndBodies) throws InterruptedException {     Collection<HttpRequest> requests = new ArrayList<>(urisAndBodies.length).     for (Tuple<String, CharSequence> uriAndBody : urisAndBodies) {         ByteBuf content = Unpooled.copiedBuffer(uriAndBody.v2(), StandardCharsets.UTF_8).         HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, method, uriAndBody.v1(), content).         request.headers().add(HttpHeaderNames.HOST, "localhost").         request.headers().add(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes()).         request.headers().add(HttpHeaderNames.CONTENT_TYPE, "application/json").         requests.add(request).     }     return sendRequests(remoteAddress, requests). }
false;private,synchronized;2;28;;private synchronized Collection<FullHttpResponse> sendRequests(final SocketAddress remoteAddress, final Collection<HttpRequest> requests) throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(requests.size()).     final Collection<FullHttpResponse> content = Collections.synchronizedList(new ArrayList<>(requests.size())).     clientBootstrap.handler(new CountDownLatchHandler(latch, content)).     ChannelFuture channelFuture = null.     try {         channelFuture = clientBootstrap.connect(remoteAddress).         channelFuture.sync().         for (HttpRequest request : requests) {             channelFuture.channel().writeAndFlush(request).         }         if (latch.await(30L, TimeUnit.SECONDS) == false) {             fail("Failed to get all expected responses.").         }     } finally {         if (channelFuture != null) {             channelFuture.channel().close().sync().         }     }     return content. }
false;public;0;4;;@Override public void close() {     clientBootstrap.config().group().shutdownGracefully().awaitUninterruptibly(). }
false;protected;2;6;;@Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {     final FullHttpResponse response = (FullHttpResponse) msg.     content.add(response.copy()).     latch.countDown(). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     super.exceptionCaught(ctx, cause).     latch.countDown(). }
false;protected;1;21;;@Override protected void initChannel(SocketChannel ch) throws Exception {     final int maxContentLength = new ByteSizeValue(100, ByteSizeUnit.MB).bytesAsInt().     ch.pipeline().addLast(new HttpResponseDecoder()).     ch.pipeline().addLast(new HttpRequestEncoder()).     ch.pipeline().addLast(new HttpObjectAggregator(maxContentLength)).     ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpObject>() {          @Override         protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {             final FullHttpResponse response = (FullHttpResponse) msg.             content.add(response.copy()).             latch.countDown().         }          @Override         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {             super.exceptionCaught(ctx, cause).             latch.countDown().         }     }). }
