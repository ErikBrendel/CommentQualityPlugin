commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;21;;@Override protected void doStart() {     boolean success = false.     try {         ThreadFactory threadFactory = daemonThreadFactory(settings, TRANSPORT_WORKER_THREAD_NAME_PREFIX).         eventLoopGroup = new NioEventLoopGroup(workerCount, threadFactory).         clientBootstrap = createClientBootstrap(eventLoopGroup).         if (NetworkService.NETWORK_SERVER.get(settings)) {             for (ProfileSettings profileSettings : profileSettings) {                 createServerBootstrap(profileSettings, eventLoopGroup).                 bindServer(profileSettings).             }         }         super.doStart().         success = true.     } finally {         if (success == false) {             doStop().         }     } }
false;private;1;25;;private Bootstrap createClientBootstrap(NioEventLoopGroup eventLoopGroup) {     final Bootstrap bootstrap = new Bootstrap().     bootstrap.group(eventLoopGroup).     bootstrap.channel(NioSocketChannel.class).     bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings)).     bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings)).     final ByteSizeValue tcpSendBufferSize = TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings).     if (tcpSendBufferSize.getBytes() > 0) {         bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes())).     }     final ByteSizeValue tcpReceiveBufferSize = TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings).     if (tcpReceiveBufferSize.getBytes() > 0) {         bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes())).     }     bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator).     final boolean reuseAddress = TransportSettings.TCP_REUSE_ADDRESS.get(settings).     bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress).     return bootstrap. }
false;private;2;36;;private void createServerBootstrap(ProfileSettings profileSettings, NioEventLoopGroup eventLoopGroup) {     String name = profileSettings.profileName.     if (logger.isDebugEnabled()) {         logger.debug("using profile[{}], worker_count[{}], port[{}], bind_host[{}], publish_host[{}], receive_predictor[{}->{}]", name, workerCount, profileSettings.portOrRange, profileSettings.bindHosts, profileSettings.publishHosts, receivePredictorMin, receivePredictorMax).     }     final ServerBootstrap serverBootstrap = new ServerBootstrap().     serverBootstrap.group(eventLoopGroup).     serverBootstrap.channel(NioServerSocketChannel.class).     serverBootstrap.childHandler(getServerChannelInitializer(name)).     serverBootstrap.handler(new ServerChannelExceptionHandler()).     serverBootstrap.childOption(ChannelOption.TCP_NODELAY, profileSettings.tcpNoDelay).     serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, profileSettings.tcpKeepAlive).     if (profileSettings.sendBufferSize.getBytes() != -1) {         serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(profileSettings.sendBufferSize.getBytes())).     }     if (profileSettings.receiveBufferSize.getBytes() != -1) {         serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(profileSettings.receiveBufferSize.bytesAsInt())).     }     serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator).     serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator).     serverBootstrap.option(ChannelOption.SO_REUSEADDR, profileSettings.reuseAddress).     serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, profileSettings.reuseAddress).     serverBootstrap.validate().     serverBootstraps.put(name, serverBootstrap). }
false;protected;1;3;;protected ChannelHandler getServerChannelInitializer(String name) {     return new ServerChannelInitializer(name). }
false;protected;1;3;;protected ChannelHandler getClientChannelInitializer(DiscoveryNode node) {     return new ClientChannelInitializer(). }
false;protected;1;20;;@Override protected Netty4TcpChannel initiateChannel(DiscoveryNode node) throws IOException {     InetSocketAddress address = node.getAddress().address().     Bootstrap bootstrapWithHandler = clientBootstrap.clone().     bootstrapWithHandler.handler(getClientChannelInitializer(node)).     bootstrapWithHandler.remoteAddress(address).     ChannelFuture connectFuture = bootstrapWithHandler.connect().     Channel channel = connectFuture.channel().     if (channel == null) {         ExceptionsHelper.maybeDieOnAnotherThread(connectFuture.cause()).         throw new IOException(connectFuture.cause()).     }     addClosedExceptionLogger(channel).     Netty4TcpChannel nettyChannel = new Netty4TcpChannel(channel, false, "default", connectFuture).     channel.attr(CHANNEL_KEY).set(nettyChannel).     return nettyChannel. }
false;protected;2;7;;@Override protected Netty4TcpServerChannel bind(String name, InetSocketAddress address) {     Channel channel = serverBootstraps.get(name).bind(address).syncUninterruptibly().channel().     Netty4TcpServerChannel esChannel = new Netty4TcpServerChannel(channel, name).     channel.attr(SERVER_CHANNEL_KEY).set(esChannel).     return esChannel. }
false;protected;0;14;;@Override @SuppressForbidden(reason = "debug") protected void stopInternal() {     Releasables.close(() -> {         Future<?> shutdownFuture = eventLoopGroup.shutdownGracefully(0, 5, TimeUnit.SECONDS).         shutdownFuture.awaitUninterruptibly().         if (shutdownFuture.isSuccess() == false) {             logger.warn("Error closing netty event loop group", shutdownFuture.cause()).         }         serverBootstraps.clear().         clientBootstrap = null.     }). }
false;protected;1;7;;@Override protected void initChannel(Channel ch) throws Exception {     ch.pipeline().addLast("logging", new ESLoggingHandler()).     ch.pipeline().addLast("size", new Netty4SizeHeaderFrameDecoder()).     // using a dot as a prefix means this cannot come from any settings parsed     ch.pipeline().addLast("dispatcher", new Netty4MessageChannelHandler(Netty4Transport.this)). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     ExceptionsHelper.maybeDieOnAnotherThread(cause).     super.exceptionCaught(ctx, cause). }
false;protected;1;10;;@Override protected void initChannel(Channel ch) throws Exception {     addClosedExceptionLogger(ch).     Netty4TcpChannel nettyTcpChannel = new Netty4TcpChannel(ch, true, name, ch.newSucceededFuture()).     ch.attr(CHANNEL_KEY).set(nettyTcpChannel).     ch.pipeline().addLast("logging", new ESLoggingHandler()).     ch.pipeline().addLast("size", new Netty4SizeHeaderFrameDecoder()).     ch.pipeline().addLast("dispatcher", new Netty4MessageChannelHandler(Netty4Transport.this)).     serverAcceptedChannel(nettyTcpChannel). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     ExceptionsHelper.maybeDieOnAnotherThread(cause).     super.exceptionCaught(ctx, cause). }
false;private;1;7;;private void addClosedExceptionLogger(Channel channel) {     channel.closeFuture().addListener(f -> {         if (f.isSuccess() == false) {             logger.debug(() -> new ParameterizedMessage("exception while closing channel: {}", channel), f.cause()).         }     }). }
false;public;2;10;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {     ExceptionsHelper.maybeDieOnAnotherThread(cause).     Netty4TcpServerChannel serverChannel = ctx.channel().attr(SERVER_CHANNEL_KEY).get().     if (cause instanceof Error) {         onServerException(serverChannel, new Exception(cause)).     } else {         onServerException(serverChannel, (Exception) cause).     } }
