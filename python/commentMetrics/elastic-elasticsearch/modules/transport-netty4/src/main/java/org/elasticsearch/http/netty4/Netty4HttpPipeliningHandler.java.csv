commented;modifiers;parameterAmount;loc;comment;code
false;public;2;6;;@Override public void channelRead(final ChannelHandlerContext ctx, final Object msg) {     assert msg instanceof FullHttpRequest : "Invalid message type: " + msg.getClass().     HttpPipelinedRequest<FullHttpRequest> pipelinedRequest = aggregator.read(((FullHttpRequest) msg)).     ctx.fireChannelRead(pipelinedRequest). }
false;public;3;19;;@Override public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise) {     assert msg instanceof Netty4HttpResponse : "Invalid message type: " + msg.getClass().     Netty4HttpResponse response = (Netty4HttpResponse) msg.     boolean success = false.     try {         List<Tuple<Netty4HttpResponse, ChannelPromise>> readyResponses = aggregator.write(response, promise).         for (Tuple<Netty4HttpResponse, ChannelPromise> readyResponse : readyResponses) {             ctx.write(readyResponse.v1(), readyResponse.v2()).         }         success = true.     } catch (IllegalStateException e) {         ctx.channel().close().     } finally {         if (success == false) {             promise.setFailure(new ClosedChannelException()).         }     } }
false;public;2;16;;@Override public void close(ChannelHandlerContext ctx, ChannelPromise promise) {     List<Tuple<Netty4HttpResponse, ChannelPromise>> inflightResponses = aggregator.removeAllInflightResponses().     if (inflightResponses.isEmpty() == false) {         ClosedChannelException closedChannelException = new ClosedChannelException().         for (Tuple<Netty4HttpResponse, ChannelPromise> inflightResponse : inflightResponses) {             try {                 inflightResponse.v2().setFailure(closedChannelException).             } catch (RuntimeException e) {                 logger.error("unexpected error while releasing pipelined http responses", e).             }         }     }     ctx.close(promise). }
