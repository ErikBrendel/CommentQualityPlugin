commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Settings settings() {     return this.settings. }
false;protected;0;41;;@Override protected void doStart() {     boolean success = false.     try {         serverBootstrap = new ServerBootstrap().         serverBootstrap.group(new NioEventLoopGroup(workerCount, daemonThreadFactory(settings, HTTP_SERVER_WORKER_THREAD_NAME_PREFIX))).         serverBootstrap.channel(NioServerSocketChannel.class).         serverBootstrap.childHandler(configureServerChannelHandler()).         serverBootstrap.handler(new ServerChannelExceptionHandler(this)).         serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings)).         serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)).         final ByteSizeValue tcpSendBufferSize = SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings).         if (tcpSendBufferSize.getBytes() > 0) {             serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes())).         }         final ByteSizeValue tcpReceiveBufferSize = SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings).         if (tcpReceiveBufferSize.getBytes() > 0) {             serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes())).         }         serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator).         serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator).         final boolean reuseAddress = SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings).         serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress).         serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress).         bindServer().         success = true.     } finally {         if (success == false) {             // otherwise we leak threads since we never moved to started             doStop().         }     } }
true;static;1;35;// package private for testing ;// package private for testing static Netty4CorsConfig buildCorsConfig(Settings settings) {     if (SETTING_CORS_ENABLED.get(settings) == false) {         return Netty4CorsConfigBuilder.forOrigins().disable().build().     }     String origin = SETTING_CORS_ALLOW_ORIGIN.get(settings).     final Netty4CorsConfigBuilder builder.     if (Strings.isNullOrEmpty(origin)) {         builder = Netty4CorsConfigBuilder.forOrigins().     } else if (origin.equals(ANY_ORIGIN)) {         builder = Netty4CorsConfigBuilder.forAnyOrigin().     } else {         try {             Pattern p = RestUtils.checkCorsSettingForRegex(origin).             if (p == null) {                 builder = Netty4CorsConfigBuilder.forOrigins(RestUtils.corsSettingAsArray(origin)).             } else {                 builder = Netty4CorsConfigBuilder.forPattern(p).             }         } catch (PatternSyntaxException e) {             throw new SettingsException("Bad regex in [" + SETTING_CORS_ALLOW_ORIGIN.getKey() + "]: [" + origin + "]", e).         }     }     if (SETTING_CORS_ALLOW_CREDENTIALS.get(settings)) {         builder.allowCredentials().     }     String[] strMethods = Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_METHODS.get(settings), ",").     HttpMethod[] methods = Arrays.stream(strMethods).map(HttpMethod::valueOf).toArray(HttpMethod[]::new).     return builder.allowedRequestMethods(methods).maxAge(SETTING_CORS_MAX_AGE.get(settings)).allowedRequestHeaders(Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_HEADERS.get(settings), ",")).shortCircuit().build(). }
false;protected;1;8;;@Override protected HttpServerChannel bind(InetSocketAddress socketAddress) throws Exception {     ChannelFuture future = serverBootstrap.bind(socketAddress).sync().     Channel channel = future.channel().     Netty4HttpServerChannel httpServerChannel = new Netty4HttpServerChannel(channel).     channel.attr(HTTP_SERVER_CHANNEL_KEY).set(httpServerChannel).     return httpServerChannel. }
false;protected;0;7;;@Override protected void stopInternal() {     if (serverBootstrap != null) {         serverBootstrap.config().group().shutdownGracefully(0, 5, TimeUnit.SECONDS).awaitUninterruptibly().         serverBootstrap = null.     } }
false;protected;2;11;;@Override protected void onException(HttpChannel channel, Exception cause) {     if (cause instanceof ReadTimeoutException) {         if (logger.isTraceEnabled()) {             logger.trace("Http read timeout {}", channel).         }         CloseableChannel.closeChannel(channel).     } else {         super.onException(channel, cause).     } }
false;public;0;3;;public ChannelHandler configureServerChannelHandler() {     return new HttpChannelHandler(this, handlingSettings). }
false;protected;1;26;;@Override protected void initChannel(Channel ch) throws Exception {     Netty4HttpChannel nettyHttpChannel = new Netty4HttpChannel(ch).     ch.attr(HTTP_CHANNEL_KEY).set(nettyHttpChannel).     ch.pipeline().addLast("read_timeout", new ReadTimeoutHandler(transport.readTimeoutMillis, TimeUnit.MILLISECONDS)).     final HttpRequestDecoder decoder = new HttpRequestDecoder(handlingSettings.getMaxInitialLineLength(), handlingSettings.getMaxHeaderSize(), handlingSettings.getMaxChunkSize()).     decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR).     ch.pipeline().addLast("decoder", decoder).     ch.pipeline().addLast("decoder_compress", new HttpContentDecompressor()).     ch.pipeline().addLast("encoder", new HttpResponseEncoder()).     final HttpObjectAggregator aggregator = new HttpObjectAggregator(handlingSettings.getMaxContentLength()).     aggregator.setMaxCumulationBufferComponents(transport.maxCompositeBufferComponents).     ch.pipeline().addLast("aggregator", aggregator).     if (handlingSettings.isCompression()) {         ch.pipeline().addLast("encoder_compress", new HttpContentCompressor(handlingSettings.getCompressionLevel())).     }     if (handlingSettings.isCorsEnabled()) {         ch.pipeline().addLast("cors", new Netty4CorsHandler(transport.corsConfig)).     }     ch.pipeline().addLast("pipelining", new Netty4HttpPipeliningHandler(logger, transport.pipeliningMaxEvents)).     ch.pipeline().addLast("handler", requestHandler).     transport.serverAcceptedChannel(nettyHttpChannel). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     ExceptionsHelper.maybeDieOnAnotherThread(cause).     super.exceptionCaught(ctx, cause). }
false;public;2;10;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {     ExceptionsHelper.maybeDieOnAnotherThread(cause).     Netty4HttpServerChannel httpServerChannel = ctx.channel().attr(HTTP_SERVER_CHANNEL_KEY).get().     if (cause instanceof Error) {         transport.onServerException(httpServerChannel, new Exception(cause)).     } else {         transport.onServerException(httpServerChannel, (Exception) cause).     } }
