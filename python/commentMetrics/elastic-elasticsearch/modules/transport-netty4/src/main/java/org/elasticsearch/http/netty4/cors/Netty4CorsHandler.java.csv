commented;modifiers;parameterAmount;loc;comment;code
false;public;2;24;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     assert msg instanceof FullHttpRequest : "Invalid message type: " + msg.getClass().     if (config.isCorsSupportEnabled()) {         request = (FullHttpRequest) msg.         if (isPreflightRequest(request)) {             try {                 handlePreflight(ctx, request).                 return.             } finally {                 releaseRequest().             }         }         if (config.isShortCircuit() && !validateOrigin()) {             try {                 forbidden(ctx, request).                 return.             } finally {                 releaseRequest().             }         }     }     ctx.fireChannelRead(msg). }
false;public;3;7;;@Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {     assert msg instanceof Netty4HttpResponse : "Invalid message type: " + msg.getClass().     Netty4HttpResponse response = (Netty4HttpResponse) msg.     setCorsResponseHeaders(response.getRequest().nettyRequest(), response, config).     ctx.write(response, promise). }
false;public,static;3;22;;public static void setCorsResponseHeaders(HttpRequest request, HttpResponse resp, Netty4CorsConfig config) {     if (!config.isCorsSupportEnabled()) {         return.     }     String originHeader = request.headers().get(HttpHeaderNames.ORIGIN).     if (!Strings.isNullOrEmpty(originHeader)) {         final String originHeaderVal.         if (config.isAnyOriginSupported()) {             originHeaderVal = ANY_ORIGIN.         } else if (config.isOriginAllowed(originHeader) || isSameOrigin(originHeader, request.headers().get(HttpHeaderNames.HOST))) {             originHeaderVal = originHeader.         } else {             originHeaderVal = null.         }         if (originHeaderVal != null) {             resp.headers().add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, originHeaderVal).         }     }     if (config.isCredentialsAllowed()) {         resp.headers().add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true").     } }
false;private;2;13;;private void handlePreflight(final ChannelHandlerContext ctx, final HttpRequest request) {     final HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK, true, true).     if (setOrigin(response)) {         setAllowMethods(response).         setAllowHeaders(response).         setAllowCredentials(response).         setMaxAge(response).         setPreflightHeaders(response).         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).     } else {         forbidden(ctx, request).     } }
false;private;0;4;;private void releaseRequest() {     request.release().     request = null. }
false;private,static;2;4;;private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {     ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.FORBIDDEN)).addListener(ChannelFutureListener.CLOSE). }
false;private,static;2;10;;private static boolean isSameOrigin(final String origin, final String host) {     if (Strings.isNullOrEmpty(host) == false) {         // strip protocol from origin         final String originDomain = SCHEME_PATTERN.matcher(origin).replaceFirst("").         if (host.equals(originDomain)) {             return true.         }     }     return false. }
true;private;1;3;/**  * This is a non CORS specification feature which enables the setting of preflight  * response headers that might be required by intermediaries.  *  * @param response the HttpResponse to which the preflight response headers should be added.  */ ;/**  * This is a non CORS specification feature which enables the setting of preflight  * response headers that might be required by intermediaries.  *  * @param response the HttpResponse to which the preflight response headers should be added.  */ private void setPreflightHeaders(final HttpResponse response) {     response.headers().add(config.preflightResponseHeaders()). }
false;private;1;20;;private boolean setOrigin(final HttpResponse response) {     final String origin = request.headers().get(HttpHeaderNames.ORIGIN).     if (!Strings.isNullOrEmpty(origin)) {         if (config.isAnyOriginSupported()) {             if (config.isCredentialsAllowed()) {                 echoRequestOrigin(response).                 setVaryHeader(response).             } else {                 setAnyOrigin(response).             }             return true.         }         if (config.isOriginAllowed(origin)) {             setOrigin(response, origin).             setVaryHeader(response).             return true.         }     }     return false. }
false;private;0;18;;private boolean validateOrigin() {     if (config.isAnyOriginSupported()) {         return true.     }     final String origin = request.headers().get(HttpHeaderNames.ORIGIN).     if (Strings.isNullOrEmpty(origin)) {         // Not a CORS request so we cannot validate it. It may be a non CORS request.         return true.     }     // if the origin is the same as the host of the request, then allow     if (isSameOrigin(origin, request.headers().get(HttpHeaderNames.HOST))) {         return true.     }     return config.isOriginAllowed(origin). }
false;private;1;3;;private void echoRequestOrigin(final HttpResponse response) {     setOrigin(response, request.headers().get(HttpHeaderNames.ORIGIN)). }
false;private,static;1;3;;private static void setVaryHeader(final HttpResponse response) {     response.headers().set(HttpHeaderNames.VARY, HttpHeaderNames.ORIGIN). }
false;private,static;1;3;;private static void setAnyOrigin(final HttpResponse response) {     setOrigin(response, ANY_ORIGIN). }
false;private,static;2;3;;private static void setOrigin(final HttpResponse response, final String origin) {     response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, origin). }
false;private;1;6;;private void setAllowCredentials(final HttpResponse response) {     if (config.isCredentialsAllowed() && !response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN).equals(ANY_ORIGIN)) {         response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true").     } }
false;private,static;1;6;;private static boolean isPreflightRequest(final HttpRequest request) {     final HttpHeaders headers = request.headers().     return request.method().equals(HttpMethod.OPTIONS) && headers.contains(HttpHeaderNames.ORIGIN) && headers.contains(HttpHeaderNames.ACCESS_CONTROL_REQUEST_METHOD). }
false;private;1;5;;private void setAllowMethods(final HttpResponse response) {     response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, config.allowedRequestMethods().stream().map(m -> m.name().trim()).collect(Collectors.toList())). }
false;private;1;3;;private void setAllowHeaders(final HttpResponse response) {     response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, config.allowedRequestHeaders()). }
false;private;1;3;;private void setMaxAge(final HttpResponse response) {     response.headers().set(HttpHeaderNames.ACCESS_CONTROL_MAX_AGE, config.maxAge()). }
