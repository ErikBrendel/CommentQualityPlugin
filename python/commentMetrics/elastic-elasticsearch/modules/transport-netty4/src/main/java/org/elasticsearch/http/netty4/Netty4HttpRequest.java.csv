commented;modifiers;parameterAmount;loc;comment;code
false;public;0;37;;@Override public RestRequest.Method method() {     HttpMethod httpMethod = request.method().     if (httpMethod == HttpMethod.GET)         return RestRequest.Method.GET.     if (httpMethod == HttpMethod.POST)         return RestRequest.Method.POST.     if (httpMethod == HttpMethod.PUT)         return RestRequest.Method.PUT.     if (httpMethod == HttpMethod.DELETE)         return RestRequest.Method.DELETE.     if (httpMethod == HttpMethod.HEAD) {         return RestRequest.Method.HEAD.     }     if (httpMethod == HttpMethod.OPTIONS) {         return RestRequest.Method.OPTIONS.     }     if (httpMethod == HttpMethod.PATCH) {         return RestRequest.Method.PATCH.     }     if (httpMethod == HttpMethod.TRACE) {         return RestRequest.Method.TRACE.     }     if (httpMethod == HttpMethod.CONNECT) {         return RestRequest.Method.CONNECT.     }     throw new IllegalArgumentException("Unexpected http method: " + httpMethod). }
false;public;0;4;;@Override public String uri() {     return request.uri(). }
false;public;0;4;;@Override public BytesReference content() {     return content. }
false;public,final;0;4;;@Override public final Map<String, List<String>> getHeaders() {     return headers. }
false;public;0;11;;@Override public List<String> strictCookies() {     String cookieString = request.headers().get(HttpHeaderNames.COOKIE).     if (cookieString != null) {         Set<Cookie> cookies = ServerCookieDecoder.STRICT.decode(cookieString).         if (!cookies.isEmpty()) {             return ServerCookieEncoder.STRICT.encode(cookies).         }     }     return Collections.emptyList(). }
false;public;0;10;;@Override public HttpVersion protocolVersion() {     if (request.protocolVersion().equals(io.netty.handler.codec.http.HttpVersion.HTTP_1_0)) {         return HttpRequest.HttpVersion.HTTP_1_0.     } else if (request.protocolVersion().equals(io.netty.handler.codec.http.HttpVersion.HTTP_1_1)) {         return HttpRequest.HttpVersion.HTTP_1_1.     } else {         throw new IllegalArgumentException("Unexpected http protocol version: " + request.protocolVersion()).     } }
false;public;1;12;;@Override public HttpRequest removeHeader(String header) {     HttpHeaders headersWithoutContentTypeHeader = new DefaultHttpHeaders().     headersWithoutContentTypeHeader.add(request.headers()).     headersWithoutContentTypeHeader.remove(header).     HttpHeaders trailingHeaders = new DefaultHttpHeaders().     trailingHeaders.add(request.trailingHeaders()).     trailingHeaders.remove(header).     FullHttpRequest requestWithoutHeader = new DefaultFullHttpRequest(request.protocolVersion(), request.method(), request.uri(), request.content(), headersWithoutContentTypeHeader, trailingHeaders).     return new Netty4HttpRequest(requestWithoutHeader, sequence). }
false;public;2;4;;@Override public Netty4HttpResponse createResponse(RestStatus status, BytesReference content) {     return new Netty4HttpResponse(this, status, content). }
false;public;0;3;;public FullHttpRequest nettyRequest() {     return request. }
false;;0;3;;int sequence() {     return sequence. }
false;public;0;4;;@Override public int size() {     return httpHeaders.size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return httpHeaders.isEmpty(). }
false;public;1;4;;@Override public boolean containsKey(Object key) {     return key instanceof String && httpHeaders.contains((String) key). }
false;public;1;4;;@Override public boolean containsValue(Object value) {     return value instanceof List && httpHeaders.names().stream().map(httpHeaders::getAll).anyMatch(value::equals). }
false;public;1;4;;@Override public List<String> get(Object key) {     return key instanceof String ? httpHeaders.getAll((String) key) : null. }
false;public;2;4;;@Override public List<String> put(String key, List<String> value) {     throw new UnsupportedOperationException("modifications are not supported"). }
false;public;1;4;;@Override public List<String> remove(Object key) {     throw new UnsupportedOperationException("modifications are not supported"). }
false;public;1;4;;@Override public void putAll(Map<? extends String, ? extends List<String>> m) {     throw new UnsupportedOperationException("modifications are not supported"). }
false;public;0;4;;@Override public void clear() {     throw new UnsupportedOperationException("modifications are not supported"). }
false;public;0;4;;@Override public Set<String> keySet() {     return httpHeaders.names(). }
false;public;0;4;;@Override public Collection<List<String>> values() {     return httpHeaders.names().stream().map(k -> Collections.unmodifiableList(httpHeaders.getAll(k))).collect(Collectors.toList()). }
false;public;0;5;;@Override public Set<Entry<String, List<String>>> entrySet() {     return httpHeaders.names().stream().map(k -> new AbstractMap.SimpleImmutableEntry<>(k, httpHeaders.getAll(k))).collect(Collectors.toSet()). }
