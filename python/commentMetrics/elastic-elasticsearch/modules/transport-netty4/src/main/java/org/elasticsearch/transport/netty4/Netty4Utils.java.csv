commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public InternalLogger newInstance(final String name) {     return new Netty4InternalESLogger(name). }
false;public,static;0;3;;public static void setup() { }
true;public,static;1;26;/**  * Set the number of available processors that Netty uses for sizing various resources (e.g., thread pools).  *  * @param availableProcessors the number of available processors  * @throws IllegalStateException if available processors was set previously and the specified value does not match the already-set value  */ ;/**  * Set the number of available processors that Netty uses for sizing various resources (e.g., thread pools).  *  * @param availableProcessors the number of available processors  * @throws IllegalStateException if available processors was set previously and the specified value does not match the already-set value  */ public static void setAvailableProcessors(final int availableProcessors) {     // we set this to false in tests to avoid tests that randomly set processors from stepping on each other     final boolean set = Booleans.parseBoolean(System.getProperty("es.set.netty.runtime.available.processors", "true")).     if (!set) {         return.     }     /*          * This can be invoked twice, once from Netty4Transport and another time from Netty4HttpServerTransport. however,          * Netty4Runtime#availableProcessors forbids settings the number of processors twice so we prevent double invocation here.          */     if (isAvailableProcessorsSet.compareAndSet(false, true)) {         NettyRuntime.setAvailableProcessors(availableProcessors).     } else if (availableProcessors != NettyRuntime.availableProcessors()) {         /*              * We have previously set the available processors yet either we are trying to set it to a different value now or there is a bug              * in Netty and our previous value did not take, bail.              */         final String message = String.format(Locale.ROOT, "available processors value [%d] did not match current value [%d]", availableProcessors, NettyRuntime.availableProcessors()).         throw new IllegalStateException(message).     } }
true;public,static;1;28;/**  * Turns the given BytesReference into a ByteBuf. Note: the returned ByteBuf will reference the internal  * pages of the BytesReference. Don't free the bytes of reference before the ByteBuf goes out of scope.  */ ;/**  * Turns the given BytesReference into a ByteBuf. Note: the returned ByteBuf will reference the internal  * pages of the BytesReference. Don't free the bytes of reference before the ByteBuf goes out of scope.  */ public static ByteBuf toByteBuf(final BytesReference reference) {     if (reference.length() == 0) {         return Unpooled.EMPTY_BUFFER.     }     if (reference instanceof ByteBufBytesReference) {         return ((ByteBufBytesReference) reference).toByteBuf().     } else {         final BytesRefIterator iterator = reference.iterator().         // usually we have one, two, or three components from the header, the message, and a buffer         final List<ByteBuf> buffers = new ArrayList<>(3).         try {             BytesRef slice.             while ((slice = iterator.next()) != null) {                 buffers.add(Unpooled.wrappedBuffer(slice.bytes, slice.offset, slice.length)).             }             if (buffers.size() == 1) {                 return buffers.get(0).             } else {                 CompositeByteBuf composite = Unpooled.compositeBuffer(buffers.size()).                 composite.addComponents(true, buffers).                 return composite.             }         } catch (IOException ex) {             throw new AssertionError("no IO happens here", ex).         }     } }
true;public,static;1;3;/**  * Wraps the given ChannelBuffer with a BytesReference  */ ;/**  * Wraps the given ChannelBuffer with a BytesReference  */ public static BytesReference toBytesReference(final ByteBuf buffer) {     return toBytesReference(buffer, buffer.readableBytes()). }
true;static;2;3;/**  * Wraps the given ChannelBuffer with a BytesReference of a given size  */ ;/**  * Wraps the given ChannelBuffer with a BytesReference of a given size  */ static BytesReference toBytesReference(final ByteBuf buffer, final int size) {     return new ByteBufBytesReference(buffer, size). }
