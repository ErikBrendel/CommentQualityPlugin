commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doStart(Consumer<? super Response> onResponse) {     lookupRemoteVersion(version -> {         remoteVersion = version.         execute(RemoteRequestBuilders.initialSearch(searchRequest, query, remoteVersion), RESPONSE_PARSER, r -> onStartResponse(onResponse, r)).     }). }
false;;1;3;;void lookupRemoteVersion(Consumer<Version> onVersion) {     execute(new Request("GET", ""), MAIN_ACTION_PARSER, onVersion). }
false;private;2;8;;private void onStartResponse(Consumer<? super Response> onResponse, Response response) {     if (Strings.hasLength(response.getScrollId()) && response.getHits().isEmpty()) {         logger.debug("First response looks like a scan response. Jumping right to the second. scroll=[{}]", response.getScrollId()).         doStartNextScroll(response.getScrollId(), timeValueMillis(0), onResponse).     } else {         onResponse.accept(response).     } }
false;protected;3;5;;@Override protected void doStartNextScroll(String scrollId, TimeValue extraKeepAlive, Consumer<? super Response> onResponse) {     TimeValue keepAlive = timeValueNanos(searchRequest.scroll().keepAlive().nanos() + extraKeepAlive.nanos()).     execute(RemoteRequestBuilders.scroll(scrollId, keepAlive, remoteVersion), RESPONSE_PARSER, onResponse). }
false;public;1;5;;@Override public void onSuccess(org.elasticsearch.client.Response response) {     logger.debug("Successfully cleared [{}]", scrollId).     onCompletion.run(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logFailure(e).     onCompletion.run(). }
false;private;1;13;;private void logFailure(Exception e) {     if (e instanceof ResponseException) {         ResponseException re = (ResponseException) e.         if (remoteVersion.before(Version.fromId(2000099)) && re.getResponse().getStatusLine().getStatusCode() == 404) {             logger.debug((Supplier<?>) () -> new ParameterizedMessage("Failed to clear scroll [{}] from pre-2.0 Elasticsearch. This is normal if the request terminated " + "normally as the scroll has already been cleared automatically.", scrollId), e).             return.         }     }     logger.warn((Supplier<?>) () -> new ParameterizedMessage("Failed to clear scroll [{}]", scrollId), e). }
false;protected;2;30;;@Override protected void clearScroll(String scrollId, Runnable onCompletion) {     client.performRequestAsync(RemoteRequestBuilders.clearScroll(scrollId, remoteVersion), new ResponseListener() {          @Override         public void onSuccess(org.elasticsearch.client.Response response) {             logger.debug("Successfully cleared [{}]", scrollId).             onCompletion.run().         }          @Override         public void onFailure(Exception e) {             logFailure(e).             onCompletion.run().         }          private void logFailure(Exception e) {             if (e instanceof ResponseException) {                 ResponseException re = (ResponseException) e.                 if (remoteVersion.before(Version.fromId(2000099)) && re.getResponse().getStatusLine().getStatusCode() == 404) {                     logger.debug((Supplier<?>) () -> new ParameterizedMessage("Failed to clear scroll [{}] from pre-2.0 Elasticsearch. This is normal if the request terminated " + "normally as the scroll has already been cleared automatically.", scrollId), e).                     return.                 }             }             logger.warn((Supplier<?>) () -> new ParameterizedMessage("Failed to clear scroll [{}]", scrollId), e).         }     }). }
false;protected;1;16;;@Override protected void cleanup(Runnable onCompletion) {     /* This is called on the RestClient's thread pool and attempting to close the client on its          * own threadpool causes it to fail to close. So we always shutdown the RestClient          * asynchronously on a thread in Elasticsearch's generic thread pool. */     threadPool.generic().submit(() -> {         try {             client.close().             logger.debug("Shut down remote connection").         } catch (IOException e) {             logger.error("Failed to shutdown the remote connection", e).         } finally {             onCompletion.run().         }     }). }
false;public;1;41;;@Override public void onSuccess(org.elasticsearch.client.Response response) {     // Restore the thread context to get the precious headers     try (ThreadContext.StoredContext ctx = contextSupplier.get()) {         // eliminates compiler warning         assert ctx != null.         T parsedResponse.         try {             HttpEntity responseEntity = response.getEntity().             InputStream content = responseEntity.getContent().             XContentType xContentType = null.             if (responseEntity.getContentType() != null) {                 final String mimeType = ContentType.parse(responseEntity.getContentType().getValue()).getMimeType().                 xContentType = XContentType.fromMediaType(mimeType).             }             if (xContentType == null) {                 try {                     throw new ElasticsearchException("Response didn't include Content-Type: " + bodyMessage(response.getEntity())).                 } catch (IOException e) {                     ElasticsearchException ee = new ElasticsearchException("Error extracting body from response").                     ee.addSuppressed(e).                     throw ee.                 }             }             // EMPTY is safe here because we don't call namedObject             try (XContentParser xContentParser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, content)) {                 parsedResponse = parser.apply(xContentParser, xContentType).             } catch (XContentParseException e) {                 /* Because we're streaming the response we can't get a copy of it here. The best we can do is hint that it                                  * is totally wrong and we're probably not talking to Elasticsearch. */                 throw new ElasticsearchException("Error parsing the response, remote is likely not an Elasticsearch instance", e).             }         } catch (IOException e) {             throw new ElasticsearchException("Error deserializing response, remote is likely not an Elasticsearch instance", e).         }         listener.accept(parsedResponse).     } }
false;public;1;25;;@Override public void onFailure(Exception e) {     try (ThreadContext.StoredContext ctx = contextSupplier.get()) {         // eliminates compiler warning         assert ctx != null.         if (e instanceof ResponseException) {             ResponseException re = (ResponseException) e.             if (RestStatus.TOO_MANY_REQUESTS.getStatus() == re.getResponse().getStatusLine().getStatusCode()) {                 if (retries.hasNext()) {                     TimeValue delay = retries.next().                     logger.trace((Supplier<?>) () -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e).                     countSearchRetry.run().                     threadPool.schedule(RetryHelper.this, delay, ThreadPool.Names.SAME).                     return.                 }             }             e = wrapExceptionToPreserveStatus(re.getResponse().getStatusLine().getStatusCode(), re.getResponse().getEntity(), re).         } else if (e instanceof ContentTooLongException) {             e = new IllegalArgumentException("Remote responded with a chunk that was too large. Use a smaller batch size.", e).         }         fail.accept(e).     } }
false;protected;0;72;;@Override protected void doRun() throws Exception {     client.performRequestAsync(request, new ResponseListener() {          @Override         public void onSuccess(org.elasticsearch.client.Response response) {             // Restore the thread context to get the precious headers             try (ThreadContext.StoredContext ctx = contextSupplier.get()) {                 // eliminates compiler warning                 assert ctx != null.                 T parsedResponse.                 try {                     HttpEntity responseEntity = response.getEntity().                     InputStream content = responseEntity.getContent().                     XContentType xContentType = null.                     if (responseEntity.getContentType() != null) {                         final String mimeType = ContentType.parse(responseEntity.getContentType().getValue()).getMimeType().                         xContentType = XContentType.fromMediaType(mimeType).                     }                     if (xContentType == null) {                         try {                             throw new ElasticsearchException("Response didn't include Content-Type: " + bodyMessage(response.getEntity())).                         } catch (IOException e) {                             ElasticsearchException ee = new ElasticsearchException("Error extracting body from response").                             ee.addSuppressed(e).                             throw ee.                         }                     }                     // EMPTY is safe here because we don't call namedObject                     try (XContentParser xContentParser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, content)) {                         parsedResponse = parser.apply(xContentParser, xContentType).                     } catch (XContentParseException e) {                         /* Because we're streaming the response we can't get a copy of it here. The best we can do is hint that it                                  * is totally wrong and we're probably not talking to Elasticsearch. */                         throw new ElasticsearchException("Error parsing the response, remote is likely not an Elasticsearch instance", e).                     }                 } catch (IOException e) {                     throw new ElasticsearchException("Error deserializing response, remote is likely not an Elasticsearch instance", e).                 }                 listener.accept(parsedResponse).             }         }          @Override         public void onFailure(Exception e) {             try (ThreadContext.StoredContext ctx = contextSupplier.get()) {                 // eliminates compiler warning                 assert ctx != null.                 if (e instanceof ResponseException) {                     ResponseException re = (ResponseException) e.                     if (RestStatus.TOO_MANY_REQUESTS.getStatus() == re.getResponse().getStatusLine().getStatusCode()) {                         if (retries.hasNext()) {                             TimeValue delay = retries.next().                             logger.trace((Supplier<?>) () -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e).                             countSearchRetry.run().                             threadPool.schedule(RetryHelper.this, delay, ThreadPool.Names.SAME).                             return.                         }                     }                     e = wrapExceptionToPreserveStatus(re.getResponse().getStatusLine().getStatusCode(), re.getResponse().getEntity(), re).                 } else if (e instanceof ContentTooLongException) {                     e = new IllegalArgumentException("Remote responded with a chunk that was too large. Use a smaller batch size.", e).                 }                 fail.accept(e).             }         }     }). }
false;public;1;4;;@Override public void onFailure(Exception t) {     fail.accept(t). }
false;private;3;87;;private <T> void execute(Request request, BiFunction<XContentParser, XContentType, T> parser, Consumer<? super T> listener) {     // Preserve the thread context so headers survive after the call     java.util.function.Supplier<ThreadContext.StoredContext> contextSupplier = threadPool.getThreadContext().newRestorableContext(true).     class RetryHelper extends AbstractRunnable {          private final Iterator<TimeValue> retries = backoffPolicy.iterator().          @Override         protected void doRun() throws Exception {             client.performRequestAsync(request, new ResponseListener() {                  @Override                 public void onSuccess(org.elasticsearch.client.Response response) {                     // Restore the thread context to get the precious headers                     try (ThreadContext.StoredContext ctx = contextSupplier.get()) {                         // eliminates compiler warning                         assert ctx != null.                         T parsedResponse.                         try {                             HttpEntity responseEntity = response.getEntity().                             InputStream content = responseEntity.getContent().                             XContentType xContentType = null.                             if (responseEntity.getContentType() != null) {                                 final String mimeType = ContentType.parse(responseEntity.getContentType().getValue()).getMimeType().                                 xContentType = XContentType.fromMediaType(mimeType).                             }                             if (xContentType == null) {                                 try {                                     throw new ElasticsearchException("Response didn't include Content-Type: " + bodyMessage(response.getEntity())).                                 } catch (IOException e) {                                     ElasticsearchException ee = new ElasticsearchException("Error extracting body from response").                                     ee.addSuppressed(e).                                     throw ee.                                 }                             }                             // EMPTY is safe here because we don't call namedObject                             try (XContentParser xContentParser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, content)) {                                 parsedResponse = parser.apply(xContentParser, xContentType).                             } catch (XContentParseException e) {                                 /* Because we're streaming the response we can't get a copy of it here. The best we can do is hint that it                                  * is totally wrong and we're probably not talking to Elasticsearch. */                                 throw new ElasticsearchException("Error parsing the response, remote is likely not an Elasticsearch instance", e).                             }                         } catch (IOException e) {                             throw new ElasticsearchException("Error deserializing response, remote is likely not an Elasticsearch instance", e).                         }                         listener.accept(parsedResponse).                     }                 }                  @Override                 public void onFailure(Exception e) {                     try (ThreadContext.StoredContext ctx = contextSupplier.get()) {                         // eliminates compiler warning                         assert ctx != null.                         if (e instanceof ResponseException) {                             ResponseException re = (ResponseException) e.                             if (RestStatus.TOO_MANY_REQUESTS.getStatus() == re.getResponse().getStatusLine().getStatusCode()) {                                 if (retries.hasNext()) {                                     TimeValue delay = retries.next().                                     logger.trace((Supplier<?>) () -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e).                                     countSearchRetry.run().                                     threadPool.schedule(RetryHelper.this, delay, ThreadPool.Names.SAME).                                     return.                                 }                             }                             e = wrapExceptionToPreserveStatus(re.getResponse().getStatusLine().getStatusCode(), re.getResponse().getEntity(), re).                         } else if (e instanceof ContentTooLongException) {                             e = new IllegalArgumentException("Remote responded with a chunk that was too large. Use a smaller batch size.", e).                         }                         fail.accept(e).                     }                 }             }).         }          @Override         public void onFailure(Exception t) {             fail.accept(t).         }     }     new RetryHelper().run(). }
true;static;3;15;/**  * Wrap the ResponseException in an exception that'll preserve its status code if possible so we can send it back to the user. We might  * not have a constant for the status code so in that case we just use 500 instead. We also extract make sure to include the response  * body in the message so the user can figure out *why* the remote Elasticsearch service threw the error back to us.  */ ;/**  * Wrap the ResponseException in an exception that'll preserve its status code if possible so we can send it back to the user. We might  * not have a constant for the status code so in that case we just use 500 instead. We also extract make sure to include the response  * body in the message so the user can figure out *why* the remote Elasticsearch service threw the error back to us.  */ static ElasticsearchStatusException wrapExceptionToPreserveStatus(int statusCode, @Nullable HttpEntity entity, Exception cause) {     RestStatus status = RestStatus.fromCode(statusCode).     String messagePrefix = "".     if (status == null) {         messagePrefix = "Couldn't extract status [" + statusCode + "]. ".         status = RestStatus.INTERNAL_SERVER_ERROR.     }     try {         return new ElasticsearchStatusException(messagePrefix + bodyMessage(entity), status, cause).     } catch (IOException ioe) {         ElasticsearchStatusException e = new ElasticsearchStatusException(messagePrefix + "Failed to extract body.", status, cause).         e.addSuppressed(ioe).         return e.     } }
false;static;1;7;;static String bodyMessage(@Nullable HttpEntity entity) throws IOException {     if (entity == null) {         return "No error body.".     } else {         return "body=" + EntityUtils.toString(entity).     } }
