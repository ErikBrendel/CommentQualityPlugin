commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Build the {@link BiFunction} to apply to all {@link RequestWrapper}.  *  * Public for testings....  */ ;/**  * Build the {@link BiFunction} to apply to all {@link RequestWrapper}.  *  * Public for testings....  */ public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {     // The default script applier executes a no-op     return (request, searchHit) -> request. }
true;protected,abstract;1;1;/**  * Build the {@link RequestWrapper} for a single search hit. This shouldn't handle  * metadata or scripting. That will be handled by copyMetadata and  * apply functions that can be overridden.  */ ;/**  * Build the {@link RequestWrapper} for a single search hit. This shouldn't handle  * metadata or scripting. That will be handled by copyMetadata and  * apply functions that can be overridden.  */ protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc).
true;protected;2;4;/**  * Copies the metadata from a hit to the request.  */ ;/**  * Copies the metadata from a hit to the request.  */ protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {     copyRouting(request, doc.getRouting()).     return request. }
true;protected;2;3;/**  * Copy the routing from a search hit to the request.  */ ;/**  * Copy the routing from a search hit to the request.  */ protected void copyRouting(RequestWrapper<?> request, String routing) {     request.setRouting(routing). }
true;protected;1;11;/**  * Used to accept or ignore a search hit. Ignored search hits will be excluded  * from the bulk request. It is also where we fail on invalid search hits, like  * when the document has no source but it's required.  */ ;/**  * Used to accept or ignore a search hit. Ignored search hits will be excluded  * from the bulk request. It is also where we fail on invalid search hits, like  * when the document has no source but it's required.  */ protected boolean accept(ScrollableHitSource.Hit doc) {     if (doc.getSource() == null) {         /*              * Either the document didn't store _source or we didn't fetch it for some reason. Since we don't allow the user to              * change the "fields" part of the search request it is unlikely that we got here because we didn't fetch _source.              * Thus the error message assumes that it wasn't stored.              */         throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source").     }     return true. }
false;private;1;12;;private BulkRequest buildBulk(Iterable<? extends ScrollableHitSource.Hit> docs) {     BulkRequest bulkRequest = new BulkRequest().     for (ScrollableHitSource.Hit doc : docs) {         if (accept(doc)) {             RequestWrapper<?> request = scriptApplier.apply(copyMetadata(buildRequest(doc), doc), doc).             if (request != null) {                 bulkRequest.add(request.self()).             }         }     }     return bulkRequest. }
false;protected;1;4;;protected ScrollableHitSource buildScrollableResultSource(BackoffPolicy backoffPolicy) {     return new ClientScrollableHitSource(logger, backoffPolicy, threadPool, worker::countSearchRetry, this::finishHim, client, mainRequest.getSearchRequest()). }
true;protected;4;4;/**  * Build the response for reindex actions.  */ ;/**  * Build the response for reindex actions.  */ protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {     return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut). }
true;public;0;14;/**  * Start the action by firing the initial search request.  */ ;/**  * Start the action by firing the initial search request.  */ public void start() {     logger.debug("[{}]: starting", task.getId()).     if (task.isCancelled()) {         logger.debug("[{}]: finishing early because the task was cancelled", task.getId()).         finishHim(null).         return.     }     try {         startTime.set(System.nanoTime()).         scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response)).     } catch (Exception e) {         finishHim(e).     } }
false;protected;0;8;;@Override protected void doRun() throws Exception {     /*                  * It is important that the batch start time be calculated from here, scroll response to scroll response. That way the time                  * waiting on the scroll doesn't count against this batch in the throttle.                  */     prepareBulkRequest(timeValueNanos(System.nanoTime()), response). }
false;public;1;4;;@Override public void onFailure(Exception e) {     finishHim(e). }
true;;3;38;/**  * Process a scroll response.  * @param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay.  * @param lastBatchSize the size of the last batch. Used to calculate the throttling delay.  * @param response the scroll response to process  */ ;/**  * Process a scroll response.  * @param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay.  * @param lastBatchSize the size of the last batch. Used to calculate the throttling delay.  * @param response the scroll response to process  */ void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {     logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size()).     if (task.isCancelled()) {         logger.debug("[{}]: finishing early because the task was cancelled", task.getId()).         finishHim(null).         return.     }     if (// If any of the shards failed that should abort the request.     (response.getFailures().size() > 0) || // Timeouts aren't shard failures but we still need to pass them back to the user.     response.isTimedOut()) {         refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut()).         return.     }     long total = response.getTotalHits().     if (mainRequest.getSize() > 0) {         total = min(total, mainRequest.getSize()).     }     worker.setTotal(total).     AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {          @Override         protected void doRun() throws Exception {             /*                  * It is important that the batch start time be calculated from here, scroll response to scroll response. That way the time                  * waiting on the scroll doesn't count against this batch in the throttle.                  */             prepareBulkRequest(timeValueNanos(System.nanoTime()), response).         }          @Override         public void onFailure(Exception e) {             finishHim(e).         }     }.     prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable).     worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable). }
true;;2;32;/**  * Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any  * delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the  * thread may be blocked by the user script.  */ ;/**  * Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any  * delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the  * thread may be blocked by the user script.  */ void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {     logger.debug("[{}]: preparing bulk request", task.getId()).     if (task.isCancelled()) {         logger.debug("[{}]: finishing early because the task was cancelled", task.getId()).         finishHim(null).         return.     }     if (response.getHits().isEmpty()) {         refreshAndFinish(emptyList(), emptyList(), false).         return.     }     worker.countBatch().     List<? extends ScrollableHitSource.Hit> hits = response.getHits().     if (mainRequest.getSize() != SIZE_ALL_MATCHES) {         // Truncate the hits if we have more than the request size         long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed()).         if (remaining < hits.size()) {             hits = hits.subList(0, (int) remaining).         }     }     BulkRequest request = buildBulk(hits).     if (request.requests().isEmpty()) {         /*              * If we noop-ed the entire batch then just skip to the next batch or the BulkRequest would fail validation.              */         startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0).         return.     }     request.timeout(mainRequest.getTimeout()).     request.waitForActiveShards(mainRequest.getWaitForActiveShards()).     sendBulkRequest(thisBatchStartTime, request). }
false;public;1;4;;@Override public void onResponse(BulkResponse response) {     onBulkResponse(thisBatchStartTime, response). }
false;public;1;4;;@Override public void onFailure(Exception e) {     finishHim(e). }
true;;2;22;/**  * Send a bulk request, handling retries.  */ ;/**  * Send a bulk request, handling retries.  */ void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {     if (logger.isDebugEnabled()) {         logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(), new ByteSizeValue(request.estimatedSizeInBytes())).     }     if (task.isCancelled()) {         logger.debug("[{}]: finishing early because the task was cancelled", task.getId()).         finishHim(null).         return.     }     bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {          @Override         public void onResponse(BulkResponse response) {             onBulkResponse(thisBatchStartTime, response).         }          @Override         public void onFailure(Exception e) {             finishHim(e).         }     }). }
true;;2;53;/**  * Processes bulk responses, accounting for failures.  */ ;/**  * Processes bulk responses, accounting for failures.  */ void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {     try {         List<Failure> failures = new ArrayList<>().         Set<String> destinationIndicesThisBatch = new HashSet<>().         for (BulkItemResponse item : response) {             if (item.isFailed()) {                 recordFailure(item.getFailure(), failures).                 continue.             }             switch(item.getOpType()) {                 case CREATE:                 case INDEX:                     if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {                         worker.countCreated().                     } else {                         worker.countUpdated().                     }                     break.                 case UPDATE:                     worker.countUpdated().                     break.                 case DELETE:                     worker.countDeleted().                     break.             }             // Track the indexes we've seen so we can refresh them if requested             destinationIndicesThisBatch.add(item.getIndex()).         }         if (task.isCancelled()) {             logger.debug("[{}]: Finishing early because the task was cancelled", task.getId()).             finishHim(null).             return.         }         addDestinationIndices(destinationIndicesThisBatch).         if (false == failures.isEmpty()) {             refreshAndFinish(unmodifiableList(failures), emptyList(), false).             return.         }         if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {             // We've processed all the requested docs.             refreshAndFinish(emptyList(), emptyList(), false).             return.         }         startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length).     } catch (Exception t) {         finishHim(t).     } }
true;;3;11;/**  * Start the next scroll request.  *  * @param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied  *        when the scroll returns  */ ;/**  * Start the next scroll request.  *  * @param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied  *        when the scroll returns  */ void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {     if (task.isCancelled()) {         logger.debug("[{}]: finishing early because the task was cancelled", task.getId()).         finishHim(null).         return.     }     TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize).     scrollSource.startNextScroll(extraKeepAlive, response -> {         onScrollResponse(lastBatchStartTime, lastBatchSize, response).     }). }
false;private;2;9;;private void recordFailure(Failure failure, List<Failure> failures) {     if (failure.getStatus() == CONFLICT) {         worker.countVersionConflict().         if (false == mainRequest.isAbortOnVersionConflict()) {             return.         }     }     failures.add(failure). }
false;public;1;4;;@Override public void onResponse(RefreshResponse response) {     finishHim(null, indexingFailures, searchFailures, timedOut). }
false;public;1;4;;@Override public void onFailure(Exception e) {     finishHim(e). }
true;;3;20;/**  * Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to  * {@link #finishHim(Exception, List, List, boolean)}.  */ ;/**  * Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to  * {@link #finishHim(Exception, List, List, boolean)}.  */ void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {     if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {         finishHim(null, indexingFailures, searchFailures, timedOut).         return.     }     RefreshRequest refresh = new RefreshRequest().     refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()])).     logger.debug("[{}]: refreshing", task.getId()).     client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {          @Override         public void onResponse(RefreshResponse response) {             finishHim(null, indexingFailures, searchFailures, timedOut).         }          @Override         public void onFailure(Exception e) {             finishHim(e).         }     }). }
true;protected;1;4;/**  * Finish the request.  *  * @param failure if non null then the request failed catastrophically with this exception  */ ;/**  * Finish the request.  *  * @param failure if non null then the request failed catastrophically with this exception  */ protected void finishHim(Exception failure) {     logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure).     finishHim(failure, emptyList(), emptyList(), false). }
true;protected;4;14;/**  * Finish the request.  * @param failure if non null then the request failed catastrophically with this exception  * @param indexingFailures any indexing failures accumulated during the request  * @param searchFailures any search failures accumulated during the request  * @param timedOut have any of the sub-requests timed out?  */ ;/**  * Finish the request.  * @param failure if non null then the request failed catastrophically with this exception  * @param indexingFailures any indexing failures accumulated during the request  * @param searchFailures any search failures accumulated during the request  * @param timedOut have any of the sub-requests timed out?  */ protected void finishHim(Exception failure, List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {     logger.debug("[{}]: finishing without any catastrophic failures", task.getId()).     scrollSource.close(() -> {         if (failure == null) {             BulkByScrollResponse response = buildResponse(timeValueNanos(System.nanoTime() - startTime.get()), indexingFailures, searchFailures, timedOut).             listener.onResponse(response).         } else {             listener.onFailure(failure).         }     }). }
true;;0;3;/**  * Get the backoff policy for use with retries.  */ ;/**  * Get the backoff policy for use with retries.  */ BackoffPolicy buildBackoffPolicy() {     return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries()). }
true;;1;3;/**  * Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the  * request asks for a refresh.  */ ;/**  * Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the  * request asks for a refresh.  */ void addDestinationIndices(Collection<String> indices) {     destinationIndices.addAll(indices). }
true;;1;3;/**  * Set the last returned scrollId. Exists entirely for testing.  */ ;/**  * Set the last returned scrollId. Exists entirely for testing.  */ void setScroll(String scroll) {     scrollSource.setScroll(scroll). }
false;;1;1;;void setIndex(String index).
false;;0;1;;String getIndex().
false;;1;1;;void setType(String type).
false;;0;1;;String getType().
false;;1;1;;void setId(String id).
false;;0;1;;String getId().
false;;1;1;;void setVersion(long version).
false;;0;1;;long getVersion().
false;;1;1;;void setVersionType(VersionType versionType).
false;;1;1;;void setRouting(String routing).
false;;0;1;;String getRouting().
false;;1;1;;void setSource(Map<String, Object> source).
false;;0;1;;Map<String, Object> getSource().
false;;0;1;;Self self().
false;public;1;4;;@Override public void setIndex(String index) {     request.index(index). }
false;public;0;4;;@Override public String getIndex() {     return request.index(). }
false;public;1;4;;@Override public void setType(String type) {     request.type(type). }
false;public;0;4;;@Override public String getType() {     return request.type(). }
false;public;1;4;;@Override public void setId(String id) {     request.id(id). }
false;public;0;4;;@Override public String getId() {     return request.id(). }
false;public;1;4;;@Override public void setVersion(long version) {     request.version(version). }
false;public;0;4;;@Override public long getVersion() {     return request.version(). }
false;public;1;4;;@Override public void setVersionType(VersionType versionType) {     request.versionType(versionType). }
false;public;1;4;;@Override public void setRouting(String routing) {     request.routing(routing). }
false;public;0;4;;@Override public String getRouting() {     return request.routing(). }
false;public;0;4;;@Override public Map<String, Object> getSource() {     return request.sourceAsMap(). }
false;public;1;4;;@Override public void setSource(Map<String, Object> source) {     request.source(source). }
false;public;0;4;;@Override public IndexRequest self() {     return request. }
true;public,static;1;3;/**  * Wraps a {@link IndexRequest} in a {@link RequestWrapper}  */ ;/**  * Wraps a {@link IndexRequest} in a {@link RequestWrapper}  */ public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {     return new IndexRequestWrapper(request). }
false;public;1;4;;@Override public void setIndex(String index) {     request.index(index). }
false;public;0;4;;@Override public String getIndex() {     return request.index(). }
false;public;1;4;;@Override public void setType(String type) {     request.type(type). }
false;public;0;4;;@Override public String getType() {     return request.type(). }
false;public;1;4;;@Override public void setId(String id) {     request.id(id). }
false;public;0;4;;@Override public String getId() {     return request.id(). }
false;public;1;4;;@Override public void setVersion(long version) {     request.version(version). }
false;public;0;4;;@Override public long getVersion() {     return request.version(). }
false;public;1;4;;@Override public void setVersionType(VersionType versionType) {     request.versionType(versionType). }
false;public;1;4;;@Override public void setRouting(String routing) {     request.routing(routing). }
false;public;0;4;;@Override public String getRouting() {     return request.routing(). }
false;public;0;4;;@Override public Map<String, Object> getSource() {     throw new UnsupportedOperationException("unable to get source from action request [" + request.getClass() + "]"). }
false;public;1;4;;@Override public void setSource(Map<String, Object> source) {     throw new UnsupportedOperationException("unable to set [source] on action request [" + request.getClass() + "]"). }
false;public;0;4;;@Override public DeleteRequest self() {     return request. }
true;public,static;1;3;/**  * Wraps a {@link DeleteRequest} in a {@link RequestWrapper}  */ ;/**  * Wraps a {@link DeleteRequest} in a {@link RequestWrapper}  */ public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {     return new DeleteRequestWrapper(request). }
false;public;2;70;;@Override @SuppressWarnings("unchecked") public RequestWrapper<?> apply(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {     if (script == null) {         return request.     }     Map<String, Object> context = new HashMap<>().     context.put(IndexFieldMapper.NAME, doc.getIndex()).     context.put(TypeFieldMapper.NAME, doc.getType()).     context.put(IdFieldMapper.NAME, doc.getId()).     Long oldVersion = doc.getVersion().     context.put(VersionFieldMapper.NAME, oldVersion).     String oldRouting = doc.getRouting().     context.put(RoutingFieldMapper.NAME, oldRouting).     context.put(SourceFieldMapper.NAME, request.getSource()).     OpType oldOpType = OpType.INDEX.     context.put("op", oldOpType.toString()).     UpdateScript.Factory factory = scriptService.compile(script, UpdateScript.CONTEXT).     UpdateScript updateScript = factory.newInstance(params, context).     updateScript.execute().     String newOp = (String) context.remove("op").     if (newOp == null) {         throw new IllegalArgumentException("Script cleared operation type").     }     /*              * It'd be lovely to only set the source if we know its been modified              * but it isn't worth keeping two copies of it around just to check!              */     request.setSource((Map<String, Object>) context.remove(SourceFieldMapper.NAME)).     Object newValue = context.remove(IndexFieldMapper.NAME).     if (false == doc.getIndex().equals(newValue)) {         scriptChangedIndex(request, newValue).     }     newValue = context.remove(TypeFieldMapper.NAME).     if (false == doc.getType().equals(newValue)) {         scriptChangedType(request, newValue).     }     newValue = context.remove(IdFieldMapper.NAME).     if (false == doc.getId().equals(newValue)) {         scriptChangedId(request, newValue).     }     newValue = context.remove(VersionFieldMapper.NAME).     if (false == Objects.equals(oldVersion, newValue)) {         scriptChangedVersion(request, newValue).     }     /*              * Its important that routing comes after parent in case you want to              * change them both.              */     newValue = context.remove(RoutingFieldMapper.NAME).     if (false == Objects.equals(oldRouting, newValue)) {         scriptChangedRouting(request, newValue).     }     OpType newOpType = OpType.fromString(newOp).     if (newOpType != oldOpType) {         return scriptChangedOpType(request, oldOpType, newOpType).     }     if (false == context.isEmpty()) {         throw new IllegalArgumentException("Invalid fields added to context [" + String.join(",", context.keySet()) + ']').     }     return request. }
false;protected;3;15;;protected RequestWrapper<?> scriptChangedOpType(RequestWrapper<?> request, OpType oldOpType, OpType newOpType) {     switch(newOpType) {         case NOOP:             taskWorker.countNoop().             return null.         case DELETE:             RequestWrapper<DeleteRequest> delete = wrap(new DeleteRequest(request.getIndex(), request.getType(), request.getId())).             delete.setVersion(request.getVersion()).             delete.setVersionType(VersionType.INTERNAL).             delete.setRouting(request.getRouting()).             return delete.         default:             throw new IllegalArgumentException("Unsupported operation type change from [" + oldOpType + "] to [" + newOpType + "]").     } }
false;protected,abstract;2;1;;protected abstract void scriptChangedIndex(RequestWrapper<?> request, Object to).
false;protected,abstract;2;1;;protected abstract void scriptChangedType(RequestWrapper<?> request, Object to).
false;protected,abstract;2;1;;protected abstract void scriptChangedId(RequestWrapper<?> request, Object to).
false;protected,abstract;2;1;;protected abstract void scriptChangedVersion(RequestWrapper<?> request, Object to).
false;protected,abstract;2;1;;protected abstract void scriptChangedRouting(RequestWrapper<?> request, Object to).
false;public,static;1;14;;public static OpType fromString(String opType) {     String lowerOpType = opType.toLowerCase(Locale.ROOT).     switch(lowerOpType) {         case "noop":             return OpType.NOOP.         case "index":             return OpType.INDEX.         case "delete":             return OpType.DELETE.         default:             throw new IllegalArgumentException("Operation type [" + lowerOpType + "] not allowed, only " + Arrays.toString(values()) + " are allowed").     } }
false;public;0;4;;@Override public String toString() {     return id.toLowerCase(Locale.ROOT). }
