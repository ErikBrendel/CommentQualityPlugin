# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1524684173;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1526029249;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1533862840;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1537806831;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1538067637;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1548775385;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure);1548918365;Finish the request.__@param failure if non null then the request failed catastrophically with this exception;protected void finishHim(Exception failure) {_        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure)__        finishHim(failure, emptyList(), emptyList(), false)__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception;protected,void,finish,him,exception,failure,logger,debug,new,parameterized,message,finishing,with,a,catastrophic,failure,task,get,id,failure,finish,him,failure,empty,list,empty,list,false
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1524684173;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1526029249;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1533862840;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1537806831;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1538067637;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1548775385;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;1548918365;Build the {@link RequestWrapper} for a single search hit. This shouldn't handle_metadata or scripting. That will be handled by copyMetadata and_apply functions that can be overridden.;protected abstract RequestWrapper<?> buildRequest(ScrollableHitSource.Hit doc)_;build,the,link,request,wrapper,for,a,single,search,hit,this,shouldn,t,handle,metadata,or,scripting,that,will,be,handled,by,copy,metadata,and,apply,functions,that,can,be,overridden;protected,abstract,request,wrapper,build,request,scrollable,hit,source,hit,doc
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1524684173;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1526029249;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1533862840;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1537806831;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1538067637;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1548775385;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> void setScroll(String scroll);1548918365;Set the last returned scrollId. Exists entirely for testing.;void setScroll(String scroll) {_        scrollSource.setScroll(scroll)__    };set,the,last,returned,scroll,id,exists,entirely,for,testing;void,set,scroll,string,scroll,scroll,source,set,scroll,scroll
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1524684173;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1526029249;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1533862840;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1537806831;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1538067637;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1548775385;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier();1548918365;Build the {@link BiFunction} to apply to all {@link RequestWrapper}.__Public for testings....;public BiFunction<RequestWrapper<?>, ScrollableHitSource.Hit, RequestWrapper<?>> buildScriptApplier() {_        _        return (request, searchHit) -> request__    };build,the,link,bi,function,to,apply,to,all,link,request,wrapper,public,for,testings;public,bi,function,request,wrapper,scrollable,hit,source,hit,request,wrapper,build,script,applier,return,request,search,hit,request
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1524684173;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1526029249;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1533862840;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1537806831;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1538067637;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1548775385;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void addDestinationIndices(Collection<String> indices);1548918365;Add to the list of indices that were modified by this request. This is the list of indices refreshed at the end of the request if the_request asks for a refresh.;void addDestinationIndices(Collection<String> indices) {_        destinationIndices.addAll(indices)__    };add,to,the,list,of,indices,that,were,modified,by,this,request,this,is,the,list,of,indices,refreshed,at,the,end,of,the,request,if,the,request,asks,for,a,refresh;void,add,destination,indices,collection,string,indices,destination,indices,add,all,indices
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1524684173;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1526029249;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1533862840;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1537806831;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1538067637;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1548775385;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response);1548918365;Processes bulk responses, accounting for failures.;void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {_        try {_            List<Failure> failures = new ArrayList<>()__            Set<String> destinationIndicesThisBatch = new HashSet<>()__            for (BulkItemResponse item : response) {_                if (item.isFailed()) {_                    recordFailure(item.getFailure(), failures)__                    continue__                }_                switch (item.getOpType()) {_                    case CREATE:_                    case INDEX:_                        if (item.getResponse().getResult() == DocWriteResponse.Result.CREATED) {_                            worker.countCreated()__                        } else {_                            worker.countUpdated()__                        }_                        break__                    case UPDATE:_                        worker.countUpdated()__                        break__                    case DELETE:_                        worker.countDeleted()__                        break__                }_                _                destinationIndicesThisBatch.add(item.getIndex())__            }__            if (task.isCancelled()) {_                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId())__                finishHim(null)__                return__            }__            addDestinationIndices(destinationIndicesThisBatch)___            if (false == failures.isEmpty()) {_                refreshAndFinish(unmodifiableList(failures), emptyList(), false)__                return__            }__            if (mainRequest.getSize() != SIZE_ALL_MATCHES && worker.getSuccessfullyProcessed() >= mainRequest.getSize()) {_                _                refreshAndFinish(emptyList(), emptyList(), false)__                return__            }__            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), response.getItems().length)__        } catch (Exception t) {_            finishHim(t)__        }_    };processes,bulk,responses,accounting,for,failures;void,on,bulk,response,time,value,this,batch,start,time,bulk,response,response,try,list,failure,failures,new,array,list,set,string,destination,indices,this,batch,new,hash,set,for,bulk,item,response,item,response,if,item,is,failed,record,failure,item,get,failure,failures,continue,switch,item,get,op,type,case,create,case,index,if,item,get,response,get,result,doc,write,response,result,created,worker,count,created,else,worker,count,updated,break,case,update,worker,count,updated,break,case,delete,worker,count,deleted,break,destination,indices,this,batch,add,item,get,index,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,add,destination,indices,destination,indices,this,batch,if,false,failures,is,empty,refresh,and,finish,unmodifiable,list,failures,empty,list,false,return,if,main,request,get,size,worker,get,successfully,processed,main,request,get,size,refresh,and,finish,empty,list,empty,list,false,return,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,response,get,items,length,catch,exception,t,finish,him,t
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1524684173;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1526029249;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1533862840;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1537806831;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1538067637;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1548775385;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize);1548918365;Start the next scroll request.__@param lastBatchSize the number of requests sent in the last batch. This is used to calculate the throttling values which are applied_when the scroll returns;void startNextScroll(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        TimeValue extraKeepAlive = worker.throttleWaitTime(lastBatchStartTime, now, lastBatchSize)__        scrollSource.startNextScroll(extraKeepAlive, response -> {_            onScrollResponse(lastBatchStartTime, lastBatchSize, response)__        })__    };start,the,next,scroll,request,param,last,batch,size,the,number,of,requests,sent,in,the,last,batch,this,is,used,to,calculate,the,throttling,values,which,are,applied,when,the,scroll,returns;void,start,next,scroll,time,value,last,batch,start,time,time,value,now,int,last,batch,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,time,value,extra,keep,alive,worker,throttle,wait,time,last,batch,start,time,now,last,batch,size,scroll,source,start,next,scroll,extra,keep,alive,response,on,scroll,response,last,batch,start,time,last,batch,size,response
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1524684173;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1526029249;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1533862840;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1537806831;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1538067637;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1548775385;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<IndexRequest> wrap(IndexRequest request);1548918365;Wraps a {@link IndexRequest} in a {@link RequestWrapper};public static RequestWrapper<IndexRequest> wrap(IndexRequest request) {_        return new IndexRequestWrapper(request)__    };wraps,a,link,index,request,in,a,link,request,wrapper;public,static,request,wrapper,index,request,wrap,index,request,request,return,new,index,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1524684173;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1526029249;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1533862840;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1537806831;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1538067637;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1548775385;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request);1548918365;Wraps a {@link DeleteRequest} in a {@link RequestWrapper};public static RequestWrapper<DeleteRequest> wrap(DeleteRequest request) {_        return new DeleteRequestWrapper(request)__    };wraps,a,link,delete,request,in,a,link,request,wrapper;public,static,request,wrapper,delete,request,wrap,delete,request,request,return,new,delete,request,wrapper,request
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1524684173;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1526029249;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1533862840;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1537806831;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1538067637;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1548775385;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> protected void copyRouting(RequestWrapper<?> request, String routing);1548918365;Copy the routing from a search hit to the request.;protected void copyRouting(RequestWrapper<?> request, String routing) {_        request.setRouting(routing)__    };copy,the,routing,from,a,search,hit,to,the,request;protected,void,copy,routing,request,wrapper,request,string,routing,request,set,routing,routing
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1524684173;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }, settings)__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e,settings
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1526029249;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }, settings)__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e,settings
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1533862840;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }, settings)__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e,settings
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1537806831;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1538067637;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1548775385;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request);1548918365;Send a bulk request, handling retries.;void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {_        if (logger.isDebugEnabled()) {_            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),_                    new ByteSizeValue(request.estimatedSizeInBytes()))__        }_        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        bulkRetry.withBackoff(client::bulk, request, new ActionListener<BulkResponse>() {_            @Override_            public void onResponse(BulkResponse response) {_                onBulkResponse(thisBatchStartTime, response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };send,a,bulk,request,handling,retries;void,send,bulk,request,time,value,this,batch,start,time,bulk,request,request,if,logger,is,debug,enabled,logger,debug,sending,entry,bulk,request,task,get,id,request,requests,size,new,byte,size,value,request,estimated,size,in,bytes,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,bulk,retry,with,backoff,client,bulk,request,new,action,listener,bulk,response,override,public,void,on,response,bulk,response,response,on,bulk,response,this,batch,start,time,response,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1524684173;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1526029249;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1533862840;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1537806831;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1538067637;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1548775385;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> protected void finishHim(Exception failure, List<Failure> indexingFailures,             List<SearchFailure> searchFailures, boolean timedOut);1548918365;Finish the request._@param failure if non null then the request failed catastrophically with this exception_@param indexingFailures any indexing failures accumulated during the request_@param searchFailures any search failures accumulated during the request_@param timedOut have any of the sub-requests timed out?;protected void finishHim(Exception failure, List<Failure> indexingFailures,_            List<SearchFailure> searchFailures, boolean timedOut) {_        logger.debug("[{}]: finishing without any catastrophic failures", task.getId())__        scrollSource.close(() -> {_            if (failure == null) {_                BulkByScrollResponse response = buildResponse(_                        timeValueNanos(System.nanoTime() - startTime.get()),_                        indexingFailures, searchFailures, timedOut)__                listener.onResponse(response)__            } else {_                listener.onFailure(failure)__            }_        })__    };finish,the,request,param,failure,if,non,null,then,the,request,failed,catastrophically,with,this,exception,param,indexing,failures,any,indexing,failures,accumulated,during,the,request,param,search,failures,any,search,failures,accumulated,during,the,request,param,timed,out,have,any,of,the,sub,requests,timed,out;protected,void,finish,him,exception,failure,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,logger,debug,finishing,without,any,catastrophic,failures,task,get,id,scroll,source,close,if,failure,null,bulk,by,scroll,response,response,build,response,time,value,nanos,system,nano,time,start,time,get,indexing,failures,search,failures,timed,out,listener,on,response,response,else,listener,on,failure,failure
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1524684173;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1526029249;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1533862840;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1537806831;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1538067637;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1548775385;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response);1548918365;Process a scroll response._@param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay._@param lastBatchSize the size of the last batch. Used to calculate the throttling delay._@param response the scroll response to process;void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, ScrollableHitSource.Response response) {_        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (    _                (response.getFailures().size() > 0)_                _                || response.isTimedOut()_                ) {_            refreshAndFinish(emptyList(), response.getFailures(), response.isTimedOut())__            return__        }_        long total = response.getTotalHits()__        if (mainRequest.getSize() > 0) {_            total = min(total, mainRequest.getSize())__        }_        worker.setTotal(total)__        AbstractRunnable prepareBulkRequestRunnable = new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                _                prepareBulkRequest(timeValueNanos(System.nanoTime()), response)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        }__        prepareBulkRequestRunnable = (AbstractRunnable) threadPool.getThreadContext().preserveContext(prepareBulkRequestRunnable)__        worker.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable)__    };process,a,scroll,response,param,last,batch,start,time,the,time,when,the,last,batch,started,used,to,calculate,the,throttling,delay,param,last,batch,size,the,size,of,the,last,batch,used,to,calculate,the,throttling,delay,param,response,the,scroll,response,to,process;void,on,scroll,response,time,value,last,batch,start,time,int,last,batch,size,scrollable,hit,source,response,response,logger,debug,got,scroll,response,with,hits,task,get,id,response,get,hits,size,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,failures,size,0,response,is,timed,out,refresh,and,finish,empty,list,response,get,failures,response,is,timed,out,return,long,total,response,get,total,hits,if,main,request,get,size,0,total,min,total,main,request,get,size,worker,set,total,total,abstract,runnable,prepare,bulk,request,runnable,new,abstract,runnable,override,protected,void,do,run,throws,exception,prepare,bulk,request,time,value,nanos,system,nano,time,response,override,public,void,on,failure,exception,e,finish,him,e,prepare,bulk,request,runnable,abstract,runnable,thread,pool,get,thread,context,preserve,context,prepare,bulk,request,runnable,worker,delay,prepare,bulk,request,thread,pool,last,batch,start,time,last,batch,size,prepare,bulk,request,runnable
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1524684173;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1526029249;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1533862840;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1537806831;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1538067637;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1548775385;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut);1548918365;Start terminating a request that finished non-catastrophically by refreshing the modified indices and then proceeding to_{@link #finishHim(Exception, List, List, boolean)}.;void refreshAndFinish(List<Failure> indexingFailures, List<SearchFailure> searchFailures, boolean timedOut) {_        if (task.isCancelled() || false == mainRequest.isRefresh() || destinationIndices.isEmpty()) {_            finishHim(null, indexingFailures, searchFailures, timedOut)__            return__        }_        RefreshRequest refresh = new RefreshRequest()__        refresh.indices(destinationIndices.toArray(new String[destinationIndices.size()]))__        logger.debug("[{}]: refreshing", task.getId())__        client.admin().indices().refresh(refresh, new ActionListener<RefreshResponse>() {_            @Override_            public void onResponse(RefreshResponse response) {_                finishHim(null, indexingFailures, searchFailures, timedOut)__            }__            @Override_            public void onFailure(Exception e) {_                finishHim(e)__            }_        })__    };start,terminating,a,request,that,finished,non,catastrophically,by,refreshing,the,modified,indices,and,then,proceeding,to,link,finish,him,exception,list,list,boolean;void,refresh,and,finish,list,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,if,task,is,cancelled,false,main,request,is,refresh,destination,indices,is,empty,finish,him,null,indexing,failures,search,failures,timed,out,return,refresh,request,refresh,new,refresh,request,refresh,indices,destination,indices,to,array,new,string,destination,indices,size,logger,debug,refreshing,task,get,id,client,admin,indices,refresh,refresh,new,action,listener,refresh,response,override,public,void,on,response,refresh,response,response,finish,him,null,indexing,failures,search,failures,timed,out,override,public,void,on,failure,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> protected abstract boolean needsSourceDocumentVersions()_;1524684173;Does this operation need the versions of the source documents?;protected abstract boolean needsSourceDocumentVersions()_;does,this,operation,need,the,versions,of,the,source,documents;protected,abstract,boolean,needs,source,document,versions
AbstractAsyncBulkByScrollAction -> protected abstract boolean needsSourceDocumentVersions()_;1526029249;Does this operation need the versions of the source documents?;protected abstract boolean needsSourceDocumentVersions()_;does,this,operation,need,the,versions,of,the,source,documents;protected,abstract,boolean,needs,source,document,versions
AbstractAsyncBulkByScrollAction -> protected abstract boolean needsSourceDocumentVersions()_;1533862840;Does this operation need the versions of the source documents?;protected abstract boolean needsSourceDocumentVersions()_;does,this,operation,need,the,versions,of,the,source,documents;protected,abstract,boolean,needs,source,document,versions
AbstractAsyncBulkByScrollAction -> protected abstract boolean needsSourceDocumentVersions()_;1537806831;Does this operation need the versions of the source documents?;protected abstract boolean needsSourceDocumentVersions()_;does,this,operation,need,the,versions,of,the,source,documents;protected,abstract,boolean,needs,source,document,versions
AbstractAsyncBulkByScrollAction -> protected abstract boolean needsSourceDocumentVersions()_;1538067637;Does this operation need the versions of the source documents?;protected abstract boolean needsSourceDocumentVersions()_;does,this,operation,need,the,versions,of,the,source,documents;protected,abstract,boolean,needs,source,document,versions
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1524684173;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1526029249;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1533862840;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1537806831;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1538067637;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1548775385;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected boolean accept(ScrollableHitSource.Hit doc);1548918365;Used to accept or ignore a search hit. Ignored search hits will be excluded_from the bulk request. It is also where we fail on invalid search hits, like_when the document has no source but it's required.;protected boolean accept(ScrollableHitSource.Hit doc) {_        if (doc.getSource() == null) {_            _            throw new IllegalArgumentException("[" + doc.getIndex() + "][" + doc.getType() + "][" + doc.getId() + "] didn't store _source")__        }_        return true__    };used,to,accept,or,ignore,a,search,hit,ignored,search,hits,will,be,excluded,from,the,bulk,request,it,is,also,where,we,fail,on,invalid,search,hits,like,when,the,document,has,no,source,but,it,s,required;protected,boolean,accept,scrollable,hit,source,hit,doc,if,doc,get,source,null,throw,new,illegal,argument,exception,doc,get,index,doc,get,type,doc,get,id,didn,t,store,return,true
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1524684173;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1526029249;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1533862840;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1537806831;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1538067637;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1548775385;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,                                                       List<SearchFailure> searchFailures, boolean timedOut);1548918365;Build the response for reindex actions.;protected BulkByScrollResponse buildResponse(TimeValue took, List<BulkItemResponse.Failure> indexingFailures,_                                                      List<SearchFailure> searchFailures, boolean timedOut) {_        return new BulkByScrollResponse(took, task.getStatus(), indexingFailures, searchFailures, timedOut)__    };build,the,response,for,reindex,actions;protected,bulk,by,scroll,response,build,response,time,value,took,list,bulk,item,response,failure,indexing,failures,list,search,failure,search,failures,boolean,timed,out,return,new,bulk,by,scroll,response,took,task,get,status,indexing,failures,search,failures,timed,out
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1524684173;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1526029249;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1533862840;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1537806831;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1538067637;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1548775385;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response);1548918365;Prepare the bulk request. Called on the generic thread pool after some preflight checks have been done one the SearchResponse and any_delay has been slept. Uses the generic thread pool because reindex is rare enough not to need its own thread pool and because the_thread may be blocked by the user script.;void prepareBulkRequest(TimeValue thisBatchStartTime, ScrollableHitSource.Response response) {_        logger.debug("[{}]: preparing bulk request", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        if (response.getHits().isEmpty()) {_            refreshAndFinish(emptyList(), emptyList(), false)__            return__        }_        worker.countBatch()__        List<? extends ScrollableHitSource.Hit> hits = response.getHits()__        if (mainRequest.getSize() != SIZE_ALL_MATCHES) {_            _            long remaining = max(0, mainRequest.getSize() - worker.getSuccessfullyProcessed())__            if (remaining < hits.size()) {_                hits = hits.subList(0, (int) remaining)__            }_        }_        BulkRequest request = buildBulk(hits)__        if (request.requests().isEmpty()) {_            _            startNextScroll(thisBatchStartTime, timeValueNanos(System.nanoTime()), 0)__            return__        }_        request.timeout(mainRequest.getTimeout())__        request.waitForActiveShards(mainRequest.getWaitForActiveShards())__        sendBulkRequest(thisBatchStartTime, request)__    };prepare,the,bulk,request,called,on,the,generic,thread,pool,after,some,preflight,checks,have,been,done,one,the,search,response,and,any,delay,has,been,slept,uses,the,generic,thread,pool,because,reindex,is,rare,enough,not,to,need,its,own,thread,pool,and,because,the,thread,may,be,blocked,by,the,user,script;void,prepare,bulk,request,time,value,this,batch,start,time,scrollable,hit,source,response,response,logger,debug,preparing,bulk,request,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,if,response,get,hits,is,empty,refresh,and,finish,empty,list,empty,list,false,return,worker,count,batch,list,extends,scrollable,hit,source,hit,hits,response,get,hits,if,main,request,get,size,long,remaining,max,0,main,request,get,size,worker,get,successfully,processed,if,remaining,hits,size,hits,hits,sub,list,0,int,remaining,bulk,request,request,build,bulk,hits,if,request,requests,is,empty,start,next,scroll,this,batch,start,time,time,value,nanos,system,nano,time,0,return,request,timeout,main,request,get,timeout,request,wait,for,active,shards,main,request,get,wait,for,active,shards,send,bulk,request,this,batch,start,time,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1524684173;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1526029249;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1533862840;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1537806831;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1538067637;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1548775385;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc);1548918365;Copies the metadata from a hit to the request.;protected RequestWrapper<?> copyMetadata(RequestWrapper<?> request, ScrollableHitSource.Hit doc) {_        copyRouting(request, doc.getRouting())__        return request__    };copies,the,metadata,from,a,hit,to,the,request;protected,request,wrapper,copy,metadata,request,wrapper,request,scrollable,hit,source,hit,doc,copy,routing,request,doc,get,routing,return,request
AbstractAsyncBulkByScrollAction -> public void start();1524684173;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> public void start();1526029249;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> public void start();1533862840;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> public void start();1537806831;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> public void start();1538067637;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> public void start();1548775385;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> public void start();1548918365;Start the action by firing the initial search request.;public void start() {_        logger.debug("[{}]: starting", task.getId())__        if (task.isCancelled()) {_            logger.debug("[{}]: finishing early because the task was cancelled", task.getId())__            finishHim(null)__            return__        }_        try {_            startTime.set(System.nanoTime())__            scrollSource.start(response -> onScrollResponse(timeValueNanos(System.nanoTime()), 0, response))__        } catch (Exception e) {_            finishHim(e)__        }_    };start,the,action,by,firing,the,initial,search,request;public,void,start,logger,debug,starting,task,get,id,if,task,is,cancelled,logger,debug,finishing,early,because,the,task,was,cancelled,task,get,id,finish,him,null,return,try,start,time,set,system,nano,time,scroll,source,start,response,on,scroll,response,time,value,nanos,system,nano,time,0,response,catch,exception,e,finish,him,e
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1524684173;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1526029249;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1533862840;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1537806831;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1538067637;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1548775385;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
AbstractAsyncBulkByScrollAction -> BackoffPolicy buildBackoffPolicy();1548918365;Get the backoff policy for use with retries.;BackoffPolicy buildBackoffPolicy() {_        return exponentialBackoff(mainRequest.getRetryBackoffInitialTime(), mainRequest.getMaxRetries())__    };get,the,backoff,policy,for,use,with,retries;backoff,policy,build,backoff,policy,return,exponential,backoff,main,request,get,retry,backoff,initial,time,main,request,get,max,retries
