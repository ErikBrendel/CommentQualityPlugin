commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "reindex_action". }
false;public;2;4;;@Override public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {     return doPrepareRequest(request, client, true, true). }
false;protected;1;15;;@Override protected ReindexRequest buildRequest(RestRequest request) throws IOException {     if (request.hasParam("pipeline")) {         throw new IllegalArgumentException("_reindex doesn't support [pipeline] as a query parameter. " + "Specify it in the [dest] object instead.").     }     ReindexRequest internal = new ReindexRequest().     try (XContentParser parser = request.contentParser()) {         PARSER.parse(parser, internal, null).     }     if (request.hasParam("scroll")) {         internal.setScroll(parseTimeValue(request.param("scroll"), "scroll")).     }     return internal. }
false;static;1;40;;static RemoteInfo buildRemoteInfo(Map<String, Object> source) throws IOException {     @SuppressWarnings("unchecked")     Map<String, Object> remote = (Map<String, Object>) source.remove("remote").     if (remote == null) {         return null.     }     String username = extractString(remote, "username").     String password = extractString(remote, "password").     String hostInRequest = requireNonNull(extractString(remote, "host"), "[host] must be specified to reindex from a remote cluster").     URI uri.     try {         uri = new URI(hostInRequest).         // URI has less stringent URL parsing than our code. We want to fail if all values are not provided.         if (uri.getPort() == -1) {             throw new URISyntaxException(hostInRequest, "The port was not defined in the [host]").         }     } catch (URISyntaxException ex) {         throw new IllegalArgumentException("[host] must be of the form [scheme]://[host]:[port](/[pathPrefix])? but was [" + hostInRequest + "]", ex).     }     String scheme = uri.getScheme().     String host = uri.getHost().     int port = uri.getPort().     String pathPrefix = null.     if (uri.getPath().isEmpty() == false) {         pathPrefix = uri.getPath().     }     Map<String, String> headers = extractStringStringMap(remote, "headers").     TimeValue socketTimeout = extractTimeValue(remote, "socket_timeout", RemoteInfo.DEFAULT_SOCKET_TIMEOUT).     TimeValue connectTimeout = extractTimeValue(remote, "connect_timeout", RemoteInfo.DEFAULT_CONNECT_TIMEOUT).     if (false == remote.isEmpty()) {         throw new IllegalArgumentException("Unsupported fields in [remote]: [" + Strings.collectionToCommaDelimitedString(remote.keySet()) + "]").     }     return new RemoteInfo(scheme, host, port, pathPrefix, queryForRemote(source), username, password, headers, socketTimeout, connectTimeout). }
true;private,static;2;15;/**  * Yank a string array from a map. Emulates XContent's permissive String to  * String array conversions.  */ ;/**  * Yank a string array from a map. Emulates XContent's permissive String to  * String array conversions.  */ private static String[] extractStringArray(Map<String, Object> source, String name) {     Object value = source.remove(name).     if (value == null) {         return null.     }     if (value instanceof List) {         @SuppressWarnings("unchecked")         List<String> list = (List<String>) value.         return list.toArray(new String[list.size()]).     } else if (value instanceof String) {         return new String[] { (String) value }.     } else {         throw new IllegalArgumentException("Expected [" + name + "] to be a list of a string but was [" + value + ']').     } }
false;private,static;2;10;;private static String extractString(Map<String, Object> source, String name) {     Object value = source.remove(name).     if (value == null) {         return null.     }     if (value instanceof String) {         return (String) value.     }     throw new IllegalArgumentException("Expected [" + name + "] to be a string but was [" + value + "]"). }
false;private,static;2;18;;private static Map<String, String> extractStringStringMap(Map<String, Object> source, String name) {     Object value = source.remove(name).     if (value == null) {         return emptyMap().     }     if (false == value instanceof Map) {         throw new IllegalArgumentException("Expected [" + name + "] to be an object containing strings but was [" + value + "]").     }     Map<?, ?> map = (Map<?, ?>) value.     for (Map.Entry<?, ?> entry : map.entrySet()) {         if (false == entry.getKey() instanceof String || false == entry.getValue() instanceof String) {             throw new IllegalArgumentException("Expected [" + name + "] to be an object containing strings but has [" + entry + "]").         }     }     // We just checked....     @SuppressWarnings("unchecked")     Map<String, String> safe = (Map<String, String>) map.     return safe. }
false;private,static;3;4;;private static TimeValue extractTimeValue(Map<String, Object> source, String name, TimeValue defaultValue) {     String string = extractString(source, name).     return string == null ? defaultValue : parseTimeValue(string, name). }
false;private,static;1;13;;private static BytesReference queryForRemote(Map<String, Object> source) throws IOException {     XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint().     Object query = source.remove("query").     if (query == null) {         return BytesReference.bytes(matchAllQuery().toXContent(builder, ToXContent.EMPTY_PARAMS)).     }     if (!(query instanceof Map)) {         throw new IllegalArgumentException("Expected [query] to be an object but was [" + query + "]").     }     @SuppressWarnings("unchecked")     Map<String, Object> map = (Map<String, Object>) query.     return BytesReference.bytes(builder.map(map)). }
