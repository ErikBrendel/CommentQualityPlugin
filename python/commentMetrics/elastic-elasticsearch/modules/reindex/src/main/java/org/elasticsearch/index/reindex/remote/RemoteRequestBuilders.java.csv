commented;modifiers;parameterAmount;loc;comment;code
false;static;3;106;;static Request initialSearch(SearchRequest searchRequest, BytesReference query, Version remoteVersion) {     // It is nasty to build paths with StringBuilder but we'll be careful....     StringBuilder path = new StringBuilder("/").     addIndexesOrTypes(path, "Index", searchRequest.indices()).     addIndexesOrTypes(path, "Type", searchRequest.types()).     path.append("_search").     Request request = new Request("POST", path.toString()).     if (searchRequest.scroll() != null) {         TimeValue keepAlive = searchRequest.scroll().keepAlive().         // V_5_0_0         if (remoteVersion.before(Version.fromId(5000099))) {             /* Versions of Elasticsearch before 5.0 couldn't parse nanos or micros                  * so we toss out that resolution, rounding up because more scroll                  * timeout seems safer than less. */             keepAlive = timeValueMillis((long) Math.ceil(keepAlive.millisFrac())).         }         request.addParameter("scroll", keepAlive.getStringRep()).     }     request.addParameter("size", Integer.toString(searchRequest.source().size())).     if (searchRequest.source().version() == null || searchRequest.source().version() == true) {         /*              * Passing `null` here just add the `version` request parameter              * without any value. This way of requesting the version works              * for all supported versions of Elasticsearch.              */         request.addParameter("version", null).     }     if (searchRequest.source().sorts() != null) {         boolean useScan = false.         // Detect if we should use search_type=scan rather than a sort         if (remoteVersion.before(Version.fromId(2010099))) {             for (SortBuilder<?> sort : searchRequest.source().sorts()) {                 if (sort instanceof FieldSortBuilder) {                     FieldSortBuilder f = (FieldSortBuilder) sort.                     if (f.getFieldName().equals(FieldSortBuilder.DOC_FIELD_NAME)) {                         useScan = true.                         break.                     }                 }             }         }         if (useScan) {             request.addParameter("search_type", "scan").         } else {             StringBuilder sorts = new StringBuilder(sortToUri(searchRequest.source().sorts().get(0))).             for (int i = 1. i < searchRequest.source().sorts().size(). i++) {                 sorts.append(',').append(sortToUri(searchRequest.source().sorts().get(i))).             }             request.addParameter("sort", sorts.toString()).         }     }     if (remoteVersion.before(Version.fromId(2000099))) {         // Versions before 2.0.0 need prompting to return interesting fields. Note that timestamp isn't available at all....         searchRequest.source().storedField("_parent").storedField("_routing").storedField("_ttl").         if (remoteVersion.before(Version.fromId(1000099))) {             // Versions before 1.0.0 don't support `"_source": true` so we have to ask for the _source in a funny way.             if (false == searchRequest.source().storedFields().fieldNames().contains("_source")) {                 searchRequest.source().storedField("_source").             }         }     }     if (searchRequest.source().storedFields() != null && false == searchRequest.source().storedFields().fieldNames().isEmpty()) {         StringBuilder fields = new StringBuilder(searchRequest.source().storedFields().fieldNames().get(0)).         for (int i = 1. i < searchRequest.source().storedFields().fieldNames().size(). i++) {             fields.append(',').append(searchRequest.source().storedFields().fieldNames().get(i)).         }         // V_5_0_0         String storedFieldsParamName = remoteVersion.before(Version.fromId(5000099)) ? "fields" : "stored_fields".         request.addParameter(storedFieldsParamName, fields.toString()).     }     // EMPTY is safe here because we're not calling namedObject     try (XContentBuilder entity = JsonXContent.contentBuilder().         XContentParser queryParser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, query)) {         entity.startObject().         entity.field("query").         {             /* We're intentionally a bit paranoid here - copying the query                  * as xcontent rather than writing a raw field. We don't want                  * poorly written queries to escape. Ever. */             entity.copyCurrentStructure(queryParser).             XContentParser.Token shouldBeEof = queryParser.nextToken().             if (shouldBeEof != null) {                 throw new ElasticsearchException("query was more than a single object. This first token after the object is [" + shouldBeEof + "]").             }         }         if (searchRequest.source().fetchSource() != null) {             entity.field("_source", searchRequest.source().fetchSource()).         } else {             if (remoteVersion.onOrAfter(Version.fromId(1000099))) {                 // Versions before 1.0 don't support `"_source": true` so we have to ask for the source as a stored field.                 entity.field("_source", true).             }         }         entity.endObject().         request.setJsonEntity(Strings.toString(entity)).     } catch (IOException e) {         throw new ElasticsearchException("unexpected error building entity", e).     }     return request. }
false;private,static;3;9;;private static void addIndexesOrTypes(StringBuilder path, String name, String[] indicesOrTypes) {     if (indicesOrTypes == null || indicesOrTypes.length == 0) {         return.     }     for (String indexOrType : indicesOrTypes) {         checkIndexOrType(name, indexOrType).     }     path.append(Strings.arrayToCommaDelimitedString(indicesOrTypes)).append('/'). }
false;private,static;2;8;;private static void checkIndexOrType(String name, String indexOrType) {     if (indexOrType.indexOf(',') >= 0) {         throw new IllegalArgumentException(name + " containing [,] not supported but got [" + indexOrType + "]").     }     if (indexOrType.indexOf('/') >= 0) {         throw new IllegalArgumentException(name + " containing [/] not supported but got [" + indexOrType + "]").     } }
false;private,static;1;7;;private static String sortToUri(SortBuilder<?> sort) {     if (sort instanceof FieldSortBuilder) {         FieldSortBuilder f = (FieldSortBuilder) sort.         return f.getFieldName() + ":" + f.order().     }     throw new IllegalArgumentException("Unsupported sort [" + sort + "]"). }
false;static;3;28;;static Request scroll(String scroll, TimeValue keepAlive, Version remoteVersion) {     Request request = new Request("POST", "/_search/scroll").     // V_5_0_0     if (remoteVersion.before(Version.fromId(5000099))) {         /* Versions of Elasticsearch before 5.0 couldn't parse nanos or micros              * so we toss out that resolution, rounding up so we shouldn't end up              * with 0s. */         keepAlive = timeValueMillis((long) Math.ceil(keepAlive.millisFrac())).     }     request.addParameter("scroll", keepAlive.getStringRep()).     if (remoteVersion.before(Version.fromId(2000099))) {         // Versions before 2.0.0 extract the plain scroll_id from the body         request.setEntity(new NStringEntity(scroll, ContentType.TEXT_PLAIN)).         return request.     }     try (XContentBuilder entity = JsonXContent.contentBuilder()) {         entity.startObject().field("scroll_id", scroll).endObject().         request.setJsonEntity(Strings.toString(entity)).     } catch (IOException e) {         throw new ElasticsearchException("failed to build scroll entity", e).     }     return request. }
false;static;2;18;;static Request clearScroll(String scroll, Version remoteVersion) {     Request request = new Request("DELETE", "/_search/scroll").     if (remoteVersion.before(Version.fromId(2000099))) {         // Versions before 2.0.0 extract the plain scroll_id from the body         request.setEntity(new NStringEntity(scroll, ContentType.TEXT_PLAIN)).         return request.     }     try (XContentBuilder entity = JsonXContent.contentBuilder()) {         entity.startObject().array("scroll_id", scroll).endObject().         request.setJsonEntity(Strings.toString(entity)).     } catch (IOException e) {         throw new ElasticsearchException("failed to build clear scroll entity", e).     }     return request. }
