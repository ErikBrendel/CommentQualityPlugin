# id;timestamp;commentText;codeText;commentWords;codeWords
BulkByScrollParallelizationHelper -> static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times);1524684173;Slice a search request into {@code times} separate search requests slicing on {@code field}. Note that the slices are *shallow*_copies of this request so don't change them.;static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times) {_        SearchRequest[] slices = new SearchRequest[times]__        for (int slice = 0_ slice < times_ slice++) {_            SliceBuilder sliceBuilder = new SliceBuilder(field, slice, times)__            SearchSourceBuilder slicedSource__            if (request.source() == null) {_                slicedSource = new SearchSourceBuilder().slice(sliceBuilder)__            } else {_                if (request.source().slice() != null) {_                    throw new IllegalStateException("Can't slice a request that already has a slice configuration")__                }_                slicedSource = request.source().copyWithNewSlice(sliceBuilder)__            }_            slices[slice] = new SearchRequest()_                    .source(slicedSource)_                    .searchType(request.searchType())_                    .indices(request.indices())_                    .types(request.types())_                    .routing(request.routing())_                    .preference(request.preference())_                    .requestCache(request.requestCache())_                    .scroll(request.scroll())_                    .indicesOptions(request.indicesOptions())__            if (request.allowPartialSearchResults() != null) {_                slices[slice].allowPartialSearchResults(request.allowPartialSearchResults())__            }_        }_        return slices__    };slice,a,search,request,into,code,times,separate,search,requests,slicing,on,code,field,note,that,the,slices,are,shallow,copies,of,this,request,so,don,t,change,them;static,search,request,slice,into,sub,requests,search,request,request,string,field,int,times,search,request,slices,new,search,request,times,for,int,slice,0,slice,times,slice,slice,builder,slice,builder,new,slice,builder,field,slice,times,search,source,builder,sliced,source,if,request,source,null,sliced,source,new,search,source,builder,slice,slice,builder,else,if,request,source,slice,null,throw,new,illegal,state,exception,can,t,slice,a,request,that,already,has,a,slice,configuration,sliced,source,request,source,copy,with,new,slice,slice,builder,slices,slice,new,search,request,source,sliced,source,search,type,request,search,type,indices,request,indices,types,request,types,routing,request,routing,preference,request,preference,request,cache,request,request,cache,scroll,request,scroll,indices,options,request,indices,options,if,request,allow,partial,search,results,null,slices,slice,allow,partial,search,results,request,allow,partial,search,results,return,slices
BulkByScrollParallelizationHelper -> static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times);1527840262;Slice a search request into {@code times} separate search requests slicing on {@code field}. Note that the slices are *shallow*_copies of this request so don't change them.;static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times) {_        SearchRequest[] slices = new SearchRequest[times]__        for (int slice = 0_ slice < times_ slice++) {_            SliceBuilder sliceBuilder = new SliceBuilder(field, slice, times)__            SearchSourceBuilder slicedSource__            if (request.source() == null) {_                slicedSource = new SearchSourceBuilder().slice(sliceBuilder)__            } else {_                if (request.source().slice() != null) {_                    throw new IllegalStateException("Can't slice a request that already has a slice configuration")__                }_                slicedSource = request.source().copyWithNewSlice(sliceBuilder)__            }_            slices[slice] = new SearchRequest()_                    .source(slicedSource)_                    .searchType(request.searchType())_                    .indices(request.indices())_                    .types(request.types())_                    .routing(request.routing())_                    .preference(request.preference())_                    .requestCache(request.requestCache())_                    .scroll(request.scroll())_                    .indicesOptions(request.indicesOptions())__            if (request.allowPartialSearchResults() != null) {_                slices[slice].allowPartialSearchResults(request.allowPartialSearchResults())__            }_        }_        return slices__    };slice,a,search,request,into,code,times,separate,search,requests,slicing,on,code,field,note,that,the,slices,are,shallow,copies,of,this,request,so,don,t,change,them;static,search,request,slice,into,sub,requests,search,request,request,string,field,int,times,search,request,slices,new,search,request,times,for,int,slice,0,slice,times,slice,slice,builder,slice,builder,new,slice,builder,field,slice,times,search,source,builder,sliced,source,if,request,source,null,sliced,source,new,search,source,builder,slice,slice,builder,else,if,request,source,slice,null,throw,new,illegal,state,exception,can,t,slice,a,request,that,already,has,a,slice,configuration,sliced,source,request,source,copy,with,new,slice,slice,builder,slices,slice,new,search,request,source,sliced,source,search,type,request,search,type,indices,request,indices,types,request,types,routing,request,routing,preference,request,preference,request,cache,request,request,cache,scroll,request,scroll,indices,options,request,indices,options,if,request,allow,partial,search,results,null,slices,slice,allow,partial,search,results,request,allow,partial,search,results,return,slices
BulkByScrollParallelizationHelper -> static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times);1529433467;Slice a search request into {@code times} separate search requests slicing on {@code field}. Note that the slices are *shallow*_copies of this request so don't change them.;static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times) {_        SearchRequest[] slices = new SearchRequest[times]__        for (int slice = 0_ slice < times_ slice++) {_            SliceBuilder sliceBuilder = new SliceBuilder(field, slice, times)__            SearchSourceBuilder slicedSource__            if (request.source() == null) {_                slicedSource = new SearchSourceBuilder().slice(sliceBuilder)__            } else {_                if (request.source().slice() != null) {_                    throw new IllegalStateException("Can't slice a request that already has a slice configuration")__                }_                slicedSource = request.source().copyWithNewSlice(sliceBuilder)__            }_            slices[slice] = new SearchRequest()_                    .source(slicedSource)_                    .searchType(request.searchType())_                    .indices(request.indices())_                    .types(request.types())_                    .routing(request.routing())_                    .preference(request.preference())_                    .requestCache(request.requestCache())_                    .scroll(request.scroll())_                    .indicesOptions(request.indicesOptions())__            if (request.allowPartialSearchResults() != null) {_                slices[slice].allowPartialSearchResults(request.allowPartialSearchResults())__            }_        }_        return slices__    };slice,a,search,request,into,code,times,separate,search,requests,slicing,on,code,field,note,that,the,slices,are,shallow,copies,of,this,request,so,don,t,change,them;static,search,request,slice,into,sub,requests,search,request,request,string,field,int,times,search,request,slices,new,search,request,times,for,int,slice,0,slice,times,slice,slice,builder,slice,builder,new,slice,builder,field,slice,times,search,source,builder,sliced,source,if,request,source,null,sliced,source,new,search,source,builder,slice,slice,builder,else,if,request,source,slice,null,throw,new,illegal,state,exception,can,t,slice,a,request,that,already,has,a,slice,configuration,sliced,source,request,source,copy,with,new,slice,slice,builder,slices,slice,new,search,request,source,sliced,source,search,type,request,search,type,indices,request,indices,types,request,types,routing,request,routing,preference,request,preference,request,cache,request,request,cache,scroll,request,scroll,indices,options,request,indices,options,if,request,allow,partial,search,results,null,slices,slice,allow,partial,search,results,request,allow,partial,search,results,return,slices
BulkByScrollParallelizationHelper -> static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times);1544808629;Slice a search request into {@code times} separate search requests slicing on {@code field}. Note that the slices are *shallow*_copies of this request so don't change them.;static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times) {_        SearchRequest[] slices = new SearchRequest[times]__        for (int slice = 0_ slice < times_ slice++) {_            SliceBuilder sliceBuilder = new SliceBuilder(field, slice, times)__            SearchSourceBuilder slicedSource__            if (request.source() == null) {_                slicedSource = new SearchSourceBuilder().slice(sliceBuilder)__            } else {_                if (request.source().slice() != null) {_                    throw new IllegalStateException("Can't slice a request that already has a slice configuration")__                }_                slicedSource = request.source().copyWithNewSlice(sliceBuilder)__            }_            SearchRequest searchRequest = new SearchRequest(request)__            searchRequest.source(slicedSource)__            slices[slice] = searchRequest__        }_        return slices__    };slice,a,search,request,into,code,times,separate,search,requests,slicing,on,code,field,note,that,the,slices,are,shallow,copies,of,this,request,so,don,t,change,them;static,search,request,slice,into,sub,requests,search,request,request,string,field,int,times,search,request,slices,new,search,request,times,for,int,slice,0,slice,times,slice,slice,builder,slice,builder,new,slice,builder,field,slice,times,search,source,builder,sliced,source,if,request,source,null,sliced,source,new,search,source,builder,slice,slice,builder,else,if,request,source,slice,null,throw,new,illegal,state,exception,can,t,slice,a,request,that,already,has,a,slice,configuration,sliced,source,request,source,copy,with,new,slice,slice,builder,search,request,search,request,new,search,request,request,search,request,source,sliced,source,slices,slice,search,request,return,slices
BulkByScrollParallelizationHelper -> static <Request extends AbstractBulkByScrollRequest<Request>> void startSlicedAction(             Request request,             BulkByScrollTask task,             Action<BulkByScrollResponse> action,             ActionListener<BulkByScrollResponse> listener,             Client client,             DiscoveryNode node,             Runnable workerAction);1529433467;Takes an action created by a {@link BulkByScrollTask} and runs it with regard to whether the request is sliced or not.__If the request is not sliced (i.e. the number of slices is 1), the worker action in the given {@link Runnable} will be started on_the local node. If the request is sliced (i.e. the number of slices is more than 1), then a subrequest will be created for each_slice and sent.__If slices are set as {@code "auto"}, this class will resolve that to a specific number based on characteristics of the source_indices. A request with {@code "auto"} slices may end up being sliced or unsliced.;static <Request extends AbstractBulkByScrollRequest<Request>> void startSlicedAction(_            Request request,_            BulkByScrollTask task,_            Action<BulkByScrollResponse> action,_            ActionListener<BulkByScrollResponse> listener,_            Client client,_            DiscoveryNode node,_            Runnable workerAction) {__        if (request.getSlices() == AbstractBulkByScrollRequest.AUTO_SLICES) {_            ClusterSearchShardsRequest shardsRequest = new ClusterSearchShardsRequest()__            shardsRequest.indices(request.getSearchRequest().indices())__            client.admin().cluster().searchShards(shardsRequest, ActionListener.wrap(_                response -> {_                    int actualNumSlices = countSlicesBasedOnShards(response)__                    sliceConditionally(request, task, action, listener, client, node, workerAction, actualNumSlices)__                },_                listener::onFailure_            ))__        } else {_            sliceConditionally(request, task, action, listener, client, node, workerAction, request.getSlices())__        }_    };takes,an,action,created,by,a,link,bulk,by,scroll,task,and,runs,it,with,regard,to,whether,the,request,is,sliced,or,not,if,the,request,is,not,sliced,i,e,the,number,of,slices,is,1,the,worker,action,in,the,given,link,runnable,will,be,started,on,the,local,node,if,the,request,is,sliced,i,e,the,number,of,slices,is,more,than,1,then,a,subrequest,will,be,created,for,each,slice,and,sent,if,slices,are,set,as,code,auto,this,class,will,resolve,that,to,a,specific,number,based,on,characteristics,of,the,source,indices,a,request,with,code,auto,slices,may,end,up,being,sliced,or,unsliced;static,request,extends,abstract,bulk,by,scroll,request,request,void,start,sliced,action,request,request,bulk,by,scroll,task,task,action,bulk,by,scroll,response,action,action,listener,bulk,by,scroll,response,listener,client,client,discovery,node,node,runnable,worker,action,if,request,get,slices,abstract,bulk,by,scroll,request,cluster,search,shards,request,shards,request,new,cluster,search,shards,request,shards,request,indices,request,get,search,request,indices,client,admin,cluster,search,shards,shards,request,action,listener,wrap,response,int,actual,num,slices,count,slices,based,on,shards,response,slice,conditionally,request,task,action,listener,client,node,worker,action,actual,num,slices,listener,on,failure,else,slice,conditionally,request,task,action,listener,client,node,worker,action,request,get,slices
BulkByScrollParallelizationHelper -> static <Request extends AbstractBulkByScrollRequest<Request>> void startSlicedAction(             Request request,             BulkByScrollTask task,             Action<BulkByScrollResponse> action,             ActionListener<BulkByScrollResponse> listener,             Client client,             DiscoveryNode node,             Runnable workerAction);1544808629;Takes an action created by a {@link BulkByScrollTask} and runs it with regard to whether the request is sliced or not.__If the request is not sliced (i.e. the number of slices is 1), the worker action in the given {@link Runnable} will be started on_the local node. If the request is sliced (i.e. the number of slices is more than 1), then a subrequest will be created for each_slice and sent.__If slices are set as {@code "auto"}, this class will resolve that to a specific number based on characteristics of the source_indices. A request with {@code "auto"} slices may end up being sliced or unsliced.;static <Request extends AbstractBulkByScrollRequest<Request>> void startSlicedAction(_            Request request,_            BulkByScrollTask task,_            Action<BulkByScrollResponse> action,_            ActionListener<BulkByScrollResponse> listener,_            Client client,_            DiscoveryNode node,_            Runnable workerAction) {__        if (request.getSlices() == AbstractBulkByScrollRequest.AUTO_SLICES) {_            ClusterSearchShardsRequest shardsRequest = new ClusterSearchShardsRequest()__            shardsRequest.indices(request.getSearchRequest().indices())__            client.admin().cluster().searchShards(shardsRequest, ActionListener.wrap(_                response -> {_                    int actualNumSlices = countSlicesBasedOnShards(response)__                    sliceConditionally(request, task, action, listener, client, node, workerAction, actualNumSlices)__                },_                listener::onFailure_            ))__        } else {_            sliceConditionally(request, task, action, listener, client, node, workerAction, request.getSlices())__        }_    };takes,an,action,created,by,a,link,bulk,by,scroll,task,and,runs,it,with,regard,to,whether,the,request,is,sliced,or,not,if,the,request,is,not,sliced,i,e,the,number,of,slices,is,1,the,worker,action,in,the,given,link,runnable,will,be,started,on,the,local,node,if,the,request,is,sliced,i,e,the,number,of,slices,is,more,than,1,then,a,subrequest,will,be,created,for,each,slice,and,sent,if,slices,are,set,as,code,auto,this,class,will,resolve,that,to,a,specific,number,based,on,characteristics,of,the,source,indices,a,request,with,code,auto,slices,may,end,up,being,sliced,or,unsliced;static,request,extends,abstract,bulk,by,scroll,request,request,void,start,sliced,action,request,request,bulk,by,scroll,task,task,action,bulk,by,scroll,response,action,action,listener,bulk,by,scroll,response,listener,client,client,discovery,node,node,runnable,worker,action,if,request,get,slices,abstract,bulk,by,scroll,request,cluster,search,shards,request,shards,request,new,cluster,search,shards,request,shards,request,indices,request,get,search,request,indices,client,admin,cluster,search,shards,shards,request,action,listener,wrap,response,int,actual,num,slices,count,slices,based,on,shards,response,slice,conditionally,request,task,action,listener,client,node,worker,action,actual,num,slices,listener,on,failure,else,slice,conditionally,request,task,action,listener,client,node,worker,action,request,get,slices
