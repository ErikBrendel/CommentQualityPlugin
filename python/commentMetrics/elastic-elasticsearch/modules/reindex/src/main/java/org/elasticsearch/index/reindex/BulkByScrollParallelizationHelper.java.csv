commented;modifiers;parameterAmount;loc;comment;code
true;static;7;23;/**  * Takes an action created by a {@link BulkByScrollTask} and runs it with regard to whether the request is sliced or not.  *  * If the request is not sliced (i.e. the number of slices is 1), the worker action in the given {@link Runnable} will be started on  * the local node. If the request is sliced (i.e. the number of slices is more than 1), then a subrequest will be created for each  * slice and sent.  *  * If slices are set as {@code "auto"}, this class will resolve that to a specific number based on characteristics of the source  * indices. A request with {@code "auto"} slices may end up being sliced or unsliced.  */ ;/**  * Takes an action created by a {@link BulkByScrollTask} and runs it with regard to whether the request is sliced or not.  *  * If the request is not sliced (i.e. the number of slices is 1), the worker action in the given {@link Runnable} will be started on  * the local node. If the request is sliced (i.e. the number of slices is more than 1), then a subrequest will be created for each  * slice and sent.  *  * If slices are set as {@code "auto"}, this class will resolve that to a specific number based on characteristics of the source  * indices. A request with {@code "auto"} slices may end up being sliced or unsliced.  */ static <Request extends AbstractBulkByScrollRequest<Request>> void startSlicedAction(Request request, BulkByScrollTask task, Action<BulkByScrollResponse> action, ActionListener<BulkByScrollResponse> listener, Client client, DiscoveryNode node, Runnable workerAction) {     if (request.getSlices() == AbstractBulkByScrollRequest.AUTO_SLICES) {         ClusterSearchShardsRequest shardsRequest = new ClusterSearchShardsRequest().         shardsRequest.indices(request.getSearchRequest().indices()).         client.admin().cluster().searchShards(shardsRequest, ActionListener.wrap(response -> {             int actualNumSlices = countSlicesBasedOnShards(response).             sliceConditionally(request, task, action, listener, client, node, workerAction, actualNumSlices).         }, listener::onFailure)).     } else {         sliceConditionally(request, task, action, listener, client, node, workerAction, request.getSlices()).     } }
false;private,static;8;22;;private static <Request extends AbstractBulkByScrollRequest<Request>> void sliceConditionally(Request request, BulkByScrollTask task, Action<BulkByScrollResponse> action, ActionListener<BulkByScrollResponse> listener, Client client, DiscoveryNode node, Runnable workerAction, int slices) {     if (slices > 1) {         task.setWorkerCount(slices).         sendSubRequests(client, action, node.getId(), task, request, listener).     } else {         SliceBuilder sliceBuilder = request.getSearchRequest().source().slice().         Integer sliceId = sliceBuilder == null ? null : sliceBuilder.getId().         task.setWorker(request.getRequestsPerSecond(), sliceId).         workerAction.run().     } }
false;private,static;1;10;;private static int countSlicesBasedOnShards(ClusterSearchShardsResponse response) {     Map<Index, Integer> countsByIndex = Arrays.stream(response.getGroups()).collect(Collectors.toMap(group -> group.getShardId().getIndex(), group -> 1, (sum, term) -> sum + term)).     Set<Integer> counts = new HashSet<>(countsByIndex.values()).     int leastShards = Collections.min(counts).     return Math.min(leastShards, AUTO_SLICE_CEILING). }
false;private,static;6;20;;private static <Request extends AbstractBulkByScrollRequest<Request>> void sendSubRequests(Client client, Action<BulkByScrollResponse> action, String localNodeId, BulkByScrollTask task, Request request, ActionListener<BulkByScrollResponse> listener) {     LeaderBulkByScrollTaskState worker = task.getLeaderState().     int totalSlices = worker.getSlices().     TaskId parentTaskId = new TaskId(localNodeId, task.getId()).     for (final SearchRequest slice : sliceIntoSubRequests(request.getSearchRequest(), IdFieldMapper.NAME, totalSlices)) {         // TODO move the request to the correct node. maybe here or somehow do it as part of startup for reindex in general....         Request requestForSlice = request.forSlice(parentTaskId, slice, totalSlices).         ActionListener<BulkByScrollResponse> sliceListener = ActionListener.wrap(r -> worker.onSliceResponse(listener, slice.source().slice().getId(), r), e -> worker.onSliceFailure(listener, slice.source().slice().getId(), e)).         client.execute(action, requestForSlice, sliceListener).     } }
true;static;3;19;/**  * Slice a search request into {@code times} separate search requests slicing on {@code field}. Note that the slices are *shallow*  * copies of this request so don't change them.  */ ;/**  * Slice a search request into {@code times} separate search requests slicing on {@code field}. Note that the slices are *shallow*  * copies of this request so don't change them.  */ static SearchRequest[] sliceIntoSubRequests(SearchRequest request, String field, int times) {     SearchRequest[] slices = new SearchRequest[times].     for (int slice = 0. slice < times. slice++) {         SliceBuilder sliceBuilder = new SliceBuilder(field, slice, times).         SearchSourceBuilder slicedSource.         if (request.source() == null) {             slicedSource = new SearchSourceBuilder().slice(sliceBuilder).         } else {             if (request.source().slice() != null) {                 throw new IllegalStateException("Can't slice a request that already has a slice configuration").             }             slicedSource = request.source().copyWithNewSlice(sliceBuilder).         }         SearchRequest searchRequest = new SearchRequest(request).         searchRequest.source(slicedSource).         slices[slice] = searchRequest.     }     return slices. }
