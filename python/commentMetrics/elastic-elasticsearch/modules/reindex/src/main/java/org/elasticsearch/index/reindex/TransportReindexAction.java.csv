# id;timestamp;commentText;codeText;commentWords;codeWords
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1524684173;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        return RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_                .setDefaultHeaders(clientHeaders)_                .setRequestConfigCallback(c -> {_                    c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                    c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                    return c__                })_                .setHttpClientConfigCallback(c -> {_                    _                    if (remoteInfo.getUsername() != null) {_                        UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                                remoteInfo.getPassword())__                        CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                        credentialsProvider.setCredentials(AuthScope.ANY, creds)__                        c.setDefaultCredentialsProvider(credentialsProvider)__                    }_                    _                    AtomicInteger threads = new AtomicInteger()__                    c.setThreadFactory(r -> {_                        String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                        Thread t = new Thread(r, name)__                        threadCollector.add(t)__                        return t__                    })__                    _                    c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                    return c__                }).build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,return,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1529341607;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1529487105;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1529658035;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1529916082;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1533063033;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1537806831;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1541419698;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector);1548775385;Build the {@link RestClient} used for reindexing from remote clusters._@param remoteInfo connection information for the remote cluster_@param taskId the id of the current task. This is added to the thread name for easier tracking_@param threadCollector a list in which we collect all the threads created by the client;static RestClient buildRestClient(RemoteInfo remoteInfo, long taskId, List<Thread> threadCollector) {_        Header[] clientHeaders = new Header[remoteInfo.getHeaders().size()]__        int i = 0__        for (Map.Entry<String, String> header : remoteInfo.getHeaders().entrySet()) {_            clientHeaders[i++] = new BasicHeader(header.getKey(), header.getValue())__        }_        final RestClientBuilder builder =_            RestClient.builder(new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme()))_            .setDefaultHeaders(clientHeaders)_            .setRequestConfigCallback(c -> {_                c.setConnectTimeout(Math.toIntExact(remoteInfo.getConnectTimeout().millis()))__                c.setSocketTimeout(Math.toIntExact(remoteInfo.getSocketTimeout().millis()))__                return c__            })_            .setHttpClientConfigCallback(c -> {_                _                if (remoteInfo.getUsername() != null) {_                    UsernamePasswordCredentials creds = new UsernamePasswordCredentials(remoteInfo.getUsername(),_                        remoteInfo.getPassword())__                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider()__                    credentialsProvider.setCredentials(AuthScope.ANY, creds)__                    c.setDefaultCredentialsProvider(credentialsProvider)__                }_                _                AtomicInteger threads = new AtomicInteger()__                c.setThreadFactory(r -> {_                    String name = "es-client-" + taskId + "-" + threads.getAndIncrement()__                    Thread t = new Thread(r, name)__                    threadCollector.add(t)__                    return t__                })__                _                c.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())__                return c__            })__        if (Strings.hasLength(remoteInfo.getPathPrefix()) && "/".equals(remoteInfo.getPathPrefix()) == false) {_            builder.setPathPrefix(remoteInfo.getPathPrefix())__        }_        return builder.build()__    };build,the,link,rest,client,used,for,reindexing,from,remote,clusters,param,remote,info,connection,information,for,the,remote,cluster,param,task,id,the,id,of,the,current,task,this,is,added,to,the,thread,name,for,easier,tracking,param,thread,collector,a,list,in,which,we,collect,all,the,threads,created,by,the,client;static,rest,client,build,rest,client,remote,info,remote,info,long,task,id,list,thread,thread,collector,header,client,headers,new,header,remote,info,get,headers,size,int,i,0,for,map,entry,string,string,header,remote,info,get,headers,entry,set,client,headers,i,new,basic,header,header,get,key,header,get,value,final,rest,client,builder,builder,rest,client,builder,new,http,host,remote,info,get,host,remote,info,get,port,remote,info,get,scheme,set,default,headers,client,headers,set,request,config,callback,c,c,set,connect,timeout,math,to,int,exact,remote,info,get,connect,timeout,millis,c,set,socket,timeout,math,to,int,exact,remote,info,get,socket,timeout,millis,return,c,set,http,client,config,callback,c,if,remote,info,get,username,null,username,password,credentials,creds,new,username,password,credentials,remote,info,get,username,remote,info,get,password,credentials,provider,credentials,provider,new,basic,credentials,provider,credentials,provider,set,credentials,auth,scope,any,creds,c,set,default,credentials,provider,credentials,provider,atomic,integer,threads,new,atomic,integer,c,set,thread,factory,r,string,name,es,client,task,id,threads,get,and,increment,thread,t,new,thread,r,name,thread,collector,add,t,return,t,c,set,default,ioreactor,config,ioreactor,config,custom,set,io,thread,count,1,build,return,c,if,strings,has,length,remote,info,get,path,prefix,equals,remote,info,get,path,prefix,false,builder,set,path,prefix,remote,info,get,path,prefix,return,builder,build
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1524684173;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1529341607;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1529487105;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1529658035;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1529916082;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1533063033;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1537806831;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1541419698;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1548775385;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist);1548918365;Build the {@link CharacterRunAutomaton} that represents the reindex-from-remote whitelist and make sure that it doesn't whitelist_the world.;static CharacterRunAutomaton buildRemoteWhitelist(List<String> whitelist) {_        if (whitelist.isEmpty()) {_            return new CharacterRunAutomaton(Automata.makeEmpty())__        }_        Automaton automaton = Regex.simpleMatchToAutomaton(whitelist.toArray(Strings.EMPTY_ARRAY))__        automaton = MinimizationOperations.minimize(automaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES)__        if (Operations.isTotal(automaton)) {_            throw new IllegalArgumentException("Refusing to start because whitelist " + whitelist + " accepts all addresses. "_                    + "This would allow users to reindex-from-remote any URL they like effectively having Elasticsearch make HTTP GETs "_                    + "for them.")__        }_        return new CharacterRunAutomaton(automaton)__    };build,the,link,character,run,automaton,that,represents,the,reindex,from,remote,whitelist,and,make,sure,that,it,doesn,t,whitelist,the,world;static,character,run,automaton,build,remote,whitelist,list,string,whitelist,if,whitelist,is,empty,return,new,character,run,automaton,automata,make,empty,automaton,automaton,regex,simple,match,to,automaton,whitelist,to,array,strings,automaton,minimization,operations,minimize,automaton,operations,if,operations,is,total,automaton,throw,new,illegal,argument,exception,refusing,to,start,because,whitelist,whitelist,accepts,all,addresses,this,would,allow,users,to,reindex,from,remote,any,url,they,like,effectively,having,elasticsearch,make,http,gets,for,them,return,new,character,run,automaton,automaton
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1524684173;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1529341607;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1529487105;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1529658035;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1529916082;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1533063033;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1537806831;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1541419698;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1548775385;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> AsyncIndexBySearchAction -> @Override         protected void copyRouting(RequestWrapper<?> request, String routing);1548918365;Override the simple copy behavior to allow more fine grained control.;@Override_        protected void copyRouting(RequestWrapper<?> request, String routing) {_            String routingSpec = mainRequest.getDestination().routing()__            if (routingSpec == null) {_                super.copyRouting(request, routing)__                return__            }_            if (routingSpec.startsWith("=")) {_                super.copyRouting(request, mainRequest.getDestination().routing().substring(1))__                return__            }_            switch (routingSpec) {_            case "keep":_                super.copyRouting(request, routing)__                break__            case "discard":_                super.copyRouting(request, null)__                break__            default:_                throw new IllegalArgumentException("Unsupported routing command")__            }_        };override,the,simple,copy,behavior,to,allow,more,fine,grained,control;override,protected,void,copy,routing,request,wrapper,request,string,routing,string,routing,spec,main,request,get,destination,routing,if,routing,spec,null,super,copy,routing,request,routing,return,if,routing,spec,starts,with,super,copy,routing,request,main,request,get,destination,routing,substring,1,return,switch,routing,spec,case,keep,super,copy,routing,request,routing,break,case,discard,super,copy,routing,request,null,break,default,throw,new,illegal,argument,exception,unsupported,routing,command
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1524684173;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1529341607;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1529487105;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1529658035;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1529916082;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1533063033;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1537806831;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1541419698;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1548775385;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
TransportReindexAction -> static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,                                          IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,                                          ClusterState clusterState);1548918365;Throws an ActionRequestValidationException if the request tries to index_back into the same index or into an index that points to two indexes._This cannot be done during request validation because the cluster state_isn't available then. Package private for testing.;static void validateAgainstAliases(SearchRequest source, IndexRequest destination, RemoteInfo remoteInfo,_                                         IndexNameExpressionResolver indexNameExpressionResolver, AutoCreateIndex autoCreateIndex,_                                         ClusterState clusterState) {_        if (remoteInfo != null) {_            return__        }_        String target = destination.index()__        if (false == autoCreateIndex.shouldAutoCreate(target, clusterState)) {_            _            target = indexNameExpressionResolver.concreteIndexNames(clusterState, destination)[0]__        }_        for (String sourceIndex : indexNameExpressionResolver.concreteIndexNames(clusterState, source)) {_            if (sourceIndex.equals(target)) {_                ActionRequestValidationException e = new ActionRequestValidationException()__                e.addValidationError("reindex cannot write into an index its reading from [" + target + ']')__                throw e__            }_        }_    };throws,an,action,request,validation,exception,if,the,request,tries,to,index,back,into,the,same,index,or,into,an,index,that,points,to,two,indexes,this,cannot,be,done,during,request,validation,because,the,cluster,state,isn,t,available,then,package,private,for,testing;static,void,validate,against,aliases,search,request,source,index,request,destination,remote,info,remote,info,index,name,expression,resolver,index,name,expression,resolver,auto,create,index,auto,create,index,cluster,state,cluster,state,if,remote,info,null,return,string,target,destination,index,if,false,auto,create,index,should,auto,create,target,cluster,state,target,index,name,expression,resolver,concrete,index,names,cluster,state,destination,0,for,string,source,index,index,name,expression,resolver,concrete,index,names,cluster,state,source,if,source,index,equals,target,action,request,validation,exception,e,new,action,request,validation,exception,e,add,validation,error,reindex,cannot,write,into,an,index,its,reading,from,target,throw,e
