commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;18;;@BeforeClass public static void setupHttpServer() throws Exception {     InetSocketAddress address = new InetSocketAddress(InetAddress.getLoopbackAddress().getHostAddress(), 0).     SSLContext sslContext = buildServerSslContext().     server = MockHttpServer.createHttps(address, 0).     server.setHttpsConfigurator(new ClientAuthHttpsConfigurator(sslContext)).     server.start().     server.createContext("/", http -> {         assert http instanceof HttpsExchange.         HttpsExchange https = (HttpsExchange) http.         handler.accept(https).         // Always respond with 200         // * If the reindex sees the 200, it means the SSL connection was established correctly.         // * We can check client certs in the handler.         https.sendResponseHeaders(200, 0).         https.close().     }). }
false;public,static;0;6;;@AfterClass public static void shutdownHttpServer() {     server.stop(0).     server = null.     handler = null. }
false;private,static;0;14;;private static SSLContext buildServerSslContext() throws Exception {     final SSLContext sslContext = SSLContext.getInstance("TLSv1.2").     final char[] password = "http-password".toCharArray().     final Path cert = PathUtils.get(ReindexRestClientSslTests.class.getResource("http/http.crt").toURI()).     final Path key = PathUtils.get(ReindexRestClientSslTests.class.getResource("http/http.key").toURI()).     final X509ExtendedKeyManager keyManager = new PemKeyConfig(cert, key, password).createKeyManager().     final Path ca = PathUtils.get(ReindexRestClientSslTests.class.getResource("ca.pem").toURI()).     final X509ExtendedTrustManager trustManager = new PemTrustConfig(Collections.singletonList(ca)).createTrustManager().     sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager }, null).     return sslContext. }
false;public;0;11;;public void testClientFailsWithUntrustedCertificate() throws IOException {     final List<Thread> threads = new ArrayList<>().     final Settings settings = Settings.builder().put("path.home", createTempDir()).build().     final Environment environment = TestEnvironment.newEnvironment(settings).     final ReindexSslConfig ssl = new ReindexSslConfig(settings, environment, mock(ResourceWatcherService.class)).     try (RestClient client = TransportReindexAction.buildRestClient(getRemoteInfo(), ssl, 1L, threads)) {         expectThrows(SSLHandshakeException.class, () -> client.performRequest(new Request("GET", "/"))).     } }
false;public;0;14;;public void testClientSucceedsWithCertificateAuthorities() throws IOException {     final List<Thread> threads = new ArrayList<>().     final Path ca = getDataPath("ca.pem").     final Settings settings = Settings.builder().put("path.home", createTempDir()).putList("reindex.ssl.certificate_authorities", ca.toString()).build().     final Environment environment = TestEnvironment.newEnvironment(settings).     final ReindexSslConfig ssl = new ReindexSslConfig(settings, environment, mock(ResourceWatcherService.class)).     try (RestClient client = TransportReindexAction.buildRestClient(getRemoteInfo(), ssl, 1L, threads)) {         final Response response = client.performRequest(new Request("GET", "/")).         assertThat(response.getStatusLine().getStatusCode(), Matchers.is(200)).     } }
false;public;0;14;;public void testClientSucceedsWithVerificationDisabled() throws IOException {     assumeFalse("Cannot disable verification in FIPS JVM", inFipsJvm()).     final List<Thread> threads = new ArrayList<>().     final Settings settings = Settings.builder().put("path.home", createTempDir()).put("reindex.ssl.verification_mode", "NONE").build().     final Environment environment = TestEnvironment.newEnvironment(settings).     final ReindexSslConfig ssl = new ReindexSslConfig(settings, environment, mock(ResourceWatcherService.class)).     try (RestClient client = TransportReindexAction.buildRestClient(getRemoteInfo(), ssl, 1L, threads)) {         final Response response = client.performRequest(new Request("GET", "/")).         assertThat(response.getStatusLine().getStatusCode(), Matchers.is(200)).     } }
false;public;0;35;;public void testClientPassesClientCertificate() throws IOException {     final List<Thread> threads = new ArrayList<>().     final Path ca = getDataPath("ca.pem").     final Path cert = getDataPath("client/client.crt").     final Path key = getDataPath("client/client.key").     final Settings settings = Settings.builder().put("path.home", createTempDir()).putList("reindex.ssl.certificate_authorities", ca.toString()).put("reindex.ssl.certificate", cert).put("reindex.ssl.key", key).put("reindex.ssl.key_passphrase", "client-password").build().     AtomicReference<Certificate[]> clientCertificates = new AtomicReference<>().     handler = https -> {         try {             clientCertificates.set(https.getSSLSession().getPeerCertificates()).         } catch (SSLPeerUnverifiedException e) {             logger.warn("Client did not provide certificates", e).             clientCertificates.set(null).         }     }.     final Environment environment = TestEnvironment.newEnvironment(settings).     final ReindexSslConfig ssl = new ReindexSslConfig(settings, environment, mock(ResourceWatcherService.class)).     try (RestClient client = TransportReindexAction.buildRestClient(getRemoteInfo(), ssl, 1L, threads)) {         final Response response = client.performRequest(new Request("GET", "/")).         assertThat(response.getStatusLine().getStatusCode(), Matchers.is(200)).         final Certificate[] certs = clientCertificates.get().         assertThat(certs, Matchers.notNullValue()).         assertThat(certs, Matchers.arrayWithSize(1)).         assertThat(certs[0], Matchers.instanceOf(X509Certificate.class)).         final X509Certificate clientCert = (X509Certificate) certs[0].         assertThat(clientCert.getSubjectDN().getName(), Matchers.is("CN=client")).         assertThat(clientCert.getIssuerDN().getName(), Matchers.is("CN=Elastic Certificate Tool Autogenerated CA")).     } }
false;private;0;4;;private RemoteInfo getRemoteInfo() {     return new RemoteInfo("https", server.getAddress().getHostName(), server.getAddress().getPort(), "/", new BytesArray("test"), "user", "password", Collections.emptyMap(), RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT). }
false;public;1;4;;@Override public void configure(HttpsParameters params) {     params.setWantClientAuth(true). }
