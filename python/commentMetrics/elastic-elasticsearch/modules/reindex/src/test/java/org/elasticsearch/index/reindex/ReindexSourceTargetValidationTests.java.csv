commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public void testObviousCases() {     fails("target", "target").     fails("target", "foo", "bar", "target", "baz").     fails("target", "foo", "bar", "target", "baz", "target").     succeeds("target", "source").     succeeds("target", "source", "source2"). }
false;public;0;12;;public void testAliasesContainTarget() {     fails("target", "target_alias").     fails("target_alias", "target").     fails("target", "foo", "bar", "target_alias", "baz").     fails("target_alias", "foo", "bar", "target_alias", "baz").     fails("target_alias", "foo", "bar", "target", "baz").     fails("target", "foo", "bar", "target_alias", "target_alias").     fails("target", "target_multi").     fails("target", "foo", "bar", "target_multi", "baz").     succeeds("target", "source_multi").     succeeds("target", "source", "source2", "source_multi"). }
false;public;0;7;;public void testTargetIsAlias() {     Exception e = expectThrows(IllegalArgumentException.class, () -> succeeds("target_multi", "foo")).     assertThat(e.getMessage(), containsString("Alias [target_multi] has more than one indices associated with it [[")).     // The index names can come in either order     assertThat(e.getMessage(), containsString("target")).     assertThat(e.getMessage(), containsString("target2")). }
false;public;0;8;;public void testRemoteInfoSkipsValidation() {     // The index doesn't have to exist     succeeds(new RemoteInfo(randomAlphaOfLength(5), "test", 9200, null, new BytesArray("test"), null, null, emptyMap(), RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT), "does_not_exist", "target").     // And it doesn't matter if they are the same index. They are considered to be different because the remote one is, well, remote.     succeeds(new RemoteInfo(randomAlphaOfLength(5), "test", 9200, null, new BytesArray("test"), null, null, emptyMap(), RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT), "target", "target"). }
false;private;2;4;;private void fails(String target, String... sources) {     Exception e = expectThrows(ActionRequestValidationException.class, () -> succeeds(target, sources)).     assertThat(e.getMessage(), containsString("reindex cannot write into an index its reading from [target]")). }
false;private;2;3;;private void succeeds(String target, String... sources) {     succeeds(null, target, sources). }
false;private;3;4;;private void succeeds(RemoteInfo remoteInfo, String target, String... sources) {     TransportReindexAction.validateAgainstAliases(new SearchRequest(sources), new IndexRequest(target), remoteInfo, INDEX_NAME_EXPRESSION_RESOLVER, AUTO_CREATE_INDEX, STATE). }
false;private,static;2;10;;private static IndexMetaData index(String name, String... aliases) {     IndexMetaData.Builder builder = IndexMetaData.builder(name).settings(Settings.builder().put("index.version.created", Version.CURRENT.id).put("index.number_of_shards", 1).put("index.number_of_replicas", 1)).     for (String alias : aliases) {         builder.putAlias(AliasMetaData.builder(alias).build()).     }     return builder.build(). }
