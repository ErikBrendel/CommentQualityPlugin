commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return Arrays.asList(Netty4Plugin.class, ReindexFromRemoteWithAuthTests.TestPlugin.class, ReindexPlugin.class). }
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;0;8;;@Override protected Settings nodeSettings() {     Settings.Builder settings = Settings.builder().put(super.nodeSettings()).     // Whitelist reindexing from the http host we're going to use     settings.put(TransportReindexAction.REMOTE_CLUSTER_WHITELIST.getKey(), "127.0.0.1:*").     settings.put(NetworkModule.HTTP_TYPE_KEY, Netty4Plugin.NETTY_HTTP_TRANSPORT_NAME).     return settings.build(). }
false;public;0;4;;@Before public void setupSourceIndex() {     client().prepareIndex("source", "test").setSource("test", "test").setRefreshPolicy(RefreshPolicy.IMMEDIATE).get(). }
false;public;0;5;;@Before public void fetchTransportAddress() {     NodeInfo nodeInfo = client().admin().cluster().prepareNodesInfo().get().getNodes().get(0).     address = nodeInfo.getHttp().getAddress().publishAddress(). }
true;private;3;5;/**  * Build a {@link RemoteInfo}, defaulting values that we don't care about in this test to values that don't hurt anything.  */ ;/**  * Build a {@link RemoteInfo}, defaulting values that we don't care about in this test to values that don't hurt anything.  */ private RemoteInfo newRemoteInfo(String username, String password, Map<String, String> headers) {     return new RemoteInfo("http", address.getAddress(), address.getPort(), null, new BytesArray("{\"match_all\":{}}"), username, password, headers, RemoteInfo.DEFAULT_SOCKET_TIMEOUT, RemoteInfo.DEFAULT_CONNECT_TIMEOUT). }
false;public;0;5;;public void testReindexFromRemoteWithAuthentication() throws Exception {     ReindexRequestBuilder request = new ReindexRequestBuilder(client(), ReindexAction.INSTANCE).source("source").destination("dest").setRemoteInfo(newRemoteInfo("Aladdin", "open sesame", emptyMap())).     assertThat(request.get(), matcher().created(1)). }
false;public;0;7;;public void testReindexSendsHeaders() throws Exception {     ReindexRequestBuilder request = new ReindexRequestBuilder(client(), ReindexAction.INSTANCE).source("source").destination("dest").setRemoteInfo(newRemoteInfo(null, null, singletonMap(TestFilter.EXAMPLE_HEADER, "doesn't matter"))).     ElasticsearchStatusException e = expectThrows(ElasticsearchStatusException.class, () -> request.get()).     assertEquals(RestStatus.BAD_REQUEST, e.status()).     assertThat(e.getMessage(), containsString("Hurray! Sent the header!")). }
false;public;0;8;;public void testReindexWithoutAuthenticationWhenRequired() throws Exception {     ReindexRequestBuilder request = new ReindexRequestBuilder(client(), ReindexAction.INSTANCE).source("source").destination("dest").setRemoteInfo(newRemoteInfo(null, null, emptyMap())).     ElasticsearchStatusException e = expectThrows(ElasticsearchStatusException.class, () -> request.get()).     assertEquals(RestStatus.UNAUTHORIZED, e.status()).     assertThat(e.getMessage(), containsString("\"reason\":\"Authentication required\"")).     assertThat(e.getMessage(), containsString("\"WWW-Authenticate\":\"Basic realm=auth-realm\"")). }
false;public;0;6;;public void testReindexWithBadAuthentication() throws Exception {     ReindexRequestBuilder request = new ReindexRequestBuilder(client(), ReindexAction.INSTANCE).source("source").destination("dest").setRemoteInfo(newRemoteInfo("junk", "auth", emptyMap())).     ElasticsearchStatusException e = expectThrows(ElasticsearchStatusException.class, () -> request.get()).     assertThat(e.getMessage(), containsString("\"reason\":\"Bad Authorization\"")). }
false;public;9;8;;@Override public Collection<Object> createComponents(Client client, ClusterService clusterService, ThreadPool threadPool, ResourceWatcherService resourceWatcherService, ScriptService scriptService, NamedXContentRegistry xContentRegistry, Environment environment, NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry) {     testFilter.set(new ReindexFromRemoteWithAuthTests.TestFilter(threadPool)).     return Collections.emptyList(). }
false;public;0;4;;@Override public List<ActionFilter> getActionFilters() {     return singletonList(testFilter.get()). }
false;public;0;4;;@Override public Collection<String> getRestHeaders() {     return Arrays.asList(TestFilter.AUTHORIZATION_HEADER, TestFilter.EXAMPLE_HEADER). }
false;public;0;4;;@Override public int order() {     return Integer.MIN_VALUE. }
false;public;5;22;;@Override public <Request extends ActionRequest, Response extends ActionResponse> void apply(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> chain) {     if (false == action.equals(SearchAction.NAME)) {         chain.proceed(task, action, request, listener).         return.     }     if (context.getHeader(EXAMPLE_HEADER) != null) {         throw new IllegalArgumentException("Hurray! Sent the header!").     }     String auth = context.getHeader(AUTHORIZATION_HEADER).     if (auth == null) {         ElasticsearchSecurityException e = new ElasticsearchSecurityException("Authentication required", RestStatus.UNAUTHORIZED).         e.addHeader("WWW-Authenticate", "Basic realm=auth-realm").         throw e.     }     if (false == REQUIRED_AUTH.equals(auth)) {         throw new ElasticsearchSecurityException("Bad Authorization", RestStatus.FORBIDDEN).     }     chain.proceed(task, action, request, listener). }
