commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void createTask() {     slices = between(2, 50).     task = new BulkByScrollTask(1, "test_type", "test_action", "test", TaskId.EMPTY_TASK_ID, Collections.emptyMap()).     task.setWorkerCount(slices). }
true;private;3;24;/**  * Test rethrottling.  * @param runningSlices the number of slices still running  * @param simulator simulate a response from the sub-request to rethrottle the child requests  * @param verifier verify the resulting response  */ ;/**  * Test rethrottling.  * @param runningSlices the number of slices still running  * @param simulator simulate a response from the sub-request to rethrottle the child requests  * @param verifier verify the resulting response  */ private void rethrottleTestCase(int runningSlices, Consumer<ActionListener<ListTasksResponse>> simulator, Consumer<ActionListener<TaskInfo>> verifier) {     Client client = mock(Client.class).     String localNodeId = randomAlphaOfLength(5).     float newRequestsPerSecond = randomValueOtherThanMany(f -> f <= 0, () -> randomFloat()).     @SuppressWarnings("unchecked")     ActionListener<TaskInfo> listener = mock(ActionListener.class).     TransportRethrottleAction.rethrottle(logger, localNodeId, client, task, newRequestsPerSecond, listener).     // Capture the sub request and the listener so we can verify they are sane     ArgumentCaptor<RethrottleRequest> subRequest = ArgumentCaptor.forClass(RethrottleRequest.class).     // Magical generics incantation.....     @SuppressWarnings({ "unchecked", "rawtypes" })     ArgumentCaptor<ActionListener<ListTasksResponse>> subListener = ArgumentCaptor.forClass((Class) ActionListener.class).     if (runningSlices > 0) {         verify(client).execute(eq(RethrottleAction.INSTANCE), subRequest.capture(), subListener.capture()).         assertEquals(new TaskId(localNodeId, task.getId()), subRequest.getValue().getParentTaskId()).         assertEquals(newRequestsPerSecond / runningSlices, subRequest.getValue().getRequestsPerSecond(), 0.00001f).         simulator.accept(subListener.getValue()).     }     verifier.accept(listener). }
false;private;1;7;;private Consumer<ActionListener<TaskInfo>> expectSuccessfulRethrottleWithStatuses(List<BulkByScrollTask.StatusOrException> sliceStatuses) {     return listener -> {         TaskInfo taskInfo = captureResponse(TaskInfo.class, listener).         assertEquals(sliceStatuses, ((BulkByScrollTask.Status) taskInfo.getStatus()).getSliceStatuses()).     }. }
false;public;0;13;;public void testRethrottleSuccessfulResponse() {     List<TaskInfo> tasks = new ArrayList<>().     List<BulkByScrollTask.StatusOrException> sliceStatuses = new ArrayList<>(slices).     for (int i = 0. i < slices. i++) {         BulkByScrollTask.Status status = believeableInProgressStatus(i).         tasks.add(new TaskInfo(new TaskId("test", 123), "test", "test", "test", status, 0, 0, true, new TaskId("test", task.getId()), Collections.emptyMap())).         sliceStatuses.add(new BulkByScrollTask.StatusOrException(status)).     }     rethrottleTestCase(slices, listener -> listener.onResponse(new ListTasksResponse(tasks, emptyList(), emptyList())), expectSuccessfulRethrottleWithStatuses(sliceStatuses)). }
false;public;0;20;;public void testRethrottleWithSomeSucceeded() {     int succeeded = between(1, slices - 1).     List<BulkByScrollTask.StatusOrException> sliceStatuses = new ArrayList<>(slices).     for (int i = 0. i < succeeded. i++) {         BulkByScrollTask.Status status = believeableCompletedStatus(i).         task.getLeaderState().onSliceResponse(neverCalled(), i, new BulkByScrollResponse(timeValueMillis(10), status, emptyList(), emptyList(), false)).         sliceStatuses.add(new BulkByScrollTask.StatusOrException(status)).     }     List<TaskInfo> tasks = new ArrayList<>().     for (int i = succeeded. i < slices. i++) {         BulkByScrollTask.Status status = believeableInProgressStatus(i).         tasks.add(new TaskInfo(new TaskId("test", 123), "test", "test", "test", status, 0, 0, true, new TaskId("test", task.getId()), Collections.emptyMap())).         sliceStatuses.add(new BulkByScrollTask.StatusOrException(status)).     }     rethrottleTestCase(slices - succeeded, listener -> listener.onResponse(new ListTasksResponse(tasks, emptyList(), emptyList())), expectSuccessfulRethrottleWithStatuses(sliceStatuses)). }
false;public;0;18;;public void testRethrottleWithAllSucceeded() {     List<BulkByScrollTask.StatusOrException> sliceStatuses = new ArrayList<>(slices).     for (int i = 0. i < slices. i++) {         @SuppressWarnings("unchecked")         ActionListener<BulkByScrollResponse> listener = i < slices - 1 ? neverCalled() : mock(ActionListener.class).         BulkByScrollTask.Status status = believeableCompletedStatus(i).         task.getLeaderState().onSliceResponse(listener, i, new BulkByScrollResponse(timeValueMillis(10), status, emptyList(), emptyList(), false)).         if (i == slices - 1) {             // The whole thing succeeded so we should have got the success             captureResponse(BulkByScrollResponse.class, listener).getStatus().         }         sliceStatuses.add(new BulkByScrollTask.StatusOrException(status)).     }     rethrottleTestCase(0, listener -> {     /* There are no async tasks to simulate because the listener is called for us. */     }, expectSuccessfulRethrottleWithStatuses(sliceStatuses)). }
false;private;1;7;;private Consumer<ActionListener<TaskInfo>> expectException(Matcher<Exception> exceptionMatcher) {     return listener -> {         ArgumentCaptor<Exception> failure = ArgumentCaptor.forClass(Exception.class).         verify(listener).onFailure(failure.capture()).         assertThat(failure.getValue(), exceptionMatcher).     }. }
false;public;0;4;;public void testRethrottleCatastrophicFailures() {     Exception e = new Exception().     rethrottleTestCase(slices, listener -> listener.onFailure(e), expectException(theInstance(e))). }
false;public;0;7;;public void testRethrottleTaskOperationFailure() {     Exception e = new Exception().     TaskOperationFailure failure = new TaskOperationFailure("test", 123, e).     rethrottleTestCase(slices, listener -> listener.onResponse(new ListTasksResponse(emptyList(), singletonList(failure), emptyList())), expectException(hasToString(containsString("Rethrottle of [test:123] failed")))). }
false;public;0;6;;public void testRethrottleNodeFailure() {     FailedNodeException e = new FailedNodeException("test", "test", new Exception()).     rethrottleTestCase(slices, listener -> listener.onResponse(new ListTasksResponse(emptyList(), emptyList(), singletonList(e))), expectException(theInstance(e))). }
false;private;1;3;;private BulkByScrollTask.Status believeableInProgressStatus(Integer sliceId) {     return new BulkByScrollTask.Status(sliceId, 10, 0, 0, 0, 0, 0, 0, 0, 0, timeValueMillis(0), 0, null, timeValueMillis(0)). }
false;private;1;3;;private BulkByScrollTask.Status believeableCompletedStatus(Integer sliceId) {     return new BulkByScrollTask.Status(sliceId, 10, 10, 0, 0, 0, 0, 0, 0, 0, timeValueMillis(0), 0, null, timeValueMillis(0)). }
false;public;1;4;;@Override public void onResponse(T response) {     throw new RuntimeException("Expected no interactions but got [" + response + "]"). }
false;public;1;4;;@Override public void onFailure(Exception e) {     throw new RuntimeException("Expected no interations but was received a failure", e). }
false;private;0;13;;private <T> ActionListener<T> neverCalled() {     return new ActionListener<T>() {          @Override         public void onResponse(T response) {             throw new RuntimeException("Expected no interactions but got [" + response + "]").         }          @Override         public void onFailure(Exception e) {             throw new RuntimeException("Expected no interations but was received a failure", e).         }     }. }
false;private;2;11;;private <T> T captureResponse(Class<T> responseClass, ActionListener<T> listener) {     ArgumentCaptor<Exception> failure = ArgumentCaptor.forClass(Exception.class).     // Rethrow any failures just so we get a nice exception if there were any. We don't expect any though.     verify(listener, atMost(1)).onFailure(failure.capture()).     if (false == failure.getAllValues().isEmpty()) {         throw new AssertionError(failure.getValue()).     }     ArgumentCaptor<T> response = ArgumentCaptor.forClass(responseClass).     verify(listener).onResponse(response.capture()).     return response.getValue(). }
