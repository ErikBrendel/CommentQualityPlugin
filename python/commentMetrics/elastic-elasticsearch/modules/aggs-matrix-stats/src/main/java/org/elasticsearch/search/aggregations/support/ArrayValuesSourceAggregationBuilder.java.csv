commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public AB subAggregations(Builder subFactories) {     throw new AggregationInitializationException("Aggregator [" + name + "] of type [" + getType() + "] cannot accept sub-aggregations"). }
true;private;1;7;/**  * Read from a stream.  */ ;/**  * Read from a stream.  */ @SuppressWarnings("unchecked") private void read(StreamInput in) throws IOException {     fields = (ArrayList<String>) in.readGenericValue().     valueType = in.readOptionalWriteable(ValueType::readFromStream).     format = in.readOptionalString().     missingMap = in.readMap(). }
false;protected,final;1;11;;@Override protected final void doWriteTo(StreamOutput out) throws IOException {     if (serializeTargetValueType()) {         out.writeOptionalWriteable(targetValueType).     }     out.writeGenericValue(fields).     out.writeOptionalWriteable(valueType).     out.writeOptionalString(format).     out.writeMap(missingMap).     innerWriteTo(out). }
true;protected,abstract;1;1;/**  * Write subclass' state to the stream  */ ;/**  * Write subclass' state to the stream  */ protected abstract void innerWriteTo(StreamOutput out) throws IOException.
true;public;1;8;/**  * Sets the field to use for this aggregation.  */ ;/**  * Sets the field to use for this aggregation.  */ @SuppressWarnings("unchecked") public AB fields(List<String> fields) {     if (fields == null) {         throw new IllegalArgumentException("[field] must not be null: [" + name + "]").     }     this.fields = fields.     return (AB) this. }
true;public;0;3;/**  * Gets the field to use for this aggregation.  */ ;/**  * Gets the field to use for this aggregation.  */ public List<String> fields() {     return fields. }
true;public;1;8;/**  * Sets the {@link ValueType} for the value produced by this aggregation  */ ;/**  * Sets the {@link ValueType} for the value produced by this aggregation  */ @SuppressWarnings("unchecked") public AB valueType(ValueType valueType) {     if (valueType == null) {         throw new IllegalArgumentException("[valueType] must not be null: [" + name + "]").     }     this.valueType = valueType.     return (AB) this. }
true;public;0;3;/**  * Gets the {@link ValueType} for the value produced by this aggregation  */ ;/**  * Gets the {@link ValueType} for the value produced by this aggregation  */ public ValueType valueType() {     return valueType. }
true;public;1;8;/**  * Sets the format to use for the output of the aggregation.  */ ;/**  * Sets the format to use for the output of the aggregation.  */ @SuppressWarnings("unchecked") public AB format(String format) {     if (format == null) {         throw new IllegalArgumentException("[format] must not be null: [" + name + "]").     }     this.format = format.     return (AB) this. }
true;public;0;3;/**  * Gets the format to use for the output of the aggregation.  */ ;/**  * Gets the format to use for the output of the aggregation.  */ public String format() {     return format. }
true;public;1;8;/**  * Sets the value to use when the aggregation finds a missing value in a  * document  */ ;/**  * Sets the value to use when the aggregation finds a missing value in a  * document  */ @SuppressWarnings("unchecked") public AB missingMap(Map<String, Object> missingMap) {     if (missingMap == null) {         throw new IllegalArgumentException("[missing] must not be null: [" + name + "]").     }     this.missingMap = missingMap.     return (AB) this. }
true;public;0;3;/**  * Gets the value to use when the aggregation finds a missing value in a  * document  */ ;/**  * Gets the value to use when the aggregation finds a missing value in a  * document  */ public Map<String, Object> missingMap() {     return missingMap. }
false;protected,final;3;7;;@Override protected final ArrayValuesSourceAggregatorFactory<VS, ?> doBuild(SearchContext context, AggregatorFactory<?> parent, AggregatorFactories.Builder subFactoriesBuilder) throws IOException {     Map<String, ValuesSourceConfig<VS>> configs = resolveConfig(context).     ArrayValuesSourceAggregatorFactory<VS, ?> factory = innerBuild(context, configs, parent, subFactoriesBuilder).     return factory. }
false;protected;1;8;;protected Map<String, ValuesSourceConfig<VS>> resolveConfig(SearchContext context) {     HashMap<String, ValuesSourceConfig<VS>> configs = new HashMap<>().     for (String field : fields) {         ValuesSourceConfig<VS> config = config(context, field, null).         configs.put(field, config).     }     return configs. }
false;protected,abstract;4;4;;protected abstract ArrayValuesSourceAggregatorFactory<VS, ?> innerBuild(SearchContext context, Map<String, ValuesSourceConfig<VS>> configs, AggregatorFactory<?> parent, AggregatorFactories.Builder subFactoriesBuilder) throws IOException.
false;public;3;50;;public ValuesSourceConfig<VS> config(SearchContext context, String field, Script script) {     ValueType valueType = this.valueType != null ? this.valueType : targetValueType.     if (field == null) {         if (script == null) {             ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(ValuesSourceType.ANY).             return config.format(resolveFormat(null, valueType)).         }         ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : this.valuesSourceType.         if (valuesSourceType == null || valuesSourceType == ValuesSourceType.ANY) {             // the specific value source type is undefined, but for scripts,             // we need to have a specific value source             // type to know how to handle the script values, so we fallback             // on Bytes             valuesSourceType = ValuesSourceType.BYTES.         }         ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(valuesSourceType).         config.missing(missingMap.get(field)).         return config.format(resolveFormat(format, valueType)).     }     MappedFieldType fieldType = context.smartNameFieldType(field).     if (fieldType == null) {         ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : this.valuesSourceType.         ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(valuesSourceType).         config.missing(missingMap.get(field)).         config.format(resolveFormat(format, valueType)).         return config.unmapped(true).     }     IndexFieldData<?> indexFieldData = context.getForField(fieldType).     ValuesSourceConfig<VS> config.     if (valuesSourceType == ValuesSourceType.ANY) {         if (indexFieldData instanceof IndexNumericFieldData) {             config = new ValuesSourceConfig<>(ValuesSourceType.NUMERIC).         } else if (indexFieldData instanceof IndexGeoPointFieldData) {             config = new ValuesSourceConfig<>(ValuesSourceType.GEOPOINT).         } else {             config = new ValuesSourceConfig<>(ValuesSourceType.BYTES).         }     } else {         config = new ValuesSourceConfig<>(valuesSourceType).     }     config.fieldContext(new FieldContext(field, indexFieldData, fieldType)).     config.missing(missingMap.get(field)).     return config.format(fieldType.docValueFormat(format, null)). }
false;private,static;2;10;;private static DocValueFormat resolveFormat(@Nullable String format, @Nullable ValueType valueType) {     if (valueType == null) {         // we can't figure it out         return DocValueFormat.RAW.     }     DocValueFormat valueFormat = valueType.defaultFormat().     if (valueFormat instanceof DocValueFormat.Decimal && format != null) {         valueFormat = new DocValueFormat.Decimal(format).     }     return valueFormat. }
true;protected;0;3;/**  * Should this builder serialize its targetValueType? Defaults to false. All subclasses that override this to true  * should use the three argument read constructor rather than the four argument version.  */ ;/**  * Should this builder serialize its targetValueType? Defaults to false. All subclasses that override this to true  * should use the three argument read constructor rather than the four argument version.  */ protected boolean serializeTargetValueType() {     return false. }
false;public,final;2;20;;@Override public final XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     // todo add ParseField support to XContentBuilder     if (fields != null) {         builder.field(CommonFields.FIELDS.getPreferredName(), fields).     }     if (missing != null) {         builder.field(CommonFields.MISSING.getPreferredName(), missing).     }     if (format != null) {         builder.field(CommonFields.FORMAT.getPreferredName(), format).     }     if (valueType != null) {         builder.field(CommonFields.VALUE_TYPE.getPreferredName(), valueType.getPreferredName()).     }     doXContentBody(builder, params).     builder.endObject().     return builder. }
false;protected,abstract;2;1;;protected abstract XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException.
false;protected,final;0;5;;@Override protected final int doHashCode() {     return Objects.hash(fields, format, missing, targetValueType, valueType, valuesSourceType, innerHashCode()). }
false;protected,abstract;0;1;;protected abstract int innerHashCode().
false;protected,final;1;17;;@Override protected final boolean doEquals(Object obj) {     ArrayValuesSourceAggregationBuilder<?, ?> other = (ArrayValuesSourceAggregationBuilder<?, ?>) obj.     if (!Objects.equals(fields, other.fields))         return false.     if (!Objects.equals(format, other.format))         return false.     if (!Objects.equals(missing, other.missing))         return false.     if (!Objects.equals(targetValueType, other.targetValueType))         return false.     if (!Objects.equals(valueType, other.valueType))         return false.     if (!Objects.equals(valuesSourceType, other.valuesSourceType))         return false.     return innerEquals(obj). }
false;protected,abstract;1;1;;protected abstract boolean innerEquals(Object obj).
