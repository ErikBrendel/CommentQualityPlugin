commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * test running stats  */ ;/**  * test running stats  */ public void testRunningStats() throws Exception {     final MatrixStatsResults results = new MatrixStatsResults(createRunningStats(fieldA, fieldB)).     actualStats.assertNearlyEqual(results). }
true;public;0;21;/**  * Test merging stats across observation shards  */ ;/**  * Test merging stats across observation shards  */ public void testMergedStats() throws Exception {     // slice observations into shards     int numShards = randomIntBetween(2, 10).     double obsPerShard = Math.floor(numObs / numShards).     int start = 0.     RunningStats stats = null.     List<Double> fieldAShard, fieldBShard.     for (int s = 0. s < numShards - 1. start = ++s * (int) obsPerShard) {         fieldAShard = fieldA.subList(start, start + (int) obsPerShard).         fieldBShard = fieldB.subList(start, start + (int) obsPerShard).         if (stats == null) {             stats = createRunningStats(fieldAShard, fieldBShard).         } else {             stats.merge(createRunningStats(fieldAShard, fieldBShard)).         }     }     stats.merge(createRunningStats(fieldA.subList(start, fieldA.size()), fieldB.subList(start, fieldB.size()))).     final MatrixStatsResults results = new MatrixStatsResults(stats).     actualStats.assertNearlyEqual(results). }
false;private;2;16;;private RunningStats createRunningStats(List<Double> fieldAObs, List<Double> fieldBObs) {     RunningStats stats = new RunningStats().     // create a document with two numeric fields     final String[] fieldNames = new String[2].     fieldNames[0] = fieldAKey.     fieldNames[1] = fieldBKey.     final double[] fieldVals = new double[2].     // running stats computation     for (int n = 0. n < fieldAObs.size(). ++n) {         fieldVals[0] = fieldAObs.get(n).         fieldVals[1] = fieldBObs.get(n).         stats.add(fieldNames, fieldVals).     }     return stats. }
