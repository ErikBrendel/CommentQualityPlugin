commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public TokenStream create(TokenStream tokenStream) {     return new WordDelimiterFilter(tokenStream, charTypeTable, flags, protoWords). }
false;public;0;11;;@Override public TokenFilterFactory getSynonymFilter() {     if (indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0)) {         throw new IllegalArgumentException("Token filter [" + name() + "] cannot be used to parse synonyms").     } else {         DEPRECATION_LOGGER.deprecatedAndMaybeLog("synonym_tokenfilters", "Token filter [" + name() + "] will not be usable to parse synonyms after v7.0").         return this.     } }
false;public;4;6;;public int getFlag(int flag, Settings settings, String key, boolean defaultValue) {     if (settings.getAsBoolean(key, defaultValue)) {         return flag.     }     return 0. }
true;static;1;25;/**  * parses a list of MappingCharFilter style rules into a custom byte[] type table  */ ;/**  * parses a list of MappingCharFilter style rules into a custom byte[] type table  */ static byte[] parseTypes(Collection<String> rules) {     SortedMap<Character, Byte> typeMap = new TreeMap<>().     for (String rule : rules) {         Matcher m = typePattern.matcher(rule).         if (!m.find())             throw new RuntimeException("Invalid Mapping Rule : [" + rule + "]").         String lhs = parseString(m.group(1).trim()).         Byte rhs = parseType(m.group(2).trim()).         if (lhs.length() != 1)             throw new RuntimeException("Invalid Mapping Rule : [" + rule + "]. Only a single character is allowed.").         if (rhs == null)             throw new RuntimeException("Invalid Mapping Rule : [" + rule + "]. Illegal type.").         typeMap.put(lhs.charAt(0), rhs).     }     // ensure the table is always at least as big as DEFAULT_WORD_DELIM_TABLE for performance     byte[] types = new byte[Math.max(typeMap.lastKey() + 1, WordDelimiterIterator.DEFAULT_WORD_DELIM_TABLE.length)].     for (int i = 0. i < types.length. i++) types[i] = WordDelimiterIterator.getType(i).     for (Map.Entry<Character, Byte> mapping : typeMap.entrySet()) types[mapping.getKey()] = mapping.getValue().     return types. }
false;private,static;1;16;;private static Byte parseType(String s) {     if (s.equals("LOWER"))         return WordDelimiterFilter.LOWER.     else if (s.equals("UPPER"))         return WordDelimiterFilter.UPPER.     else if (s.equals("ALPHA"))         return WordDelimiterFilter.ALPHA.     else if (s.equals("DIGIT"))         return WordDelimiterFilter.DIGIT.     else if (s.equals("ALPHANUM"))         return WordDelimiterFilter.ALPHANUM.     else if (s.equals("SUBWORD_DELIM"))         return WordDelimiterFilter.SUBWORD_DELIM.     else         return null. }
false;private,static;1;42;;private static String parseString(String s) {     char[] out = new char[256].     int readPos = 0.     int len = s.length().     int writePos = 0.     while (readPos < len) {         char c = s.charAt(readPos++).         if (c == '\\') {             if (readPos >= len)                 throw new RuntimeException("Invalid escaped char in [" + s + "]").             c = s.charAt(readPos++).             switch(c) {                 case '\\':                     c = '\\'.                     break.                 case 'n':                     c = '\n'.                     break.                 case 't':                     c = '\t'.                     break.                 case 'r':                     c = '\r'.                     break.                 case 'b':                     c = '\b'.                     break.                 case 'f':                     c = '\f'.                     break.                 case 'u':                     if (readPos + 3 >= len)                         throw new RuntimeException("Invalid escaped char in [" + s + "]").                     c = (char) Integer.parseInt(s.substring(readPos, readPos + 4), 16).                     readPos += 4.                     break.             }         }         out[writePos++] = c.     }     return new String(out, 0, writePos). }
false;public;0;4;;@Override public boolean breaksFastVectorHighlighter() {     return true. }
