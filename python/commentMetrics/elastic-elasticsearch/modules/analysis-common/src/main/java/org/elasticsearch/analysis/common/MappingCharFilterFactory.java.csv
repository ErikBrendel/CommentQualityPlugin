commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Reader create(Reader tokenStream) {     return new MappingCharFilter(normMap, tokenStream). }
true;private;2;12;/**  * parses a list of MappingCharFilter style rules into a normalize char map  */ ;/**  * parses a list of MappingCharFilter style rules into a normalize char map  */ private void parseRules(List<String> rules, NormalizeCharMap.Builder map) {     for (String rule : rules) {         Matcher m = rulePattern.matcher(rule).         if (!m.find())             throw new RuntimeException("Invalid Mapping Rule : [" + rule + "]").         String lhs = parseString(m.group(1).trim()).         String rhs = parseString(m.group(2).trim()).         if (lhs == null || rhs == null)             throw new RuntimeException("Invalid Mapping Rule : [" + rule + "]. Illegal mapping.").         map.add(lhs, rhs).     } }
false;private;1;41;;private String parseString(String s) {     int readPos = 0.     int len = s.length().     int writePos = 0.     while (readPos < len) {         char c = s.charAt(readPos++).         if (c == '\\') {             if (readPos >= len)                 throw new RuntimeException("Invalid escaped char in [" + s + "]").             c = s.charAt(readPos++).             switch(c) {                 case '\\':                     c = '\\'.                     break.                 case 'n':                     c = '\n'.                     break.                 case 't':                     c = '\t'.                     break.                 case 'r':                     c = '\r'.                     break.                 case 'b':                     c = '\b'.                     break.                 case 'f':                     c = '\f'.                     break.                 case 'u':                     if (readPos + 3 >= len)                         throw new RuntimeException("Invalid escaped char in [" + s + "]").                     c = (char) Integer.parseInt(s.substring(readPos, readPos + 4), 16).                     readPos += 4.                     break.             }         }         out[writePos++] = c.     }     return new String(out, 0, writePos). }
