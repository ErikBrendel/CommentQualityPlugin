commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;53;;@Override public final boolean incrementToken() throws IOException {     clearAttributes().     int length = 0.     // this variable is always initialized     int start = -1.     int end = -1.     char[] buffer = termAtt.buffer().     while (true) {         if (bufferIndex >= dataLen) {             offset += dataLen.             // read supplementary char aware with CharacterUtils             CharacterUtils.fill(ioBuffer, input).             if (ioBuffer.getLength() == 0) {                 // so next offset += dataLen won't decrement offset                 dataLen = 0.                 if (length > 0) {                     break.                 } else {                     finalOffset = correctOffset(offset).                     return false.                 }             }             dataLen = ioBuffer.getLength().             bufferIndex = 0.         }         // use CharacterUtils here to support < 3.1 UTF-16 code unit behavior if the char based methods are gone         final int c = Character.codePointAt(ioBuffer.getBuffer(), bufferIndex, ioBuffer.getLength()).         final int charCount = Character.charCount(c).         bufferIndex += charCount.         if (Character.isLetter(c)) {             // if it's a token char             if (length == 0) {                 // start of token                 assert start == -1.                 start = offset + bufferIndex - charCount.                 end = start.             } else if (length >= buffer.length - 1) {                 // check if a supplementary could run out of bounds                 // make sure a supplementary fits in the buffer                 buffer = termAtt.resizeBuffer(2 + length).             }             end += charCount.             // buffer it, normalized             length += Character.toChars(Character.toLowerCase(c), buffer, length).             int maxTokenLen = CharTokenizer.DEFAULT_MAX_WORD_LEN.             if (length >= maxTokenLen) {                 // buffer overflow! make sure to check for >= surrogate pair could break == test                 break.             }         } else if (length > 0) {             // return 'em             break.         }     }     termAtt.setLength(length).     assert start != -1.     offsetAtt.setOffset(correctOffset(start), finalOffset = correctOffset(end)).     return true. }
false;public,final;0;6;;@Override public final void end() throws IOException {     super.end().     // set final offset     offsetAtt.setOffset(finalOffset, finalOffset). }
false;public;0;9;;@Override public void reset() throws IOException {     super.reset().     bufferIndex = 0.     offset = 0.     dataLen = 0.     finalOffset = 0.     // make sure to reset the IO buffer!!     ioBuffer.reset(). }
