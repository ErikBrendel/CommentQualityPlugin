commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;3;;private static Collection<Class<? extends Plugin>> mockPlugins() {     return Arrays.asList(getTestTransportPlugin(), MockHttpTransport.TestPlugin.class). }
false;public;0;20;;public void testInitializiationIsConsistent() {     long clusterSeed = randomLong().     boolean masterNodes = randomBoolean().     int minNumDataNodes = randomIntBetween(0, 9).     int maxNumDataNodes = randomIntBetween(minNumDataNodes, 10).     String clusterName = randomRealisticUnicodeOfCodepointLengthBetween(1, 10).     NodeConfigurationSource nodeConfigurationSource = NodeConfigurationSource.EMPTY.     int numClientNodes = randomIntBetween(0, 10).     String nodePrefix = randomRealisticUnicodeOfCodepointLengthBetween(1, 10).     Path baseDir = createTempDir().     InternalTestCluster cluster0 = new InternalTestCluster(clusterSeed, baseDir, masterNodes, randomBoolean(), minNumDataNodes, maxNumDataNodes, clusterName, nodeConfigurationSource, numClientNodes, nodePrefix, Collections.emptyList(), Function.identity()).     InternalTestCluster cluster1 = new InternalTestCluster(clusterSeed, baseDir, masterNodes, randomBoolean(), minNumDataNodes, maxNumDataNodes, clusterName, nodeConfigurationSource, numClientNodes, nodePrefix, Collections.emptyList(), Function.identity()).     // TODO: this is not ideal - we should have a way to make sure ports are initialized in the same way     assertClusters(cluster0, cluster1, false). }
false;public,static;3;9;;public static void assertClusters(InternalTestCluster cluster0, InternalTestCluster cluster1, boolean checkClusterUniqueSettings) {     Settings defaultSettings0 = cluster0.getDefaultSettings().     Settings defaultSettings1 = cluster1.getDefaultSettings().     assertSettings(defaultSettings0, defaultSettings1, checkClusterUniqueSettings).     assertThat(cluster0.numDataNodes(), equalTo(cluster1.numDataNodes())).     if (checkClusterUniqueSettings) {         assertThat(cluster0.getClusterName(), equalTo(cluster1.getClusterName())).     } }
false;public,static;3;13;;public static void assertSettings(Settings left, Settings right, boolean checkClusterUniqueSettings) {     Set<String> keys0 = left.keySet().     Set<String> keys1 = right.keySet().     assertThat("--> left:\n" + left.toDelimitedString('\n') + "\n-->right:\n" + right.toDelimitedString('\n'), keys0.size(), equalTo(keys1.size())).     for (String key : keys0) {         if (clusterUniqueSettings.contains(key) && checkClusterUniqueSettings == false) {             continue.         }         assertTrue("key [" + key + "] is missing in " + keys1, keys1.contains(key)).         assertEquals(right.get(key), left.get(key)).     } }
false;public;1;15;;@Override public Settings nodeSettings(int nodeOrdinal) {     final Settings.Builder settings = Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2 * ((masterNodes ? InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES : 0) + maxNumDataNodes + numClientNodes)).put(DiscoveryModule.DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).     if (autoManageMinMasterNodes == false) {         assert minNumDataNodes == maxNumDataNodes.         assert masterNodes == false.     }     return settings.build(). }
false;public;1;4;;@Override public Path nodeConfigPath(int nodeOrdinal) {     return null. }
false;public;0;5;;@Override public Settings transportClientSettings() {     return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build(). }
false;public;0;89;;public void testBeforeTest() throws Exception {     final boolean autoManageMinMasterNodes = randomBoolean().     long clusterSeed = randomLong().     final boolean masterNodes.     final int minNumDataNodes.     final int maxNumDataNodes.     final int bootstrapMasterNodeIndex.     if (autoManageMinMasterNodes) {         masterNodes = randomBoolean().         minNumDataNodes = randomIntBetween(0, 3).         maxNumDataNodes = randomIntBetween(minNumDataNodes, 4).         bootstrapMasterNodeIndex = -1.     } else {         // if we manage min master nodes, we need to lock down the number of nodes         minNumDataNodes = randomIntBetween(0, 4).         maxNumDataNodes = minNumDataNodes.         masterNodes = false.         bootstrapMasterNodeIndex = maxNumDataNodes == 0 ? -1 : randomIntBetween(0, maxNumDataNodes - 1).     }     final int numClientNodes = randomIntBetween(0, 2).     final String clusterName1 = "shared1".     final String clusterName2 = "shared2".     String transportClient = getTestTransportType().     NodeConfigurationSource nodeConfigurationSource = new NodeConfigurationSource() {          @Override         public Settings nodeSettings(int nodeOrdinal) {             final Settings.Builder settings = Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2 * ((masterNodes ? InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES : 0) + maxNumDataNodes + numClientNodes)).put(DiscoveryModule.DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).             if (autoManageMinMasterNodes == false) {                 assert minNumDataNodes == maxNumDataNodes.                 assert masterNodes == false.             }             return settings.build().         }          @Override         public Path nodeConfigPath(int nodeOrdinal) {             return null.         }          @Override         public Settings transportClientSettings() {             return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build().         }     }.     String nodePrefix = "foobar".     Path baseDir = createTempDir().     InternalTestCluster cluster0 = new InternalTestCluster(clusterSeed, baseDir, masterNodes, autoManageMinMasterNodes, minNumDataNodes, maxNumDataNodes, clusterName1, nodeConfigurationSource, numClientNodes, nodePrefix, mockPlugins(), Function.identity()).     cluster0.setBootstrapMasterNodeIndex(bootstrapMasterNodeIndex).     InternalTestCluster cluster1 = new InternalTestCluster(clusterSeed, baseDir, masterNodes, autoManageMinMasterNodes, minNumDataNodes, maxNumDataNodes, clusterName2, nodeConfigurationSource, numClientNodes, nodePrefix, mockPlugins(), Function.identity()).     cluster1.setBootstrapMasterNodeIndex(bootstrapMasterNodeIndex).     assertClusters(cluster0, cluster1, false).     long seed = randomLong().     try {         {             Random random = new Random(seed).             cluster0.beforeTest(random, random.nextDouble()).         }         {             Random random = new Random(seed).             cluster1.beforeTest(random, random.nextDouble()).         }         assertArrayEquals(cluster0.getNodeNames(), cluster1.getNodeNames()).         Iterator<Client> iterator1 = cluster1.getClients().iterator().         for (Client client : cluster0.getClients()) {             assertTrue(iterator1.hasNext()).             Client other = iterator1.next().             assertSettings(client.settings(), other.settings(), false).         }         cluster0.afterTest().         cluster1.afterTest().     } finally {         IOUtils.close(cluster0, cluster1).     } }
false;public;1;11;;@Override public Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2 + (masterNodes ? InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES : 0) + maxNumDataNodes + numClientNodes).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).putList(DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).build(). }
false;public;1;4;;@Override public Path nodeConfigPath(int nodeOrdinal) {     return null. }
false;public;0;5;;@Override public Settings transportClientSettings() {     return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build(). }
false;public;0;91;;public void testDataFolderAssignmentAndCleaning() throws IOException, InterruptedException {     long clusterSeed = randomLong().     boolean masterNodes = randomBoolean().     // we need one stable node     final int minNumDataNodes = 2.     final int maxNumDataNodes = 2.     final int numClientNodes = randomIntBetween(0, 2).     final String clusterName1 = "shared1".     String transportClient = getTestTransportType().     NodeConfigurationSource nodeConfigurationSource = new NodeConfigurationSource() {          @Override         public Settings nodeSettings(int nodeOrdinal) {             return Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2 + (masterNodes ? InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES : 0) + maxNumDataNodes + numClientNodes).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).putList(DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).build().         }          @Override         public Path nodeConfigPath(int nodeOrdinal) {             return null.         }          @Override         public Settings transportClientSettings() {             return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build().         }     }.     String nodePrefix = "test".     Path baseDir = createTempDir().     InternalTestCluster cluster = new InternalTestCluster(clusterSeed, baseDir, masterNodes, true, minNumDataNodes, maxNumDataNodes, clusterName1, nodeConfigurationSource, numClientNodes, nodePrefix, mockPlugins(), Function.identity()).     try {         cluster.beforeTest(random(), 0.0).         final int originalMasterCount = cluster.numMasterNodes().         final Map<String, Path[]> shardNodePaths = new HashMap<>().         for (String name : cluster.getNodeNames()) {             shardNodePaths.put(name, getNodePaths(cluster, name)).         }         String poorNode = randomValueOtherThanMany(n -> originalMasterCount == 1 && n.equals(cluster.getMasterName()), () -> randomFrom(cluster.getNodeNames())).         Path dataPath = getNodePaths(cluster, poorNode)[0].         final Path testMarker = dataPath.resolve("testMarker").         Files.createDirectories(testMarker).         int expectedMasterCount = originalMasterCount.         if (cluster.getInstance(ClusterService.class, poorNode).localNode().isMasterNode()) {             expectedMasterCount--.         }         cluster.stopRandomNode(InternalTestCluster.nameFilter(poorNode)).         // stopping a node half way shouldn't clean data         assertFileExists(testMarker).         final String stableNode = randomFrom(cluster.getNodeNames()).         final Path stableDataPath = getNodePaths(cluster, stableNode)[0].         final Path stableTestMarker = stableDataPath.resolve("stableTestMarker").         assertThat(stableDataPath, not(dataPath)).         Files.createDirectories(stableTestMarker).         final String newNode1 = cluster.startNode().         expectedMasterCount++.         assertThat(getNodePaths(cluster, newNode1)[0], equalTo(dataPath)).         // starting a node should re-use data folders and not clean it         assertFileExists(testMarker).         final String newNode2 = cluster.startNode().         expectedMasterCount++.         final Path newDataPath = getNodePaths(cluster, newNode2)[0].         final Path newTestMarker = newDataPath.resolve("newTestMarker").         assertThat(newDataPath, not(dataPath)).         Files.createDirectories(newTestMarker).         cluster.beforeTest(random(), 0.0).         // the cluster should be reset for a new test, cleaning up the extra path we made         assertFileNotExists(newTestMarker).         // a new unknown node used this path, it should be cleaned         assertFileNotExists(testMarker).         // but leaving the structure of existing, reused nodes         assertFileExists(stableTestMarker).         for (String name : cluster.getNodeNames()) {             assertThat("data paths for " + name + " changed", getNodePaths(cluster, name), equalTo(shardNodePaths.get(name))).         }         cluster.beforeTest(random(), 0.0).         // but leaving the structure of existing, reused nodes         assertFileExists(stableTestMarker).         for (String name : cluster.getNodeNames()) {             assertThat("data paths for " + name + " changed", getNodePaths(cluster, name), equalTo(shardNodePaths.get(name))).         }     } finally {         cluster.close().     } }
false;private;2;8;;private Path[] getNodePaths(InternalTestCluster cluster, String name) {     final NodeEnvironment nodeEnvironment = cluster.getInstance(NodeEnvironment.class, name).     if (nodeEnvironment.hasNodeFile()) {         return nodeEnvironment.nodeDataPaths().     } else {         return new Path[0].     } }
false;public;1;10;;@Override public Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), numNodes).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).put(DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.getKey(), 0).putList(DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).build(). }
false;public;1;4;;@Override public Path nodeConfigPath(int nodeOrdinal) {     return null. }
false;public;0;5;;@Override public Settings transportClientSettings() {     return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build(). }
false;public;0;88;;public void testDifferentRolesMaintainPathOnRestart() throws Exception {     final Path baseDir = createTempDir().     final int numNodes = 5.     String transportClient = getTestTransportType().     InternalTestCluster cluster = new InternalTestCluster(randomLong(), baseDir, false, false, 0, 0, "test", new NodeConfigurationSource() {          @Override         public Settings nodeSettings(int nodeOrdinal) {             return Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), numNodes).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).put(DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.getKey(), 0).putList(DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).build().         }          @Override         public Path nodeConfigPath(int nodeOrdinal) {             return null.         }          @Override         public Settings transportClientSettings() {             return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build().         }     }, 0, "", mockPlugins(), Function.identity()).     cluster.beforeTest(random(), 0.0).     List<DiscoveryNode.Role> roles = new ArrayList<>().     for (int i = 0. i < numNodes. i++) {         final DiscoveryNode.Role role = i == numNodes - 1 && roles.contains(MASTER) == false ? // last node and still no master         MASTER : randomFrom(MASTER, DiscoveryNode.Role.DATA, DiscoveryNode.Role.INGEST).         roles.add(role).     }     cluster.setBootstrapMasterNodeIndex(randomIntBetween(0, (int) roles.stream().filter(role -> role.equals(MASTER)).count() - 1)).     try {         Map<DiscoveryNode.Role, Set<String>> pathsPerRole = new HashMap<>().         for (int i = 0. i < numNodes. i++) {             final DiscoveryNode.Role role = roles.get(i).             final String node.             switch(role) {                 case MASTER:                     node = cluster.startMasterOnlyNode().                     break.                 case DATA:                     node = cluster.startDataOnlyNode().                     break.                 case INGEST:                     node = cluster.startCoordinatingOnlyNode(Settings.EMPTY).                     break.                 default:                     throw new IllegalStateException("get your story straight").             }             Set<String> rolePaths = pathsPerRole.computeIfAbsent(role, k -> new HashSet<>()).             for (Path path : getNodePaths(cluster, node)) {                 assertTrue(rolePaths.add(path.toString())).             }         }         cluster.validateClusterFormed().         cluster.fullRestart().         Map<DiscoveryNode.Role, Set<String>> result = new HashMap<>().         for (String name : cluster.getNodeNames()) {             DiscoveryNode node = cluster.getInstance(ClusterService.class, name).localNode().             List<String> paths = Arrays.stream(getNodePaths(cluster, name)).map(Path::toString).collect(Collectors.toList()).             if (node.isMasterNode()) {                 result.computeIfAbsent(MASTER, k -> new HashSet<>()).addAll(paths).             } else if (node.isDataNode()) {                 result.computeIfAbsent(DATA, k -> new HashSet<>()).addAll(paths).             } else {                 result.computeIfAbsent(INGEST, k -> new HashSet<>()).addAll(paths).             }         }         assertThat(result.size(), equalTo(pathsPerRole.size())).         for (DiscoveryNode.Role role : result.keySet()) {             assertThat("path are not the same for " + role, result.get(role), equalTo(pathsPerRole.get(role))).         }     } finally {         cluster.close().     } }
false;public;1;9;;@Override public Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).putList(DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).build(). }
false;public;1;4;;@Override public Path nodeConfigPath(int nodeOrdinal) {     return null. }
false;public;0;5;;@Override public Settings transportClientSettings() {     return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build(). }
false;public;0;49;;public void testTwoNodeCluster() throws Exception {     String transportClient = getTestTransportType().     NodeConfigurationSource nodeConfigurationSource = new NodeConfigurationSource() {          @Override         public Settings nodeSettings(int nodeOrdinal) {             return Settings.builder().put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2).put(NetworkModule.TRANSPORT_TYPE_KEY, getTestTransportType()).putList(DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "file").putList(SettingsBasedSeedHostsProvider.DISCOVERY_SEED_HOSTS_SETTING.getKey()).build().         }          @Override         public Path nodeConfigPath(int nodeOrdinal) {             return null.         }          @Override         public Settings transportClientSettings() {             return Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, transportClient).build().         }     }.     String nodePrefix = "test".     Path baseDir = createTempDir().     List<Class<? extends Plugin>> plugins = new ArrayList<>(mockPlugins()).     plugins.add(NodeAttrCheckPlugin.class).     InternalTestCluster cluster = new InternalTestCluster(randomLong(), baseDir, false, true, 2, 2, "test", nodeConfigurationSource, 0, nodePrefix, plugins, Function.identity()).     try {         cluster.beforeTest(random(), 0.0).         switch(randomInt(2)) {             case 0:                 cluster.stopRandomDataNode().                 cluster.startNode().                 break.             case 1:                 cluster.rollingRestart(InternalTestCluster.EMPTY_CALLBACK).                 break.             case 2:                 cluster.fullRestart().                 break.         }     } finally {         cluster.close().     } }
false;public;0;7;;@Override public Settings additionalSettings() {     if (settings.get("node.attr.dummy") != null) {         fail("dummy setting already exists").     }     return Settings.builder().put("node.attr.dummy", true).build(). }
