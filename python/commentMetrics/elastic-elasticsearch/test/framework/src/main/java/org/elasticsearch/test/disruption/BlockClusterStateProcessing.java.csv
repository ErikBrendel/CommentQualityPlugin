commented;modifiers;parameterAmount;loc;comment;code
false;public;0;32;;@Override public void startDisrupting() {     final String disruptionNodeCopy = disruptedNode.     if (disruptionNodeCopy == null) {         return.     }     ClusterService clusterService = cluster.getInstance(ClusterService.class, disruptionNodeCopy).     if (clusterService == null) {         return.     }     logger.info("delaying cluster state updates on node [{}]", disruptionNodeCopy).     boolean success = disruptionLatch.compareAndSet(null, new CountDownLatch(1)).     assert success : "startDisrupting called without waiting on stopDisrupting to complete".     final CountDownLatch started = new CountDownLatch(1).     clusterService.getClusterApplierService().runOnApplierThread("service_disruption_block", currentState -> {         started.countDown().         CountDownLatch latch = disruptionLatch.get().         if (latch != null) {             try {                 latch.await().             } catch (InterruptedException e) {                 Throwables.rethrow(e).             }         }     }, (source, e) -> logger.error("unexpected error during disruption", e), Priority.IMMEDIATE).     try {         started.await().     } catch (InterruptedException e) {     } }
false;public;0;8;;@Override public void stopDisrupting() {     CountDownLatch latch = disruptionLatch.get().     if (latch != null) {         latch.countDown().     } }
false;public;1;4;;@Override public void removeAndEnsureHealthy(InternalTestCluster cluster) {     removeFromCluster(cluster). }
false;public;0;4;;@Override public TimeValue expectedTimeToHeal() {     return TimeValue.timeValueMinutes(0). }
