commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public void startDisrupting() {     disrupting = true.     worker = new Thread(new BackgroundWorker(), "long_gc_simulation_" + thread_ids.incrementAndGet()).     worker.setDaemon(true).     worker.start(). }
false;public;0;15;;@Override public void stopDisrupting() {     if (worker == null) {         return.     }     logger.info("stopping long GCs on [{}]", disruptedNode).     disrupting = false.     worker.interrupt().     try {         worker.join(2 * (intervalBetweenDelaysMax + delayDurationMax)).     } catch (InterruptedException e) {         logger.info("background thread failed to stop").     }     worker = null. }
false;private;1;13;;private void simulateLongGC(final TimeValue duration) throws InterruptedException {     logger.info("node [{}] goes into GC for for [{}]", disruptedNode, duration).     final Set<Thread> nodeThreads = new HashSet<>().     try {         while (suspendThreads(nodeThreads)) .         if (!nodeThreads.isEmpty()) {             Thread.sleep(duration.millis()).         }     } finally {         logger.info("node [{}] resumes from GC", disruptedNode).         resumeThreads(nodeThreads).     } }
false;public;0;18;;@Override public void run() {     while (disrupting) {         try {             TimeValue duration = new TimeValue(delayDurationMin + random.nextInt((int) (delayDurationMax - delayDurationMin))).             simulateLongGC(duration).             duration = new TimeValue(intervalBetweenDelaysMin + random.nextInt((int) (intervalBetweenDelaysMax - intervalBetweenDelaysMin))).             if (disrupting) {                 Thread.sleep(duration.millis()).             }         } catch (InterruptedException e) {         } catch (Exception e) {             logger.error("error in background worker", e).         }     } }
