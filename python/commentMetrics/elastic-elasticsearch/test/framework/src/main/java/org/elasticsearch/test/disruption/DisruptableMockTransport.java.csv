commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;1;1;;protected abstract ConnectionStatus getConnectionStatus(DiscoveryNode destination).
false;protected,abstract;1;1;;protected abstract Optional<DisruptableMockTransport> getDisruptableMockTransport(TransportAddress address).
false;protected,abstract;1;1;;protected abstract void execute(Runnable runnable).
false;protected,final;2;8;;protected final void execute(String action, Runnable runnable) {     // handshake needs to run inline as the caller blockingly waits on the result     if (action.equals(HANDSHAKE_ACTION_NAME)) {         runnable.run().     } else {         execute(runnable).     } }
false;public;0;3;;public DiscoveryNode getLocalNode() {     return localNode. }
false;public;6;6;;@Override public TransportService createTransportService(Settings settings, ThreadPool threadPool, TransportInterceptor interceptor, Function<BoundTransportAddress, DiscoveryNode> localNodeFactory, @Nullable ClusterSettings clusterSettings, Set<String> taskHeaders) {     return new TransportService(settings, this, threadPool, interceptor, localNodeFactory, clusterSettings, taskHeaders). }
false;public;0;4;;@Override public DiscoveryNode getNode() {     return node. }
false;public;4;5;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {     onSendRequest(requestId, action, request, matchingTransport.get()). }
false;public;3;21;;@Override public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> listener) {     final Optional<DisruptableMockTransport> matchingTransport = getDisruptableMockTransport(node.getAddress()).     if (matchingTransport.isPresent()) {         listener.onResponse(new CloseableConnection() {              @Override             public DiscoveryNode getNode() {                 return node.             }              @Override             public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {                 onSendRequest(requestId, action, request, matchingTransport.get()).             }         }).         return () -> {         }.     } else {         throw new ConnectTransportException(node, "node " + node + " does not exist").     } }
false;public;0;16;;@Override public void run() {     switch(getConnectionStatus(destinationTransport.getLocalNode())) {         case BLACK_HOLE:             onBlackholedDuringSend(requestId, action, destinationTransport).             break.         case DISCONNECTED:             onDisconnectedDuringSend(requestId, action, destinationTransport).             break.         case CONNECTED:             onConnectedDuringSend(requestId, action, request, destinationTransport).             break.     } }
false;public;0;4;;@Override public String toString() {     return getRequestDescription(requestId, action, destinationTransport.getLocalNode()). }
false;protected;4;30;;protected void onSendRequest(long requestId, String action, TransportRequest request, DisruptableMockTransport destinationTransport) {     assert destinationTransport.getLocalNode().equals(getLocalNode()) == false : "non-local message from " + getLocalNode() + " to itself".     destinationTransport.execute(action, new Runnable() {          @Override         public void run() {             switch(getConnectionStatus(destinationTransport.getLocalNode())) {                 case BLACK_HOLE:                     onBlackholedDuringSend(requestId, action, destinationTransport).                     break.                 case DISCONNECTED:                     onDisconnectedDuringSend(requestId, action, destinationTransport).                     break.                 case CONNECTED:                     onConnectedDuringSend(requestId, action, request, destinationTransport).                     break.             }         }          @Override         public String toString() {             return getRequestDescription(requestId, action, destinationTransport.getLocalNode()).         }     }). }
false;public;0;4;;@Override public void run() {     handleError(requestId, new ConnectTransportException(destination, "disconnected")). }
false;public;0;4;;@Override public String toString() {     return "disconnection response to " + getRequestDescription(requestId, action, destination). }
false;protected;3;13;;protected Runnable getDisconnectException(long requestId, String action, DiscoveryNode destination) {     return new Runnable() {          @Override         public void run() {             handleError(requestId, new ConnectTransportException(destination, "disconnected")).         }          @Override         public String toString() {             return "disconnection response to " + getRequestDescription(requestId, action, destination).         }     }. }
false;protected;3;4;;protected String getRequestDescription(long requestId, String action, DiscoveryNode destination) {     return new ParameterizedMessage("[{}][{}] from {} to {}", requestId, action, getLocalNode(), destination).getFormattedMessage(). }
false;protected;3;10;;protected void onBlackholedDuringSend(long requestId, String action, DisruptableMockTransport destinationTransport) {     if (action.equals(HANDSHAKE_ACTION_NAME)) {         logger.trace("ignoring blackhole and delivering {}", getRequestDescription(requestId, action, destinationTransport.getLocalNode())).         // handshakes always have a timeout, and are sent in a blocking fashion, so we must respond with an exception.         destinationTransport.execute(action, getDisconnectException(requestId, action, destinationTransport.getLocalNode())).     } else {         logger.trace("dropping {}", getRequestDescription(requestId, action, destinationTransport.getLocalNode())).     } }
false;protected;3;3;;protected void onDisconnectedDuringSend(long requestId, String action, DisruptableMockTransport destinationTransport) {     destinationTransport.execute(action, getDisconnectException(requestId, action, destinationTransport.getLocalNode())). }
false;public;0;4;;@Override public String getProfileName() {     return "default". }
false;public;0;4;;@Override public String getChannelType() {     return "disruptable-mock-transport-channel". }
false;public;0;9;;@Override public void run() {     if (destinationTransport.getConnectionStatus(getLocalNode()) != ConnectionStatus.CONNECTED) {         logger.trace("dropping response to {}: channel is not CONNECTED", requestDescription).     } else {         handleResponse(requestId, response).     } }
false;public;0;4;;@Override public String toString() {     return "response to " + requestDescription. }
false;public;1;19;;@Override public void sendResponse(final TransportResponse response) {     execute(action, new Runnable() {          @Override         public void run() {             if (destinationTransport.getConnectionStatus(getLocalNode()) != ConnectionStatus.CONNECTED) {                 logger.trace("dropping response to {}: channel is not CONNECTED", requestDescription).             } else {                 handleResponse(requestId, response).             }         }          @Override         public String toString() {             return "response to " + requestDescription.         }     }). }
false;public;0;9;;@Override public void run() {     if (destinationTransport.getConnectionStatus(getLocalNode()) != ConnectionStatus.CONNECTED) {         logger.trace("dropping response to {}: channel is not CONNECTED", requestDescription).     } else {         handleRemoteError(requestId, exception).     } }
false;public;0;4;;@Override public String toString() {     return "error response to " + requestDescription. }
false;public;1;19;;@Override public void sendResponse(Exception exception) {     execute(action, new Runnable() {          @Override         public void run() {             if (destinationTransport.getConnectionStatus(getLocalNode()) != ConnectionStatus.CONNECTED) {                 logger.trace("dropping response to {}: channel is not CONNECTED", requestDescription).             } else {                 handleRemoteError(requestId, exception).             }         }          @Override         public String toString() {             return "error response to " + requestDescription.         }     }). }
false;protected;4;78;;protected void onConnectedDuringSend(long requestId, String action, TransportRequest request, DisruptableMockTransport destinationTransport) {     final RequestHandlerRegistry<TransportRequest> requestHandler = destinationTransport.getRequestHandler(action).     final DiscoveryNode destination = destinationTransport.getLocalNode().     final String requestDescription = getRequestDescription(requestId, action, destination).     final TransportChannel transportChannel = new TransportChannel() {          @Override         public String getProfileName() {             return "default".         }          @Override         public String getChannelType() {             return "disruptable-mock-transport-channel".         }          @Override         public void sendResponse(final TransportResponse response) {             execute(action, new Runnable() {                  @Override                 public void run() {                     if (destinationTransport.getConnectionStatus(getLocalNode()) != ConnectionStatus.CONNECTED) {                         logger.trace("dropping response to {}: channel is not CONNECTED", requestDescription).                     } else {                         handleResponse(requestId, response).                     }                 }                  @Override                 public String toString() {                     return "response to " + requestDescription.                 }             }).         }          @Override         public void sendResponse(Exception exception) {             execute(action, new Runnable() {                  @Override                 public void run() {                     if (destinationTransport.getConnectionStatus(getLocalNode()) != ConnectionStatus.CONNECTED) {                         logger.trace("dropping response to {}: channel is not CONNECTED", requestDescription).                     } else {                         handleRemoteError(requestId, exception).                     }                 }                  @Override                 public String toString() {                     return "error response to " + requestDescription.                 }             }).         }     }.     final TransportRequest copiedRequest.     try {         copiedRequest = copyWriteable(request, writeableRegistry(), requestHandler::newRequest).     } catch (IOException e) {         throw new AssertionError("exception de/serializing request", e).     }     try {         requestHandler.processMessageReceived(copiedRequest, transportChannel).     } catch (Exception e) {         try {             transportChannel.sendResponse(e).         } catch (Exception ee) {             logger.warn("failed to send failure", e).         }     } }
