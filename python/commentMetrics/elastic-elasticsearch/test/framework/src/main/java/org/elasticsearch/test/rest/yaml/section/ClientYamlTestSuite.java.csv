commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;31;;public static ClientYamlTestSuite parse(NamedXContentRegistry executeableSectionRegistry, String api, Path file) throws IOException {     if (!Files.isRegularFile(file)) {         throw new IllegalArgumentException(file.toAbsolutePath() + " is not a file").     }     String filename = file.getFileName().toString().     // remove the file extension     int i = filename.lastIndexOf('.').     if (i > 0) {         filename = filename.substring(0, i).     }     // our yaml parser seems to be too tolerant. Each yaml suite must end with \n, otherwise clients tests might break.     try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {         ByteBuffer bb = ByteBuffer.wrap(new byte[1]).         if (channel.size() == 0) {             throw new IllegalArgumentException("test suite file " + file.toString() + " is empty").         }         channel.read(bb, channel.size() - 1).         if (bb.get(0) != 10) {             throw new IOException("test suite [" + api + "/" + filename + "] doesn't end with line feed (\\n)").         }     }     try (XContentParser parser = YamlXContent.yamlXContent.createParser(executeableSectionRegistry, LoggingDeprecationHandler.INSTANCE, Files.newInputStream(file))) {         return parse(api, filename, parser).     } catch (Exception e) {         throw new IOException("Error parsing " + api + "/" + filename, e).     } }
false;public,static;3;26;;public static ClientYamlTestSuite parse(String api, String suiteName, XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new XContentParseException(parser.getTokenLocation(), "expected token to be START_OBJECT but was " + parser.currentToken()).     }     SetupSection setupSection = SetupSection.parseIfNext(parser).     TeardownSection teardownSection = TeardownSection.parseIfNext(parser).     Set<ClientYamlTestSection> testSections = new TreeSet<>().     while (true) {         // and a null at the end of the file (at least two consecutive null tokens)         if (parser.currentToken() == null) {             if (parser.nextToken() == null) {                 break.             }         }         ClientYamlTestSection testSection = ClientYamlTestSection.parse(parser).         if (testSections.add(testSection) == false) {             throw new ParsingException(testSection.getLocation(), "duplicate test section [" + testSection.getName() + "]").         }     }     return new ClientYamlTestSuite(api, suiteName, setupSection, teardownSection, new ArrayList<>(testSections)). }
false;public;0;3;;public String getApi() {     return api. }
false;public;0;3;;public String getName() {     return name. }
false;public;0;3;;public String getPath() {     return api + "/" + name. }
false;public;0;3;;public SetupSection getSetupSection() {     return setupSection. }
false;public;0;3;;public TeardownSection getTeardownSection() {     return teardownSection. }
false;public;0;10;;public void validate() {     Stream<String> errors = validateExecutableSections(setupSection.getExecutableSections(), null, setupSection, null).     errors = Stream.concat(errors, validateExecutableSections(teardownSection.getDoSections(), null, null, teardownSection)).     errors = Stream.concat(errors, testSections.stream().flatMap(section -> validateExecutableSections(section.getExecutableSections(), section, setupSection, teardownSection))).     String errorMessage = errors.collect(Collectors.joining(",\n")).     if (errorMessage.isEmpty() == false) {         throw new IllegalArgumentException(getPath() + ":\n" + errorMessage).     } }
false;private,static;4;37;;private static Stream<String> validateExecutableSections(List<ExecutableSection> sections, ClientYamlTestSection testSection, SetupSection setupSection, TeardownSection teardownSection) {     Stream<String> errors = sections.stream().filter(section -> section instanceof DoSection).map(section -> (DoSection) section).filter(section -> false == section.getExpectedWarningHeaders().isEmpty()).filter(section -> false == hasSkipFeature("warnings", testSection, setupSection, teardownSection)).map(section -> "attempted to add a [do] with a [warnings] section " + "without a corresponding [\"skip\": \"features\": \"warnings\"] so runners that do not support the [warnings] " + "section can skip the test at line [" + section.getLocation().lineNumber + "]").     errors = Stream.concat(errors, sections.stream().filter(section -> section instanceof DoSection).map(section -> (DoSection) section).filter(section -> NodeSelector.ANY != section.getApiCallSection().getNodeSelector()).filter(section -> false == hasSkipFeature("node_selector", testSection, setupSection, teardownSection)).map(section -> "attempted to add a [do] with a [node_selector] " + "section without a corresponding [\"skip\": \"features\": \"node_selector\"] so runners that do not support the " + "[node_selector] section can skip the test at line [" + section.getLocation().lineNumber + "]")).     errors = Stream.concat(errors, sections.stream().filter(section -> section instanceof ContainsAssertion).filter(section -> false == hasSkipFeature("contains", testSection, setupSection, teardownSection)).map(section -> "attempted to add a [contains] assertion " + "without a corresponding [\"skip\": \"features\": \"contains\"] so runners that do not support the " + "[contains] assertion can skip the test at line [" + section.getLocation().lineNumber + "]")).     errors = Stream.concat(errors, sections.stream().filter(section -> section instanceof DoSection).map(section -> (DoSection) section).filter(section -> false == section.getApiCallSection().getHeaders().isEmpty()).filter(section -> false == hasSkipFeature("headers", testSection, setupSection, teardownSection)).map(section -> "attempted to add a [do] with a [headers] section without a corresponding " + "[\"skip\": \"features\": \"headers\"] so runners that do not support the [headers] section can skip the test at " + "line [" + section.getLocation().lineNumber + "]")).     return errors. }
false;private,static;4;6;;private static boolean hasSkipFeature(String feature, ClientYamlTestSection testSection, SetupSection setupSection, TeardownSection teardownSection) {     return (testSection != null && hasSkipFeature(feature, testSection.getSkipSection())) || (setupSection != null && hasSkipFeature(feature, setupSection.getSkipSection())) || (teardownSection != null && hasSkipFeature(feature, teardownSection.getSkipSection())). }
false;private,static;2;3;;private static boolean hasSkipFeature(String feature, SkipSection skipSection) {     return skipSection != null && skipSection.getFeatures().contains(feature). }
false;public;0;3;;public List<ClientYamlTestSection> getTestSections() {     return testSections. }
