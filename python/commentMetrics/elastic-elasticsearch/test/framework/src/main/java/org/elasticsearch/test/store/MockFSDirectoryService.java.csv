commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Directory newDirectory() throws IOException {     return wrap(delegateService.newDirectory()). }
false;protected,synchronized;2;4;;@Override protected synchronized Directory newFSDirectory(Path location, LockFactory lockFactory) throws IOException {     throw new UnsupportedOperationException(). }
false;public,static;3;34;;public static void checkIndex(Logger logger, Store store, ShardId shardId) {     if (store.tryIncRef()) {         logger.info("start check index").         try {             Directory dir = store.directory().             if (!Lucene.indexExists(dir)) {                 return.             }             try {                 BytesStreamOutput os = new BytesStreamOutput().                 PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name()).                 CheckIndex.Status status = store.checkIndex(out).                 out.flush().                 if (!status.clean) {                     ESTestCase.checkIndexFailed = true.                     logger.warn("check index [failure] index files={}\n{}", Arrays.toString(dir.listAll()), os.bytes().utf8ToString()).                     throw new IOException("index check failure").                 } else {                     if (logger.isDebugEnabled()) {                         logger.debug("check index [success]\n{}", os.bytes().utf8ToString()).                     }                 }             } catch (LockObtainFailedException e) {                 ESTestCase.checkIndexFailed = true.                 throw new IllegalStateException("IndexWriter is still open on shard " + shardId, e).             }         } catch (Exception e) {             logger.warn("failed to check index", e).         } finally {             logger.info("end check index").             store.decRef().         }     } }
false;private;1;12;;private Directory wrap(Directory dir) {     final ElasticsearchMockDirectoryWrapper w = new ElasticsearchMockDirectoryWrapper(random, dir, this.crashIndex).     w.setRandomIOExceptionRate(randomIOExceptionRate).     w.setRandomIOExceptionRateOnOpen(randomIOExceptionRateOnOpen).     w.setThrottling(throttle).     // we do this on the index level     w.setCheckIndexOnClose(false).     // TODO: make this test robust to virus scanner     w.setAssertNoDeleteOpenFile(false).     w.setUseSlowOpenClosers(false).     LuceneTestCase.closeAfterSuite(new CloseableDirectory(w)).     return w. }
false;private;2;12;;private FsDirectoryService randomDirectoryService(IndexSettings indexSettings, ShardPath path) {     final IndexMetaData build = IndexMetaData.builder(indexSettings.getIndexMetaData()).settings(Settings.builder().put(indexSettings.getIndexMetaData().getSettings()).put(IndexModule.INDEX_STORE_TYPE_SETTING.getKey(), RandomPicks.randomFrom(random, IndexModule.Type.values()).getSettingsKey())).build().     final IndexSettings newIndexSettings = new IndexSettings(build, indexSettings.getNodeSettings()).     return new FsDirectoryService(newIndexSettings, path). }
false;public,synchronized;0;6;;@Override public synchronized void crash() throws IOException {     if (crash) {         super.crash().     } }
false;public;0;13;;@Override public void close() {     // failures.     try {         if (failureMarker.wasSuccessful() && dir.isOpen()) {             Assert.fail("Directory not closed: " + dir).         }     } finally {     // TODO: perform real close of the delegate: LUCENE-4058     // dir.close().     } }
