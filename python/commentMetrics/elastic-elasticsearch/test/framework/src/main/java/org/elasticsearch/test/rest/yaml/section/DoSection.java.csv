commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;96;;public static DoSection parse(XContentParser parser) throws IOException {     String currentFieldName = null.     XContentParser.Token token.     DoSection doSection = new DoSection(parser.getTokenLocation()).     ApiCallSection apiCallSection = null.     NodeSelector nodeSelector = NodeSelector.ANY.     Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER).     List<String> expectedWarnings = new ArrayList<>().     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new IllegalArgumentException("expected [" + XContentParser.Token.START_OBJECT + "], " + "found [" + parser.currentToken() + "], the do section is not properly indented").     }     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if ("catch".equals(currentFieldName)) {                 doSection.setCatch(parser.text()).             } else {                 throw new ParsingException(parser.getTokenLocation(), "unsupported field [" + currentFieldName + "]").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if ("warnings".equals(currentFieldName)) {                 while ((token = parser.nextToken()) == XContentParser.Token.VALUE_STRING) {                     expectedWarnings.add(parser.text()).                 }                 if (token != XContentParser.Token.END_ARRAY) {                     throw new ParsingException(parser.getTokenLocation(), "[warnings] must be a string array but saw [" + token + "]").                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "unknown array [" + currentFieldName + "]").             }         } else if (token == XContentParser.Token.START_OBJECT) {             if ("headers".equals(currentFieldName)) {                 String headerName = null.                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         headerName = parser.currentName().                     } else if (token.isValue()) {                         headers.put(headerName, parser.text()).                     }                 }             } else if ("node_selector".equals(currentFieldName)) {                 String selectorName = null.                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         selectorName = parser.currentName().                     } else {                         NodeSelector newSelector = buildNodeSelector(selectorName, parser).                         nodeSelector = nodeSelector == NodeSelector.ANY ? newSelector : new ComposeNodeSelector(nodeSelector, newSelector).                     }                 }             } else if (currentFieldName != null) {                 // must be part of API call then                 apiCallSection = new ApiCallSection(currentFieldName).                 String paramName = null.                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         paramName = parser.currentName().                     } else if (token.isValue()) {                         if ("body".equals(paramName)) {                             String body = parser.text().                             XContentParser bodyParser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, body).                             // multiple bodies are supported e.g. in case of bulk provided as a whole string                             while (bodyParser.nextToken() != null) {                                 apiCallSection.addBody(bodyParser.mapOrdered()).                             }                         } else {                             apiCallSection.addParam(paramName, parser.text()).                         }                     } else if (token == XContentParser.Token.START_OBJECT) {                         if ("body".equals(paramName)) {                             apiCallSection.addBody(parser.mapOrdered()).                         }                     }                 }             }         }     }     try {         if (apiCallSection == null) {             throw new IllegalArgumentException("client call section is mandatory within a do section").         }         apiCallSection.addHeaders(headers).         apiCallSection.setNodeSelector(nodeSelector).         doSection.setApiCallSection(apiCallSection).         doSection.setExpectedWarningHeaders(unmodifiableList(expectedWarnings)).     } finally {         parser.nextToken().     }     return doSection. }
false;public;0;3;;public String getCatch() {     return catchParam. }
false;public;1;3;;public void setCatch(String catchParam) {     this.catchParam = catchParam. }
false;public;0;3;;public ApiCallSection getApiCallSection() {     return apiCallSection. }
false;;1;3;;void setApiCallSection(ApiCallSection apiCallSection) {     this.apiCallSection = apiCallSection. }
true;;0;3;/**  * Warning headers that we expect from this response. If the headers don't match exactly this request is considered to have failed.  * Defaults to emptyList.  */ ;/**  * Warning headers that we expect from this response. If the headers don't match exactly this request is considered to have failed.  * Defaults to emptyList.  */ List<String> getExpectedWarningHeaders() {     return expectedWarningHeaders. }
true;;1;3;/**  * Set the warning headers that we expect from this response. If the headers don't match exactly this request is considered to have  * failed. Defaults to emptyList.  */ ;/**  * Set the warning headers that we expect from this response. If the headers don't match exactly this request is considered to have  * failed. Defaults to emptyList.  */ void setExpectedWarningHeaders(List<String> expectedWarningHeaders) {     this.expectedWarningHeaders = expectedWarningHeaders. }
false;public;0;4;;@Override public XContentLocation getLocation() {     return location. }
false;public;1;46;;@Override public void execute(ClientYamlTestExecutionContext executionContext) throws IOException {     if ("param".equals(catchParam)) {         // client should throw validation error before sending request         // lets just return without doing anything as we don't have any client to test here         logger.info("found [catch: param], no request sent").         return.     }     try {         ClientYamlTestResponse response = executionContext.callApi(apiCallSection.getApi(), apiCallSection.getParams(), apiCallSection.getBodies(), apiCallSection.getHeaders(), apiCallSection.getNodeSelector()).         if (Strings.hasLength(catchParam)) {             String catchStatusCode.             if (catches.containsKey(catchParam)) {                 catchStatusCode = catches.get(catchParam).v1().             } else if (catchParam.startsWith("/") && catchParam.endsWith("/")) {                 catchStatusCode = "4xx|5xx".             } else {                 throw new UnsupportedOperationException("catch value [" + catchParam + "] not supported").             }             fail(formatStatusCodeMessage(response, catchStatusCode)).         }         checkWarningHeaders(response.getWarningHeaders(), executionContext.masterVersion()).     } catch (ClientYamlTestResponseException e) {         ClientYamlTestResponse restTestResponse = e.getRestTestResponse().         if (!Strings.hasLength(catchParam)) {             fail(formatStatusCodeMessage(restTestResponse, "2xx")).         } else if (catches.containsKey(catchParam)) {             assertStatusCode(restTestResponse).         } else if (catchParam.length() > 2 && catchParam.startsWith("/") && catchParam.endsWith("/")) {             // the text of the error message matches regular expression             assertThat(formatStatusCodeMessage(restTestResponse, "4xx|5xx"), e.getResponseException().getResponse().getStatusLine().getStatusCode(), greaterThanOrEqualTo(400)).             Object error = executionContext.response("error").             assertThat("error was expected in the response", error, notNullValue()).             // remove delimiters from regex             String regex = catchParam.substring(1, catchParam.length() - 1).             assertThat("the error message was expected to match the provided regex but didn't", error.toString(), matches(regex)).         } else {             throw new UnsupportedOperationException("catch value [" + catchParam + "] not supported").         }     } }
true;;2;39;/**  * Check that the response contains only the warning headers that we expect.  */ ;/**  * Check that the response contains only the warning headers that we expect.  */ void checkWarningHeaders(final List<String> warningHeaders, final Version masterVersion) {     final List<String> unexpected = new ArrayList<>().     final List<String> unmatched = new ArrayList<>().     final List<String> missing = new ArrayList<>().     // LinkedHashSet so that missing expected warnings come back in a predictable order which is nice for testing     final Set<String> expected = new LinkedHashSet<>(expectedWarningHeaders.stream().map(DeprecationLogger::escapeAndEncode).collect(Collectors.toList())).     for (final String header : warningHeaders) {         final Matcher matcher = WARNING_HEADER_PATTERN.matcher(header).         final boolean matches = matcher.matches().         if (matches) {             final String message = matcher.group(1).             if (message.startsWith("[types removal]")) {             /*                      * We skip warnings related to types deprecation so that we can continue to run the many                      * mixed-version tests that used typed APIs.                      */             } else if (expected.remove(message) == false) {                 unexpected.add(header).             }         } else {             unmatched.add(header).         }     }     if (expected.isEmpty() == false) {         for (final String header : expected) {             missing.add(header).         }     }     if (unexpected.isEmpty() == false || unmatched.isEmpty() == false || missing.isEmpty() == false) {         final StringBuilder failureMessage = new StringBuilder().         appendBadHeaders(failureMessage, unexpected, "got unexpected warning header" + (unexpected.size() > 1 ? "s" : "")).         appendBadHeaders(failureMessage, unmatched, "got unmatched warning header" + (unmatched.size() > 1 ? "s" : "")).         appendBadHeaders(failureMessage, missing, "did not get expected warning header" + (missing.size() > 1 ? "s" : "")).         fail(failureMessage.toString()).     } }
false;private;3;9;;private void appendBadHeaders(final StringBuilder sb, final List<String> headers, final String message) {     if (headers.isEmpty() == false) {         sb.append(message).append(" [\n").         for (final String header : headers) {             sb.append("\t").append(header).append("\n").         }         sb.append("]\n").     } }
false;private;1;5;;private void assertStatusCode(ClientYamlTestResponse restTestResponse) {     Tuple<String, org.hamcrest.Matcher<Integer>> stringMatcherTuple = catches.get(catchParam).     assertThat(formatStatusCodeMessage(restTestResponse, stringMatcherTuple.v1()), restTestResponse.getStatusCode(), stringMatcherTuple.v2()). }
false;private;2;8;;private String formatStatusCodeMessage(ClientYamlTestResponse restTestResponse, String expected) {     String api = apiCallSection.getApi().     if ("raw".equals(api)) {         api += "[method=" + apiCallSection.getParams().get("method") + " path=" + apiCallSection.getParams().get("path") + "]".     }     return "expected [" + expected + "] status code but api [" + api + "] returned [" + restTestResponse.getStatusCode() + " " + restTestResponse.getReasonPhrase() + "] [" + restTestResponse.getBodyAsString() + "]". }
false;private,static;2;10;;private static NodeSelector buildNodeSelector(String name, XContentParser parser) throws IOException {     switch(name) {         case "attribute":             return parseAttributeValuesSelector(parser).         case "version":             return parseVersionSelector(parser).         default:             throw new XContentParseException(parser.getTokenLocation(), "unknown node_selector [" + name + "]").     } }
false;public;1;10;;@Override public void select(Iterable<Node> nodes) {     for (Node node : nodes) {         if (node.getAttributes() == null) {             throw new IllegalStateException("expected [attributes] metadata to be set but got " + node).         }     }     delegate.select(nodes). }
false;public;0;4;;@Override public String toString() {     return delegate.toString(). }
false;private,static;1;45;;private static NodeSelector parseAttributeValuesSelector(XContentParser parser) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_OBJECT) {         throw new XContentParseException(parser.getTokenLocation(), "expected START_OBJECT").     }     String key = null.     XContentParser.Token token.     NodeSelector result = NodeSelector.ANY.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             key = parser.currentName().         } else if (token.isValue()) {             /*                  * HasAttributeNodeSelector selects nodes that do not have                  * attribute metadata set so it can be used against nodes that                  * have not yet been sniffed. In these tests we expect the node                  * metadata to be explicitly sniffed if we need it and we'd                  * like to hard fail if it is not so we wrap the selector so we                  * can assert that the data is sniffed.                  */             NodeSelector delegate = new HasAttributeNodeSelector(key, parser.text()).             NodeSelector newSelector = new NodeSelector() {                  @Override                 public void select(Iterable<Node> nodes) {                     for (Node node : nodes) {                         if (node.getAttributes() == null) {                             throw new IllegalStateException("expected [attributes] metadata to be set but got " + node).                         }                     }                     delegate.select(nodes).                 }                  @Override                 public String toString() {                     return delegate.toString().                 }             }.             result = result == NodeSelector.ANY ? newSelector : new ComposeNodeSelector(result, newSelector).         } else {             throw new XContentParseException(parser.getTokenLocation(), "expected [" + key + "] to be a value").         }     }     return result. }
false;public;1;14;;@Override public void select(Iterable<Node> nodes) {     for (Iterator<Node> itr = nodes.iterator(). itr.hasNext(). ) {         Node node = itr.next().         if (node.getVersion() == null) {             throw new IllegalStateException("expected [version] metadata to be set but got " + node).         }         Version version = Version.fromString(node.getVersion()).         if (false == (version.onOrAfter(range[0]) && version.onOrBefore(range[1]))) {             itr.remove().         }     } }
false;public;0;4;;@Override public String toString() {     return "version between [" + range[0] + "] and [" + range[1] + "]". }
false;private,static;1;27;;private static NodeSelector parseVersionSelector(XContentParser parser) throws IOException {     if (false == parser.currentToken().isValue()) {         throw new XContentParseException(parser.getTokenLocation(), "expected [version] to be a value").     }     Version[] range = SkipSection.parseVersionRange(parser.text()).     return new NodeSelector() {          @Override         public void select(Iterable<Node> nodes) {             for (Iterator<Node> itr = nodes.iterator(). itr.hasNext(). ) {                 Node node = itr.next().                 if (node.getVersion() == null) {                     throw new IllegalStateException("expected [version] metadata to be set but got " + node).                 }                 Version version = Version.fromString(node.getVersion()).                 if (false == (version.onOrAfter(range[0]) && version.onOrBefore(range[1]))) {                     itr.remove().                 }             }         }          @Override         public String toString() {             return "version between [" + range[0] + "] and [" + range[1] + "]".         }     }. }
false;public;1;5;;@Override public void select(Iterable<Node> nodes) {     rhs.select(nodes).     lhs.select(nodes). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     ComposeNodeSelector that = (ComposeNodeSelector) o.     return Objects.equals(lhs, that.lhs) && Objects.equals(rhs, that.rhs). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(lhs, rhs). }
false;public;0;5;;@Override public String toString() {     // . as in haskell's "compose" operator     return lhs + "." + rhs. }
