commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void testRunStarted(final Description description) throws Exception {     Package testClassPackage = description.getTestClass().getPackage().     previousPackageLoggingMap = processTestLogging(testClassPackage != null ? testClassPackage.getAnnotation(TestLogging.class) : null).     previousClassLoggingMap = processTestLogging(description.getAnnotation(TestLogging.class)). }
false;public;1;5;;@Override public void testRunFinished(final Result result) throws Exception {     previousClassLoggingMap = reset(previousClassLoggingMap).     previousPackageLoggingMap = reset(previousPackageLoggingMap). }
false;public;1;5;;@Override public void testStarted(final Description description) throws Exception {     final TestLogging testLogging = description.getAnnotation(TestLogging.class).     previousLoggingMap = processTestLogging(testLogging). }
false;public;1;4;;@Override public void testFinished(final Description description) throws Exception {     previousLoggingMap = reset(previousLoggingMap). }
true;private,static;1;6;/**  * Obtain the logger with the given name.  *  * @param loggerName the logger to obtain  * @return the logger  */ ;/**  * Obtain the logger with the given name.  *  * @param loggerName the logger to obtain  * @return the logger  */ private static Logger resolveLogger(String loggerName) {     if (loggerName.equalsIgnoreCase("_root")) {         return LogManager.getRootLogger().     }     return LogManager.getLogger(loggerName). }
true;private;1;21;/**  * Applies the test logging annotation and returns the existing logging levels.  *  * @param testLogging the test logging annotation to apply  * @return the existing logging levels  */ ;/**  * Applies the test logging annotation and returns the existing logging levels.  *  * @param testLogging the test logging annotation to apply  * @return the existing logging levels  */ private Map<String, String> processTestLogging(final TestLogging testLogging) {     final Map<String, String> map = getLoggersAndLevelsFromAnnotation(testLogging).     if (map == null) {         return Collections.emptyMap().     }     // obtain the existing logging levels so that we can restore them at the end of the test. we have to do this separately from setting     // the logging levels so that setting foo does not impact the logging level for foo.bar when we check the existing logging level for     // for.bar     final Map<String, String> existing = new TreeMap<>().     for (final Map.Entry<String, String> entry : map.entrySet()) {         final Logger logger = resolveLogger(entry.getKey()).         existing.put(entry.getKey(), logger.getLevel().toString()).     }     for (final Map.Entry<String, String> entry : map.entrySet()) {         final Logger logger = resolveLogger(entry.getKey()).         Loggers.setLevel(logger, entry.getValue()).     }     return existing. }
true;private,static;1;18;/**  * Obtain the logging levels from the test logging annotation.  *  * @param testLogging the test logging annotation  * @return a map from logger name to logging level  */ ;/**  * Obtain the logging levels from the test logging annotation.  *  * @param testLogging the test logging annotation  * @return a map from logger name to logging level  */ private static Map<String, String> getLoggersAndLevelsFromAnnotation(final TestLogging testLogging) {     if (testLogging == null) {         return Collections.emptyMap().     }     // use a sorted set so that we apply a parent logger before its children thus not overwriting the child setting when processing the     // parent setting     final Map<String, String> map = new TreeMap<>().     final String[] loggersAndLevels = testLogging.value().split(",").     for (final String loggerAndLevel : loggersAndLevels) {         final String[] loggerAndLevelArray = loggerAndLevel.split(":").         if (loggerAndLevelArray.length == 2) {             map.put(loggerAndLevelArray[0], loggerAndLevelArray[1]).         } else {             throw new IllegalArgumentException("invalid test logging annotation [" + loggerAndLevel + "]").         }     }     return map. }
true;private;1;8;/**  * Reset the logging levels to the state provided by the map.  *  * @param map the logging levels to apply  * @return an empty map  */ ;/**  * Reset the logging levels to the state provided by the map.  *  * @param map the logging levels to apply  * @return an empty map  */ private Map<String, String> reset(final Map<String, String> map) {     for (final Map.Entry<String, String> previousLogger : map.entrySet()) {         final Logger logger = resolveLogger(previousLogger.getKey()).         Loggers.setLevel(logger, previousLogger.getValue()).     }     return Collections.emptyMap(). }
