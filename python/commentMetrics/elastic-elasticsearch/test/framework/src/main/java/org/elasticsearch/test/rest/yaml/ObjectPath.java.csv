commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;6;;public static ObjectPath createFromResponse(Response response) throws IOException {     byte[] bytes = EntityUtils.toByteArray(response.getEntity()).     String contentType = response.getHeader("Content-Type").     XContentType xContentType = XContentType.fromMediaTypeOrFormat(contentType).     return ObjectPath.createFromXContent(xContentType.xContent(), new BytesArray(bytes)). }
false;public,static;2;9;;public static ObjectPath createFromXContent(XContent xContent, BytesReference input) throws IOException {     try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, input.streamInput())) {         if (parser.nextToken() == XContentParser.Token.START_ARRAY) {             return new ObjectPath(parser.listOrderedMap()).         }         return new ObjectPath(parser.mapOrdered()).     } }
true;public,static;2;3;/**  * A utility method that creates an {@link ObjectPath} via {@link #ObjectPath(Object)} returns  * the result of calling {@link #evaluate(String)} on it.  */ ;/**  * A utility method that creates an {@link ObjectPath} via {@link #ObjectPath(Object)} returns  * the result of calling {@link #evaluate(String)} on it.  */ public static <T> T evaluate(Object object, String path) throws IOException {     return new ObjectPath(object).evaluate(path, Stash.EMPTY). }
true;public;1;3;/**  * Returns the object corresponding to the provided path if present, null otherwise  */ ;/**  * Returns the object corresponding to the provided path if present, null otherwise  */ public <T> T evaluate(String path) throws IOException {     return evaluate(path, Stash.EMPTY). }
true;public;2;12;/**  * Returns the object corresponding to the provided path if present, null otherwise  */ ;/**  * Returns the object corresponding to the provided path if present, null otherwise  */ @SuppressWarnings("unchecked") public <T> T evaluate(String path, Stash stash) throws IOException {     String[] parts = parsePath(path).     Object object = this.object.     for (String part : parts) {         object = evaluate(part, object, stash).         if (object == null) {             return null.         }     }     return (T) object. }
false;private;3;23;;@SuppressWarnings("unchecked") private Object evaluate(String key, Object object, Stash stash) throws IOException {     if (stash.containsStashedValue(key)) {         key = stash.getValue(key).toString().     }     if (object instanceof Map) {         return ((Map<String, Object>) object).get(key).     }     if (object instanceof List) {         List<Object> list = (List<Object>) object.         try {             return list.get(Integer.valueOf(key)).         } catch (NumberFormatException e) {             throw new IllegalArgumentException("element was a list, but [" + key + "] was not numeric", e).         } catch (IndexOutOfBoundsException e) {             throw new IllegalArgumentException("element was a list with " + list.size() + " elements, but [" + key + "] was out of bounds", e).         }     }     throw new IllegalArgumentException("no object found for [" + key + "] within object of class [" + object.getClass() + "]"). }
false;private;1;32;;private String[] parsePath(String path) {     List<String> list = new ArrayList<>().     StringBuilder current = new StringBuilder().     boolean escape = false.     for (int i = 0. i < path.length(). i++) {         char c = path.charAt(i).         if (c == '\\') {             escape = true.             continue.         }         if (c == '.') {             if (escape) {                 escape = false.             } else {                 if (current.length() > 0) {                     list.add(current.toString()).                     current.setLength(0).                 }                 continue.             }         }         current.append(c).     }     if (current.length() > 0) {         list.add(current.toString()).     }     return list.toArray(new String[list.size()]). }
true;public;1;10;/**  * Create a new {@link XContentBuilder} from the xContent object underlying this {@link ObjectPath}.  * This only works for {@link ObjectPath} instances created from an xContent object, not from nested  * substructures. We throw an {@link UnsupportedOperationException} in those cases.  */ ;/**  * Create a new {@link XContentBuilder} from the xContent object underlying this {@link ObjectPath}.  * This only works for {@link ObjectPath} instances created from an xContent object, not from nested  * substructures. We throw an {@link UnsupportedOperationException} in those cases.  */ @SuppressWarnings("unchecked") public XContentBuilder toXContentBuilder(XContent xContent) throws IOException {     XContentBuilder builder = XContentBuilder.builder(xContent).     if (this.object instanceof Map) {         builder.map((Map<String, Object>) this.object).     } else {         throw new UnsupportedOperationException("Only ObjectPath created from a map supported.").     }     return builder. }
