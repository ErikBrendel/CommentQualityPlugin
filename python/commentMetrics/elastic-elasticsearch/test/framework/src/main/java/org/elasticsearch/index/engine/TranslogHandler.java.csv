commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;long appliedOperations() {     return appliedOperations.get(). }
false;private;1;5;;private DocumentMapperForType docMapper(String type) {     RootObjectMapper.Builder rootBuilder = new RootObjectMapper.Builder(type).     DocumentMapper.Builder b = new DocumentMapper.Builder(rootBuilder, mapperService).     return new DocumentMapperForType(b.build(mapperService), mappingUpdate). }
false;private;2;20;;private void applyOperation(Engine engine, Engine.Operation operation) throws IOException {     switch(operation.operationType()) {         case INDEX:             Engine.Index engineIndex = (Engine.Index) operation.             Mapping update = engineIndex.parsedDoc().dynamicMappingsUpdate().             if (engineIndex.parsedDoc().dynamicMappingsUpdate() != null) {                 recoveredTypes.compute(engineIndex.type(), (k, mapping) -> mapping == null ? update : mapping.merge(update)).             }             engine.index(engineIndex).             break.         case DELETE:             engine.delete((Engine.Delete) operation).             break.         case NO_OP:             engine.noOp((Engine.NoOp) operation).             break.         default:             throw new IllegalStateException("No operation defined for [" + operation + "]").     } }
true;public;0;3;/**  * Returns the recovered types modifying the mapping during the recovery  */ ;/**  * Returns the recovered types modifying the mapping during the recovery  */ public Map<String, Mapping> getRecoveredTypes() {     return recoveredTypes. }
false;public;2;11;;@Override public int run(Engine engine, Translog.Snapshot snapshot) throws IOException {     int opsRecovered = 0.     Translog.Operation operation.     while ((operation = snapshot.next()) != null) {         applyOperation(engine, convertToEngineOp(operation, Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY)).         opsRecovered++.         appliedOperations.incrementAndGet().     }     return opsRecovered. }
false;private;2;25;;private Engine.Operation convertToEngineOp(Translog.Operation operation, Engine.Operation.Origin origin) {     switch(operation.opType()) {         case INDEX:             final Translog.Index index = (Translog.Index) operation.             final String indexName = mapperService.index().getName().             final Engine.Index engineIndex = IndexShard.prepareIndex(docMapper(index.type()), mapperService.getIndexSettings().getIndexVersionCreated(), new SourceToParse(indexName, index.type(), index.id(), index.source(), XContentHelper.xContentType(index.source()), index.routing()), index.seqNo(), index.primaryTerm(), index.version(), null, origin, index.getAutoGeneratedIdTimestamp(), true, SequenceNumbers.UNASSIGNED_SEQ_NO, 0).             return engineIndex.         case DELETE:             final Translog.Delete delete = (Translog.Delete) operation.             final Engine.Delete engineDelete = new Engine.Delete(delete.type(), delete.id(), delete.uid(), delete.seqNo(), delete.primaryTerm(), delete.version(), null, origin, System.nanoTime(), SequenceNumbers.UNASSIGNED_SEQ_NO, 0).             return engineDelete.         case NO_OP:             final Translog.NoOp noOp = (Translog.NoOp) operation.             final Engine.NoOp engineNoOp = new Engine.NoOp(noOp.seqNo(), noOp.primaryTerm(), origin, System.nanoTime(), noOp.reason()).             return engineNoOp.         default:             throw new IllegalStateException("No operation defined for [" + operation + "]").     } }
