commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void initializeUseDefaultNumberOfShards() {     useDefaultNumberOfShards = usually(). }
false;public;0;34;;@Before public void initAndResetContext() throws Exception {     if (restTestExecutionContext == null) {         assert adminExecutionContext == null.         assert blacklistPathMatchers == null.         final ClientYamlSuiteRestSpec restSpec = ClientYamlSuiteRestSpec.load(SPEC_PATH).         validateSpec(restSpec).         final List<HttpHost> hosts = getClusterHosts().         Tuple<Version, Version> versionVersionTuple = readVersionsFromCatNodes(adminClient()).         final Version esVersion = versionVersionTuple.v1().         final Version masterVersion = versionVersionTuple.v2().         logger.info("initializing client, minimum es version [{}], master version, [{}], hosts {}", esVersion, masterVersion, hosts).         clientYamlTestClient = initClientYamlTestClient(restSpec, client(), hosts, esVersion, masterVersion).         restTestExecutionContext = new ClientYamlTestExecutionContext(clientYamlTestClient, randomizeContentType()).         adminExecutionContext = new ClientYamlTestExecutionContext(clientYamlTestClient, false).         final String[] blacklist = resolvePathsProperty(REST_TESTS_BLACKLIST, null).         blacklistPathMatchers = new ArrayList<>().         for (final String entry : blacklist) {             blacklistPathMatchers.add(new BlacklistedPathPatternMatcher(entry)).         }         final String[] blacklistAdditions = resolvePathsProperty(REST_TESTS_BLACKLIST_ADDITIONS, null).         for (final String entry : blacklistAdditions) {             blacklistPathMatchers.add(new BlacklistedPathPatternMatcher(entry)).         }     }     assert restTestExecutionContext != null.     assert adminExecutionContext != null.     assert blacklistPathMatchers != null.     // admin context must be available for @After always, regardless of whether the test was blacklisted     adminExecutionContext.clear().     restTestExecutionContext.clear(). }
false;protected;5;8;;protected ClientYamlTestClient initClientYamlTestClient(final ClientYamlSuiteRestSpec restSpec, final RestClient restClient, final List<HttpHost> hosts, final Version esVersion, final Version masterVersion) {     return new ClientYamlTestClient(restSpec, restClient, hosts, esVersion, masterVersion, this::getClientBuilderWithSniffedHosts). }
false;public,static;0;11;;@AfterClass public static void closeClient() throws IOException {     try {         IOUtils.close(clientYamlTestClient).     } finally {         blacklistPathMatchers = null.         restTestExecutionContext = null.         adminExecutionContext = null.         clientYamlTestClient = null.     } }
true;public,static;0;3;/**  * Create parameters for this parameterized test. Uses the  * {@link ExecutableSection#XCONTENT_REGISTRY list} of executable sections  * defined in {@link ExecutableSection}.  */ ;/**  * Create parameters for this parameterized test. Uses the  * {@link ExecutableSection#XCONTENT_REGISTRY list} of executable sections  * defined in {@link ExecutableSection}.  */ public static Iterable<Object[]> createParameters() throws Exception {     return createParameters(ExecutableSection.XCONTENT_REGISTRY). }
true;public,static;1;44;/**  * Create parameters for this parameterized test.  */ ;/**  * Create parameters for this parameterized test.  */ public static Iterable<Object[]> createParameters(NamedXContentRegistry executeableSectionRegistry) throws Exception {     // default to all tests under the test root     String[] paths = resolvePathsProperty(REST_TESTS_SUITE, "").     Map<String, Set<Path>> yamlSuites = loadSuites(paths).     List<ClientYamlTestSuite> suites = new ArrayList<>().     IllegalArgumentException validationException = null.     // yaml suites are grouped by directory (effectively by api)     for (String api : yamlSuites.keySet()) {         List<Path> yamlFiles = new ArrayList<>(yamlSuites.get(api)).         for (Path yamlFile : yamlFiles) {             ClientYamlTestSuite suite = ClientYamlTestSuite.parse(executeableSectionRegistry, api, yamlFile).             suites.add(suite).             try {                 suite.validate().             } catch (IllegalArgumentException e) {                 if (validationException == null) {                     validationException = new IllegalArgumentException("Validation errors for the following test suites:\n- " + e.getMessage()).                 } else {                     String previousMessage = validationException.getMessage().                     Throwable[] suppressed = validationException.getSuppressed().                     validationException = new IllegalArgumentException(previousMessage + "\n- " + e.getMessage()).                     for (Throwable t : suppressed) {                         validationException.addSuppressed(t).                     }                 }                 validationException.addSuppressed(e).             }         }     }     if (validationException != null) {         throw validationException.     }     List<Object[]> tests = new ArrayList<>().     for (ClientYamlTestSuite yamlTestSuite : suites) {         for (ClientYamlTestSection testSection : yamlTestSuite.getTestSections()) {             tests.add(new Object[] { new ClientYamlTestCandidate(yamlTestSuite, testSection) }).         }     }     // sort the candidates so they will always be in the same order before being shuffled, for repeatability     tests.sort(Comparator.comparing(o -> ((ClientYamlTestCandidate) o[0]).getTestPath())).     return tests. }
true;static;1;21;// pkg private for tests ;/**  * Find all yaml suites that match the given list of paths from the root test path.  */ // pkg private for tests static Map<String, Set<Path>> loadSuites(String... paths) throws Exception {     Map<String, Set<Path>> files = new HashMap<>().     Path root = PathUtils.get(ESClientYamlSuiteTestCase.class.getResource(TESTS_PATH).toURI()).     for (String strPath : paths) {         Path path = root.resolve(strPath).         if (Files.isDirectory(path)) {             Files.walk(path).forEach(file -> {                 if (file.toString().endsWith(".yml")) {                     addSuite(root, file, files).                 } else if (file.toString().endsWith(".yaml")) {                     throw new IllegalArgumentException("yaml files are no longer supported: " + file).                 }             }).         } else {             path = root.resolve(strPath + ".yml").             assert Files.exists(path).             addSuite(root, path, files).         }     }     return files. }
true;private,static;3;9;/**  * Add a single suite file to the set of suites.  */ ;/**  * Add a single suite file to the set of suites.  */ private static void addSuite(Path root, Path file, Map<String, Set<Path>> files) {     String groupName = root.relativize(file.getParent()).toString().     Set<Path> filesSet = files.get(groupName).     if (filesSet == null) {         filesSet = new HashSet<>().         files.put(groupName, filesSet).     }     filesSet.add(file). }
false;private,static;2;8;;private static String[] resolvePathsProperty(String propertyName, String defaultValue) {     String property = System.getProperty(propertyName).     if (!Strings.hasLength(property)) {         return defaultValue == null ? Strings.EMPTY_ARRAY : new String[] { defaultValue }.     } else {         return property.split(PATHS_SEPARATOR).     } }
false;protected;0;3;;protected ClientYamlTestExecutionContext getAdminExecutionContext() {     return adminExecutionContext. }
false;private,static;1;16;;private static void validateSpec(ClientYamlSuiteRestSpec restSpec) {     boolean validateSpec = RandomizedTest.systemPropertyAsBoolean(REST_TESTS_VALIDATE_SPEC, true).     if (validateSpec) {         StringBuilder errorMessage = new StringBuilder().         for (ClientYamlSuiteRestApi restApi : restSpec.getApis()) {             if (restApi.getMethods().contains("GET") && restApi.isBodySupported()) {                 if (!restApi.getMethods().contains("POST")) {                     errorMessage.append("\n- ").append(restApi.getName()).append(" supports GET with a body but doesn't support POST").                 }             }         }         if (errorMessage.length() > 0) {             throw new IllegalArgumentException(errorMessage.toString()).         }     } }
false;private,static;1;27;;private static Tuple<Version, Version> readVersionsFromCatNodes(RestClient restClient) throws IOException {     // we simply go to the _cat/nodes API and parse all versions in the cluster     Request request = new Request("GET", "/_cat/nodes").     request.addParameter("h", "version,master").     Response response = restClient.performRequest(request).     ClientYamlTestResponse restTestResponse = new ClientYamlTestResponse(response).     String nodesCatResponse = restTestResponse.getBodyAsString().     String[] split = nodesCatResponse.split("\n").     Version version = null.     Version masterVersion = null.     for (String perNode : split) {         final String[] versionAndMaster = perNode.split("\\s+").         assert versionAndMaster.length == 2 : "invalid line: " + perNode + " length: " + versionAndMaster.length.         final Version currentVersion = Version.fromString(versionAndMaster[0]).         final boolean master = versionAndMaster[1].trim().equals("*").         if (master) {             assert masterVersion == null.             masterVersion = currentVersion.         }         if (version == null) {             version = currentVersion.         } else if (version.onOrAfter(currentVersion)) {             version = currentVersion.         }     }     return new Tuple<>(version, masterVersion). }
false;public;0;52;;public void test() throws IOException {     // skip test if it matches one of the blacklist globs     for (BlacklistedPathPatternMatcher blacklistedPathMatcher : blacklistPathMatchers) {         String testPath = testCandidate.getSuitePath() + "/" + testCandidate.getTestSection().getName().         assumeFalse("[" + testCandidate.getTestPath() + "] skipped, reason: blacklisted", blacklistedPathMatcher.isSuffixMatch(testPath)).     }     // skip test if the whole suite (yaml file) is disabled     assumeFalse(testCandidate.getSetupSection().getSkipSection().getSkipMessage(testCandidate.getSuitePath()), testCandidate.getSetupSection().getSkipSection().skip(restTestExecutionContext.esVersion())).     // skip test if the whole suite (yaml file) is disabled     assumeFalse(testCandidate.getTeardownSection().getSkipSection().getSkipMessage(testCandidate.getSuitePath()), testCandidate.getTeardownSection().getSkipSection().skip(restTestExecutionContext.esVersion())).     // skip test if test section is disabled     assumeFalse(testCandidate.getTestSection().getSkipSection().getSkipMessage(testCandidate.getTestPath()), testCandidate.getTestSection().getSkipSection().skip(restTestExecutionContext.esVersion())).     // let's check that there is something to run, otherwise there might be a problem with the test section     if (testCandidate.getTestSection().getExecutableSections().size() == 0) {         throw new IllegalArgumentException("No executable sections loaded for [" + testCandidate.getTestPath() + "]").     }     if (useDefaultNumberOfShards == false && testCandidate.getTestSection().getSkipSection().getFeatures().contains("default_shards") == false) {         final Request request = new Request("PUT", "/_template/global").         request.setJsonEntity("{\"index_patterns\":[\"*\"],\"settings\":{\"index.number_of_shards\":2}}").         adminClient().performRequest(request).     }     if (!testCandidate.getSetupSection().isEmpty()) {         logger.debug("start setup test [{}]", testCandidate.getTestPath()).         for (ExecutableSection executableSection : testCandidate.getSetupSection().getExecutableSections()) {             executeSection(executableSection).         }         logger.debug("end setup test [{}]", testCandidate.getTestPath()).     }     restTestExecutionContext.clear().     try {         for (ExecutableSection executableSection : testCandidate.getTestSection().getExecutableSections()) {             executeSection(executableSection).         }     } finally {         logger.debug("start teardown test [{}]", testCandidate.getTestPath()).         for (ExecutableSection doSection : testCandidate.getTeardownSection().getDoSections()) {             executeSection(doSection).         }         logger.debug("end teardown test [{}]", testCandidate.getTestPath()).     } }
true;private;1;15;/**  * Execute an {@link ExecutableSection}, careful to log its place of origin on failure.  */ ;/**  * Execute an {@link ExecutableSection}, careful to log its place of origin on failure.  */ private void executeSection(ExecutableSection executableSection) {     try {         executableSection.execute(restTestExecutionContext).     } catch (AssertionError | Exception e) {         // Dump the stash on failure. Instead of dumping it in true json we escape `\n`s so stack traces are easier to read         logger.info("Stash dump on test failure [{}]", Strings.toString(restTestExecutionContext.stash(), true, true).replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t")).         if (e instanceof AssertionError) {             throw new AssertionError(errorMessage(executableSection, e), e).         } else {             throw new RuntimeException(errorMessage(executableSection, e), e).         }     } }
false;private;2;3;;private String errorMessage(ExecutableSection executableSection, Throwable t) {     return "Failure at [" + testCandidate.getSuitePath() + ":" + executableSection.getLocation().lineNumber + "]: " + t.getMessage(). }
false;protected;0;3;;protected boolean randomizeContentType() {     return true. }
true;protected,final;0;9;/**  * Sniff the cluster for host metadata and return a  * {@link RestClientBuilder} for a client with that metadata.  */ ;/**  * Sniff the cluster for host metadata and return a  * {@link RestClientBuilder} for a client with that metadata.  */ protected final RestClientBuilder getClientBuilderWithSniffedHosts() throws IOException {     ElasticsearchNodesSniffer.Scheme scheme = ElasticsearchNodesSniffer.Scheme.valueOf(getProtocol().toUpperCase(Locale.ROOT)).     ElasticsearchNodesSniffer sniffer = new ElasticsearchNodesSniffer(adminClient(), ElasticsearchNodesSniffer.DEFAULT_SNIFF_REQUEST_TIMEOUT, scheme).     RestClientBuilder builder = RestClient.builder(sniffer.sniff().toArray(new Node[0])).     configureClient(builder, restClientSettings()).     return builder. }
