commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public long seed() {     return seed. }
true;public;2;6;/**  * This method should be executed before each test to reset the cluster to its initial state.  */ ;/**  * This method should be executed before each test to reset the cluster to its initial state.  */ public void beforeTest(Random random, double transportClientRatio) throws IOException, InterruptedException {     assert transportClientRatio >= 0.0 && transportClientRatio <= 1.0.     logger.debug("Reset test cluster with transport client ratio: [{}]", transportClientRatio).     this.transportClientRatio = transportClientRatio.     this.random = new Random(random.nextLong()). }
true;public;1;5;/**  * Wipes any data that a test can leave behind: indices, templates (except exclude templates) and repositories  */ ;/**  * Wipes any data that a test can leave behind: indices, templates (except exclude templates) and repositories  */ public void wipe(Set<String> excludeTemplates) {     wipeIndices("_all").     wipeAllTemplates(excludeTemplates).     wipeRepositories(). }
true;public;0;2;/**  * Assertions that should run before the cluster is wiped should be called in this method  */ ;/**  * Assertions that should run before the cluster is wiped should be called in this method  */ public void beforeIndexDeletion() throws Exception { }
true;public;0;3;/**  * This method checks all the things that need to be checked after each test  */ ;/**  * This method checks all the things that need to be checked after each test  */ public void assertAfterTest() throws IOException {     ensureEstimatedStats(). }
true;public,abstract;0;1;/**  * This method should be executed during tear down, after each test (but after assertAfterTest)  */ ;/**  * This method should be executed during tear down, after each test (but after assertAfterTest)  */ public abstract void afterTest() throws IOException.
true;public,abstract;0;1;/**  * Returns a client connected to any node in the cluster  */ ;/**  * Returns a client connected to any node in the cluster  */ public abstract Client client().
true;public,abstract;0;1;/**  * Returns the number of nodes in the cluster.  */ ;/**  * Returns the number of nodes in the cluster.  */ public abstract int size().
true;public,abstract;0;1;/**  * Returns the number of data nodes in the cluster.  */ ;/**  * Returns the number of data nodes in the cluster.  */ public abstract int numDataNodes().
true;public,abstract;0;1;/**  * Returns the number of data and master eligible nodes in the cluster.  */ ;/**  * Returns the number of data and master eligible nodes in the cluster.  */ public abstract int numDataAndMasterNodes().
true;public,abstract;0;1;/**  * Returns the http addresses of the nodes within the cluster.  * Can be used to run REST tests against the test cluster.  */ ;/**  * Returns the http addresses of the nodes within the cluster.  * Can be used to run REST tests against the test cluster.  */ public abstract InetSocketAddress[] httpAddresses().
true;public,abstract;0;2;/**  * Closes the current cluster  */ ;/**  * Closes the current cluster  */ @Override public abstract void close() throws IOException.
true;public;1;23;/**  * Deletes the given indices from the tests cluster. If no index name is passed to this method  * all indices are removed.  */ ;/**  * Deletes the given indices from the tests cluster. If no index name is passed to this method  * all indices are removed.  */ public void wipeIndices(String... indices) {     assert indices != null && indices.length > 0.     if (size() > 0) {         try {             assertAcked(client().admin().indices().prepareDelete(indices)).         } catch (IndexNotFoundException e) {         // ignore         } catch (IllegalArgumentException e) {             // which is the case in the CloseIndexDisableCloseAllTests             if ("_all".equals(indices[0])) {                 ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().execute().actionGet().                 ObjectArrayList<String> concreteIndices = new ObjectArrayList<>().                 for (IndexMetaData indexMetaData : clusterStateResponse.getState().metaData()) {                     concreteIndices.add(indexMetaData.getIndex().getName()).                 }                 if (!concreteIndices.isEmpty()) {                     assertAcked(client().admin().indices().prepareDelete(concreteIndices.toArray(String.class))).                 }             }         }     } }
true;public;1;15;/**  * Removes all templates, except the templates defined in the exclude  */ ;/**  * Removes all templates, except the templates defined in the exclude  */ public void wipeAllTemplates(Set<String> exclude) {     if (size() > 0) {         GetIndexTemplatesResponse response = client().admin().indices().prepareGetTemplates().get().         for (IndexTemplateMetaData indexTemplate : response.getIndexTemplates()) {             if (exclude.contains(indexTemplate.getName())) {                 continue.             }             try {                 client().admin().indices().prepareDeleteTemplate(indexTemplate.getName()).execute().actionGet().             } catch (IndexTemplateMissingException e) {             // ignore             }         }     } }
true;public;1;15;/**  * Deletes index templates, support wildcard notation.  * If no template name is passed to this method all templates are removed.  */ ;/**  * Deletes index templates, support wildcard notation.  * If no template name is passed to this method all templates are removed.  */ public void wipeTemplates(String... templates) {     if (size() > 0) {         // if nothing is provided, delete all         if (templates.length == 0) {             templates = new String[] { "*" }.         }         for (String template : templates) {             try {                 client().admin().indices().prepareDeleteTemplate(template).execute().actionGet().             } catch (IndexTemplateMissingException e) {             // ignore             }         }     } }
true;public;1;15;/**  * Deletes repositories, supports wildcard notation.  */ ;/**  * Deletes repositories, supports wildcard notation.  */ public void wipeRepositories(String... repositories) {     if (size() > 0) {         // if nothing is provided, delete all         if (repositories.length == 0) {             repositories = new String[] { "*" }.         }         for (String repository : repositories) {             try {                 client().admin().cluster().prepareDeleteRepository(repository).execute().actionGet().             } catch (RepositoryMissingException ex) {             // ignore             }         }     } }
true;public,abstract;0;1;/**  * Ensures that any breaker statistics are reset to 0.  *  * The implementation is specific to the test cluster, because the act of  * checking some breaker stats can increase them.  */ ;/**  * Ensures that any breaker statistics are reset to 0.  *  * The implementation is specific to the test cluster, because the act of  * checking some breaker stats can increase them.  */ public abstract void ensureEstimatedStats().
true;public,abstract;0;1;/**  * Returns the cluster name  */ ;/**  * Returns the cluster name  */ public abstract String getClusterName().
true;public,abstract;0;1;/**  * Returns an {@link Iterable} over all clients in this test cluster  */ ;/**  * Returns an {@link Iterable} over all clients in this test cluster  */ public abstract Iterable<Client> getClients().
true;public,abstract;0;1;/**  * Returns this clusters {@link NamedWriteableRegistry} this is needed to  * deserialize binary content from this cluster that might include custom named writeables  */ ;/**  * Returns this clusters {@link NamedWriteableRegistry} this is needed to  * deserialize binary content from this cluster that might include custom named writeables  */ public abstract NamedWriteableRegistry getNamedWriteableRegistry().
