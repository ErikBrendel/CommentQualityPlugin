commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public boolean implies(ProtectionDomain domain, Permission permission) {     // implements union     return esPolicy.implies(domain, permission) || testFramework.implies(domain, permission). }
true;private,static;3;14;/**  * Add the codebase url of the given classname to the codebases map, if the class exists.  */ ;/**  * Add the codebase url of the given classname to the codebases map, if the class exists.  */ private static void addClassCodebase(Map<String, URL> codebases, String name, String classname) {     try {         Class<?> clazz = BootstrapForTesting.class.getClassLoader().loadClass(classname).         URL location = clazz.getProtectionDomain().getCodeSource().getLocation().         if (location.toString().endsWith(".jar") == false) {             if (codebases.put(name, location) != null) {                 throw new IllegalStateException("Already added " + name + " codebase for testing").             }         }     } catch (ClassNotFoundException e) {     // no class, fall through to not add. this can happen for any tests that do not include     // the given class. eg only core tests include plugin-classloader     } }
false;public;2;10;;@Override public boolean implies(ProtectionDomain domain, Permission permission) {     // implements union     for (Policy p : policies) {         if (p.implies(domain, permission)) {             return true.         }     }     return false. }
true;static;0;47;/**  * we don't know which codesources belong to which plugin, so just remove the permission from key codebases  * like core, test-framework, etc. this way tests fail if accesscontroller blocks are missing.  */ ;/**  * we don't know which codesources belong to which plugin, so just remove the permission from key codebases  * like core, test-framework, etc. this way tests fail if accesscontroller blocks are missing.  */ @SuppressForbidden(reason = "accesses fully qualified URLs to configure security") static Map<String, Policy> getPluginPermissions() throws Exception {     List<URL> pluginPolicies = Collections.list(BootstrapForTesting.class.getClassLoader().getResources(PluginInfo.ES_PLUGIN_POLICY)).     if (pluginPolicies.isEmpty()) {         return Collections.emptyMap().     }     // compute classpath minus obvious places, all other jars will get the permission.     Set<URL> codebases = new HashSet<>(parseClassPathWithSymlinks()).     Set<URL> excluded = new HashSet<>(Arrays.asList(// es core     Bootstrap.class.getProtectionDomain().getCodeSource().getLocation(), // es test framework     BootstrapForTesting.class.getProtectionDomain().getCodeSource().getLocation(), // lucene test framework     LuceneTestCase.class.getProtectionDomain().getCodeSource().getLocation(), // randomized runner     RandomizedRunner.class.getProtectionDomain().getCodeSource().getLocation(), // junit library     Assert.class.getProtectionDomain().getCodeSource().getLocation())).     codebases.removeAll(excluded).     // parse each policy file, with codebase substitution from the classpath     final List<Policy> policies = new ArrayList<>(pluginPolicies.size()).     for (URL policyFile : pluginPolicies) {         policies.add(Security.readPolicy(policyFile, Security.getCodebaseJarMap(codebases))).     }     // consult each policy file for those codebases     Map<String, Policy> map = new HashMap<>().     for (URL url : codebases) {         map.put(url.getFile(), new Policy() {              @Override             public boolean implies(ProtectionDomain domain, Permission permission) {                 // implements union                 for (Policy p : policies) {                     if (p.implies(domain, permission)) {                         return true.                     }                 }                 return false.             }         }).     }     return Collections.unmodifiableMap(map). }
true;static;0;12;/**  * return parsed classpath, but with symlinks resolved to destination files for matching  * this is for matching the toRealPath() in the code where we have a proper plugin structure  */ ;/**  * return parsed classpath, but with symlinks resolved to destination files for matching  * this is for matching the toRealPath() in the code where we have a proper plugin structure  */ @SuppressForbidden(reason = "does evil stuff with paths and urls because devs and jenkins do evil stuff with paths and urls") static Set<URL> parseClassPathWithSymlinks() throws Exception {     Set<URL> raw = JarHell.parseClassPath().     Set<URL> cooked = new HashSet<>(raw.size()).     for (URL url : raw) {         boolean added = cooked.add(PathUtils.get(url.toURI()).toRealPath().toUri().toURL()).         if (added == false) {             throw new IllegalStateException("Duplicate in classpath after resolving symlinks: " + url).         }     }     return raw. }
true;public,static;0;1;// does nothing, just easy way to make sure the class is loaded. ;// does nothing, just easy way to make sure the class is loaded. public static void ensureInitialized() { }
