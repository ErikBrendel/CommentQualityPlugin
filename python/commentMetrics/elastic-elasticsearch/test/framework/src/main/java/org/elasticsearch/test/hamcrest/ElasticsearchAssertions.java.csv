commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static void assertAcked(AcknowledgedRequestBuilder<?, ?, ?> builder) {     assertAcked(builder.get()). }
false;public,static;1;3;;public static void assertNoTimeout(ClusterHealthRequestBuilder requestBuilder) {     assertNoTimeout(requestBuilder.get()). }
false;public,static;1;3;;public static void assertNoTimeout(ClusterHealthResponse response) {     assertThat("ClusterHealthResponse has timed out - returned: [" + response + "]", response.isTimedOut(), is(false)). }
false;public,static;1;3;;public static void assertAcked(AcknowledgedResponse response) {     assertThat(response.getClass().getSimpleName() + " failed - not acked", response.isAcknowledged(), equalTo(true)). }
false;public,static;1;3;;public static void assertAcked(DeleteIndexRequestBuilder builder) {     assertAcked(builder.get()). }
true;public,static;1;5;/**  * Assert that an index creation was fully acknowledged, meaning that both the index creation cluster  * state update was successful and that the requisite number of shard copies were started before returning.  */ ;/**  * Assert that an index creation was fully acknowledged, meaning that both the index creation cluster  * state update was successful and that the requisite number of shard copies were started before returning.  */ public static void assertAcked(CreateIndexResponse response) {     assertThat(response.getClass().getSimpleName() + " failed - not acked", response.isAcknowledged(), equalTo(true)).     assertTrue(response.getClass().getSimpleName() + " failed - index creation acked but not all shards were started", response.isShardsAcknowledged()). }
true;public,static;1;3;/**  * Executes the request and fails if the request has not been blocked.  *  * @param builder the request builder  */ ;/**  * Executes the request and fails if the request has not been blocked.  *  * @param builder the request builder  */ public static void assertBlocked(ActionRequestBuilder builder) {     assertBlocked(builder, (ClusterBlock) null). }
true;public,static;1;12;/**  * Checks that all shard requests of a replicated broadcast request failed due to a cluster block  *  * @param replicatedBroadcastResponse the response that should only contain failed shard responses  */ ;/**  * Checks that all shard requests of a replicated broadcast request failed due to a cluster block  *  * @param replicatedBroadcastResponse the response that should only contain failed shard responses  */ public static void assertBlocked(BroadcastResponse replicatedBroadcastResponse) {     assertThat("all shard requests should have failed", replicatedBroadcastResponse.getFailedShards(), equalTo(replicatedBroadcastResponse.getTotalShards())).     for (DefaultShardOperationFailedException exception : replicatedBroadcastResponse.getShardFailures()) {         ClusterBlockException clusterBlockException = (ClusterBlockException) ExceptionsHelper.unwrap(exception.getCause(), ClusterBlockException.class).         assertNotNull("expected the cause of failure to be a ClusterBlockException but got " + exception.getCause().getMessage(), clusterBlockException).         assertThat(clusterBlockException.blocks().size(), greaterThan(0)).         assertThat(clusterBlockException.status(), CoreMatchers.equalTo(RestStatus.FORBIDDEN)).     } }
true;public,static;2;20;/**  * Executes the request and fails if the request has not been blocked by a specific {@link ClusterBlock}.  *  * @param builder the request builder  * @param expectedBlockId the expected block id  */ ;/**  * Executes the request and fails if the request has not been blocked by a specific {@link ClusterBlock}.  *  * @param builder the request builder  * @param expectedBlockId the expected block id  */ public static void assertBlocked(final ActionRequestBuilder builder, @Nullable final Integer expectedBlockId) {     try {         builder.get().         fail("Request executed with success but a ClusterBlockException was expected").     } catch (ClusterBlockException e) {         assertThat(e.blocks().size(), greaterThan(0)).         assertThat(e.status(), equalTo(RestStatus.FORBIDDEN)).         if (expectedBlockId != null) {             boolean found = false.             for (ClusterBlock clusterBlock : e.blocks()) {                 if (clusterBlock.id() == expectedBlockId) {                     found = true.                     break.                 }             }             assertThat("Request should have been blocked by [" + expectedBlockId + "] instead of " + e.blocks(), found, equalTo(true)).         }     } }
true;public,static;2;3;/**  * Executes the request and fails if the request has not been blocked by a specific {@link ClusterBlock}.  *  * @param builder the request builder  * @param expectedBlock the expected block  */ ;/**  * Executes the request and fails if the request has not been blocked by a specific {@link ClusterBlock}.  *  * @param builder the request builder  * @param expectedBlock the expected block  */ public static void assertBlocked(final ActionRequestBuilder builder, @Nullable final ClusterBlock expectedBlock) {     assertBlocked(builder, expectedBlock != null ? expectedBlock.id() : null). }
false;public,static;1;10;;public static String formatShardStatus(BroadcastResponse response) {     StringBuilder msg = new StringBuilder().     msg.append(" Total shards: ").append(response.getTotalShards()).append(" Successful shards: ").append(response.getSuccessfulShards()).append(" & ").append(response.getFailedShards()).append(" shard failures:").     for (DefaultShardOperationFailedException failure : response.getShardFailures()) {         msg.append("\n ").append(failure).     }     return msg.toString(). }
false;public,static;1;10;;public static String formatShardStatus(SearchResponse response) {     StringBuilder msg = new StringBuilder().     msg.append(" Total shards: ").append(response.getTotalShards()).append(" Successful shards: ").append(response.getSuccessfulShards()).append(" & ").append(response.getFailedShards()).append(" shard failures:").     for (ShardSearchFailure failure : response.getShardFailures()) {         msg.append("\n ").append(failure).     }     return msg.toString(). }
false;public,static;1;3;;public static void assertNoSearchHits(SearchResponse searchResponse) {     assertEquals(0, searchResponse.getHits().getHits().length). }
false;public,static;2;13;;public static void assertSearchHits(SearchResponse searchResponse, String... ids) {     String shardStatus = formatShardStatus(searchResponse).     Set<String> idsSet = new HashSet<>(Arrays.asList(ids)).     for (SearchHit hit : searchResponse.getHits()) {         assertThat("id [" + hit.getId() + "] was found in search results but wasn't expected (type [" + hit.getType() + "], index [" + hit.getIndex() + "])" + shardStatus, idsSet.remove(hit.getId()), equalTo(true)).     }     assertThat("Some expected ids were not found in search results: " + Arrays.toString(idsSet.toArray(new String[idsSet.size()])) + "." + shardStatus, idsSet.size(), equalTo(0)). }
false;public,static;2;9;;public static void assertSortValues(SearchResponse searchResponse, Object[]... sortValues) {     assertSearchResponse(searchResponse).     SearchHit[] hits = searchResponse.getHits().getHits().     assertEquals(sortValues.length, hits.length).     for (int i = 0. i < sortValues.length. ++i) {         final Object[] hitsSortValues = hits[i].getSortValues().         assertArrayEquals("Offset " + Integer.toString(i) + ", id " + hits[i].getId(), sortValues[i], hitsSortValues).     } }
false;public,static;2;8;;public static void assertOrderedSearchHits(SearchResponse searchResponse, String... ids) {     String shardStatus = formatShardStatus(searchResponse).     assertThat("Expected different hit count. " + shardStatus, searchResponse.getHits().getHits().length, equalTo(ids.length)).     for (int i = 0. i < ids.length. i++) {         SearchHit hit = searchResponse.getHits().getHits()[i].         assertThat("Expected id: " + ids[i] + " at position " + i + " but wasn't." + shardStatus, hit.getId(), equalTo(ids[i])).     } }
false;public,static;2;7;;public static void assertHitCount(SearchResponse countResponse, long expectedHitCount) {     final TotalHits totalHits = countResponse.getHits().getTotalHits().     if (totalHits.relation != TotalHits.Relation.EQUAL_TO || totalHits.value != expectedHitCount) {         fail("Count is " + totalHits + " but " + expectedHitCount + " was expected. " + formatShardStatus(countResponse)).     } }
false;public,static;1;5;;public static void assertExists(GetResponse response) {     String message = String.format(Locale.ROOT, "Expected %s/%s/%s to exist, but does not", response.getIndex(), response.getType(), response.getId()).     assertThat(message, response.isExists(), is(true)). }
false;public,static;2;3;;public static void assertFirstHit(SearchResponse searchResponse, Matcher<SearchHit> matcher) {     assertSearchHit(searchResponse, 1, matcher). }
false;public,static;2;3;;public static void assertSecondHit(SearchResponse searchResponse, Matcher<SearchHit> matcher) {     assertSearchHit(searchResponse, 2, matcher). }
false;public,static;2;3;;public static void assertThirdHit(SearchResponse searchResponse, Matcher<SearchHit> matcher) {     assertSearchHit(searchResponse, 3, matcher). }
false;public,static;2;3;;public static void assertFourthHit(SearchResponse searchResponse, Matcher<SearchHit> matcher) {     assertSearchHit(searchResponse, 4, matcher). }
false;public,static;3;6;;public static void assertSearchHit(SearchResponse searchResponse, int number, Matcher<SearchHit> matcher) {     assertThat(number, greaterThan(0)).     assertThat("SearchHit number must be greater than 0", number, greaterThan(0)).     assertThat(searchResponse.getHits().getTotalHits().value, greaterThanOrEqualTo((long) number)).     assertThat(searchResponse.getHits().getAt(number - 1), matcher). }
false;public,static;1;4;;public static void assertNoFailures(SearchResponse searchResponse) {     assertThat("Unexpected ShardFailures: " + Arrays.toString(searchResponse.getShardFailures()), searchResponse.getShardFailures().length, equalTo(0)). }
false;public,static;1;4;;public static void assertFailures(SearchResponse searchResponse) {     assertThat("Expected at least one shard failure, got none", searchResponse.getShardFailures().length, greaterThan(0)). }
false;public,static;1;4;;public static void assertNoFailures(BulkResponse response) {     assertThat("Unexpected ShardFailures: " + response.buildFailureMessage(), response.hasFailures(), is(false)). }
false;public,static;3;21;;public static void assertFailures(SearchRequestBuilder searchRequestBuilder, RestStatus restStatus, Matcher<String> reasonMatcher) {     // we can either run into partial or total failures depending on the current number of shards     try {         SearchResponse searchResponse = searchRequestBuilder.get().         assertThat("Expected shard failures, got none", searchResponse.getShardFailures().length, greaterThan(0)).         for (ShardSearchFailure shardSearchFailure : searchResponse.getShardFailures()) {             assertThat(shardSearchFailure.status(), equalTo(restStatus)).             assertThat(shardSearchFailure.reason(), reasonMatcher).         }     } catch (SearchPhaseExecutionException e) {         assertThat(e.status(), equalTo(restStatus)).         assertThat(e.toString(), reasonMatcher).         for (ShardSearchFailure shardSearchFailure : e.shardFailures()) {             assertThat(shardSearchFailure.status(), equalTo(restStatus)).             assertThat(shardSearchFailure.reason(), reasonMatcher).         }     } catch (Exception e) {         fail("SearchPhaseExecutionException expected but got " + e.getClass()).     } }
false;public,static;1;3;;public static void assertNoFailures(BroadcastResponse response) {     assertThat("Unexpected ShardFailures: " + Arrays.toString(response.getShardFailures()), response.getFailedShards(), equalTo(0)). }
false;public,static;1;5;;public static void assertAllSuccessful(BroadcastResponse response) {     assertNoFailures(response).     assertThat("Expected all shards successful", response.getSuccessfulShards(), equalTo(response.getTotalShards())). }
false;public,static;1;5;;public static void assertAllSuccessful(SearchResponse response) {     assertNoFailures(response).     assertThat("Expected all shards successful", response.getSuccessfulShards(), equalTo(response.getTotalShards())). }
false;public,static;5;3;;public static void assertHighlight(SearchResponse resp, int hit, String field, int fragment, Matcher<String> matcher) {     assertHighlight(resp, hit, field, fragment, greaterThan(fragment), matcher). }
false;public,static;6;4;;public static void assertHighlight(SearchResponse resp, int hit, String field, int fragment, int totalFragments, Matcher<String> matcher) {     assertHighlight(resp, hit, field, fragment, equalTo(totalFragments), matcher). }
false;public,static;4;3;;public static void assertHighlight(SearchHit hit, String field, int fragment, Matcher<String> matcher) {     assertHighlight(hit, field, fragment, greaterThan(fragment), matcher). }
false;public,static;5;3;;public static void assertHighlight(SearchHit hit, String field, int fragment, int totalFragments, Matcher<String> matcher) {     assertHighlight(hit, field, fragment, equalTo(totalFragments), matcher). }
false;private,static;6;6;;private static void assertHighlight(SearchResponse resp, int hit, String field, int fragment, Matcher<Integer> fragmentsMatcher, Matcher<String> matcher) {     assertNoFailures(resp).     assertThat("not enough hits", resp.getHits().getHits().length, greaterThan(hit)).     assertHighlight(resp.getHits().getHits()[hit], field, fragment, fragmentsMatcher, matcher). }
false;private,static;5;6;;private static void assertHighlight(SearchHit hit, String field, int fragment, Matcher<Integer> fragmentsMatcher, Matcher<String> matcher) {     assertThat(hit.getHighlightFields(), hasKey(field)).     assertThat(hit.getHighlightFields().get(field).fragments().length, fragmentsMatcher).     assertThat(hit.getHighlightFields().get(field).fragments()[fragment].string(), matcher). }
false;public,static;3;5;;public static void assertNotHighlighted(SearchResponse resp, int hit, String field) {     assertNoFailures(resp).     assertThat("not enough hits", resp.getHits().getHits().length, greaterThan(hit)).     assertThat(resp.getHits().getHits()[hit].getHighlightFields(), not(hasKey(field))). }
false;public,static;4;8;;public static void assertSuggestionSize(Suggest searchSuggest, int entry, int size, String key) {     assertThat(searchSuggest, notNullValue()).     String msg = "Suggest result: " + searchSuggest.toString().     assertThat(msg, searchSuggest.size(), greaterThanOrEqualTo(1)).     assertThat(msg, searchSuggest.getSuggestion(key).getName(), equalTo(key)).     assertThat(msg, searchSuggest.getSuggestion(key).getEntries().size(), greaterThanOrEqualTo(entry)).     assertThat(msg, searchSuggest.getSuggestion(key).getEntries().get(entry).getOptions().size(), equalTo(size)). }
false;public,static;3;15;;public static void assertSuggestionPhraseCollateMatchExists(Suggest searchSuggest, String key, int numberOfPhraseExists) {     int counter = 0.     assertThat(searchSuggest, notNullValue()).     String msg = "Suggest result: " + searchSuggest.toString().     assertThat(msg, searchSuggest.size(), greaterThanOrEqualTo(1)).     assertThat(msg, searchSuggest.getSuggestion(key).getName(), equalTo(key)).     for (Suggest.Suggestion.Entry.Option option : searchSuggest.getSuggestion(key).getEntries().get(0).getOptions()) {         if (option.collateMatch()) {             counter++.         }     }     assertThat(counter, equalTo(numberOfPhraseExists)). }
false;public,static;5;9;;public static void assertSuggestion(Suggest searchSuggest, int entry, int ord, String key, String text) {     assertThat(searchSuggest, notNullValue()).     String msg = "Suggest result: " + searchSuggest.toString().     assertThat(msg, searchSuggest.size(), greaterThanOrEqualTo(1)).     assertThat(msg, searchSuggest.getSuggestion(key).getName(), equalTo(key)).     assertThat(msg, searchSuggest.getSuggestion(key).getEntries().size(), greaterThanOrEqualTo(entry)).     assertThat(msg, searchSuggest.getSuggestion(key).getEntries().get(entry).getOptions().size(), greaterThan(ord)).     assertThat(msg, searchSuggest.getSuggestion(key).getEntries().get(entry).getOptions().get(ord).getText().string(), equalTo(text)). }
true;public,static;4;3;/**  * Assert suggestion returns exactly the provided text.  */ ;/**  * Assert suggestion returns exactly the provided text.  */ public static void assertSuggestion(Suggest searchSuggest, int entry, String key, String... text) {     assertSuggestion(searchSuggest, entry, key, text.length, text). }
true;public,static;5;6;/**  * Assert suggestion returns size suggestions and the first are the provided  * text.  */ ;/**  * Assert suggestion returns size suggestions and the first are the provided  * text.  */ public static void assertSuggestion(Suggest searchSuggest, int entry, String key, int size, String... text) {     assertSuggestionSize(searchSuggest, entry, size, key).     for (int i = 0. i < text.length. i++) {         assertSuggestion(searchSuggest, entry, i, key, text[i]).     } }
true;public,static;2;7;/**  * Assert that an index template is missing  */ ;/**  * Assert that an index template is missing  */ public static void assertIndexTemplateMissing(GetIndexTemplatesResponse templatesResponse, String name) {     List<String> templateNames = new ArrayList<>().     for (IndexTemplateMetaData indexTemplateMetaData : templatesResponse.getIndexTemplates()) {         templateNames.add(indexTemplateMetaData.name()).     }     assertThat(templateNames, not(hasItem(name))). }
true;public,static;2;7;/**  * Assert that an index template exists  */ ;/**  * Assert that an index template exists  */ public static void assertIndexTemplateExists(GetIndexTemplatesResponse templatesResponse, String name) {     List<String> templateNames = new ArrayList<>().     for (IndexTemplateMetaData indexTemplateMetaData : templatesResponse.getIndexTemplates()) {         templateNames.add(indexTemplateMetaData.name()).     }     assertThat(templateNames, hasItem(name)). }
true;public,static;1;3;/**  * Assert that aliases are missing  */ ;/**  * Assert that aliases are missing  */ public static void assertAliasesMissing(AliasesExistResponse aliasesExistResponse) {     assertFalse("Aliases shouldn't exist", aliasesExistResponse.exists()). }
true;public,static;1;3;/**  * Assert that aliases exist  */ ;/**  * Assert that aliases exist  */ public static void assertAliasesExist(AliasesExistResponse aliasesExistResponse) {     assertTrue("Aliases should exist", aliasesExistResponse.exists()). }
true;public,static;1;3;/*      * matchers      */ ;/*      * matchers      */ public static Matcher<SearchHit> hasId(final String id) {     return new ElasticsearchMatchers.SearchHitHasIdMatcher(id). }
false;public,static;1;3;;public static Matcher<SearchHit> hasType(final String type) {     return new ElasticsearchMatchers.SearchHitHasTypeMatcher(type). }
false;public,static;1;3;;public static Matcher<SearchHit> hasIndex(final String index) {     return new ElasticsearchMatchers.SearchHitHasIndexMatcher(index). }
false;public,static;1;3;;public static Matcher<SearchHit> hasScore(final float score) {     return new ElasticsearchMatchers.SearchHitHasScoreMatcher(score). }
false;public,static;2;3;;public static <T, V> CombinableMatcher<T> hasProperty(Function<? super T, ? extends V> property, Matcher<V> valueMatcher) {     return ElasticsearchMatchers.HasPropertyLambdaMatcher.hasProperty(property, valueMatcher). }
false;public,static;1;3;;public static Function<SearchHit, Object> fieldFromSource(String fieldName) {     return (response) -> response.getSourceAsMap().get(fieldName). }
false;public,static;3;7;;public static <T extends Query> T assertBooleanSubQuery(Query query, Class<T> subqueryType, int i) {     assertThat(query, instanceOf(BooleanQuery.class)).     BooleanQuery q = (BooleanQuery) query.     assertThat(q.clauses().size(), greaterThan(i)).     assertThat(q.clauses().get(i).getQuery(), instanceOf(subqueryType)).     return subqueryType.cast(q.clauses().get(i).getQuery()). }
false;public,static;3;7;;public static <T extends Query> T assertDisjunctionSubQuery(Query query, Class<T> subqueryType, int i) {     assertThat(query, instanceOf(DisjunctionMaxQuery.class)).     DisjunctionMaxQuery q = (DisjunctionMaxQuery) query.     assertThat(q.getDisjuncts().size(), greaterThan(i)).     assertThat(q.getDisjuncts().get(i), instanceOf(subqueryType)).     return subqueryType.cast(q.getDisjuncts().get(i)). }
true;public,static;2;3;/**  * Run the request from a given builder and check that it throws an exception of the right type  */ ;/**  * Run the request from a given builder and check that it throws an exception of the right type  */ public static <E extends Throwable> void assertThrows(ActionRequestBuilder<?, ?> builder, Class<E> exceptionClass) {     assertThrows(builder.execute(), exceptionClass). }
true;public,static;3;3;/**  * Run the request from a given builder and check that it throws an exception of the right type, with a given {@link RestStatus}  */ ;/**  * Run the request from a given builder and check that it throws an exception of the right type, with a given {@link RestStatus}  */ public static <E extends Throwable> void assertThrows(ActionRequestBuilder<?, ?> builder, Class<E> exceptionClass, RestStatus status) {     assertThrows(builder.execute(), exceptionClass, status). }
true;public,static;3;3;/**  * Run the request from a given builder and check that it throws an exception of the right type  *  * @param extraInfo extra information to add to the failure message  */ ;/**  * Run the request from a given builder and check that it throws an exception of the right type  *  * @param extraInfo extra information to add to the failure message  */ public static <E extends Throwable> void assertThrows(ActionRequestBuilder<?, ?> builder, Class<E> exceptionClass, String extraInfo) {     assertThrows(builder.execute(), exceptionClass, extraInfo). }
true;public,static;2;3;/**  * Run future.actionGet() and check that it throws an exception of the right type  */ ;/**  * Run future.actionGet() and check that it throws an exception of the right type  */ public static <E extends Throwable> void assertThrows(ActionFuture future, Class<E> exceptionClass) {     assertThrows(future, exceptionClass, null, null). }
true;public,static;3;3;/**  * Run future.actionGet() and check that it throws an exception of the right type, with a given {@link RestStatus}  */ ;/**  * Run future.actionGet() and check that it throws an exception of the right type, with a given {@link RestStatus}  */ public static <E extends Throwable> void assertThrows(ActionFuture future, Class<E> exceptionClass, RestStatus status) {     assertThrows(future, exceptionClass, status, null). }
true;public,static;3;3;/**  * Run future.actionGet() and check that it throws an exception of the right type  *  * @param extraInfo extra information to add to the failure message  */ ;/**  * Run future.actionGet() and check that it throws an exception of the right type  *  * @param extraInfo extra information to add to the failure message  */ public static <E extends Throwable> void assertThrows(ActionFuture future, Class<E> exceptionClass, String extraInfo) {     assertThrows(future, exceptionClass, null, extraInfo). }
true;public,static;4;30;/**  * Run future.actionGet() and check that it throws an exception of the right type, optionally checking the exception's rest status  *  * @param exceptionClass expected exception class  * @param status         {@link org.elasticsearch.rest.RestStatus} to check for. Can be null to disable the check  * @param extraInfo      extra information to add to the failure message. Can be null.  */ ;/**  * Run future.actionGet() and check that it throws an exception of the right type, optionally checking the exception's rest status  *  * @param exceptionClass expected exception class  * @param status         {@link org.elasticsearch.rest.RestStatus} to check for. Can be null to disable the check  * @param extraInfo      extra information to add to the failure message. Can be null.  */ public static <E extends Throwable> void assertThrows(ActionFuture future, Class<E> exceptionClass, @Nullable RestStatus status, @Nullable String extraInfo) {     boolean fail = false.     extraInfo = extraInfo == null || extraInfo.isEmpty() ? "" : extraInfo + ": ".     extraInfo += "expected a " + exceptionClass + " exception to be thrown".     if (status != null) {         extraInfo += " with status [" + status + "]".     }     try {         future.actionGet().         fail = true.     } catch (ElasticsearchException esException) {         assertThat(extraInfo, esException.unwrapCause(), instanceOf(exceptionClass)).         if (status != null) {             assertThat(extraInfo, ExceptionsHelper.status(esException), equalTo(status)).         }     } catch (Exception e) {         assertThat(extraInfo, e, instanceOf(exceptionClass)).         if (status != null) {             assertThat(extraInfo, ExceptionsHelper.status(e), equalTo(status)).         }     }     // has to be outside catch clause to get a proper message     if (fail) {         throw new AssertionError(extraInfo).     } }
false;public,static;2;3;;public static <E extends Throwable> void assertThrows(ActionRequestBuilder<?, ?> builder, RestStatus status) {     assertThrows(builder.execute(), status). }
false;public,static;3;3;;public static <E extends Throwable> void assertThrows(ActionRequestBuilder<?, ?> builder, RestStatus status, String extraInfo) {     assertThrows(builder.execute(), status, extraInfo). }
false;public,static;2;3;;public static <E extends Throwable> void assertThrows(ActionFuture future, RestStatus status) {     assertThrows(future, status, null). }
false;public,static;3;16;;public static void assertThrows(ActionFuture future, RestStatus status, String extraInfo) {     boolean fail = false.     extraInfo = extraInfo == null || extraInfo.isEmpty() ? "" : extraInfo + ": ".     extraInfo += "expected a " + status + " status exception to be thrown".     try {         future.actionGet().         fail = true.     } catch (Exception e) {         assertThat(extraInfo, ExceptionsHelper.status(e), equalTo(status)).     }     // has to be outside catch clause to get a proper message     if (fail) {         throw new AssertionError(extraInfo).     } }
true;public,static;1;3;/**  * Applies basic assertions on the SearchResponse. This method checks if all shards were successful, if  * any of the shards threw an exception and if the response is serializable.  */ ;/**  * Applies basic assertions on the SearchResponse. This method checks if all shards were successful, if  * any of the shards threw an exception and if the response is serializable.  */ public static SearchResponse assertSearchResponse(SearchRequestBuilder request) {     return assertSearchResponse(request.get()). }
true;public,static;1;4;/**  * Applies basic assertions on the SearchResponse. This method checks if all shards were successful, if  * any of the shards threw an exception and if the response is serializable.  */ ;/**  * Applies basic assertions on the SearchResponse. This method checks if all shards were successful, if  * any of the shards threw an exception and if the response is serializable.  */ public static SearchResponse assertSearchResponse(SearchResponse response) {     assertNoFailures(response).     return response. }
true;public,static;1;3;/**  * Check if a file exists  */ ;/**  * Check if a file exists  */ public static void assertFileExists(Path file) {     assertThat("file/dir [" + file + "] should exist.", Files.exists(file), is(true)). }
true;public,static;1;3;/**  * Check if a file does not exist  */ ;/**  * Check if a file does not exist  */ public static void assertFileNotExists(Path file) {     assertThat("file/dir [" + file + "] should not exist.", Files.exists(file), is(false)). }
true;public,static;3;24;/**  * Asserts that the provided {@link BytesReference}s created through  * {@link org.elasticsearch.common.xcontent.ToXContent#toXContent(XContentBuilder, ToXContent.Params)} hold the same content.  * The comparison is done by parsing both into a map and comparing those two, so that keys ordering doesn't matter.  * Also binary values (byte[]) are properly compared through arrays comparisons.  */ ;/**  * Asserts that the provided {@link BytesReference}s created through  * {@link org.elasticsearch.common.xcontent.ToXContent#toXContent(XContentBuilder, ToXContent.Params)} hold the same content.  * The comparison is done by parsing both into a map and comparing those two, so that keys ordering doesn't matter.  * Also binary values (byte[]) are properly compared through arrays comparisons.  */ public static void assertToXContentEquivalent(BytesReference expected, BytesReference actual, XContentType xContentType) throws IOException {     // we tried comparing byte per byte, but that didn't fly for a couple of reasons:     // 1) whenever anything goes through a map while parsing, ordering is not preserved, which is perfectly ok     // 2) Jackson SMILE parser parses floats as double, which then get printed out as double (with double precision)     // Note that byte[] holding binary values need special treatment as they need to be properly compared item per item.     Map<String, Object> actualMap = null.     Map<String, Object> expectedMap = null.     try (XContentParser actualParser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, actual.streamInput())) {         actualMap = actualParser.map().         try (XContentParser expectedParser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, expected.streamInput())) {             expectedMap = expectedParser.map().             try {                 assertMapEquals(expectedMap, actualMap).             } catch (AssertionError error) {                 NotEqualMessageBuilder message = new NotEqualMessageBuilder().                 message.compareMaps(actualMap, expectedMap).                 throw new AssertionError("Error when comparing xContent.\n" + message.toString(), error).             }         }     } }
true;public,static;3;6;/**  * Wait for a latch to countdown and provide a useful error message if it does not  * Often latches are called as <code>assertTrue(latch.await(1, TimeUnit.SECONDS)).</code>  * In case of a failure this will just throw an assertion error without any further message  *  * @param latch    The latch to wait for  * @param timeout  The value of the timeout  * @param unit     The unit of the timeout  * @throws InterruptedException An exception if the waiting is interrupted  */ ;/**  * Wait for a latch to countdown and provide a useful error message if it does not  * Often latches are called as <code>assertTrue(latch.await(1, TimeUnit.SECONDS)).</code>  * In case of a failure this will just throw an assertion error without any further message  *  * @param latch    The latch to wait for  * @param timeout  The value of the timeout  * @param unit     The unit of the timeout  * @throws InterruptedException An exception if the waiting is interrupted  */ public static void awaitLatch(CountDownLatch latch, long timeout, TimeUnit unit) throws InterruptedException {     TimeValue timeValue = new TimeValue(timeout, unit).     String message = String.format(Locale.ROOT, "expected latch to be counted down after %s, but was not", timeValue).     boolean isCountedDown = latch.await(timeout, unit).     assertThat(message, isCountedDown, is(true)). }
true;private,static;2;13;/**  * Compares two maps recursively, using arrays comparisons for byte[] through Arrays.equals(byte[], byte[])  */ ;/**  * Compares two maps recursively, using arrays comparisons for byte[] through Arrays.equals(byte[], byte[])  */ private static void assertMapEquals(Map<String, Object> expected, Map<String, Object> actual) {     assertEquals(expected.size(), actual.size()).     for (Map.Entry<String, Object> expectedEntry : expected.entrySet()) {         String expectedKey = expectedEntry.getKey().         Object expectedValue = expectedEntry.getValue().         if (expectedValue == null) {             assertTrue(actual.get(expectedKey) == null && actual.containsKey(expectedKey)).         } else {             Object actualValue = actual.get(expectedKey).             assertObjectEquals(expectedValue, actualValue).         }     } }
true;private,static;2;8;/**  * Compares two lists recursively, but using arrays comparisons for byte[] through Arrays.equals(byte[], byte[])  */ ;/**  * Compares two lists recursively, but using arrays comparisons for byte[] through Arrays.equals(byte[], byte[])  */ private static void assertListEquals(List<Object> expected, List<Object> actual) {     assertEquals(expected.size(), actual.size()).     Iterator<Object> actualIterator = actual.iterator().     for (Object expectedValue : expected) {         Object actualValue = actualIterator.next().         assertObjectEquals(expectedValue, actualValue).     } }
true;private,static;2;15;/**  * Compares two objects, recursively walking eventual maps and lists encountered, and using arrays comparisons  * for byte[] through Arrays.equals(byte[], byte[])  */ ;/**  * Compares two objects, recursively walking eventual maps and lists encountered, and using arrays comparisons  * for byte[] through Arrays.equals(byte[], byte[])  */ @SuppressWarnings("unchecked") private static void assertObjectEquals(Object expected, Object actual) {     if (expected instanceof Map) {         assertThat(actual, instanceOf(Map.class)).         assertMapEquals((Map<String, Object>) expected, (Map<String, Object>) actual).     } else if (expected instanceof List) {         assertListEquals((List<Object>) expected, (List<Object>) actual).     } else if (expected instanceof byte[]) {         // byte[] is really a special case for binary values when comparing SMILE and CBOR, arrays of other types         // don't need to be handled. Ordinary arrays get parsed as lists.         assertArrayEquals((byte[]) expected, (byte[]) actual).     } else {         assertEquals(expected, actual).     } }
