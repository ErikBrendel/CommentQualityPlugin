commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;11;/**  * Parse a {@link SkipSection} if the next field is {@code skip}, otherwise returns {@link SkipSection#EMPTY}.  */ ;/**  * Parse a {@link SkipSection} if the next field is {@code skip}, otherwise returns {@link SkipSection#EMPTY}.  */ public static SkipSection parseIfNext(XContentParser parser) throws IOException {     ParserUtils.advanceToFieldName(parser).     if ("skip".equals(parser.currentName())) {         SkipSection section = parse(parser).         parser.nextToken().         return section.     }     return EMPTY. }
false;public,static;1;44;;public static SkipSection parse(XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new IllegalArgumentException("Expected [" + XContentParser.Token.START_OBJECT + ", found [" + parser.currentToken() + "], the skip section is not properly indented").     }     String currentFieldName = null.     XContentParser.Token token.     String version = null.     String reason = null.     List<String> features = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if ("version".equals(currentFieldName)) {                 version = parser.text().             } else if ("reason".equals(currentFieldName)) {                 reason = parser.text().             } else if ("features".equals(currentFieldName)) {                 features.add(parser.text()).             } else {                 throw new ParsingException(parser.getTokenLocation(), "field " + currentFieldName + " not supported within skip section").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if ("features".equals(currentFieldName)) {                 while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                     features.add(parser.text()).                 }             }         }     }     parser.nextToken().     if (!Strings.hasLength(version) && features.isEmpty()) {         throw new ParsingException(parser.getTokenLocation(), "version or features is mandatory within skip section").     }     if (Strings.hasLength(version) && !Strings.hasLength(reason)) {         throw new ParsingException(parser.getTokenLocation(), "reason is mandatory within skip version section").     }     return new SkipSection(version, features, reason). }
false;public;0;3;;public Version getLowerVersion() {     return lowerVersion. }
false;public;0;3;;public Version getUpperVersion() {     return upperVersion. }
false;public;0;3;;public List<String> getFeatures() {     return features. }
false;public;0;3;;public String getReason() {     return reason. }
false;public;1;9;;public boolean skip(Version currentVersion) {     if (isEmpty()) {         return false.     }     boolean skip = lowerVersion != null && upperVersion != null && currentVersion.onOrAfter(lowerVersion) && currentVersion.onOrBefore(upperVersion).     skip |= Features.areAllSupported(features) == false.     return skip. }
false;public;0;3;;public boolean isVersionCheck() {     return features.isEmpty(). }
false;public;0;3;;public boolean isEmpty() {     return EMPTY.equals(this). }
false;static;1;19;;static Version[] parseVersionRange(String versionRange) {     if (versionRange == null) {         return new Version[] { null, null }.     }     if (versionRange.trim().equals("all")) {         return new Version[] { VersionUtils.getFirstVersion(), Version.CURRENT }.     }     String[] skipVersions = versionRange.split("-").     if (skipVersions.length > 2) {         throw new IllegalArgumentException("version range malformed: " + versionRange).     }     String lower = skipVersions[0].trim().     String upper = skipVersions[1].trim().     return new Version[] { lower.isEmpty() ? VersionUtils.getFirstVersion() : Version.fromString(lower), upper.isEmpty() ? Version.CURRENT : Version.fromString(upper) }. }
false;public;1;11;;public String getSkipMessage(String description) {     StringBuilder messageBuilder = new StringBuilder().     messageBuilder.append("[").append(description).append("] skipped,").     if (reason != null) {         messageBuilder.append(" reason: [").append(getReason()).append("]").     }     if (features.isEmpty() == false) {         messageBuilder.append(" unsupported features ").append(getFeatures()).     }     return messageBuilder.toString(). }
