commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;16;;public static void corruptIndex(Random random, Path indexPath, boolean corruptSegments) throws IOException {     // corrupt files     final Path[] filesToCorrupt = Files.walk(indexPath).filter(p -> {         final String name = p.getFileName().toString().         boolean segmentFile = name.startsWith("segments_") || name.endsWith(".si").         return Files.isRegularFile(p) && // Skip files added by Lucene's ExtrasFS         name.startsWith("extra") == false && IndexWriter.WRITE_LOCK_NAME.equals(name) == false && (corruptSegments ? segmentFile : segmentFile == false).     }).toArray(Path[]::new).     corruptFile(random, filesToCorrupt). }
true;public,static;2;48;/**  * Corrupts a random file at a random position  */ ;/**  * Corrupts a random file at a random position  */ public static void corruptFile(Random random, Path... files) throws IOException {     assertTrue("files must be non-empty", files.length > 0).     final Path fileToCorrupt = RandomPicks.randomFrom(random, files).     assertTrue(fileToCorrupt + " is not a file", Files.isRegularFile(fileToCorrupt)).     try (Directory dir = FSDirectory.open(fileToCorrupt.toAbsolutePath().getParent())) {         long checksumBeforeCorruption.         try (IndexInput input = dir.openInput(fileToCorrupt.getFileName().toString(), IOContext.DEFAULT)) {             checksumBeforeCorruption = CodecUtil.retrieveChecksum(input).         }         try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) {             long maxPosition = raf.size().             if (fileToCorrupt.getFileName().toString().endsWith(".cfs") && maxPosition > 4) {                 // TODO: it is known that Lucene does not check the checksum of CFS file (CompoundFileS, like an archive)                 // see note at https://github.com/elastic/elasticsearch/pull/33911                 // so far, don't corrupt crc32 part of checksum (last 4 bytes) of cfs file                 // checksum is 8 bytes: first 4 bytes have to be zeros, while crc32 value is not verified                 maxPosition -= 4.             }             final int position = random.nextInt((int) Math.min(Integer.MAX_VALUE, maxPosition)).             corruptAt(fileToCorrupt, raf, position).         }         long checksumAfterCorruption.         long actualChecksumAfterCorruption.         try (ChecksumIndexInput input = dir.openChecksumInput(fileToCorrupt.getFileName().toString(), IOContext.DEFAULT)) {             assertThat(input.getFilePointer(), is(0L)).             input.seek(input.length() - CodecUtil.footerLength()).             checksumAfterCorruption = input.getChecksum().             input.seek(input.length() - 8).             actualChecksumAfterCorruption = input.readLong().         }         // we need to add assumptions here that the checksums actually really don't match there is a small chance to get collisions         // in the checksum which is ok though....         StringBuilder msg = new StringBuilder().         msg.append("before: [").append(checksumBeforeCorruption).append("] ").         msg.append("after: [").append(checksumAfterCorruption).append("] ").         msg.append("checksum value after corruption: ").append(actualChecksumAfterCorruption).append("] ").         msg.append("file: ").append(fileToCorrupt.getFileName()).append(" length: ").         msg.append(dir.fileLength(fileToCorrupt.getFileName().toString())).         logger.info("Checksum {}", msg).         assumeTrue("Checksum collision - " + msg.toString(), // collision         checksumAfterCorruption != checksumBeforeCorruption || // checksum corrupted         actualChecksumAfterCorruption != checksumBeforeCorruption).         assertThat("no file corrupted", fileToCorrupt, notNullValue()).     } }
false;static;3;19;;static void corruptAt(Path path, FileChannel channel, int position) throws IOException {     // read     channel.position(position).     long filePointer = channel.position().     ByteBuffer bb = ByteBuffer.wrap(new byte[1]).     channel.read(bb).     bb.flip().     // corrupt     byte oldValue = bb.get(0).     byte newValue = (byte) (oldValue + 1).     bb.put(0, newValue).     // rewrite     channel.position(filePointer).     channel.write(bb).     logger.info("Corrupting file --  flipping at position {} from {} to {} file: {}", filePointer, Integer.toHexString(oldValue), Integer.toHexString(newValue), path.getFileName()). }
