commented;modifiers;parameterAmount;loc;comment;code
true;public;2;7;/**  * Allows to saved a specific field in the stash as key-value pair  */ ;/**  * Allows to saved a specific field in the stash as key-value pair  */ public void stashValue(String key, Object value) {     logger.trace("stashing [{}]=[{}]", key, value).     Object old = stash.put(key, value).     if (old != null && old != value) {         logger.trace("replaced stashed value [{}] with same key [{}]", old, key).     } }
true;public;0;3;/**  * Clears the previously stashed values  */ ;/**  * Clears the previously stashed values  */ public void clear() {     stash.clear(). }
true;public;1;13;/**  * Tells whether a particular key needs to be looked up in the stash based on its name.  * Returns true if the string representation of the key starts with "$", false otherwise  * The stash contains fields eventually extracted from previous responses that can be reused  * as arguments for following requests (e.g. scroll_id)  */ ;/**  * Tells whether a particular key needs to be looked up in the stash based on its name.  * Returns true if the string representation of the key starts with "$", false otherwise  * The stash contains fields eventually extracted from previous responses that can be reused  * as arguments for following requests (e.g. scroll_id)  */ public boolean containsStashedValue(Object key) {     if (key == null || false == key instanceof CharSequence) {         return false.     }     String stashKey = key.toString().     if (false == Strings.hasLength(stashKey)) {         return false.     }     if (stashKey.startsWith("$")) {         return true.     }     return EXTENDED_KEY.matcher(stashKey).find(). }
true;public;1;19;/**  * Retrieves a value from the current stash.  * The stash contains fields eventually extracted from previous responses that can be reused  * as arguments for following requests (e.g. scroll_id)  */ ;/**  * Retrieves a value from the current stash.  * The stash contains fields eventually extracted from previous responses that can be reused  * as arguments for following requests (e.g. scroll_id)  */ public Object getValue(String key) throws IOException {     if (key.charAt(0) == '$' && key.charAt(1) != '{') {         return unstash(key.substring(1)).     }     Matcher matcher = EXTENDED_KEY.matcher(key).     /*          * String*Buffer* because that is what the Matcher API takes. In modern versions of java the uncontended synchronization is very,          * very cheap so that should not be a problem.          */     StringBuffer result = new StringBuffer(key.length()).     if (false == matcher.find()) {         throw new IllegalArgumentException("Doesn't contain any stash keys [" + key + "]").     }     do {         matcher.appendReplacement(result, Matcher.quoteReplacement(unstash(matcher.group(1)).toString())).     } while (matcher.find()).     matcher.appendTail(result).     return result.toString(). }
false;private;1;7;;private Object unstash(String key) throws IOException {     Object stashedValue = stashObjectPath.evaluate(key).     if (stashedValue == null) {         throw new IllegalArgumentException("stashed value not found for key [" + key + "]").     }     return stashedValue. }
true;public;1;4;/**  * Goes recursively against each map entry and replaces any string value starting with "$" with its  * corresponding value retrieved from the stash  */ ;/**  * Goes recursively against each map entry and replaces any string value starting with "$" with its  * corresponding value retrieved from the stash  */ // Safe because we check that all the map keys are string in unstashObject @SuppressWarnings("unchecked") public Map<String, Object> replaceStashedValues(Map<String, Object> map) throws IOException {     return (Map<String, Object>) unstashObject(new ArrayList<>(), map). }
false;private;2;41;;private Object unstashObject(List<Object> path, Object obj) throws IOException {     if (obj instanceof List) {         List<?> list = (List<?>) obj.         List<Object> result = new ArrayList<>().         int index = 0.         for (Object o : list) {             path.add(index++).             if (containsStashedValue(o)) {                 result.add(getValue(path, o.toString())).             } else {                 result.add(unstashObject(path, o)).             }             path.remove(path.size() - 1).         }         return result.     }     if (obj instanceof Map) {         Map<?, ?> map = (Map<?, ?>) obj.         Map<String, Object> result = new HashMap<>().         for (Map.Entry<?, ?> entry : map.entrySet()) {             String key = (String) entry.getKey().             Object value = entry.getValue().             if (containsStashedValue(key)) {                 key = getValue(key).toString().             }             path.add(key).             if (containsStashedValue(value)) {                 value = getValue(path, value.toString()).             } else {                 value = unstashObject(path, value).             }             path.remove(path.size() - 1).             if (null != result.putIfAbsent(key, value)) {                 throw new IllegalArgumentException("Unstashing has caused a key conflict! The map is [" + result + "] and the key is [" + entry.getKey() + "] which unstashes to [" + key + "]").             }         }         return result.     }     return obj. }
true;private;2;22;/**  * Lookup a value from the stash adding support for a special key ({@code $_path}) which  * returns a string that is the location in the path of the of the object currently being  * unstashed. This is useful during documentation testing.  */ ;/**  * Lookup a value from the stash adding support for a special key ({@code $_path}) which  * returns a string that is the location in the path of the of the object currently being  * unstashed. This is useful during documentation testing.  */ private Object getValue(List<Object> path, String key) throws IOException {     Matcher matcher = PATH.matcher(key).     if (false == matcher.find()) {         return getValue(key).     }     StringBuilder pathBuilder = new StringBuilder().     Iterator<Object> element = path.iterator().     if (element.hasNext()) {         pathBuilder.append(element.next().toString().replace(".", "\\.")).         while (element.hasNext()) {             pathBuilder.append('.').             pathBuilder.append(element.next().toString().replace(".", "\\.")).         }     }     String builtPath = Matcher.quoteReplacement(pathBuilder.toString()).     StringBuffer newKey = new StringBuffer(key.length()).     do {         matcher.appendReplacement(newKey, builtPath).     } while (matcher.find()).     matcher.appendTail(newKey).     return getValue(newKey.toString()). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("stash", stash).     return builder. }
