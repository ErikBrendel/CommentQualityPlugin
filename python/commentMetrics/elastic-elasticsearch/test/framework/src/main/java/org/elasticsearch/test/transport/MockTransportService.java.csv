commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<Setting<?>> getSettings() {     return Arrays.asList(MockTaskManager.USE_MOCK_TASK_MANAGER_SETTING). }
false;public,static;4;5;;public static MockTransportService createNewService(Settings settings, Version version, ThreadPool threadPool, @Nullable ClusterSettings clusterSettings) {     MockNioTransport mockTransport = newMockTransport(settings, version, threadPool).     return createNewService(settings, mockTransport, version, threadPool, clusterSettings, Collections.emptySet()). }
false;public,static;3;11;;public static MockNioTransport newMockTransport(Settings settings, Version version, ThreadPool threadPool) {     // some tests use MockTransportService to do network based testing. Yet, we run tests in multiple JVMs that means     // concurrent tests could claim port that another JVM just released and if that test tries to simulate a disconnect it might     // be smart enough to re-connect depending on what is tested. To reduce the risk, since this is very hard to debug we use     // a different default port range per JVM unless the incoming settings override it     // use a non-default port otherwise some cluster in this JVM might reuse a port     int basePort = 10300 + (JVM_ORDINAL * 100).     settings = Settings.builder().put(TransportSettings.PORT.getKey(), basePort + "-" + (basePort + 100)).put(settings).build().     NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry(ClusterModule.getNamedWriteables()).     return new MockNioTransport(settings, version, threadPool, new NetworkService(Collections.emptyList()), new MockPageCacheRecycler(settings), namedWriteableRegistry, new NoneCircuitBreakerService()). }
false;public,static;6;8;;public static MockTransportService createNewService(Settings settings, Transport transport, Version version, ThreadPool threadPool, @Nullable ClusterSettings clusterSettings, Set<String> taskHeaders) {     return new MockTransportService(settings, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundAddress -> new DiscoveryNode(Node.NODE_NAME_SETTING.get(settings), UUIDs.randomBase64UUID(), boundAddress.publishAddress(), Node.NODE_ATTRIBUTES.getAsMap(settings), DiscoveryNode.getRolesFromSettings(settings), version), clusterSettings, taskHeaders). }
false;private,static;1;7;;private static TransportAddress[] extractTransportAddresses(TransportService transportService) {     HashSet<TransportAddress> transportAddresses = new HashSet<>().     BoundTransportAddress boundTransportAddress = transportService.boundAddress().     transportAddresses.addAll(Arrays.asList(boundTransportAddress.boundAddresses())).     transportAddresses.add(boundTransportAddress.publishAddress()).     return transportAddresses.toArray(new TransportAddress[transportAddresses.size()]). }
false;protected;3;8;;@Override protected TaskManager createTaskManager(Settings settings, ThreadPool threadPool, Set<String> taskHeaders) {     if (MockTaskManager.USE_MOCK_TASK_MANAGER_SETTING.get(settings)) {         return new MockTaskManager(settings, threadPool, taskHeaders).     } else {         return super.createTaskManager(settings, threadPool, taskHeaders).     } }
true;public;0;4;/**  * Clears all the registered rules.  */ ;/**  * Clears all the registered rules.  */ public void clearAllRules() {     transport().clearBehaviors().     connectionManager().clearBehaviors(). }
true;public;1;5;/**  * Clears the rule associated with the provided delegate service.  */ ;/**  * Clears the rule associated with the provided delegate service.  */ public void clearRule(TransportService transportService) {     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         clearRule(transportAddress).     } }
true;public;1;4;/**  * Clears the rule associated with the provided delegate address.  */ ;/**  * Clears the rule associated with the provided delegate address.  */ public void clearRule(TransportAddress transportAddress) {     transport().clearBehavior(transportAddress).     connectionManager().clearBehavior(transportAddress). }
true;public;1;5;/**  * Adds a rule that will cause every send request to fail, and each new connect since the rule  * is added to fail as well.  */ ;/**  * Adds a rule that will cause every send request to fail, and each new connect since the rule  * is added to fail as well.  */ public void addFailToSendNoConnectRule(TransportService transportService) {     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         addFailToSendNoConnectRule(transportAddress).     } }
true;public;1;12;/**  * Adds a rule that will cause every send request to fail, and each new connect since the rule  * is added to fail as well.  */ ;/**  * Adds a rule that will cause every send request to fail, and each new connect since the rule  * is added to fail as well.  */ public void addFailToSendNoConnectRule(TransportAddress transportAddress) {     transport().addConnectBehavior(transportAddress, (transport, discoveryNode, profile, listener) -> {         listener.onFailure(new ConnectTransportException(discoveryNode, "DISCONNECT: simulated")).         return () -> {         }.     }).     transport().addSendBehavior(transportAddress, (connection, requestId, action, request, options) -> {         connection.close().         // send the request, which will blow up         connection.sendRequest(requestId, action, request, options).     }). }
true;public;2;3;/**  * Adds a rule that will cause matching operations to throw ConnectTransportExceptions  */ ;/**  * Adds a rule that will cause matching operations to throw ConnectTransportExceptions  */ public void addFailToSendNoConnectRule(TransportService transportService, final String... blockedActions) {     addFailToSendNoConnectRule(transportService, new HashSet<>(Arrays.asList(blockedActions))). }
true;public;2;5;/**  * Adds a rule that will cause matching operations to throw ConnectTransportExceptions  */ ;/**  * Adds a rule that will cause matching operations to throw ConnectTransportExceptions  */ public void addFailToSendNoConnectRule(TransportService transportService, final Set<String> blockedActions) {     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         addFailToSendNoConnectRule(transportAddress, blockedActions).     } }
true;public;2;9;/**  * Adds a rule that will cause matching operations to throw ConnectTransportExceptions  */ ;/**  * Adds a rule that will cause matching operations to throw ConnectTransportExceptions  */ public void addFailToSendNoConnectRule(TransportAddress transportAddress, final Set<String> blockedActions) {     transport().addSendBehavior(transportAddress, (connection, requestId, action, request, options) -> {         if (blockedActions.contains(action)) {             logger.info("--> preventing {} request", action).             connection.close().         }         connection.sendRequest(requestId, action, request, options).     }). }
true;public;1;5;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  */ ;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  */ public void addUnresponsiveRule(TransportService transportService) {     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         addUnresponsiveRule(transportAddress).     } }
true;public;1;10;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  */ ;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  */ public void addUnresponsiveRule(TransportAddress transportAddress) {     transport().addConnectBehavior(transportAddress, (transport, discoveryNode, profile, listener) -> {         listener.onFailure(new ConnectTransportException(discoveryNode, "UNRESPONSIVE: simulated")).         return () -> {         }.     }).     transport().addSendBehavior(transportAddress, (connection, requestId, action, request, options) -> {     // don't send anything, the receiving node is unresponsive     }). }
true;public;2;5;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  *  * @param duration the amount of time to delay sending and connecting.  */ ;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  *  * @param duration the amount of time to delay sending and connecting.  */ public void addUnresponsiveRule(TransportService transportService, final TimeValue duration) {     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         addUnresponsiveRule(transportAddress, duration).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.debug("failed to send delayed request", e). }
false;protected;0;4;;@Override protected void doRun() throws IOException {     connection.sendRequest(requestId, action, clonedRequest, options). }
false;public;5;38;;@Override public void sendRequest(Transport.Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {     // delayed sending - even if larger then the request timeout to simulated a potential late response from target node     TimeValue delay = delaySupplier.get().     if (delay.millis() <= 0) {         connection.sendRequest(requestId, action, request, options).         return.     }     // poor mans request cloning...     RequestHandlerRegistry reg = MockTransportService.this.getRequestHandler(action).     BytesStreamOutput bStream = new BytesStreamOutput().     request.writeTo(bStream).     final TransportRequest clonedRequest = reg.newRequest(bStream.bytes().streamInput()).     final RunOnce runnable = new RunOnce(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             logger.debug("failed to send delayed request", e).         }          @Override         protected void doRun() throws IOException {             connection.sendRequest(requestId, action, clonedRequest, options).         }     }).     // store the request to send it once the rule is cleared.     synchronized (this) {         if (cleared) {             runnable.run().         } else {             requestsToSendWhenCleared.add(runnable).             threadPool.schedule(runnable, delay, ThreadPool.Names.GENERIC).         }     } }
false;public;0;8;;@Override public void clearCallback() {     synchronized (this) {         assert cleared == false.         cleared = true.         requestsToSendWhenCleared.forEach(Runnable::run).     } }
true;public;2;81;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  *  * @param duration the amount of time to delay sending and connecting.  */ ;/**  * Adds a rule that will cause ignores each send request, simulating an unresponsive node  * and failing to connect once the rule was added.  *  * @param duration the amount of time to delay sending and connecting.  */ public void addUnresponsiveRule(TransportAddress transportAddress, final TimeValue duration) {     final long startTime = System.currentTimeMillis().     Supplier<TimeValue> delaySupplier = () -> new TimeValue(duration.millis() - (System.currentTimeMillis() - startTime)).     transport().addConnectBehavior(transportAddress, (transport, discoveryNode, profile, listener) -> {         TimeValue delay = delaySupplier.get().         if (delay.millis() <= 0) {             return original.openConnection(discoveryNode, profile, listener).         }         // TODO: Replace with proper setting         TimeValue connectingTimeout = TransportSettings.CONNECT_TIMEOUT.getDefault(Settings.EMPTY).         try {             if (delay.millis() < connectingTimeout.millis()) {                 Thread.sleep(delay.millis()).                 return original.openConnection(discoveryNode, profile, listener).             } else {                 Thread.sleep(connectingTimeout.millis()).                 listener.onFailure(new ConnectTransportException(discoveryNode, "UNRESPONSIVE: simulated")).                 return () -> {                 }.             }         } catch (InterruptedException e) {             listener.onFailure(new ConnectTransportException(discoveryNode, "UNRESPONSIVE: simulated")).             return () -> {             }.         }     }).     transport().addSendBehavior(transportAddress, new StubbableTransport.SendRequestBehavior() {          private final Queue<Runnable> requestsToSendWhenCleared = new LinkedBlockingDeque<>().          private boolean cleared = false.          @Override         public void sendRequest(Transport.Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {             // delayed sending - even if larger then the request timeout to simulated a potential late response from target node             TimeValue delay = delaySupplier.get().             if (delay.millis() <= 0) {                 connection.sendRequest(requestId, action, request, options).                 return.             }             // poor mans request cloning...             RequestHandlerRegistry reg = MockTransportService.this.getRequestHandler(action).             BytesStreamOutput bStream = new BytesStreamOutput().             request.writeTo(bStream).             final TransportRequest clonedRequest = reg.newRequest(bStream.bytes().streamInput()).             final RunOnce runnable = new RunOnce(new AbstractRunnable() {                  @Override                 public void onFailure(Exception e) {                     logger.debug("failed to send delayed request", e).                 }                  @Override                 protected void doRun() throws IOException {                     connection.sendRequest(requestId, action, clonedRequest, options).                 }             }).             // store the request to send it once the rule is cleared.             synchronized (this) {                 if (cleared) {                     runnable.run().                 } else {                     requestsToSendWhenCleared.add(runnable).                     threadPool.schedule(runnable, delay, ThreadPool.Names.GENERIC).                 }             }         }          @Override         public void clearCallback() {             synchronized (this) {                 assert cleared == false.                 cleared = true.                 requestsToSendWhenCleared.forEach(Runnable::run).             }         }     }). }
true;public;2;7;/**  * Adds a new send behavior that is used for communication with the given delegate service.  *  * @return {@code true} if no other send behavior was registered for any of the addresses bound by delegate service.  */ ;/**  * Adds a new send behavior that is used for communication with the given delegate service.  *  * @return {@code true} if no other send behavior was registered for any of the addresses bound by delegate service.  */ public boolean addSendBehavior(TransportService transportService, StubbableTransport.SendRequestBehavior sendBehavior) {     boolean noRegistered = true.     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         noRegistered &= addSendBehavior(transportAddress, sendBehavior).     }     return noRegistered. }
true;public;2;3;/**  * Adds a new send behavior that is used for communication with the given delegate address.  *  * @return {@code true} if no other send behavior was registered for this address before.  */ ;/**  * Adds a new send behavior that is used for communication with the given delegate address.  *  * @return {@code true} if no other send behavior was registered for this address before.  */ public boolean addSendBehavior(TransportAddress transportAddress, StubbableTransport.SendRequestBehavior sendBehavior) {     return transport().addSendBehavior(transportAddress, sendBehavior). }
true;public;1;3;/**  * Adds a send behavior that is the default send behavior.  *  * @return {@code true} if no default send behavior was registered  */ ;/**  * Adds a send behavior that is the default send behavior.  *  * @return {@code true} if no default send behavior was registered  */ public boolean addSendBehavior(StubbableTransport.SendRequestBehavior behavior) {     return transport().setDefaultSendBehavior(behavior). }
true;public;2;7;/**  * Adds a new connect behavior that is used for creating connections with the given delegate service.  *  * @return {@code true} if no other send behavior was registered for any of the addresses bound by delegate service.  */ ;/**  * Adds a new connect behavior that is used for creating connections with the given delegate service.  *  * @return {@code true} if no other send behavior was registered for any of the addresses bound by delegate service.  */ public boolean addConnectBehavior(TransportService transportService, StubbableTransport.OpenConnectionBehavior connectBehavior) {     boolean noRegistered = true.     for (TransportAddress transportAddress : extractTransportAddresses(transportService)) {         noRegistered &= addConnectBehavior(transportAddress, connectBehavior).     }     return noRegistered. }
true;public;2;3;/**  * Adds a new connect behavior that is used for creating connections with the given delegate address.  *  * @return {@code true} if no other send behavior was registered for this address before.  */ ;/**  * Adds a new connect behavior that is used for creating connections with the given delegate address.  *  * @return {@code true} if no other send behavior was registered for this address before.  */ public boolean addConnectBehavior(TransportAddress transportAddress, StubbableTransport.OpenConnectionBehavior connectBehavior) {     return transport().addConnectBehavior(transportAddress, connectBehavior). }
true;public;2;3;/**  * Adds a get connection behavior that is used for communication with the given delegate address.  *  * @return {@code true} if no other get connection behavior was registered for this address before.  */ ;/**  * Adds a get connection behavior that is used for communication with the given delegate address.  *  * @return {@code true} if no other get connection behavior was registered for this address before.  */ public boolean addGetConnectionBehavior(TransportAddress transportAddress, StubbableConnectionManager.GetConnectionBehavior behavior) {     return connectionManager().addConnectBehavior(transportAddress, behavior). }
true;public;1;3;/**  * Adds a get connection behavior that is the default get connection behavior.  *  * @return {@code true} if no default get connection behavior was registered.  */ ;/**  * Adds a get connection behavior that is the default get connection behavior.  *  * @return {@code true} if no default get connection behavior was registered.  */ public boolean addGetConnectionBehavior(StubbableConnectionManager.GetConnectionBehavior behavior) {     return connectionManager().setDefaultGetConnectionBehavior(behavior). }
true;public;2;3;/**  * Adds a node connected behavior that is used for the given delegate address.  *  * @return {@code true} if no other node connected behavior was registered for this address before.  */ ;/**  * Adds a node connected behavior that is used for the given delegate address.  *  * @return {@code true} if no other node connected behavior was registered for this address before.  */ public boolean addNodeConnectedBehavior(TransportAddress transportAddress, StubbableConnectionManager.NodeConnectedBehavior behavior) {     return connectionManager().addNodeConnectedBehavior(transportAddress, behavior). }
true;public;1;3;/**  * Adds a node connected behavior that is the default node connected behavior.  *  * @return {@code true} if no default node connected behavior was registered.  */ ;/**  * Adds a node connected behavior that is the default node connected behavior.  *  * @return {@code true} if no default node connected behavior was registered.  */ public boolean addNodeConnectedBehavior(StubbableConnectionManager.NodeConnectedBehavior behavior) {     return connectionManager().setDefaultNodeConnectedBehavior(behavior). }
false;public;0;3;;public StubbableTransport transport() {     return (StubbableTransport) transport. }
false;public;0;3;;public StubbableConnectionManager connectionManager() {     return (StubbableConnectionManager) connectionManager. }
false;public;2;2;;public void receivedRequest(long requestId, String action) { }
false;public;2;2;;public void responseSent(long requestId, String action) { }
false;public;3;2;;public void responseSent(long requestId, String action, Throwable t) { }
false;public;3;2;;public void receivedResponse(long requestId, DiscoveryNode sourceNode, String action) { }
false;public;4;2;;public void requestSent(DiscoveryNode node, long requestId, String action, TransportRequestOptions options) { }
false;public;1;3;;public void addTracer(Tracer tracer) {     activeTracers.add(tracer). }
false;public;0;3;;public void clearTracers() {     activeTracers.clear(). }
false;protected;0;4;;@Override protected boolean traceEnabled() {     return super.traceEnabled() || activeTracers.isEmpty() == false. }
false;protected;2;7;;@Override protected void traceReceivedRequest(long requestId, String action) {     super.traceReceivedRequest(requestId, action).     for (Tracer tracer : activeTracers) {         tracer.receivedRequest(requestId, action).     } }
false;protected;2;7;;@Override protected void traceResponseSent(long requestId, String action) {     super.traceResponseSent(requestId, action).     for (Tracer tracer : activeTracers) {         tracer.responseSent(requestId, action).     } }
false;protected;3;7;;@Override protected void traceResponseSent(long requestId, String action, Exception e) {     super.traceResponseSent(requestId, action, e).     for (Tracer tracer : activeTracers) {         tracer.responseSent(requestId, action, e).     } }
false;protected;3;7;;@Override protected void traceReceivedResponse(long requestId, DiscoveryNode sourceNode, String action) {     super.traceReceivedResponse(requestId, sourceNode, action).     for (Tracer tracer : activeTracers) {         tracer.receivedResponse(requestId, sourceNode, action).     } }
false;protected;4;7;;@Override protected void traceRequestSent(DiscoveryNode node, long requestId, String action, TransportRequestOptions options) {     super.traceRequestSent(node, requestId, action, options).     for (Tracer tracer : activeTracers) {         tracer.requestSent(node, requestId, action, options).     } }
false;public;0;7;;public Transport getOriginalTransport() {     Transport transport = transport().     while (transport instanceof StubbableTransport) {         transport = ((StubbableTransport) transport).getDelegate().     }     return transport. }
false;public;2;23;;@Override public Transport.Connection openConnection(DiscoveryNode node, ConnectionProfile profile) throws IOException {     Transport.Connection connection = super.openConnection(node, profile).     synchronized (openConnections) {         openConnections.computeIfAbsent(node, n -> new CopyOnWriteArrayList<>()).add(connection).         connection.addCloseListener(ActionListener.wrap(() -> {             synchronized (openConnections) {                 List<Transport.Connection> connections = openConnections.get(node).                 boolean remove = connections.remove(connection).                 assert remove : "Should have removed connection".                 if (connections.isEmpty()) {                     openConnections.remove(node).                 }                 if (openConnections.isEmpty()) {                     openConnections.notifyAll().                 }             }         })).     }     return connection. }
false;protected;0;14;;@Override protected void doClose() throws IOException {     super.doClose().     try {         synchronized (openConnections) {             if (openConnections.isEmpty() == false) {                 openConnections.wait(TimeUnit.SECONDS.toMillis(30L)).             }             assert openConnections.size() == 0 : "still open connections: " + openConnections.         }     } catch (InterruptedException e) {         throw new IllegalStateException(e).     } }
false;public;0;3;;public DiscoveryNode getLocalDiscoNode() {     return this.getLocalNode(). }
