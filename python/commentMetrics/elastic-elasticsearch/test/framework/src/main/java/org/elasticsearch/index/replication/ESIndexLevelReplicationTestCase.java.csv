commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;3;;protected ReplicationGroup createGroup(int replicas) throws IOException {     return createGroup(replicas, Settings.EMPTY). }
false;protected;2;4;;protected ReplicationGroup createGroup(int replicas, Settings settings) throws IOException {     IndexMetaData metaData = buildIndexMetaData(replicas, settings, indexMapping).     return new ReplicationGroup(metaData). }
false;protected;1;3;;protected IndexMetaData buildIndexMetaData(int replicas) throws IOException {     return buildIndexMetaData(replicas, indexMapping). }
false;protected;2;3;;protected IndexMetaData buildIndexMetaData(int replicas, Map<String, String> mappings) throws IOException {     return buildIndexMetaData(replicas, Settings.EMPTY, mappings). }
false;protected;3;17;;protected IndexMetaData buildIndexMetaData(int replicas, Settings indexSettings, Map<String, String> mappings) throws IOException {     Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, replicas).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), randomBoolean()).put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomBoolean() ? IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.get(Settings.EMPTY) : between(0, 1000)).put(indexSettings).build().     IndexMetaData.Builder metaData = IndexMetaData.builder(index.getName()).settings(settings).primaryTerm(0, randomIntBetween(1, 100)).     for (Map.Entry<String, String> typeMapping : mappings.entrySet()) {         metaData.putMapping(typeMapping.getKey(), typeMapping.getValue()).     }     return metaData.build(). }
false;protected;1;10;;protected IndexRequest copyIndexRequest(IndexRequest inRequest) throws IOException {     final IndexRequest outRequest = new IndexRequest().     try (BytesStreamOutput out = new BytesStreamOutput()) {         inRequest.writeTo(out).         try (StreamInput in = out.bytes().streamInput()) {             outRequest.readFrom(in).         }     }     return outRequest. }
false;protected;1;4;;protected DiscoveryNode getDiscoveryNode(String id) {     return new DiscoveryNode(id, id, buildNewFakeTransportAddress(), Collections.emptyMap(), Collections.singleton(DiscoveryNode.Role.DATA), Version.CURRENT). }
false;public;3;4;;@Override public void sync(ShardId shardId, RetentionLeases retentionLeases, ActionListener<ReplicationResponse> listener) {     syncRetentionLeases(shardId, retentionLeases, listener). }
false;public;2;8;;@Override public void backgroundSync(ShardId shardId, RetentionLeases retentionLeases) {     sync(shardId, retentionLeases, ActionListener.wrap(r -> {     }, e -> {         throw new AssertionError("failed to backgroun sync retention lease", e).     })). }
false;private;2;4;;private ShardRouting createShardRouting(String nodeId, boolean primary) {     return TestShardRouting.newShardRouting(shardId, nodeId, primary, ShardRoutingState.INITIALIZING, primary ? RecoverySource.EmptyStoreRecoverySource.INSTANCE : RecoverySource.PeerRecoverySource.INSTANCE). }
false;protected;1;3;;protected EngineFactory getEngineFactory(ShardRouting routing) {     return new InternalEngineFactory(). }
false;public;1;13;;public int indexDocs(final int numOfDoc) throws Exception {     for (int doc = 0. doc < numOfDoc. doc++) {         final IndexRequest indexRequest = new IndexRequest(index.getName(), "type", Integer.toString(docId.incrementAndGet())).source("{}", XContentType.JSON).         final BulkItemResponse response = index(indexRequest).         if (response.isFailed()) {             throw response.getFailure().getCause().         } else {             assertEquals(DocWriteResponse.Result.CREATED, response.getResponse().getResult()).         }     }     return numOfDoc. }
false;public;1;12;;public int appendDocs(final int numOfDoc) throws Exception {     for (int doc = 0. doc < numOfDoc. doc++) {         final IndexRequest indexRequest = new IndexRequest(index.getName(), "type").source("{}", XContentType.JSON).         final BulkItemResponse response = index(indexRequest).         if (response.isFailed()) {             throw response.getFailure().getCause().         } else if (response.isFailed() == false) {             assertEquals(DocWriteResponse.Result.CREATED, response.getResponse().getResult()).         }     }     return numOfDoc. }
false;public;1;3;;public BulkItemResponse index(IndexRequest indexRequest) throws Exception {     return executeWriteRequest(indexRequest, indexRequest.getRefreshPolicy()). }
false;public;1;3;;public BulkItemResponse delete(DeleteRequest deleteRequest) throws Exception {     return executeWriteRequest(deleteRequest, deleteRequest.getRefreshPolicy()). }
false;private;2;12;;private BulkItemResponse executeWriteRequest(DocWriteRequest<?> writeRequest, WriteRequest.RefreshPolicy refreshPolicy) throws Exception {     PlainActionFuture<BulkItemResponse> listener = new PlainActionFuture<>().     final ActionListener<BulkShardResponse> wrapBulkListener = ActionListener.wrap(bulkShardResponse -> listener.onResponse(bulkShardResponse.getResponses()[0]), listener::onFailure).     BulkItemRequest[] items = new BulkItemRequest[1].     items[0] = new BulkItemRequest(0, writeRequest).     BulkShardRequest request = new BulkShardRequest(shardId, refreshPolicy, items).     new WriteReplicationAction(request, wrapBulkListener, this).execute().     return listener.get(). }
false;public,synchronized;0;3;;public synchronized void startAll() throws IOException {     startReplicas(replicas.size()). }
false;public,synchronized;1;16;;public synchronized int startReplicas(int numOfReplicasToStart) throws IOException {     if (primary.routingEntry().initializing()) {         startPrimary().     }     int started = 0.     for (IndexShard replicaShard : replicas) {         if (replicaShard.routingEntry().initializing()) {             recoverReplica(replicaShard).             started++.             if (started > numOfReplicasToStart) {                 break.             }         }     }     return started. }
false;public;0;14;;public void startPrimary() throws IOException {     recoverPrimary(primary).     HashSet<String> activeIds = new HashSet<>().     activeIds.addAll(activeIds()).     activeIds.add(primary.routingEntry().allocationId().getId()).     ShardRouting startedRoutingEntry = ShardRoutingHelper.moveToStarted(primary.routingEntry()).     IndexShardRoutingTable routingTable = routingTable(shr -> shr == primary.routingEntry() ? startedRoutingEntry : shr).     primary.updateShardState(startedRoutingEntry, primary.getPendingPrimaryTerm(), null, currentClusterStateVersion.incrementAndGet(), activeIds, routingTable, Collections.emptySet()).     for (final IndexShard replica : replicas) {         recoverReplica(replica).     }     computeReplicationTargets(). }
false;public;0;7;;public IndexShard addReplica() throws IOException {     final ShardRouting replicaRouting = createShardRouting("s" + replicaId.incrementAndGet(), false).     final IndexShard replica = newShard(replicaRouting, indexMetaData, null, getEngineFactory(replicaRouting), () -> {     }, retentionLeaseSyncer).     addReplica(replica).     return replica. }
false;public,synchronized;1;10;;public synchronized void addReplica(IndexShard replica) throws IOException {     assert shardRoutings().stream().filter(shardRouting -> shardRouting.isSameAllocation(replica.routingEntry())).findFirst().isPresent() == false : "replica with aId [" + replica.routingEntry().allocationId() + "] already exists".     replicas.add(replica).     if (replicationTargets != null) {         replicationTargets.addReplica(replica).     }     updateAllocationIDsOnPrimary(). }
false;protected,synchronized;1;5;;protected synchronized void recoverPrimary(IndexShard primary) {     final DiscoveryNode pNode = getDiscoveryNode(primary.routingEntry().currentNodeId()).     primary.markAsRecovering("store", new RecoveryState(primary.routingEntry(), pNode, null)).     primary.recoverFromStore(). }
false;public,synchronized;2;17;;public synchronized IndexShard addReplicaWithExistingPath(final ShardPath shardPath, final String nodeId) throws IOException {     final ShardRouting shardRouting = TestShardRouting.newShardRouting(shardId, nodeId, false, ShardRoutingState.INITIALIZING, RecoverySource.PeerRecoverySource.INSTANCE).     final IndexShard newReplica = newShard(shardRouting, shardPath, indexMetaData, null, null, getEngineFactory(shardRouting), () -> {     }, retentionLeaseSyncer, EMPTY_EVENT_LISTENER).     replicas.add(newReplica).     if (replicationTargets != null) {         replicationTargets.addReplica(newReplica).     }     updateAllocationIDsOnPrimary().     return newReplica. }
false;public,synchronized;0;3;;public synchronized List<IndexShard> getReplicas() {     return Collections.unmodifiableList(replicas). }
false;public;1;5;;@Override public void onResponse(PrimaryReplicaSyncer.ResyncTask resyncTask) {     listener.onResponse(resyncTask).     fut.onResponse(resyncTask). }
false;public;1;5;;@Override public void onFailure(Exception e) {     listener.onFailure(e).     fut.onFailure(e). }
true;public;1;21;/**  * promotes the specific replica as the new primary  */ ;/**  * promotes the specific replica as the new primary  */ public Future<PrimaryReplicaSyncer.ResyncTask> promoteReplicaToPrimary(IndexShard replica) throws IOException {     PlainActionFuture<PrimaryReplicaSyncer.ResyncTask> fut = new PlainActionFuture<>().     promoteReplicaToPrimary(replica, (shard, listener) -> {         computeReplicationTargets().         primaryReplicaSyncer.resync(shard, new ActionListener<PrimaryReplicaSyncer.ResyncTask>() {              @Override             public void onResponse(PrimaryReplicaSyncer.ResyncTask resyncTask) {                 listener.onResponse(resyncTask).                 fut.onResponse(resyncTask).             }              @Override             public void onFailure(Exception e) {                 listener.onFailure(e).                 fut.onFailure(e).             }         }).     }).     return fut. }
false;public,synchronized;2;16;;public synchronized void promoteReplicaToPrimary(IndexShard replica, BiConsumer<IndexShard, ActionListener<PrimaryReplicaSyncer.ResyncTask>> primaryReplicaSyncer) throws IOException {     final long newTerm = indexMetaData.primaryTerm(shardId.id()) + 1.     IndexMetaData.Builder newMetaData = IndexMetaData.builder(indexMetaData).primaryTerm(shardId.id(), newTerm).     indexMetaData = newMetaData.build().     assertTrue(replicas.remove(replica)).     closeShards(primary).     primary = replica.     assert primary.routingEntry().active() : "only active replicas can be promoted to primary: " + primary.routingEntry().     ShardRouting primaryRouting = replica.routingEntry().moveActiveReplicaToPrimary().     IndexShardRoutingTable routingTable = routingTable(shr -> shr == replica.routingEntry() ? primaryRouting : shr).     primary.updateShardState(primaryRouting, newTerm, primaryReplicaSyncer, currentClusterStateVersion.incrementAndGet(), activeIds(), routingTable, Collections.emptySet()). }
false;private,synchronized;0;4;;private synchronized Set<String> activeIds() {     return shardRoutings().stream().filter(ShardRouting::active).map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet()). }
false;private,synchronized;1;5;;private synchronized IndexShardRoutingTable routingTable(Function<ShardRouting, ShardRouting> transformer) {     IndexShardRoutingTable.Builder routingTable = new IndexShardRoutingTable.Builder(primary.shardId()).     shardRoutings().stream().map(transformer).forEach(routingTable::addShard).     return routingTable.build(). }
false;public,synchronized;1;8;;public synchronized boolean removeReplica(IndexShard replica) throws IOException {     final boolean removed = replicas.remove(replica).     if (removed) {         updateAllocationIDsOnPrimary().         computeReplicationTargets().     }     return removed. }
false;public;1;3;;public void recoverReplica(IndexShard replica) throws IOException {     recoverReplica(replica, (r, sourceNode) -> new RecoveryTarget(r, sourceNode, recoveryListener, version -> {     })). }
false;public;2;4;;public void recoverReplica(IndexShard replica, BiFunction<IndexShard, DiscoveryNode, RecoveryTarget> targetSupplier) throws IOException {     recoverReplica(replica, targetSupplier, true). }
false;public;3;11;;public void recoverReplica(IndexShard replica, BiFunction<IndexShard, DiscoveryNode, RecoveryTarget> targetSupplier, boolean markAsRecovering) throws IOException {     final IndexShardRoutingTable routingTable = routingTable(Function.identity()).     final Set<String> inSyncIds = activeIds().     ESIndexLevelReplicationTestCase.this.recoverUnstartedReplica(replica, primary, targetSupplier, markAsRecovering, inSyncIds, routingTable).     ESIndexLevelReplicationTestCase.this.startReplicaAfterRecovery(replica, primary, inSyncIds, routingTable).     computeReplicationTargets(). }
false;public,synchronized;0;3;;public synchronized DiscoveryNode getPrimaryNode() {     return getDiscoveryNode(primary.routingEntry().currentNodeId()). }
false;public;2;9;;public Future<Void> asyncRecoverReplica(final IndexShard replica, final BiFunction<IndexShard, DiscoveryNode, RecoveryTarget> targetSupplier) throws IOException {     final FutureTask<Void> task = new FutureTask<>(() -> {         recoverReplica(replica, targetSupplier).         return null.     }).     threadPool.generic().execute(task).     return task. }
false;public,synchronized;1;13;;public synchronized void assertAllEqual(int expectedCount) throws IOException {     Set<String> primaryIds = getShardDocUIDs(primary).     assertThat(primaryIds.size(), equalTo(expectedCount)).     for (IndexShard replica : replicas) {         Set<String> replicaIds = getShardDocUIDs(replica).         Set<String> temp = new HashSet<>(primaryIds).         temp.removeAll(replicaIds).         assertThat(replica.routingEntry() + " is missing docs", temp, empty()).         temp = new HashSet<>(replicaIds).         temp.removeAll(primaryIds).         assertThat(replica.routingEntry() + " has extra docs", temp, empty()).     } }
false;public,synchronized;1;5;;public synchronized void refresh(String source) {     for (IndexShard shard : this) {         shard.refresh(source).     } }
false;public,synchronized;0;6;;public synchronized void flush() {     final FlushRequest request = new FlushRequest().     for (IndexShard shard : this) {         shard.flush(request).     } }
false;public,synchronized;0;3;;public synchronized List<ShardRouting> shardRoutings() {     return StreamSupport.stream(this.spliterator(), false).map(IndexShard::routingEntry).collect(Collectors.toList()). }
false;public,synchronized;0;17;;@Override public synchronized void close() throws Exception {     if (closed == false) {         closed = true.         try {             final List<DocIdSeqNoAndTerm> docsOnPrimary = getDocIdAndSeqNos(primary).             for (IndexShard replica : replicas) {                 assertThat(replica.getMaxSeenAutoIdTimestamp(), equalTo(primary.getMaxSeenAutoIdTimestamp())).                 assertThat(replica.getMaxSeqNoOfUpdatesOrDeletes(), greaterThanOrEqualTo(primary.getMaxSeqNoOfUpdatesOrDeletes())).                 assertThat(getDocIdAndSeqNos(replica), equalTo(docsOnPrimary)).             }         } catch (AlreadyClosedException ignored) {         }         closeShards(this).     } else {         throw new AlreadyClosedException("too bad").     } }
false;public;0;4;;@Override public Iterator<IndexShard> iterator() {     return Iterators.concat(replicas.iterator(), Collections.singleton(primary).iterator()). }
false;public,synchronized;0;3;;public synchronized IndexShard getPrimary() {     return primary. }
false;public,synchronized;0;4;;public synchronized void reinitPrimaryShard() throws IOException {     primary = reinitShard(primary).     computeReplicationTargets(). }
false;public;0;9;;public void syncGlobalCheckpoint() {     PlainActionFuture<ReplicationResponse> listener = new PlainActionFuture<>().     try {         new GlobalCheckpointSync(listener, this).execute().         listener.get().     } catch (Exception e) {         throw new AssertionError(e).     } }
false;private;0;6;;private void updateAllocationIDsOnPrimary() throws IOException {     primary.updateShardState(primary.routingEntry(), primary.getPendingPrimaryTerm(), null, currentClusterStateVersion.incrementAndGet(), activeIds(), routingTable(Function.identity()), Collections.emptySet()). }
false;private,synchronized;0;3;;private synchronized void computeReplicationTargets() {     this.replicationTargets = new ReplicationTargets(this.primary, new ArrayList<>(this.replicas)). }
false;private,synchronized;0;3;;private synchronized ReplicationTargets getReplicationTargets() {     return replicationTargets. }
false;protected;3;6;;protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {     RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(shardId, leases).     ActionListener<RetentionLeaseSyncAction.Response> wrappedListener = ActionListener.wrap(r -> listener.onResponse(new ReplicationResponse()), listener::onFailure).     new SyncRetentionLeases(request, ReplicationGroup.this, wrappedListener).execute(). }
false;public,synchronized;4;4;;public synchronized RetentionLease addRetentionLease(String id, long retainingSequenceNumber, String source, ActionListener<ReplicationResponse> listener) {     return getPrimary().addRetentionLease(id, retainingSequenceNumber, source, listener). }
false;public,synchronized;3;3;;public synchronized RetentionLease renewRetentionLease(String id, long retainingSequenceNumber, String source) {     return getPrimary().renewRetentionLease(id, retainingSequenceNumber, source). }
false;public,synchronized;2;3;;public synchronized void removeRetentionLease(String id, ActionListener<ReplicationResponse> listener) {     getPrimary().removeRetentionLease(id, listener). }
false;public;2;11;;public void executeRetentionLeasesSyncRequestOnReplica(RetentionLeaseSyncAction.Request request, IndexShard replica) {     final PlainActionFuture<Releasable> acquirePermitFuture = new PlainActionFuture<>().     replica.acquireReplicaOperationPermit(getPrimary().getOperationPrimaryTerm(), getPrimary().getGlobalCheckpoint(), getPrimary().getMaxSeqNoOfUpdatesOrDeletes(), acquirePermitFuture, ThreadPool.Names.SAME, request).     try (Releasable ignored = acquirePermitFuture.actionGet()) {         replica.updateRetentionLeasesOnReplica(request.getRetentionLeases()).         replica.persistRetentionLeases().     } catch (Exception e) {         throw new AssertionError("failed to execute retention lease request on replica [" + replica.routingEntry() + "]", e).     } }
true;synchronized;1;3;/**  * This does not modify the replication targets, but only adds a replica to the list.  * If the targets is updated to include the given replica, a replication action would  * be able to find this replica to execute write requests on it.  */ ;/**  * This does not modify the replication targets, but only adds a replica to the list.  * If the targets is updated to include the given replica, a replication action would  * be able to find this replica to execute write requests on it.  */ synchronized void addReplica(IndexShard replica) {     replicas.add(replica). }
false;synchronized;1;8;;synchronized IndexShard findReplicaShard(ShardRouting replicaRouting) {     for (IndexShard replica : replicas) {         if (replica.routingEntry().isSameAllocation(replicaRouting)) {             return replica.         }     }     throw new AssertionError("replica [" + replicaRouting + "] is not found. replicas[" + replicas + "] primary[" + primary + "]"). }
false;public;1;4;;@Override public void onResponse(PrimaryResult result) {     result.respond(listener). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;0;18;;public void execute() {     try {         new ReplicationOperation<>(request, new PrimaryRef(), new ActionListener<PrimaryResult>() {              @Override             public void onResponse(PrimaryResult result) {                 result.respond(listener).             }              @Override             public void onFailure(Exception e) {                 listener.onFailure(e).             }         }, new ReplicasRef(), logger, opType).execute().     } catch (Exception e) {         listener.onFailure(e).     } }
false;;0;3;;IndexShard getPrimaryShard() {     return replicationTargets.primary. }
false;protected,abstract;2;1;;protected abstract PrimaryResult performOnPrimary(IndexShard primary, Request request) throws Exception.
false;protected,abstract;2;1;;protected abstract void performOnReplica(ReplicaRequest request, IndexShard replica) throws Exception.
false;public;0;4;;@Override public ShardRouting routingEntry() {     return getPrimaryShard().routingEntry(). }
false;public;2;4;;@Override public void failShard(String message, Exception exception) {     throw new UnsupportedOperationException("failing a primary isn't supported. failure: " + message, exception). }
false;public;1;4;;@Override public PrimaryResult perform(Request request) throws Exception {     return performOnPrimary(getPrimaryShard(), request). }
false;public;2;4;;@Override public void updateLocalCheckpointForShard(String allocationId, long checkpoint) {     getPrimaryShard().updateLocalCheckpointForShard(allocationId, checkpoint). }
false;public;2;4;;@Override public void updateGlobalCheckpointForShard(String allocationId, long globalCheckpoint) {     getPrimaryShard().updateGlobalCheckpointForShard(allocationId, globalCheckpoint). }
false;public;0;4;;@Override public long localCheckpoint() {     return getPrimaryShard().getLocalCheckpoint(). }
false;public;0;4;;@Override public long globalCheckpoint() {     return getPrimaryShard().getGlobalCheckpoint(). }
false;public;0;4;;@Override public long maxSeqNoOfUpdatesOrDeletes() {     return getPrimaryShard().getMaxSeqNoOfUpdatesOrDeletes(). }
false;public;0;4;;@Override public org.elasticsearch.index.shard.ReplicationGroup getReplicationGroup() {     return getPrimaryShard().getReplicationGroup(). }
false;public;1;11;;@Override public void onResponse(Releasable releasable) {     try {         performOnReplica(request, replica).         releasable.close().         listener.onResponse(new ReplicaResponse(replica.getLocalCheckpoint(), replica.getGlobalCheckpoint())).     } catch (final Exception e) {         Releasables.closeWhileHandlingException(releasable).         listener.onFailure(e).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;5;32;;@Override public void performOn(final ShardRouting replicaRouting, final ReplicaRequest request, final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes, final ActionListener<ReplicationOperation.ReplicaResponse> listener) {     IndexShard replica = replicationTargets.findReplicaShard(replicaRouting).     replica.acquireReplicaOperationPermit(getPrimaryShard().getPendingPrimaryTerm(), globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, new ActionListener<Releasable>() {          @Override         public void onResponse(Releasable releasable) {             try {                 performOnReplica(request, replica).                 releasable.close().                 listener.onResponse(new ReplicaResponse(replica.getLocalCheckpoint(), replica.getGlobalCheckpoint())).             } catch (final Exception e) {                 Releasables.closeWhileHandlingException(releasable).                 listener.onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }, ThreadPool.Names.WRITE, request). }
false;public;6;6;;@Override public void failShardIfNeeded(ShardRouting replica, String message, Exception exception, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     throw new UnsupportedOperationException("failing shard " + replica + " isn't supported. failure: " + message, exception). }
false;public;5;5;;@Override public void markShardCopyAsStaleIfNeeded(ShardId shardId, String allocationId, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     throw new UnsupportedOperationException("can't mark " + shardId + ", aid [" + allocationId + "] as stale"). }
false;public;0;4;;@Override public ReplicaRequest replicaRequest() {     return replicaRequest. }
false;public;1;4;;@Override public void setShardInfo(ReplicationResponse.ShardInfo shardInfo) {     finalResponse.setShardInfo(shardInfo). }
false;public;1;3;;public void respond(ActionListener<Response> listener) {     listener.onResponse(finalResponse). }
false;protected;2;6;;@Override protected PrimaryResult performOnPrimary(IndexShard primary, BulkShardRequest request) throws Exception {     final TransportWriteAction.WritePrimaryResult<BulkShardRequest, BulkShardResponse> result = executeShardBulkOnPrimary(primary, request).     return new PrimaryResult(result.replicaRequest(), result.finalResponseIfSuccessful). }
false;protected;2;5;;@Override protected void performOnReplica(BulkShardRequest request, IndexShard replica) throws Exception {     executeShardBulkOnReplica(request, replica, getPrimaryShard().getPendingPrimaryTerm(), getPrimaryShard().getGlobalCheckpoint(), getPrimaryShard().getMaxSeqNoOfUpdatesOrDeletes()). }
false;private;2;18;;private TransportWriteAction.WritePrimaryResult<BulkShardRequest, BulkShardResponse> executeShardBulkOnPrimary(IndexShard primary, BulkShardRequest request) throws Exception {     for (BulkItemRequest itemRequest : request.items()) {         if (itemRequest.request() instanceof IndexRequest) {             ((IndexRequest) itemRequest.request()).process(Version.CURRENT, null, index.getName()).         }     }     final PlainActionFuture<Releasable> permitAcquiredFuture = new PlainActionFuture<>().     primary.acquirePrimaryOperationPermit(permitAcquiredFuture, ThreadPool.Names.SAME, request).     final TransportWriteAction.WritePrimaryResult<BulkShardRequest, BulkShardResponse> result.     try (Releasable ignored = permitAcquiredFuture.actionGet()) {         MappingUpdatePerformer noopMappingUpdater = (update, shardId, type) -> {         }.         result = TransportShardBulkAction.performOnPrimary(request, primary, null, System::currentTimeMillis, noopMappingUpdater, null).     }     TransportWriteActionTestHelper.performPostWriteActions(primary, request, result.location, logger).     return result. }
false;private;2;6;;private <Request extends ReplicatedWriteRequest & DocWriteRequest> BulkShardRequest executeReplicationRequestOnPrimary(IndexShard primary, Request request) throws Exception {     final BulkShardRequest bulkShardRequest = new BulkShardRequest(shardId, request.getRefreshPolicy(), new BulkItemRequest[] { new BulkItemRequest(0, request) }).     return executeShardBulkOnPrimary(primary, bulkShardRequest).replicaRequest(). }
false;private;5;11;;private void executeShardBulkOnReplica(BulkShardRequest request, IndexShard replica, long operationPrimaryTerm, long globalCheckpointOnPrimary, long maxSeqNoOfUpdatesOrDeletes) throws Exception {     final PlainActionFuture<Releasable> permitAcquiredFuture = new PlainActionFuture<>().     replica.acquireReplicaOperationPermit(operationPrimaryTerm, globalCheckpointOnPrimary, maxSeqNoOfUpdatesOrDeletes, permitAcquiredFuture, ThreadPool.Names.SAME, request).     final Translog.Location location.     try (Releasable ignored = permitAcquiredFuture.actionGet()) {         location = TransportShardBulkAction.performOnReplica(request, replica).     }     TransportWriteActionTestHelper.performPostWriteActions(replica, request, location, logger). }
true;;2;3;/**  * indexes the given requests on the supplied primary, modifying it for replicas  */ ;/**  * indexes the given requests on the supplied primary, modifying it for replicas  */ BulkShardRequest indexOnPrimary(IndexRequest request, IndexShard primary) throws Exception {     return executeReplicationRequestOnPrimary(primary, request). }
true;;2;3;/**  * Executes the delete request on the primary, and modifies it for replicas.  */ ;/**  * Executes the delete request on the primary, and modifies it for replicas.  */ BulkShardRequest deleteOnPrimary(DeleteRequest request, IndexShard primary) throws Exception {     return executeReplicationRequestOnPrimary(primary, request). }
true;;3;3;/**  * indexes the given requests on the supplied replica shard  */ ;/**  * indexes the given requests on the supplied replica shard  */ void indexOnReplica(BulkShardRequest request, ReplicationGroup group, IndexShard replica) throws Exception {     indexOnReplica(request, group, replica, group.primary.getPendingPrimaryTerm()). }
false;;4;4;;void indexOnReplica(BulkShardRequest request, ReplicationGroup group, IndexShard replica, long term) throws Exception {     executeShardBulkOnReplica(request, replica, term, group.primary.getGlobalCheckpoint(), group.primary.getMaxSeqNoOfUpdatesOrDeletes()). }
true;;3;4;/**  * Executes the delete request on the given replica shard.  */ ;/**  * Executes the delete request on the given replica shard.  */ void deleteOnReplica(BulkShardRequest request, ReplicationGroup group, IndexShard replica) throws Exception {     executeShardBulkOnReplica(request, replica, group.primary.getPendingPrimaryTerm(), group.primary.getGlobalCheckpoint(), group.primary.getMaxSeqNoOfUpdatesOrDeletes()). }
false;protected;2;6;;@Override protected PrimaryResult performOnPrimary(final IndexShard primary, final GlobalCheckpointSyncAction.Request request) throws Exception {     primary.sync().     return new PrimaryResult(request, new ReplicationResponse()). }
false;protected;2;4;;@Override protected void performOnReplica(final GlobalCheckpointSyncAction.Request request, final IndexShard replica) throws IOException {     replica.sync(). }
false;protected;2;6;;@Override protected PrimaryResult performOnPrimary(IndexShard primary, ResyncReplicationRequest request) throws Exception {     final TransportWriteAction.WritePrimaryResult<ResyncReplicationRequest, ResyncReplicationResponse> result = executeResyncOnPrimary(primary, request).     return new PrimaryResult(result.replicaRequest(), result.finalResponseIfSuccessful). }
false;protected;2;5;;@Override protected void performOnReplica(ResyncReplicationRequest request, IndexShard replica) throws Exception {     executeResyncOnReplica(replica, request, getPrimaryShard().getPendingPrimaryTerm(), getPrimaryShard().getGlobalCheckpoint(), getPrimaryShard().getMaxSeqNoOfUpdatesOrDeletes()). }
false;private;2;8;;private TransportWriteAction.WritePrimaryResult<ResyncReplicationRequest, ResyncReplicationResponse> executeResyncOnPrimary(IndexShard primary, ResyncReplicationRequest request) throws Exception {     final TransportWriteAction.WritePrimaryResult<ResyncReplicationRequest, ResyncReplicationResponse> result = new TransportWriteAction.WritePrimaryResult<>(TransportResyncReplicationAction.performOnPrimary(request, primary), new ResyncReplicationResponse(), null, null, primary, logger).     TransportWriteActionTestHelper.performPostWriteActions(primary, request, result.location, logger).     return result. }
false;private;5;11;;private void executeResyncOnReplica(IndexShard replica, ResyncReplicationRequest request, long operationPrimaryTerm, long globalCheckpointOnPrimary, long maxSeqNoOfUpdatesOrDeletes) throws Exception {     final Translog.Location location.     final PlainActionFuture<Releasable> acquirePermitFuture = new PlainActionFuture<>().     replica.acquireReplicaOperationPermit(operationPrimaryTerm, globalCheckpointOnPrimary, maxSeqNoOfUpdatesOrDeletes, acquirePermitFuture, ThreadPool.Names.SAME, request).     try (Releasable ignored = acquirePermitFuture.actionGet()) {         location = TransportResyncReplicationAction.performOnReplica(request, replica).     }     TransportWriteActionTestHelper.performPostWriteActions(replica, request, location, logger). }
false;protected;2;5;;@Override protected PrimaryResult performOnPrimary(IndexShard primary, RetentionLeaseSyncAction.Request request) throws Exception {     primary.persistRetentionLeases().     return new PrimaryResult(request, new RetentionLeaseSyncAction.Response()). }
false;protected;2;5;;@Override protected void performOnReplica(RetentionLeaseSyncAction.Request request, IndexShard replica) throws Exception {     replica.updateRetentionLeasesOnReplica(request.getRetentionLeases()).     replica.persistRetentionLeases(). }
