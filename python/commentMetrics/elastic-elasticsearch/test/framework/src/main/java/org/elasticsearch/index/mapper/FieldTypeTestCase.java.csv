commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;1;1;/**  * Modifies the property  */ ;/**  * Modifies the property  */ public abstract void modify(MappedFieldType ft).
true;public;1;1;/**  * Optional method to implement that allows the field type that will be compared to be modified,  * so that it does not have the default value for the property being modified.  */ ;/**  * Optional method to implement that allows the field type that will be compared to be modified,  * so that it does not have the default value for the property being modified.  */ public void normalizeOther(MappedFieldType other) { }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setBoost(1.1f). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setHasDocValues(ft.hasDocValues() == false). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setIndexAnalyzer(new NamedAnalyzer("bar", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setIndexAnalyzer(new NamedAnalyzer("bar", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void normalizeOther(MappedFieldType other) {     other.setIndexAnalyzer(new NamedAnalyzer("foo", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setIndexAnalyzer(new NamedAnalyzer("foo", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void normalizeOther(MappedFieldType other) {     other.setIndexAnalyzer(new NamedAnalyzer("foo", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSearchAnalyzer(new NamedAnalyzer("bar", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSearchAnalyzer(new NamedAnalyzer("bar", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void normalizeOther(MappedFieldType other) {     other.setSearchAnalyzer(new NamedAnalyzer("foo", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSearchQuoteAnalyzer(new NamedAnalyzer("bar", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSearchQuoteAnalyzer(new NamedAnalyzer("bar", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void normalizeOther(MappedFieldType other) {     other.setSearchQuoteAnalyzer(new NamedAnalyzer("foo", AnalyzerScope.INDEX, new StandardAnalyzer())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSimilarity(new SimilarityProvider("foo", new BM25Similarity())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSimilarity(new SimilarityProvider("foo", new BM25Similarity())). }
false;public;1;4;;@Override public void normalizeOther(MappedFieldType other) {     other.setSimilarity(new SimilarityProvider("bar", new BM25Similarity())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setSimilarity(new SimilarityProvider("foo", new BM25Similarity())). }
false;public;1;4;;@Override public void normalizeOther(MappedFieldType other) {     other.setSimilarity(new SimilarityProvider("foo", new BM25Similarity())). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setEagerGlobalOrdinals(ft.eagerGlobalOrdinals() == false). }
false;public;1;4;;@Override public void modify(MappedFieldType ft) {     ft.setNullValue(dummyNullValue). }
true;protected;1;3;/**  * Add a mutation that will be tested for all expected semantics of equality and compatibility.  * These should be added in an @Before method.  */ ;/**  * Add a mutation that will be tested for all expected semantics of equality and compatibility.  * These should be added in an @Before method.  */ protected void addModifier(Modifier modifier) {     modifiers.add(modifier). }
true;protected;1;3;/**  * Sets the null value used by the modifier for null value testing. This should be set in an @Before method.  */ ;/**  * Sets the null value used by the modifier for null value testing. This should be set in an @Before method.  */ protected void setDummyNullValue(Object value) {     dummyNullValue = value. }
true;protected,abstract;0;1;/**  * Create a default constructed fieldtype  */ ;/**  * Create a default constructed fieldtype  */ protected abstract MappedFieldType createDefaultFieldType().
false;;0;5;;MappedFieldType createNamedDefaultFieldType() {     MappedFieldType fieldType = createDefaultFieldType().     fieldType.setName("foo").     return fieldType. }
true;protected;3;6;// TODO: remove this once toString is no longer final on FieldType... ;// TODO: remove this once toString is no longer final on FieldType... protected void assertFieldTypeEquals(String property, MappedFieldType ft1, MappedFieldType ft2) {     if (ft1.equals(ft2) == false) {         fail("Expected equality, testing property " + property + "\nexpected: " + toString(ft1) + ". \nactual:   " + toString(ft2) + "\n").     } }
false;protected;3;6;;protected void assertFieldTypeNotEquals(String property, MappedFieldType ft1, MappedFieldType ft2) {     if (ft1.equals(ft2)) {         fail("Expected inequality, testing property " + property + "\nfirst:  " + toString(ft1) + ". \nsecond: " + toString(ft2) + "\n").     } }
false;protected;3;5;;protected void assertCompatible(String msg, MappedFieldType ft1, MappedFieldType ft2) {     List<String> conflicts = new ArrayList<>().     ft1.checkCompatibility(ft2, conflicts).     assertTrue("Found conflicts for " + msg + ": " + conflicts, conflicts.isEmpty()). }
false;protected;4;14;;protected void assertNotCompatible(String msg, MappedFieldType ft1, MappedFieldType ft2, String... messages) {     assert messages.length != 0.     List<String> conflicts = new ArrayList<>().     ft1.checkCompatibility(ft2, conflicts).     for (String message : messages) {         boolean found = false.         for (String conflict : conflicts) {             if (conflict.contains(message)) {                 found = true.             }         }         assertTrue("Missing conflict for " + msg + ": [" + message + "] in conflicts " + conflicts, found).     } }
false;protected;1;14;;protected String toString(MappedFieldType ft) {     return "MappedFieldType{" + "name=" + ft.name() + ", boost=" + ft.boost() + ", docValues=" + ft.hasDocValues() + ", indexAnalyzer=" + ft.indexAnalyzer() + ", searchAnalyzer=" + ft.searchAnalyzer() + ", searchQuoteAnalyzer=" + ft.searchQuoteAnalyzer() + ", similarity=" + ft.similarity() + ", eagerGlobalOrdinals=" + ft.eagerGlobalOrdinals() + ", nullValue=" + ft.nullValue() + ", nullValueAsString='" + ft.nullValueAsString() + "'" + "} " + super.toString(). }
false;public;0;16;;public void testClone() {     MappedFieldType fieldType = createNamedDefaultFieldType().     MappedFieldType clone = fieldType.clone().     assertNotSame(clone, fieldType).     assertEquals(clone.getClass(), fieldType.getClass()).     assertEquals(clone, fieldType).     // transitivity     assertEquals(clone, clone.clone()).     for (Modifier modifier : modifiers) {         fieldType = createNamedDefaultFieldType().         modifier.modify(fieldType).         clone = fieldType.clone().         assertNotSame(clone, fieldType).         assertFieldTypeEquals(modifier.property, clone, fieldType).     } }
false;public;0;20;;public void testEquals() {     MappedFieldType ft1 = createNamedDefaultFieldType().     MappedFieldType ft2 = createNamedDefaultFieldType().     // reflexive     assertEquals(ft1, ft1).     // symmetric     assertEquals(ft1, ft2).     assertEquals(ft2, ft1).     assertEquals(ft1.hashCode(), ft2.hashCode()).     for (Modifier modifier : modifiers) {         ft1 = createNamedDefaultFieldType().         ft2 = createNamedDefaultFieldType().         modifier.modify(ft2).         assertFieldTypeNotEquals(modifier.property, ft1, ft2).         assertNotEquals("hash code for modified property " + modifier.property, ft1.hashCode(), ft2.hashCode()).         // modify the same property and they are equal again         modifier.modify(ft1).         assertFieldTypeEquals(modifier.property, ft1, ft2).         assertEquals("hash code for modified property " + modifier.property, ft1.hashCode(), ft2.hashCode()).     } }
false;public;0;12;;public void testFreeze() {     for (Modifier modifier : modifiers) {         MappedFieldType fieldType = createNamedDefaultFieldType().         fieldType.freeze().         try {             modifier.modify(fieldType).             fail("expected already frozen exception for property " + modifier.property).         } catch (IllegalStateException e) {             assertTrue(e.getMessage().contains("already frozen")).         }     } }
false;public;0;2;;@Override public MappedFieldType clone() {     return null. }
false;public;0;2;;@Override public String typeName() {     return fieldType.typeName(). }
false;public;1;2;;@Override public Query existsQuery(QueryShardContext context) {     return null. }
false;public;0;2;;@Override public MappedFieldType clone() {     return null. }
false;public;0;2;;@Override public String typeName() {     return "othertype". }
false;public;1;2;;@Override public Query existsQuery(QueryShardContext context) {     return null. }
false;public;0;38;;public void testCheckTypeName() {     final MappedFieldType fieldType = createNamedDefaultFieldType().     List<String> conflicts = new ArrayList<>().     // no exception     fieldType.checkCompatibility(fieldType, conflicts).     assertTrue(conflicts.toString(), conflicts.isEmpty()).     MappedFieldType bogus = new TermBasedFieldType() {          @Override         public MappedFieldType clone() {             return null.         }          @Override         public String typeName() {             return fieldType.typeName().         }          @Override         public Query existsQuery(QueryShardContext context) {             return null.         }     }.     try {         fieldType.checkCompatibility(bogus, conflicts).         fail("expected bad types exception").     } catch (IllegalStateException e) {         assertTrue(e.getMessage().contains("Type names equal")).     }     assertTrue(conflicts.toString(), conflicts.isEmpty()).     MappedFieldType other = new TermBasedFieldType() {          @Override         public MappedFieldType clone() {             return null.         }          @Override         public String typeName() {             return "othertype".         }          @Override         public Query existsQuery(QueryShardContext context) {             return null.         }     }.     try {         fieldType.checkCompatibility(other, conflicts).         fail().     } catch (IllegalArgumentException e) {         assertTrue(e.getMessage(), e.getMessage().contains("cannot be changed from type")).     }     assertTrue(conflicts.toString(), conflicts.isEmpty()). }
false;public;0;22;;public void testCheckCompatibility() {     MappedFieldType ft1 = createNamedDefaultFieldType().     MappedFieldType ft2 = createNamedDefaultFieldType().     assertCompatible("default", ft1, ft2).     assertCompatible("default", ft2, ft1).     for (Modifier modifier : modifiers) {         ft1 = createNamedDefaultFieldType().         ft2 = createNamedDefaultFieldType().         modifier.normalizeOther(ft1).         modifier.modify(ft2).         if (modifier.updateable) {             assertCompatible(modifier.property, ft1, ft2).             // always symmetric when not strict             assertCompatible(modifier.property, ft2, ft1).         } else {             // not compatible whether strict or not             String conflict = "different [" + modifier.property + "]".             assertNotCompatible(modifier.property, ft1, ft2, conflict).             assertNotCompatible(modifier.property, ft2, ft1, conflict).         }     } }
