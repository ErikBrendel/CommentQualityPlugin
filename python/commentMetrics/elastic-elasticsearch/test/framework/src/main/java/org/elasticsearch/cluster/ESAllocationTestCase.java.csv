commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static MockAllocationService createAllocationService() {     return createAllocationService(Settings.Builder.EMPTY_SETTINGS). }
false;public,static;1;3;;public static MockAllocationService createAllocationService(Settings settings) {     return createAllocationService(settings, random()). }
false;public,static;2;3;;public static MockAllocationService createAllocationService(Settings settings, Random random) {     return createAllocationService(settings, EMPTY_CLUSTER_SETTINGS, random). }
false;public,static;3;5;;public static MockAllocationService createAllocationService(Settings settings, ClusterSettings clusterSettings, Random random) {     return new MockAllocationService(randomAllocationDeciders(settings, clusterSettings, random), new TestGatewayAllocator(), new BalancedShardsAllocator(settings), EmptyClusterInfoService.INSTANCE). }
false;public,static;2;5;;public static MockAllocationService createAllocationService(Settings settings, ClusterInfoService clusterInfoService) {     return new MockAllocationService(randomAllocationDeciders(settings, EMPTY_CLUSTER_SETTINGS, random()), new TestGatewayAllocator(), new BalancedShardsAllocator(settings), clusterInfoService). }
false;public,static;2;5;;public static MockAllocationService createAllocationService(Settings settings, GatewayAllocator gatewayAllocator) {     return new MockAllocationService(randomAllocationDeciders(settings, EMPTY_CLUSTER_SETTINGS, random()), gatewayAllocator, new BalancedShardsAllocator(settings), EmptyClusterInfoService.INSTANCE). }
false;public,static;3;6;;public static AllocationDeciders randomAllocationDeciders(Settings settings, ClusterSettings clusterSettings, Random random) {     List<AllocationDecider> deciders = new ArrayList<>(ClusterModule.createAllocationDeciders(settings, clusterSettings, Collections.emptyList())).     Collections.shuffle(deciders, random).     return new AllocationDeciders(deciders). }
false;protected,static;1;3;;protected static DiscoveryNode newNode(String nodeId) {     return newNode(nodeId, Version.CURRENT). }
false;protected,static;3;3;;protected static DiscoveryNode newNode(String nodeName, String nodeId, Map<String, String> attributes) {     return new DiscoveryNode(nodeName, nodeId, buildNewFakeTransportAddress(), attributes, MASTER_DATA_ROLES, Version.CURRENT). }
false;protected,static;2;3;;protected static DiscoveryNode newNode(String nodeId, Map<String, String> attributes) {     return new DiscoveryNode(nodeId, buildNewFakeTransportAddress(), attributes, MASTER_DATA_ROLES, Version.CURRENT). }
false;protected,static;2;3;;protected static DiscoveryNode newNode(String nodeId, Set<DiscoveryNode.Role> roles) {     return new DiscoveryNode(nodeId, buildNewFakeTransportAddress(), emptyMap(), roles, Version.CURRENT). }
false;protected,static;2;3;;protected static DiscoveryNode newNode(String nodeId, Version version) {     return new DiscoveryNode(nodeId, buildNewFakeTransportAddress(), emptyMap(), MASTER_DATA_ROLES, version). }
false;protected,static;2;8;;protected static ClusterState startRandomInitializingShard(ClusterState clusterState, AllocationService strategy) {     List<ShardRouting> initializingShards = clusterState.getRoutingNodes().shardsWithState(INITIALIZING).     if (initializingShards.isEmpty()) {         return clusterState.     }     return strategy.applyStartedShards(clusterState, arrayAsArrayList(initializingShards.get(randomInt(initializingShards.size() - 1)))). }
false;protected,static;0;6;;protected static AllocationDeciders yesAllocationDeciders() {     return new AllocationDeciders(Arrays.asList(new TestAllocateDecision(Decision.YES), new SameShardAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)))). }
false;protected,static;0;3;;protected static AllocationDeciders noAllocationDeciders() {     return new AllocationDeciders(Collections.singleton(new TestAllocateDecision(Decision.NO))). }
false;protected,static;0;6;;protected static AllocationDeciders throttleAllocationDeciders() {     return new AllocationDeciders(Arrays.asList(new TestAllocateDecision(Decision.THROTTLE), new SameShardAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)))). }
false;protected;2;9;;protected ClusterState applyStartedShardsUntilNoChange(ClusterState clusterState, AllocationService service) {     ClusterState lastClusterState.     do {         lastClusterState = clusterState.         logger.debug("ClusterState: {}", clusterState.getRoutingNodes()).         clusterState = service.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).     } while (lastClusterState.equals(clusterState) == false).     return clusterState. }
false;public;3;4;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return decision. }
false;public;2;4;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {     return decision. }
false;public;2;4;;@Override public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {     return decision. }
false;public;1;3;;public void setNanoTimeOverride(long nanoTime) {     this.nanoTimeOverride = nanoTime. }
false;protected;0;4;;@Override protected long currentNanoTime() {     return nanoTimeOverride == -1L ? super.currentNanoTime() : nanoTimeOverride. }
false;public;2;4;;@Override public void applyStartedShards(RoutingAllocation allocation, List<ShardRouting> startedShards) { // no-op }
false;public;2;4;;@Override public void applyFailedShards(RoutingAllocation allocation, List<FailedShard> failedShards) { // no-op }
false;public;1;13;;@Override public void allocateUnassigned(RoutingAllocation allocation) {     final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator().     while (unassignedIterator.hasNext()) {         ShardRouting shard = unassignedIterator.next().         if (shard.primary() || shard.unassignedInfo().getReason() == UnassignedInfo.Reason.INDEX_CREATED) {             continue.         }         if (shard.unassignedInfo().isDelayed()) {             unassignedIterator.removeAndIgnore(UnassignedInfo.AllocationStatus.DELAYED_ALLOCATION, allocation.changes()).         }     } }
