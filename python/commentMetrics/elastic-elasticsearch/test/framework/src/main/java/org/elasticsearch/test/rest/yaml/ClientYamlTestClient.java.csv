commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Version getEsVersion() {     return esVersion. }
false;public;0;3;;public Version getMasterVersion() {     return masterVersion. }
true;public;5;101;/**  * Calls an api with the provided parameters and body  */ ;/**  * Calls an api with the provided parameters and body  */ public ClientYamlTestResponse callApi(String apiName, Map<String, String> params, HttpEntity entity, Map<String, String> headers, NodeSelector nodeSelector) throws IOException {     ClientYamlSuiteRestApi restApi = restApi(apiName).     // divide params between ones that go within query string and ones that go within path     Map<String, String> pathParts = new HashMap<>().     Map<String, String> queryStringParams = new HashMap<>().     Set<String> apiRequiredPathParts = restApi.getPathParts().entrySet().stream().filter(Entry::getValue).map(Entry::getKey).collect(Collectors.toSet()).     Set<String> apiRequiredParameters = restApi.getParams().entrySet().stream().filter(Entry::getValue).map(Entry::getKey).collect(Collectors.toSet()).     for (Map.Entry<String, String> entry : params.entrySet()) {         if (restApi.getPathParts().containsKey(entry.getKey())) {             pathParts.put(entry.getKey(), entry.getValue()).             apiRequiredPathParts.remove(entry.getKey()).         } else if (restApi.getParams().containsKey(entry.getKey()) || restSpec.isGlobalParameter(entry.getKey()) || restSpec.isClientParameter(entry.getKey())) {             queryStringParams.put(entry.getKey(), entry.getValue()).             apiRequiredParameters.remove(entry.getKey()).         } else {             throw new IllegalArgumentException("path/param [" + entry.getKey() + "] not supported by [" + restApi.getName() + "] " + "api").         }     }     if (false == apiRequiredPathParts.isEmpty()) {         throw new IllegalArgumentException("missing required path part: " + apiRequiredPathParts + " by [" + restApi.getName() + "] api").     }     if (false == apiRequiredParameters.isEmpty()) {         throw new IllegalArgumentException("missing required parameter: " + apiRequiredParameters + " by [" + restApi.getName() + "] api").     }     List<String> supportedMethods = restApi.getSupportedMethods(pathParts.keySet()).     String requestMethod.     if (entity != null) {         if (false == restApi.isBodySupported()) {             throw new IllegalArgumentException("body is not supported by [" + restApi.getName() + "] api").         }         String contentType = entity.getContentType().getValue().         // randomly test the GET with source param instead of GET/POST with body         if (sendBodyAsSourceParam(supportedMethods, contentType, entity.getContentLength())) {             logger.debug("sending the request body as source param with GET method").             queryStringParams.put("source", EntityUtils.toString(entity)).             queryStringParams.put("source_content_type", contentType).             requestMethod = HttpGet.METHOD_NAME.             entity = null.         } else {             requestMethod = RandomizedTest.randomFrom(supportedMethods).         }     } else {         if (restApi.isBodyRequired()) {             throw new IllegalArgumentException("body is required by [" + restApi.getName() + "] api").         }         requestMethod = RandomizedTest.randomFrom(supportedMethods).     }     // the rest path to use is randomized out of the matching ones (if more than one)     ClientYamlSuiteRestPath restPath = RandomizedTest.randomFrom(restApi.getFinalPaths(pathParts)).     // Encode rules for path and query string parameters are different. We use URI to encode the path.     // We need to encode each path part separately, as each one might contain slashes that need to be escaped, which needs to     // be done manually.     String requestPath.     if (restPath.getPathParts().length == 0) {         requestPath = "/".     } else {         StringBuilder finalPath = new StringBuilder().         for (String pathPart : restPath.getPathParts()) {             try {                 finalPath.append('/').                 // We prepend "/" to the path part to handle parts that start with - or other invalid characters                 URI uri = new URI(null, null, null, -1, "/" + pathPart, null, null).                 // manually escape any slash that each part may contain                 finalPath.append(uri.getRawPath().substring(1).replaceAll("/", "%2F")).             } catch (URISyntaxException e) {                 throw new RuntimeException("unable to build uri", e).             }         }         requestPath = finalPath.toString().     }     logger.debug("calling api [{}]", apiName).     Request request = new Request(requestMethod, requestPath).     for (Map.Entry<String, String> param : queryStringParams.entrySet()) {         request.addParameter(param.getKey(), param.getValue()).     }     request.setEntity(entity).     setOptions(request, headers).     try {         Response response = getRestClient(nodeSelector).performRequest(request).         return new ClientYamlTestResponse(response).     } catch (ResponseException e) {         throw new ClientYamlTestResponseException(e).     } }
false;protected;1;13;;protected RestClient getRestClient(NodeSelector nodeSelector) {     // lazily build a new client in case we need to point to some specific node     return restClients.computeIfAbsent(nodeSelector, selector -> {         RestClientBuilder builder.         try {             builder = clientBuilderWithSniffedNodes.get().         } catch (IOException e) {             throw new UncheckedIOException(e).         }         builder.setNodeSelector(selector).         return builder.build().     }). }
false;protected,static;2;10;;protected static void setOptions(Request request, Map<String, String> headers) {     RequestOptions.Builder options = request.getOptions().toBuilder().     for (Map.Entry<String, String> header : headers.entrySet()) {         logger.debug("Adding header {} with value {}", header.getKey(), header.getValue()).         options.addHeader(header.getKey(), header.getValue()).     }     // We check the warnings ourselves so we don't need the client to do it for us     options.setWarningsHandler(WarningsHandler.PERMISSIVE).     request.setOptions(options). }
false;private,static;3;20;;private static boolean sendBodyAsSourceParam(List<String> supportedMethods, String contentType, long contentLength) {     if (false == supportedMethods.contains(HttpGet.METHOD_NAME)) {         // The API doesn't claim to support GET anyway         return false.     }     if (contentLength < 0) {         // Negative length means "unknown" or "huge" in this case. Either way we can't send it as a parameter         return false.     }     if (contentLength > 2000) {         // Long bodies won't fit in the parameter and will cause a too_long_frame_exception         return false.     }     if (false == contentType.startsWith(ContentType.APPLICATION_JSON.getMimeType()) && false == contentType.startsWith(YAML_CONTENT_TYPE.getMimeType())) {         // We can only encode JSON or YAML this way.         return false.     }     return RandomizedTest.rarely(). }
false;private;1;7;;private ClientYamlSuiteRestApi restApi(String apiName) {     ClientYamlSuiteRestApi restApi = restSpec.getApi(apiName).     if (restApi == null) {         throw new IllegalArgumentException("rest api [" + apiName + "] doesn't exist in the rest spec").     }     return restApi. }
false;public;0;6;;@Override public void close() throws IOException {     for (RestClient restClient : restClients.values()) {         restClient.close().     } }
