# id;timestamp;commentText;codeText;commentWords;codeWords
VersionUtils -> public static Version getFirstVersion();1524684173;Returns the oldest released {@link Version};public static Version getFirstVersion() {_        return RELEASED_VERSIONS.get(0)__    };returns,the,oldest,released,link,version;public,static,version,get,first,version,return,get,0
VersionUtils -> public static Version getFirstVersion();1525334055;Returns the oldest released {@link Version};public static Version getFirstVersion() {_        return RELEASED_VERSIONS.get(0)__    };returns,the,oldest,released,link,version;public,static,version,get,first,version,return,get,0
VersionUtils -> public static Version getFirstVersion();1528103657;Returns the oldest released {@link Version};public static Version getFirstVersion() {_        return RELEASED_VERSIONS.get(0)__    };returns,the,oldest,released,link,version;public,static,version,get,first,version,return,get,0
VersionUtils -> public static Version getFirstVersion();1549608646;Returns the oldest released {@link Version};public static Version getFirstVersion() {_        return RELEASED_VERSIONS.get(0)__    };returns,the,oldest,released,link,version;public,static,version,get,first,version,return,get,0
VersionUtils -> public static Version maxCompatibleVersion(Version version);1524684173;Returns the maximum {@link Version} that is compatible with the given version.;public static Version maxCompatibleVersion(Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).filter(version::onOrBefore)_            .collect(Collectors.toList())__        assert compatible.size() > 0__        return compatible.get(compatible.size() - 1)__    };returns,the,maximum,link,version,that,is,compatible,with,the,given,version;public,static,version,max,compatible,version,version,version,final,list,version,compatible,stream,filter,version,is,compatible,filter,version,on,or,before,collect,collectors,to,list,assert,compatible,size,0,return,compatible,get,compatible,size,1
VersionUtils -> public static Version maxCompatibleVersion(Version version);1525334055;Returns the maximum {@link Version} that is compatible with the given version.;public static Version maxCompatibleVersion(Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).filter(version::onOrBefore)_            .collect(Collectors.toList())__        assert compatible.size() > 0__        return compatible.get(compatible.size() - 1)__    };returns,the,maximum,link,version,that,is,compatible,with,the,given,version;public,static,version,max,compatible,version,version,version,final,list,version,compatible,stream,filter,version,is,compatible,filter,version,on,or,before,collect,collectors,to,list,assert,compatible,size,0,return,compatible,get,compatible,size,1
VersionUtils -> public static Version maxCompatibleVersion(Version version);1528103657;Returns the maximum {@link Version} that is compatible with the given version.;public static Version maxCompatibleVersion(Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).filter(version::onOrBefore)_            .collect(Collectors.toList())__        assert compatible.size() > 0__        return compatible.get(compatible.size() - 1)__    };returns,the,maximum,link,version,that,is,compatible,with,the,given,version;public,static,version,max,compatible,version,version,version,final,list,version,compatible,stream,filter,version,is,compatible,filter,version,on,or,before,collect,collectors,to,list,assert,compatible,size,0,return,compatible,get,compatible,size,1
VersionUtils -> public static Version maxCompatibleVersion(Version version);1549608646;Returns the maximum {@link Version} that is compatible with the given version.;public static Version maxCompatibleVersion(Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).filter(version::onOrBefore)_            .collect(Collectors.toList())__        assert compatible.size() > 0__        return compatible.get(compatible.size() - 1)__    };returns,the,maximum,link,version,that,is,compatible,with,the,given,version;public,static,version,max,compatible,version,version,version,final,list,version,compatible,stream,filter,version,is,compatible,filter,version,on,or,before,collect,collectors,to,list,assert,compatible,size,0,return,compatible,get,compatible,size,1
VersionUtils -> public static Version incompatibleFutureVersion(Version version);1524684173;returns the first future incompatible version;public static Version incompatibleFutureVersion(Version version) {_        final Optional<Version> opt = ALL_VERSIONS.stream().filter(version::before).filter(v -> v.isCompatible(version) == false).findAny()__        assert opt.isPresent() : "no future incompatible version for " + version__        return opt.get()__    };returns,the,first,future,incompatible,version;public,static,version,incompatible,future,version,version,version,final,optional,version,opt,stream,filter,version,before,filter,v,v,is,compatible,version,false,find,any,assert,opt,is,present,no,future,incompatible,version,for,version,return,opt,get
VersionUtils -> public static Version incompatibleFutureVersion(Version version);1525334055;returns the first future incompatible version;public static Version incompatibleFutureVersion(Version version) {_        final Optional<Version> opt = ALL_VERSIONS.stream().filter(version::before).filter(v -> v.isCompatible(version) == false).findAny()__        assert opt.isPresent() : "no future incompatible version for " + version__        return opt.get()__    };returns,the,first,future,incompatible,version;public,static,version,incompatible,future,version,version,version,final,optional,version,opt,stream,filter,version,before,filter,v,v,is,compatible,version,false,find,any,assert,opt,is,present,no,future,incompatible,version,for,version,return,opt,get
VersionUtils -> public static Version incompatibleFutureVersion(Version version);1528103657;returns the first future incompatible version;public static Version incompatibleFutureVersion(Version version) {_        final Optional<Version> opt = ALL_VERSIONS.stream().filter(version::before).filter(v -> v.isCompatible(version) == false).findAny()__        assert opt.isPresent() : "no future incompatible version for " + version__        return opt.get()__    };returns,the,first,future,incompatible,version;public,static,version,incompatible,future,version,version,version,final,optional,version,opt,stream,filter,version,before,filter,v,v,is,compatible,version,false,find,any,assert,opt,is,present,no,future,incompatible,version,for,version,return,opt,get
VersionUtils -> public static Version incompatibleFutureVersion(Version version);1549608646;returns the first future incompatible version;public static Version incompatibleFutureVersion(Version version) {_        final Optional<Version> opt = ALL_VERSIONS.stream().filter(version::before).filter(v -> v.isCompatible(version) == false).findAny()__        assert opt.isPresent() : "no future incompatible version for " + version__        return opt.get()__    };returns,the,first,future,incompatible,version;public,static,version,incompatible,future,version,version,version,final,optional,version,opt,stream,filter,version,before,filter,v,v,is,compatible,version,false,find,any,assert,opt,is,present,no,future,incompatible,version,for,version,return,opt,get
VersionUtils -> static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass);1524684173;Sort versions that have backwards compatibility guarantees from_those that don't. Doesn't actually check whether or not the versions_are released, instead it relies on gradle to have already checked_this which it does in {@code :core:verifyVersions}. So long as the_rules here match up with the rules in gradle then this should_produce sensible results._@return a tuple containing versions with backwards compatibility_guarantees in v1 and versions without the guranteees in v2;static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass) {_        List<Version> versions = Version.getDeclaredVersions(versionClass)___        Version last = versions.remove(versions.size() - 1)__        assert last.equals(current) : "The highest version must be the current one "_            + "but was [" + last + "] and current was [" + current + "]"___        if (current.revision != 0) {_            _            return new Tuple<>(unmodifiableList(versions), singletonList(current))__        }__        _        int unreleasedIndex = versions.size() - 1__        while (true) {_            if (unreleasedIndex < 0) {_                throw new IllegalArgumentException("Couldn't find first non-alpha release")__            }_            _            if (versions.get(unreleasedIndex).isRelease()) {_                break__            }_            unreleasedIndex--__        }__        Version unreleased = versions.remove(unreleasedIndex)__        if (unreleased.revision == 0) {_            _            do {_                unreleasedIndex--__            } while (versions.get(unreleasedIndex).isRelease() == false)__            Version earlierUnreleased = versions.remove(unreleasedIndex)___            _            _            if (earlierUnreleased.revision == 0) {_                unreleasedIndex--__                Version actualUnreleasedPreviousMinor = versions.remove(unreleasedIndex)__                return new Tuple<>(unmodifiableList(versions), unmodifiableList(Arrays.asList(actualUnreleasedPreviousMinor,_                    earlierUnreleased, unreleased, current)))__            }__            return new Tuple<>(unmodifiableList(versions), unmodifiableList(Arrays.asList(earlierUnreleased, unreleased, current)))__        } else if (unreleased.major == current.major) {_            _            do {_                unreleasedIndex--__            } while (unreleasedIndex > 0 && versions.get(unreleasedIndex).major == current.major)__            if (unreleasedIndex > 0) {_                _                Version earlierMajorsMinor = versions.remove(unreleasedIndex)__                return new Tuple<>(unmodifiableList(versions), unmodifiableList(Arrays.asList(earlierMajorsMinor, unreleased, current)))__            }_        }_        return new Tuple<>(unmodifiableList(versions), unmodifiableList(Arrays.asList(unreleased, current)))__    };sort,versions,that,have,backwards,compatibility,guarantees,from,those,that,don,t,doesn,t,actually,check,whether,or,not,the,versions,are,released,instead,it,relies,on,gradle,to,have,already,checked,this,which,it,does,in,code,core,verify,versions,so,long,as,the,rules,here,match,up,with,the,rules,in,gradle,then,this,should,produce,sensible,results,return,a,tuple,containing,versions,with,backwards,compatibility,guarantees,in,v1,and,versions,without,the,guranteees,in,v2;static,tuple,list,version,list,version,resolve,released,versions,version,current,class,version,class,list,version,versions,version,get,declared,versions,version,class,version,last,versions,remove,versions,size,1,assert,last,equals,current,the,highest,version,must,be,the,current,one,but,was,last,and,current,was,current,if,current,revision,0,return,new,tuple,unmodifiable,list,versions,singleton,list,current,int,unreleased,index,versions,size,1,while,true,if,unreleased,index,0,throw,new,illegal,argument,exception,couldn,t,find,first,non,alpha,release,if,versions,get,unreleased,index,is,release,break,unreleased,index,version,unreleased,versions,remove,unreleased,index,if,unreleased,revision,0,do,unreleased,index,while,versions,get,unreleased,index,is,release,false,version,earlier,unreleased,versions,remove,unreleased,index,if,earlier,unreleased,revision,0,unreleased,index,version,actual,unreleased,previous,minor,versions,remove,unreleased,index,return,new,tuple,unmodifiable,list,versions,unmodifiable,list,arrays,as,list,actual,unreleased,previous,minor,earlier,unreleased,unreleased,current,return,new,tuple,unmodifiable,list,versions,unmodifiable,list,arrays,as,list,earlier,unreleased,unreleased,current,else,if,unreleased,major,current,major,do,unreleased,index,while,unreleased,index,0,versions,get,unreleased,index,major,current,major,if,unreleased,index,0,version,earlier,majors,minor,versions,remove,unreleased,index,return,new,tuple,unmodifiable,list,versions,unmodifiable,list,arrays,as,list,earlier,majors,minor,unreleased,current,return,new,tuple,unmodifiable,list,versions,unmodifiable,list,arrays,as,list,unreleased,current
VersionUtils -> static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass);1525334055;Sort versions that have backwards compatibility guarantees from_those that don't. Doesn't actually check whether or not the versions_are released, instead it relies on gradle to have already checked_this which it does in {@code :core:verifyVersions}. So long as the_rules here match up with the rules in gradle then this should_produce sensible results._@return a tuple containing versions with backwards compatibility_guarantees in v1 and versions without the guranteees in v2;static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass) {_        _        Map<Integer, List<Version>> majorVersions = Version.getDeclaredVersions(versionClass).stream()_            .collect(Collectors.groupingBy(v -> (int)v.major))__        _        _        _        List<Version> oldVersions = majorVersions.getOrDefault((int)current.major - 2, Collections.emptyList())__        List<List<Version>> previousMajor = splitByMinor(majorVersions.get((int)current.major - 1))__        List<List<Version>> currentMajor = splitByMinor(majorVersions.get((int)current.major))___        List<Version> unreleasedVersions = new ArrayList<>()__        final List<List<Version>> stableVersions__        if (currentMajor.size() == 1) {_            _            stableVersions = previousMajor__            _            moveLastToUnreleased(currentMajor, unreleasedVersions)__        } else {_            _            stableVersions = currentMajor__            _            moveLastToUnreleased(previousMajor, unreleasedVersions)__        }__        _        Version lastMinor = moveLastToUnreleased(stableVersions, unreleasedVersions)__        if (lastMinor.revision == 0) {_            if (stableVersions.get(stableVersions.size() - 1).size() == 1) {_                _                moveLastToUnreleased(stableVersions, unreleasedVersions)__            }_            _            moveLastToUnreleased(stableVersions, unreleasedVersions)__        }__        List<Version> releasedVersions = Stream.concat(oldVersions.stream(),_            Stream.concat(previousMajor.stream(), currentMajor.stream()).flatMap(List::stream))_            .collect(Collectors.toList())__        Collections.sort(unreleasedVersions)_ _        return new Tuple<>(Collections.unmodifiableList(releasedVersions), Collections.unmodifiableList(unreleasedVersions))__    };sort,versions,that,have,backwards,compatibility,guarantees,from,those,that,don,t,doesn,t,actually,check,whether,or,not,the,versions,are,released,instead,it,relies,on,gradle,to,have,already,checked,this,which,it,does,in,code,core,verify,versions,so,long,as,the,rules,here,match,up,with,the,rules,in,gradle,then,this,should,produce,sensible,results,return,a,tuple,containing,versions,with,backwards,compatibility,guarantees,in,v1,and,versions,without,the,guranteees,in,v2;static,tuple,list,version,list,version,resolve,released,versions,version,current,class,version,class,map,integer,list,version,major,versions,version,get,declared,versions,version,class,stream,collect,collectors,grouping,by,v,int,v,major,list,version,old,versions,major,versions,get,or,default,int,current,major,2,collections,empty,list,list,list,version,previous,major,split,by,minor,major,versions,get,int,current,major,1,list,list,version,current,major,split,by,minor,major,versions,get,int,current,major,list,version,unreleased,versions,new,array,list,final,list,list,version,stable,versions,if,current,major,size,1,stable,versions,previous,major,move,last,to,unreleased,current,major,unreleased,versions,else,stable,versions,current,major,move,last,to,unreleased,previous,major,unreleased,versions,version,last,minor,move,last,to,unreleased,stable,versions,unreleased,versions,if,last,minor,revision,0,if,stable,versions,get,stable,versions,size,1,size,1,move,last,to,unreleased,stable,versions,unreleased,versions,move,last,to,unreleased,stable,versions,unreleased,versions,list,version,released,versions,stream,concat,old,versions,stream,stream,concat,previous,major,stream,current,major,stream,flat,map,list,stream,collect,collectors,to,list,collections,sort,unreleased,versions,return,new,tuple,collections,unmodifiable,list,released,versions,collections,unmodifiable,list,unreleased,versions
VersionUtils -> static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass);1528103657;Sort versions that have backwards compatibility guarantees from_those that don't. Doesn't actually check whether or not the versions_are released, instead it relies on gradle to have already checked_this which it does in {@code :core:verifyVersions}. So long as the_rules here match up with the rules in gradle then this should_produce sensible results._@return a tuple containing versions with backwards compatibility_guarantees in v1 and versions without the guranteees in v2;static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass) {_        _        Map<Integer, List<Version>> majorVersions = Version.getDeclaredVersions(versionClass).stream()_            .collect(Collectors.groupingBy(v -> (int)v.major))__        _        _        _        List<Version> oldVersions = majorVersions.getOrDefault((int)current.major - 2, Collections.emptyList())__        List<List<Version>> previousMajor = splitByMinor(majorVersions.get((int)current.major - 1))__        List<List<Version>> currentMajor = splitByMinor(majorVersions.get((int)current.major))___        List<Version> unreleasedVersions = new ArrayList<>()__        final List<List<Version>> stableVersions__        if (currentMajor.size() == 1) {_            _            stableVersions = previousMajor__            _            moveLastToUnreleased(currentMajor, unreleasedVersions)__        } else {_            _            stableVersions = currentMajor__            _            moveLastToUnreleased(previousMajor, unreleasedVersions)__        }__        _        Version lastMinor = moveLastToUnreleased(stableVersions, unreleasedVersions)__        if (lastMinor.revision == 0) {_            if (stableVersions.get(stableVersions.size() - 1).size() == 1) {_                _                moveLastToUnreleased(stableVersions, unreleasedVersions)__            }_            _            moveLastToUnreleased(stableVersions, unreleasedVersions)__        }__        List<Version> releasedVersions = Stream.concat(oldVersions.stream(),_            Stream.concat(previousMajor.stream(), currentMajor.stream()).flatMap(List::stream))_            .collect(Collectors.toList())__        Collections.sort(unreleasedVersions)_ _        return new Tuple<>(Collections.unmodifiableList(releasedVersions), Collections.unmodifiableList(unreleasedVersions))__    };sort,versions,that,have,backwards,compatibility,guarantees,from,those,that,don,t,doesn,t,actually,check,whether,or,not,the,versions,are,released,instead,it,relies,on,gradle,to,have,already,checked,this,which,it,does,in,code,core,verify,versions,so,long,as,the,rules,here,match,up,with,the,rules,in,gradle,then,this,should,produce,sensible,results,return,a,tuple,containing,versions,with,backwards,compatibility,guarantees,in,v1,and,versions,without,the,guranteees,in,v2;static,tuple,list,version,list,version,resolve,released,versions,version,current,class,version,class,map,integer,list,version,major,versions,version,get,declared,versions,version,class,stream,collect,collectors,grouping,by,v,int,v,major,list,version,old,versions,major,versions,get,or,default,int,current,major,2,collections,empty,list,list,list,version,previous,major,split,by,minor,major,versions,get,int,current,major,1,list,list,version,current,major,split,by,minor,major,versions,get,int,current,major,list,version,unreleased,versions,new,array,list,final,list,list,version,stable,versions,if,current,major,size,1,stable,versions,previous,major,move,last,to,unreleased,current,major,unreleased,versions,else,stable,versions,current,major,move,last,to,unreleased,previous,major,unreleased,versions,version,last,minor,move,last,to,unreleased,stable,versions,unreleased,versions,if,last,minor,revision,0,if,stable,versions,get,stable,versions,size,1,size,1,move,last,to,unreleased,stable,versions,unreleased,versions,move,last,to,unreleased,stable,versions,unreleased,versions,list,version,released,versions,stream,concat,old,versions,stream,stream,concat,previous,major,stream,current,major,stream,flat,map,list,stream,collect,collectors,to,list,collections,sort,unreleased,versions,return,new,tuple,collections,unmodifiable,list,released,versions,collections,unmodifiable,list,unreleased,versions
VersionUtils -> static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass);1549608646;Sort versions that have backwards compatibility guarantees from_those that don't. Doesn't actually check whether or not the versions_are released, instead it relies on gradle to have already checked_this which it does in {@code :core:verifyVersions}. So long as the_rules here match up with the rules in gradle then this should_produce sensible results._@return a tuple containing versions with backwards compatibility_guarantees in v1 and versions without the guranteees in v2;static Tuple<List<Version>, List<Version>> resolveReleasedVersions(Version current, Class<?> versionClass) {_        _        Map<Integer, List<Version>> majorVersions = Version.getDeclaredVersions(versionClass).stream()_            .collect(Collectors.groupingBy(v -> (int)v.major))__        _        _        _        List<List<Version>> oldVersions = splitByMinor(majorVersions.getOrDefault((int)current.major - 2, Collections.emptyList()))__        List<List<Version>> previousMajor = splitByMinor(majorVersions.get((int)current.major - 1))__        List<List<Version>> currentMajor = splitByMinor(majorVersions.get((int)current.major))___        List<Version> unreleasedVersions = new ArrayList<>()__        final List<List<Version>> stableVersions__        if (currentMajor.size() == 1) {_            _            stableVersions = previousMajor__            _            moveLastToUnreleased(currentMajor, unreleasedVersions)__        } else {_            _            stableVersions = currentMajor__            _            moveLastToUnreleased(previousMajor, unreleasedVersions)__        }__        _        Version lastMinor = moveLastToUnreleased(stableVersions, unreleasedVersions)__        if (lastMinor.revision == 0) {_            if (stableVersions.get(stableVersions.size() - 1).size() == 1) {_                _                moveLastToUnreleased(stableVersions, unreleasedVersions)__            }_            _            if (stableVersions.isEmpty() == false) {_                moveLastToUnreleased(stableVersions, unreleasedVersions)__            }_        }__        _        if (previousMajor.isEmpty()) {_            assert currentMajor.isEmpty() : currentMajor__            _            moveLastToUnreleased(oldVersions, unreleasedVersions)__            _            moveLastToUnreleased(oldVersions, unreleasedVersions)__        }_        List<Version> releasedVersions = Stream.of(oldVersions, previousMajor, currentMajor)_            .flatMap(List::stream).flatMap(List::stream).collect(Collectors.toList())__        Collections.sort(unreleasedVersions)_ _        return new Tuple<>(Collections.unmodifiableList(releasedVersions), Collections.unmodifiableList(unreleasedVersions))__    };sort,versions,that,have,backwards,compatibility,guarantees,from,those,that,don,t,doesn,t,actually,check,whether,or,not,the,versions,are,released,instead,it,relies,on,gradle,to,have,already,checked,this,which,it,does,in,code,core,verify,versions,so,long,as,the,rules,here,match,up,with,the,rules,in,gradle,then,this,should,produce,sensible,results,return,a,tuple,containing,versions,with,backwards,compatibility,guarantees,in,v1,and,versions,without,the,guranteees,in,v2;static,tuple,list,version,list,version,resolve,released,versions,version,current,class,version,class,map,integer,list,version,major,versions,version,get,declared,versions,version,class,stream,collect,collectors,grouping,by,v,int,v,major,list,list,version,old,versions,split,by,minor,major,versions,get,or,default,int,current,major,2,collections,empty,list,list,list,version,previous,major,split,by,minor,major,versions,get,int,current,major,1,list,list,version,current,major,split,by,minor,major,versions,get,int,current,major,list,version,unreleased,versions,new,array,list,final,list,list,version,stable,versions,if,current,major,size,1,stable,versions,previous,major,move,last,to,unreleased,current,major,unreleased,versions,else,stable,versions,current,major,move,last,to,unreleased,previous,major,unreleased,versions,version,last,minor,move,last,to,unreleased,stable,versions,unreleased,versions,if,last,minor,revision,0,if,stable,versions,get,stable,versions,size,1,size,1,move,last,to,unreleased,stable,versions,unreleased,versions,if,stable,versions,is,empty,false,move,last,to,unreleased,stable,versions,unreleased,versions,if,previous,major,is,empty,assert,current,major,is,empty,current,major,move,last,to,unreleased,old,versions,unreleased,versions,move,last,to,unreleased,old,versions,unreleased,versions,list,version,released,versions,stream,of,old,versions,previous,major,current,major,flat,map,list,stream,flat,map,list,stream,collect,collectors,to,list,collections,sort,unreleased,versions,return,new,tuple,collections,unmodifiable,list,released,versions,collections,unmodifiable,list,unreleased,versions
VersionUtils -> public static Version randomVersion(Random random);1524684173;Returns a random {@link Version} from all available versions.;public static Version randomVersion(Random random) {_        return ALL_VERSIONS.get(random.nextInt(ALL_VERSIONS.size()))__    };returns,a,random,link,version,from,all,available,versions;public,static,version,random,version,random,random,return,get,random,next,int,size
VersionUtils -> public static Version randomVersion(Random random);1525334055;Returns a random {@link Version} from all available versions.;public static Version randomVersion(Random random) {_        return ALL_VERSIONS.get(random.nextInt(ALL_VERSIONS.size()))__    };returns,a,random,link,version,from,all,available,versions;public,static,version,random,version,random,random,return,get,random,next,int,size
VersionUtils -> public static Version randomVersion(Random random);1528103657;Returns a random {@link Version} from all available versions.;public static Version randomVersion(Random random) {_        return ALL_VERSIONS.get(random.nextInt(ALL_VERSIONS.size()))__    };returns,a,random,link,version,from,all,available,versions;public,static,version,random,version,random,random,return,get,random,next,int,size
VersionUtils -> public static Version randomVersion(Random random);1549608646;Returns a random {@link Version} from all available versions.;public static Version randomVersion(Random random) {_        return ALL_VERSIONS.get(random.nextInt(ALL_VERSIONS.size()))__    };returns,a,random,link,version,from,all,available,versions;public,static,version,random,version,random,random,return,get,random,next,int,size
VersionUtils -> public static Version getPreviousVersion();1524684173;Get the released version before {@link Version#CURRENT}.;public static Version getPreviousVersion() {_        Version version = getPreviousVersion(Version.CURRENT)__        assert version.before(Version.CURRENT)__        return version__    };get,the,released,version,before,link,version,current;public,static,version,get,previous,version,version,version,get,previous,version,version,current,assert,version,before,version,current,return,version
VersionUtils -> public static Version getPreviousVersion();1525334055;Get the released version before {@link Version#CURRENT}.;public static Version getPreviousVersion() {_        Version version = getPreviousVersion(Version.CURRENT)__        assert version.before(Version.CURRENT)__        return version__    };get,the,released,version,before,link,version,current;public,static,version,get,previous,version,version,version,get,previous,version,version,current,assert,version,before,version,current,return,version
VersionUtils -> public static Version getPreviousVersion();1528103657;Get the released version before {@link Version#CURRENT}.;public static Version getPreviousVersion() {_        Version version = getPreviousVersion(Version.CURRENT)__        assert version.before(Version.CURRENT)__        return version__    };get,the,released,version,before,link,version,current;public,static,version,get,previous,version,version,version,get,previous,version,version,current,assert,version,before,version,current,return,version
VersionUtils -> public static Version getPreviousVersion();1549608646;Get the released version before {@link Version#CURRENT}.;public static Version getPreviousVersion() {_        Version version = getPreviousVersion(Version.CURRENT)__        assert version.before(Version.CURRENT)__        return version__    };get,the,released,version,before,link,version,current;public,static,version,get,previous,version,version,version,get,previous,version,version,current,assert,version,before,version,current,return,version
VersionUtils -> public static List<Version> allUnreleasedVersions();1524684173;Returns an immutable, sorted list containing all unreleased versions.;public static List<Version> allUnreleasedVersions() {_        return UNRELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,unreleased,versions;public,static,list,version,all,unreleased,versions,return
VersionUtils -> public static List<Version> allUnreleasedVersions();1525334055;Returns an immutable, sorted list containing all unreleased versions.;public static List<Version> allUnreleasedVersions() {_        return UNRELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,unreleased,versions;public,static,list,version,all,unreleased,versions,return
VersionUtils -> public static List<Version> allUnreleasedVersions();1528103657;Returns an immutable, sorted list containing all unreleased versions.;public static List<Version> allUnreleasedVersions() {_        return UNRELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,unreleased,versions;public,static,list,version,all,unreleased,versions,return
VersionUtils -> public static List<Version> allUnreleasedVersions();1549608646;Returns an immutable, sorted list containing all unreleased versions.;public static List<Version> allUnreleasedVersions() {_        return UNRELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,unreleased,versions;public,static,list,version,all,unreleased,versions,return
VersionUtils -> public static List<Version> allVersions();1524684173;Returns an immutable, sorted list containing all versions, both released and unreleased.;public static List<Version> allVersions() {_        return ALL_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,versions,both,released,and,unreleased;public,static,list,version,all,versions,return
VersionUtils -> public static List<Version> allVersions();1525334055;Returns an immutable, sorted list containing all versions, both released and unreleased.;public static List<Version> allVersions() {_        return ALL_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,versions,both,released,and,unreleased;public,static,list,version,all,versions,return
VersionUtils -> public static List<Version> allVersions();1528103657;Returns an immutable, sorted list containing all versions, both released and unreleased.;public static List<Version> allVersions() {_        return ALL_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,versions,both,released,and,unreleased;public,static,list,version,all,versions,return
VersionUtils -> public static List<Version> allVersions();1549608646;Returns an immutable, sorted list containing all versions, both released and unreleased.;public static List<Version> allVersions() {_        return ALL_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,versions,both,released,and,unreleased;public,static,list,version,all,versions,return
VersionUtils -> public static List<Version> allReleasedVersions();1524684173;Returns an immutable, sorted list containing all released versions.;public static List<Version> allReleasedVersions() {_        return RELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,released,versions;public,static,list,version,all,released,versions,return
VersionUtils -> public static List<Version> allReleasedVersions();1525334055;Returns an immutable, sorted list containing all released versions.;public static List<Version> allReleasedVersions() {_        return RELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,released,versions;public,static,list,version,all,released,versions,return
VersionUtils -> public static List<Version> allReleasedVersions();1528103657;Returns an immutable, sorted list containing all released versions.;public static List<Version> allReleasedVersions() {_        return RELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,released,versions;public,static,list,version,all,released,versions,return
VersionUtils -> public static List<Version> allReleasedVersions();1549608646;Returns an immutable, sorted list containing all released versions.;public static List<Version> allReleasedVersions() {_        return RELEASED_VERSIONS__    };returns,an,immutable,sorted,list,containing,all,released,versions;public,static,list,version,all,released,versions,return
VersionUtils -> public static Version randomCompatibleVersion(Random random, Version version);1524684173;Returns a random {@link Version} from all available versions, that is compatible with the given version.;public static Version randomCompatibleVersion(Random random, Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).collect(Collectors.toList())__        return compatible.get(random.nextInt(compatible.size()))__    };returns,a,random,link,version,from,all,available,versions,that,is,compatible,with,the,given,version;public,static,version,random,compatible,version,random,random,version,version,final,list,version,compatible,stream,filter,version,is,compatible,collect,collectors,to,list,return,compatible,get,random,next,int,compatible,size
VersionUtils -> public static Version randomCompatibleVersion(Random random, Version version);1525334055;Returns a random {@link Version} from all available versions, that is compatible with the given version.;public static Version randomCompatibleVersion(Random random, Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).collect(Collectors.toList())__        return compatible.get(random.nextInt(compatible.size()))__    };returns,a,random,link,version,from,all,available,versions,that,is,compatible,with,the,given,version;public,static,version,random,compatible,version,random,random,version,version,final,list,version,compatible,stream,filter,version,is,compatible,collect,collectors,to,list,return,compatible,get,random,next,int,compatible,size
VersionUtils -> public static Version randomCompatibleVersion(Random random, Version version);1528103657;Returns a random {@link Version} from all available versions, that is compatible with the given version.;public static Version randomCompatibleVersion(Random random, Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).collect(Collectors.toList())__        return compatible.get(random.nextInt(compatible.size()))__    };returns,a,random,link,version,from,all,available,versions,that,is,compatible,with,the,given,version;public,static,version,random,compatible,version,random,random,version,version,final,list,version,compatible,stream,filter,version,is,compatible,collect,collectors,to,list,return,compatible,get,random,next,int,compatible,size
VersionUtils -> public static Version randomCompatibleVersion(Random random, Version version);1549608646;Returns a random {@link Version} from all available versions, that is compatible with the given version.;public static Version randomCompatibleVersion(Random random, Version version) {_        final List<Version> compatible = ALL_VERSIONS.stream().filter(version::isCompatible).collect(Collectors.toList())__        return compatible.get(random.nextInt(compatible.size()))__    };returns,a,random,link,version,from,all,available,versions,that,is,compatible,with,the,given,version;public,static,version,random,compatible,version,random,random,version,version,final,list,version,compatible,stream,filter,version,is,compatible,collect,collectors,to,list,return,compatible,get,random,next,int,compatible,size
VersionUtils -> public static Version getPreviousMinorVersion();1524684173;Returns the released {@link Version} before the {@link Version#CURRENT}_where the minor version is less than the currents minor version.;public static Version getPreviousMinorVersion() {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.minor < Version.CURRENT.minor || v.major < Version.CURRENT.major) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions of the minor before [" + Version.CURRENT + "]")__    };returns,the,released,link,version,before,the,link,version,current,where,the,minor,version,is,less,than,the,currents,minor,version;public,static,version,get,previous,minor,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,minor,version,current,minor,v,major,version,current,major,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,of,the,minor,before,version,current
VersionUtils -> public static Version getPreviousMinorVersion();1525334055;Returns the released {@link Version} before the {@link Version#CURRENT}_where the minor version is less than the currents minor version.;public static Version getPreviousMinorVersion() {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.minor < Version.CURRENT.minor || v.major < Version.CURRENT.major) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions of the minor before [" + Version.CURRENT + "]")__    };returns,the,released,link,version,before,the,link,version,current,where,the,minor,version,is,less,than,the,currents,minor,version;public,static,version,get,previous,minor,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,minor,version,current,minor,v,major,version,current,major,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,of,the,minor,before,version,current
VersionUtils -> public static Version getPreviousMinorVersion();1528103657;Returns the released {@link Version} before the {@link Version#CURRENT}_where the minor version is less than the currents minor version.;public static Version getPreviousMinorVersion() {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.minor < Version.CURRENT.minor || v.major < Version.CURRENT.major) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions of the minor before [" + Version.CURRENT + "]")__    };returns,the,released,link,version,before,the,link,version,current,where,the,minor,version,is,less,than,the,currents,minor,version;public,static,version,get,previous,minor,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,minor,version,current,minor,v,major,version,current,major,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,of,the,minor,before,version,current
VersionUtils -> public static Version getPreviousMinorVersion();1549608646;Returns the released {@link Version} before the {@link Version#CURRENT}_where the minor version is less than the currents minor version.;public static Version getPreviousMinorVersion() {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.minor < Version.CURRENT.minor || v.major < Version.CURRENT.major) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions of the minor before [" + Version.CURRENT + "]")__    };returns,the,released,link,version,before,the,link,version,current,where,the,minor,version,is,less,than,the,currents,minor,version;public,static,version,get,previous,minor,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,minor,version,current,minor,v,major,version,current,major,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,of,the,minor,before,version,current
VersionUtils -> public static Version getPreviousVersion(Version version);1524684173;Get the released version before {@code version}.;public static Version getPreviousVersion(Version version) {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.before(version)) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions before [" + version + "]")__    };get,the,released,version,before,code,version;public,static,version,get,previous,version,version,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,before,version,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,before,version
VersionUtils -> public static Version getPreviousVersion(Version version);1525334055;Get the released version before {@code version}.;public static Version getPreviousVersion(Version version) {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.before(version)) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions before [" + version + "]")__    };get,the,released,version,before,code,version;public,static,version,get,previous,version,version,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,before,version,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,before,version
VersionUtils -> public static Version getPreviousVersion(Version version);1528103657;Get the released version before {@code version}.;public static Version getPreviousVersion(Version version) {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.before(version)) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions before [" + version + "]")__    };get,the,released,version,before,code,version;public,static,version,get,previous,version,version,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,before,version,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,before,version
VersionUtils -> public static Version getPreviousVersion(Version version);1549608646;Get the released version before {@code version}.;public static Version getPreviousVersion(Version version) {_        for (int i = RELEASED_VERSIONS.size() - 1_ i >= 0_ i--) {_            Version v = RELEASED_VERSIONS.get(i)__            if (v.before(version)) {_                return v__            }_        }_        throw new IllegalArgumentException("couldn't find any released versions before [" + version + "]")__    };get,the,released,version,before,code,version;public,static,version,get,previous,version,version,version,for,int,i,size,1,i,0,i,version,v,get,i,if,v,before,version,return,v,throw,new,illegal,argument,exception,couldn,t,find,any,released,versions,before,version
VersionUtils -> public static Version compatibleFutureVersion(Version version);1528103657;returns the first future compatible version;public static Version compatibleFutureVersion(Version version) {_        final Optional<Version> opt = ALL_VERSIONS.stream().filter(version::before).filter(v -> v.isCompatible(version)).findAny()__        assert opt.isPresent() : "no future compatible version for " + version__        return opt.get()__    };returns,the,first,future,compatible,version;public,static,version,compatible,future,version,version,version,final,optional,version,opt,stream,filter,version,before,filter,v,v,is,compatible,version,find,any,assert,opt,is,present,no,future,compatible,version,for,version,return,opt,get
VersionUtils -> public static Version compatibleFutureVersion(Version version);1549608646;returns the first future compatible version;public static Version compatibleFutureVersion(Version version) {_        final Optional<Version> opt = ALL_VERSIONS.stream().filter(version::before).filter(v -> v.isCompatible(version)).findAny()__        assert opt.isPresent() : "no future compatible version for " + version__        return opt.get()__    };returns,the,first,future,compatible,version;public,static,version,compatible,future,version,version,version,final,optional,version,opt,stream,filter,version,before,filter,v,v,is,compatible,version,find,any,assert,opt,is,present,no,future,compatible,version,for,version,return,opt,get
VersionUtils -> public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion);1524684173;Returns a random {@link Version} between <code>minVersion</code> and <code>maxVersion</code> (inclusive).;public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion) {_        int minVersionIndex = 0__        if (minVersion != null) {_            minVersionIndex = ALL_VERSIONS.indexOf(minVersion)__        }_        int maxVersionIndex = ALL_VERSIONS.size() - 1__        if (maxVersion != null) {_            maxVersionIndex = ALL_VERSIONS.indexOf(maxVersion)__        }_        if (minVersionIndex == -1) {_            throw new IllegalArgumentException("minVersion [" + minVersion + "] does not exist.")__        } else if (maxVersionIndex == -1) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] does not exist.")__        } else if (minVersionIndex > maxVersionIndex) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] cannot be less than minVersion [" + minVersion + "]")__        } else {_            _            int range = maxVersionIndex + 1 - minVersionIndex__            return ALL_VERSIONS.get(minVersionIndex + random.nextInt(range))__        }_    };returns,a,random,link,version,between,code,min,version,code,and,code,max,version,code,inclusive;public,static,version,random,version,between,random,random,nullable,version,min,version,nullable,version,max,version,int,min,version,index,0,if,min,version,null,min,version,index,index,of,min,version,int,max,version,index,size,1,if,max,version,null,max,version,index,index,of,max,version,if,min,version,index,1,throw,new,illegal,argument,exception,min,version,min,version,does,not,exist,else,if,max,version,index,1,throw,new,illegal,argument,exception,max,version,max,version,does,not,exist,else,if,min,version,index,max,version,index,throw,new,illegal,argument,exception,max,version,max,version,cannot,be,less,than,min,version,min,version,else,int,range,max,version,index,1,min,version,index,return,get,min,version,index,random,next,int,range
VersionUtils -> public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion);1525334055;Returns a random {@link Version} between <code>minVersion</code> and <code>maxVersion</code> (inclusive).;public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion) {_        int minVersionIndex = 0__        if (minVersion != null) {_            minVersionIndex = ALL_VERSIONS.indexOf(minVersion)__        }_        int maxVersionIndex = ALL_VERSIONS.size() - 1__        if (maxVersion != null) {_            maxVersionIndex = ALL_VERSIONS.indexOf(maxVersion)__        }_        if (minVersionIndex == -1) {_            throw new IllegalArgumentException("minVersion [" + minVersion + "] does not exist.")__        } else if (maxVersionIndex == -1) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] does not exist.")__        } else if (minVersionIndex > maxVersionIndex) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] cannot be less than minVersion [" + minVersion + "]")__        } else {_            _            int range = maxVersionIndex + 1 - minVersionIndex__            return ALL_VERSIONS.get(minVersionIndex + random.nextInt(range))__        }_    };returns,a,random,link,version,between,code,min,version,code,and,code,max,version,code,inclusive;public,static,version,random,version,between,random,random,nullable,version,min,version,nullable,version,max,version,int,min,version,index,0,if,min,version,null,min,version,index,index,of,min,version,int,max,version,index,size,1,if,max,version,null,max,version,index,index,of,max,version,if,min,version,index,1,throw,new,illegal,argument,exception,min,version,min,version,does,not,exist,else,if,max,version,index,1,throw,new,illegal,argument,exception,max,version,max,version,does,not,exist,else,if,min,version,index,max,version,index,throw,new,illegal,argument,exception,max,version,max,version,cannot,be,less,than,min,version,min,version,else,int,range,max,version,index,1,min,version,index,return,get,min,version,index,random,next,int,range
VersionUtils -> public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion);1528103657;Returns a random {@link Version} between <code>minVersion</code> and <code>maxVersion</code> (inclusive).;public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion) {_        int minVersionIndex = 0__        if (minVersion != null) {_            minVersionIndex = ALL_VERSIONS.indexOf(minVersion)__        }_        int maxVersionIndex = ALL_VERSIONS.size() - 1__        if (maxVersion != null) {_            maxVersionIndex = ALL_VERSIONS.indexOf(maxVersion)__        }_        if (minVersionIndex == -1) {_            throw new IllegalArgumentException("minVersion [" + minVersion + "] does not exist.")__        } else if (maxVersionIndex == -1) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] does not exist.")__        } else if (minVersionIndex > maxVersionIndex) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] cannot be less than minVersion [" + minVersion + "]")__        } else {_            _            int range = maxVersionIndex + 1 - minVersionIndex__            return ALL_VERSIONS.get(minVersionIndex + random.nextInt(range))__        }_    };returns,a,random,link,version,between,code,min,version,code,and,code,max,version,code,inclusive;public,static,version,random,version,between,random,random,nullable,version,min,version,nullable,version,max,version,int,min,version,index,0,if,min,version,null,min,version,index,index,of,min,version,int,max,version,index,size,1,if,max,version,null,max,version,index,index,of,max,version,if,min,version,index,1,throw,new,illegal,argument,exception,min,version,min,version,does,not,exist,else,if,max,version,index,1,throw,new,illegal,argument,exception,max,version,max,version,does,not,exist,else,if,min,version,index,max,version,index,throw,new,illegal,argument,exception,max,version,max,version,cannot,be,less,than,min,version,min,version,else,int,range,max,version,index,1,min,version,index,return,get,min,version,index,random,next,int,range
VersionUtils -> public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion);1549608646;Returns a random {@link Version} between <code>minVersion</code> and <code>maxVersion</code> (inclusive).;public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion) {_        int minVersionIndex = 0__        if (minVersion != null) {_            minVersionIndex = ALL_VERSIONS.indexOf(minVersion)__        }_        int maxVersionIndex = ALL_VERSIONS.size() - 1__        if (maxVersion != null) {_            maxVersionIndex = ALL_VERSIONS.indexOf(maxVersion)__        }_        if (minVersionIndex == -1) {_            throw new IllegalArgumentException("minVersion [" + minVersion + "] does not exist.")__        } else if (maxVersionIndex == -1) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] does not exist.")__        } else if (minVersionIndex > maxVersionIndex) {_            throw new IllegalArgumentException("maxVersion [" + maxVersion + "] cannot be less than minVersion [" + minVersion + "]")__        } else {_            _            int range = maxVersionIndex + 1 - minVersionIndex__            return ALL_VERSIONS.get(minVersionIndex + random.nextInt(range))__        }_    };returns,a,random,link,version,between,code,min,version,code,and,code,max,version,code,inclusive;public,static,version,random,version,between,random,random,nullable,version,min,version,nullable,version,max,version,int,min,version,index,0,if,min,version,null,min,version,index,index,of,min,version,int,max,version,index,size,1,if,max,version,null,max,version,index,index,of,max,version,if,min,version,index,1,throw,new,illegal,argument,exception,min,version,min,version,does,not,exist,else,if,max,version,index,1,throw,new,illegal,argument,exception,max,version,max,version,does,not,exist,else,if,min,version,index,max,version,index,throw,new,illegal,argument,exception,max,version,max,version,cannot,be,less,than,min,version,min,version,else,int,range,max,version,index,1,min,version,index,return,get,min,version,index,random,next,int,range
