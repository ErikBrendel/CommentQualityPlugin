commented;modifiers;parameterAmount;loc;comment;code
false;public;6;10;;public TransportService createTransportService(Settings settings, ThreadPool threadPool, TransportInterceptor interceptor, Function<BoundTransportAddress, DiscoveryNode> localNodeFactory, @Nullable ClusterSettings clusterSettings, Set<String> taskHeaders) {     StubbableConnectionManager connectionManager = new StubbableConnectionManager(new ConnectionManager(settings, this), settings, this).     connectionManager.setDefaultNodeConnectedBehavior((cm, discoveryNode) -> nodeConnected(discoveryNode)).     connectionManager.setDefaultGetConnectionBehavior((cm, discoveryNode) -> createConnection(discoveryNode)).     return new TransportService(settings, this, threadPool, interceptor, localNodeFactory, clusterSettings, taskHeaders, connectionManager). }
true;public;2;16;/**  * simulate a response for the given requestId  */ ;/**  * simulate a response for the given requestId  */ @SuppressWarnings("unchecked") public <Response extends TransportResponse> void handleResponse(final long requestId, final Response response) {     final TransportResponseHandler<Response> transportResponseHandler = (TransportResponseHandler<Response>) responseHandlers.onResponseReceived(requestId, listener).     if (transportResponseHandler != null) {         final Response deliveredResponse.         try (BytesStreamOutput output = new BytesStreamOutput()) {             response.writeTo(output).             deliveredResponse = transportResponseHandler.read(new NamedWriteableAwareStreamInput(output.bytes().streamInput(), writeableRegistry())).         } catch (IOException | UnsupportedOperationException e) {             throw new AssertionError("failed to serialize/deserialize response " + response, e).         }         transportResponseHandler.handleResponse(deliveredResponse).     } }
true;public;2;5;/**  * simulate a local error for the given requestId, will be wrapped  * by a {@link SendRequestTransportException}  *  * @param requestId the id corresponding to the captured send  *                  request  * @param t         the failure to wrap  */ ;/**  * simulate a local error for the given requestId, will be wrapped  * by a {@link SendRequestTransportException}  *  * @param requestId the id corresponding to the captured send  *                  request  * @param t         the failure to wrap  */ public void handleLocalError(final long requestId, final Throwable t) {     Tuple<DiscoveryNode, String> request = requests.get(requestId).     assert request != null.     this.handleError(requestId, new SendRequestTransportException(request.v1(), request.v2(), t)). }
true;public;2;14;/**  * simulate a remote error for the given requestId, will be wrapped  * by a {@link RemoteTransportException}  *  * @param requestId the id corresponding to the captured send  *                  request  * @param t         the failure to wrap  */ ;/**  * simulate a remote error for the given requestId, will be wrapped  * by a {@link RemoteTransportException}  *  * @param requestId the id corresponding to the captured send  *                  request  * @param t         the failure to wrap  */ public void handleRemoteError(final long requestId, final Throwable t) {     final RemoteTransportException remoteException.     if (rarely(Randomness.get())) {         remoteException = new RemoteTransportException("remote failure, coming from local node", t).     } else {         try (BytesStreamOutput output = new BytesStreamOutput()) {             output.writeException(t).             remoteException = new RemoteTransportException("remote failure", output.bytes().streamInput().readException()).         } catch (IOException ioException) {             throw new AssertionError("failed to serialize/deserialize supplied exception " + t, ioException).         }     }     this.handleError(requestId, remoteException). }
true;public;2;6;/**  * simulate an error for the given requestId, unlike  * {@link #handleLocalError(long, Throwable)} and  * {@link #handleRemoteError(long, Throwable)}, the provided  * exception will not be wrapped but will be delivered to the  * transport layer as is  *  * @param requestId the id corresponding to the captured send  *                  request  * @param e         the failure  */ ;/**  * simulate an error for the given requestId, unlike  * {@link #handleLocalError(long, Throwable)} and  * {@link #handleRemoteError(long, Throwable)}, the provided  * exception will not be wrapped but will be delivered to the  * transport layer as is  *  * @param requestId the id corresponding to the captured send  *                  request  * @param e         the failure  */ public void handleError(final long requestId, final TransportException e) {     final TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).     if (transportResponseHandler != null) {         transportResponseHandler.handleException(e).     } }
false;public;3;5;;@Override public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> listener) {     listener.onResponse(createConnection(node)).     return () -> {     }. }
false;public;0;4;;@Override public DiscoveryNode getNode() {     return node. }
false;public;4;6;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {     requests.put(requestId, Tuple.tuple(node, action)).     onSendRequest(requestId, action, request, node). }
false;public;1;15;;public Connection createConnection(DiscoveryNode node) {     return new CloseableConnection() {          @Override         public DiscoveryNode getNode() {             return node.         }          @Override         public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {             requests.put(requestId, Tuple.tuple(node, action)).             onSendRequest(requestId, action, request, node).         }     }. }
false;protected;4;2;;protected void onSendRequest(long requestId, String action, TransportRequest request, DiscoveryNode node) { }
false;protected;1;3;;protected boolean nodeConnected(DiscoveryNode discoveryNode) {     return true. }
false;public;0;4;;@Override public TransportStats getStats() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public BoundTransportAddress boundAddress() {     return null. }
false;public;0;4;;@Override public Map<String, BoundTransportAddress> profileBoundAddresses() {     return null. }
false;public;2;4;;@Override public TransportAddress[] addressesFromString(String address, int perAddressLimit) {     return new TransportAddress[0]. }
false;public;0;4;;@Override public Lifecycle.State lifecycleState() {     return null. }
false;public;1;3;;@Override public void addLifecycleListener(LifecycleListener listener) { }
false;public;1;3;;@Override public void removeLifecycleListener(LifecycleListener listener) { }
false;public;0;3;;@Override public void start() { }
false;public;0;3;;@Override public void stop() { }
false;public;0;3;;@Override public void close() { }
false;public;0;4;;@Override public List<String> getLocalAddresses() {     return Collections.emptyList(). }
false;public;1;9;;@Override public <Request extends TransportRequest> void registerRequestHandler(RequestHandlerRegistry<Request> reg) {     synchronized (requestHandlerMutex) {         if (requestHandlers.containsKey(reg.getAction())) {             throw new IllegalArgumentException("transport handlers for action " + reg.getAction() + " is already registered").         }         requestHandlers = MapBuilder.newMapBuilder(requestHandlers).put(reg.getAction(), reg).immutableMap().     } }
false;public;0;4;;@Override public ResponseHandlers getResponseHandlers() {     return responseHandlers. }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public RequestHandlerRegistry<TransportRequest> getRequestHandler(String action) {     return requestHandlers.get(action). }
false;public;1;7;;@Override public void addMessageListener(TransportMessageListener listener) {     if (this.listener != null) {         throw new IllegalStateException("listener already set").     }     this.listener = listener. }
false;public;1;8;;@Override public boolean removeMessageListener(TransportMessageListener listener) {     if (listener == this.listener) {         this.listener = null.         return true.     }     return false. }
false;protected;0;3;;protected NamedWriteableRegistry writeableRegistry() {     return new NamedWriteableRegistry(ClusterModule.getNamedWriteables()). }
