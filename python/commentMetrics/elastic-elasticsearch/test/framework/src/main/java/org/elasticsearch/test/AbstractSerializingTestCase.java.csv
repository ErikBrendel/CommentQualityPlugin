commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;10;/**  * Generic test that creates new instance from the test instance and checks  * both for equality and asserts equality on the two instances.  */ ;/**  * Generic test that creates new instance from the test instance and checks  * both for equality and asserts equality on the two instances.  */ public final void testFromXContent() throws IOException {     xContentTester(this::createParser, this::createXContextTestInstance, getToXContentParams(), this::doParseInstance).numberOfTestRuns(NUMBER_OF_TEST_RUNS).supportsUnknownFields(supportsUnknownFields()).shuffleFieldsExceptions(getShuffleFieldsExceptions()).randomFieldsExcludeFilter(getRandomFieldsExcludeFilter()).assertEqualsConsumer(this::assertEqualInstances).assertToXContentEquivalence(assertToXContentEquivalence()).test(). }
true;protected,abstract;1;1;/**  * Parses to a new instance using the provided {@link XContentParser}  */ ;/**  * Parses to a new instance using the provided {@link XContentParser}  */ protected abstract T doParseInstance(XContentParser parser) throws IOException.
true;protected;1;3;/**  * Creates a random instance to use in the xcontent tests.  * Override this method if the random instance that you build  * should be aware of the {@link XContentType} used in the test.  */ ;/**  * Creates a random instance to use in the xcontent tests.  * Override this method if the random instance that you build  * should be aware of the {@link XContentType} used in the test.  */ protected T createXContextTestInstance(XContentType xContentType) {     return createTestInstance(). }
true;protected;0;3;/**  * Indicates whether the parser supports unknown fields or not. In case it does, such behaviour will be tested by  * inserting random fields before parsing and checking that they don't make parsing fail.  */ ;/**  * Indicates whether the parser supports unknown fields or not. In case it does, such behaviour will be tested by  * inserting random fields before parsing and checking that they don't make parsing fail.  */ protected boolean supportsUnknownFields() {     return false. }
true;protected;0;3;/**  * Returns a predicate that given the field name indicates whether the field has to be excluded from random fields insertion or not  */ ;/**  * Returns a predicate that given the field name indicates whether the field has to be excluded from random fields insertion or not  */ protected Predicate<String> getRandomFieldsExcludeFilter() {     return field -> false. }
true;protected;0;3;/**  * Fields that have to be ignored when shuffling as part of testFromXContent  */ ;/**  * Fields that have to be ignored when shuffling as part of testFromXContent  */ protected String[] getShuffleFieldsExceptions() {     return Strings.EMPTY_ARRAY. }
true;protected;0;3;/**  * Params that have to be provided when calling calling {@link ToXContent#toXContent(XContentBuilder, ToXContent.Params)}  */ ;/**  * Params that have to be provided when calling calling {@link ToXContent#toXContent(XContentBuilder, ToXContent.Params)}  */ protected ToXContent.Params getToXContentParams() {     return ToXContent.EMPTY_PARAMS. }
true;protected;0;3;/**  * Whether or not to assert equivalence of the {@link org.elasticsearch.common.xcontent.XContent} of the test instance and the instance  * parsed from the {@link org.elasticsearch.common.xcontent.XContent} of the test instance.  *  * @return true if equivalence should be asserted, otherwise false  */ ;/**  * Whether or not to assert equivalence of the {@link org.elasticsearch.common.xcontent.XContent} of the test instance and the instance  * parsed from the {@link org.elasticsearch.common.xcontent.XContent} of the test instance.  *  * @return true if equivalence should be asserted, otherwise false  */ protected boolean assertToXContentEquivalence() {     return true. }
true;protected;0;3;/**  * @return a random date between 1970 and ca 2065  */ ;/**  * @return a random date between 1970 and ca 2065  */ protected Date randomDate() {     return new Date(randomLongBetween(0, 3000000000000L)). }
