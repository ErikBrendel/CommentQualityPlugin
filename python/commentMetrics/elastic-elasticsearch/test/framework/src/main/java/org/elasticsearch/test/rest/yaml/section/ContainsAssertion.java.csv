commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;5;;public static ContainsAssertion parse(XContentParser parser) throws IOException {     XContentLocation location = parser.getTokenLocation().     Tuple<String, Object> stringObjectTuple = ParserUtils.parseTuple(parser).     return new ContainsAssertion(location, stringObjectTuple.v1(), stringObjectTuple.v2()). }
false;protected;2;28;;@Override protected void doAssert(Object actualValue, Object expectedValue) {     // add support for matching objects ({a:b}) against list of objects ([ {a:b, c:d} ])     if (expectedValue instanceof Map && actualValue instanceof List) {         logger.trace("assert that [{}] contains [{}]", actualValue, expectedValue).         Map<String, Object> expectedMap = (Map<String, Object>) expectedValue.         List<Object> actualList = (List<Object>) actualValue.         List<Map<String, Object>> actualValues = actualList.stream().filter(each -> each instanceof Map).map((each -> (Map<String, Object>) each)).filter(each -> each.keySet().containsAll(expectedMap.keySet())).collect(Collectors.toList()).         assertThat(getField() + " expected to be a list with at least one object that has keys: " + expectedMap.keySet() + " but it was " + actualList, actualValues, is(not(empty()))).         assertTrue(getField() + " expected to be a list with at least on object that matches " + expectedMap + " but was " + actualValues, actualValues.stream().anyMatch(each -> each.entrySet().containsAll(expectedMap.entrySet()))).     } else {         fail("'contains' only supports checking an object against a list of objects").     } }
