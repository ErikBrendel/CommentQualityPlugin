# id;timestamp;commentText;codeText;commentWords;codeWords
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1535723122;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1536314350;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1536611444;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1536828374;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1537806831;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1538067637;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1538424609;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1539615817;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1540238977;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1541335413;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1541618615;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1543940134;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1543942400;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1544203340;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1544684920;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1545678410;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1546875837;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1546927432;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1547174095;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1547332999;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1548342168;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1548593396;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1548944389;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1549059559;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1549663373;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1549989658;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1550256122;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException;1551110274;Asserts the provided engine has a consistent document history between translog and Lucene index.;public static void assertConsistentHistoryBetweenTranslogAndLuceneIndex(Engine engine, MapperService mapper) throws IOException {_        if (mapper.documentMapper() == null || engine.config().getIndexSettings().isSoftDeleteEnabled() == false_            || (engine instanceof InternalEngine) == false) {_            return__        }_        final long maxSeqNo = ((InternalEngine) engine).getLocalCheckpointTracker().getMaxSeqNo()__        if (maxSeqNo < 0) {_            return_ _        }_        final Map<Long, Translog.Operation> translogOps = new HashMap<>()__        try (Translog.Snapshot snapshot = EngineTestCase.getTranslog(engine).newSnapshot()) {_            Translog.Operation op__            while ((op = snapshot.next()) != null) {_                translogOps.put(op.seqNo(), op)__            }_        }_        final Map<Long, Translog.Operation> luceneOps = readAllOperationsInLucene(engine, mapper).stream()_            .collect(Collectors.toMap(Translog.Operation::seqNo, Function.identity()))__        final long globalCheckpoint = EngineTestCase.getTranslog(engine).getLastSyncedGlobalCheckpoint()__        final long retainedOps = engine.config().getIndexSettings().getSoftDeleteRetentionOperations()__        final long seqNoForRecovery__        try (Engine.IndexCommitRef safeCommit = engine.acquireSafeIndexCommit()) {_            seqNoForRecovery = Long.parseLong(safeCommit.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__        }_        final long minSeqNoToRetain = Math.min(seqNoForRecovery, globalCheckpoint + 1 - retainedOps)__        for (Translog.Operation translogOp : translogOps.values()) {_            final Translog.Operation luceneOp = luceneOps.get(translogOp.seqNo())__            if (luceneOp == null) {_                if (minSeqNoToRetain <= translogOp.seqNo() && translogOp.seqNo() <= maxSeqNo) {_                    fail("Operation not found seq# [" + translogOp.seqNo() + "], global checkpoint [" + globalCheckpoint + "], " +_                        "retention policy [" + retainedOps + "], maxSeqNo [" + maxSeqNo + "], translog op [" + translogOp + "]")__                } else {_                    continue__                }_            }_            assertThat(luceneOp, notNullValue())__            assertThat(luceneOp.toString(), luceneOp.primaryTerm(), equalTo(translogOp.primaryTerm()))__            assertThat(luceneOp.opType(), equalTo(translogOp.opType()))__            if (luceneOp.opType() == Translog.Operation.Type.INDEX) {_                assertThat(luceneOp.getSource().source, equalTo(translogOp.getSource().source))__            }_        }_    };asserts,the,provided,engine,has,a,consistent,document,history,between,translog,and,lucene,index;public,static,void,assert,consistent,history,between,translog,and,lucene,index,engine,engine,mapper,service,mapper,throws,ioexception,if,mapper,document,mapper,null,engine,config,get,index,settings,is,soft,delete,enabled,false,engine,instanceof,internal,engine,false,return,final,long,max,seq,no,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,if,max,seq,no,0,return,final,map,long,translog,operation,translog,ops,new,hash,map,try,translog,snapshot,snapshot,engine,test,case,get,translog,engine,new,snapshot,translog,operation,op,while,op,snapshot,next,null,translog,ops,put,op,seq,no,op,final,map,long,translog,operation,lucene,ops,read,all,operations,in,lucene,engine,mapper,stream,collect,collectors,to,map,translog,operation,seq,no,function,identity,final,long,global,checkpoint,engine,test,case,get,translog,engine,get,last,synced,global,checkpoint,final,long,retained,ops,engine,config,get,index,settings,get,soft,delete,retention,operations,final,long,seq,no,for,recovery,try,engine,index,commit,ref,safe,commit,engine,acquire,safe,index,commit,seq,no,for,recovery,long,parse,long,safe,commit,get,index,commit,get,user,data,get,sequence,numbers,1,final,long,min,seq,no,to,retain,math,min,seq,no,for,recovery,global,checkpoint,1,retained,ops,for,translog,operation,translog,op,translog,ops,values,final,translog,operation,lucene,op,lucene,ops,get,translog,op,seq,no,if,lucene,op,null,if,min,seq,no,to,retain,translog,op,seq,no,translog,op,seq,no,max,seq,no,fail,operation,not,found,seq,translog,op,seq,no,global,checkpoint,global,checkpoint,retention,policy,retained,ops,max,seq,no,max,seq,no,translog,op,translog,op,else,continue,assert,that,lucene,op,not,null,value,assert,that,lucene,op,to,string,lucene,op,primary,term,equal,to,translog,op,primary,term,assert,that,lucene,op,op,type,equal,to,translog,op,op,type,if,lucene,op,op,type,translog,operation,type,index,assert,that,lucene,op,get,source,source,equal,to,translog,op,get,source,source
EngineTestCase -> public static void assertMaxSeqNoInCommitUserData(Engine engine) throws Exception;1550256122;Asserts that the max_seq_no stored in the commit's user_data is never smaller than seq_no of any document in the commit.;public static void assertMaxSeqNoInCommitUserData(Engine engine) throws Exception {_        List<IndexCommit> commits = DirectoryReader.listCommits(engine.store.directory())__        for (IndexCommit commit : commits) {_            try (DirectoryReader reader = DirectoryReader.open(commit)) {_                AtomicLong maxSeqNoFromDocs = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__                Lucene.scanSeqNosInReader(reader, 0, Long.MAX_VALUE, n -> maxSeqNoFromDocs.set(Math.max(n, maxSeqNoFromDocs.get())))__                assertThat(Long.parseLong(commit.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),_                    greaterThanOrEqualTo(maxSeqNoFromDocs.get()))__            }_        }_    };asserts,that,the,stored,in,the,commit,s,is,never,smaller,than,of,any,document,in,the,commit;public,static,void,assert,max,seq,no,in,commit,user,data,engine,engine,throws,exception,list,index,commit,commits,directory,reader,list,commits,engine,store,directory,for,index,commit,commit,commits,try,directory,reader,reader,directory,reader,open,commit,atomic,long,max,seq,no,from,docs,new,atomic,long,sequence,numbers,lucene,scan,seq,nos,in,reader,reader,0,long,n,max,seq,no,from,docs,set,math,max,n,max,seq,no,from,docs,get,assert,that,long,parse,long,commit,get,user,data,get,sequence,numbers,greater,than,or,equal,to,max,seq,no,from,docs,get
EngineTestCase -> public static void assertMaxSeqNoInCommitUserData(Engine engine) throws Exception;1551110274;Asserts that the max_seq_no stored in the commit's user_data is never smaller than seq_no of any document in the commit.;public static void assertMaxSeqNoInCommitUserData(Engine engine) throws Exception {_        List<IndexCommit> commits = DirectoryReader.listCommits(engine.store.directory())__        for (IndexCommit commit : commits) {_            try (DirectoryReader reader = DirectoryReader.open(commit)) {_                AtomicLong maxSeqNoFromDocs = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__                Lucene.scanSeqNosInReader(reader, 0, Long.MAX_VALUE, n -> maxSeqNoFromDocs.set(Math.max(n, maxSeqNoFromDocs.get())))__                assertThat(Long.parseLong(commit.getUserData().get(SequenceNumbers.MAX_SEQ_NO)),_                    greaterThanOrEqualTo(maxSeqNoFromDocs.get()))__            }_        }_    };asserts,that,the,stored,in,the,commit,s,is,never,smaller,than,of,any,document,in,the,commit;public,static,void,assert,max,seq,no,in,commit,user,data,engine,engine,throws,exception,list,index,commit,commits,directory,reader,list,commits,engine,store,directory,for,index,commit,commit,commits,try,directory,reader,reader,directory,reader,open,commit,atomic,long,max,seq,no,from,docs,new,atomic,long,sequence,numbers,lucene,scan,seq,nos,in,reader,reader,0,long,n,max,seq,no,from,docs,set,math,max,n,max,seq,no,from,docs,get,assert,that,long,parse,long,commit,get,user,data,get,sequence,numbers,greater,than,or,equal,to,max,seq,no,from,docs,get
EngineTestCase -> public static Set<String> getDocIds(Engine engine, boolean refresh) throws IOException;1535723122;Gets all docId from the given engine.;public static Set<String> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            Set<String> ids = new HashSet<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        ids.add(Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length)))__                    }_                }_            }_            return ids__        }_    };gets,all,doc,id,from,the,given,engine;public,static,set,string,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,set,string,ids,new,hash,set,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,ids,add,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,return,ids
EngineTestCase -> public static Set<String> getDocIds(Engine engine, boolean refresh) throws IOException;1536314350;Gets all docId from the given engine.;public static Set<String> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            Set<String> ids = new HashSet<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        ids.add(Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length)))__                    }_                }_            }_            return ids__        }_    };gets,all,doc,id,from,the,given,engine;public,static,set,string,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,set,string,ids,new,hash,set,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,ids,add,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,return,ids
EngineTestCase -> public static Set<String> getDocIds(Engine engine, boolean refresh) throws IOException;1536611444;Gets all docId from the given engine.;public static Set<String> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            Set<String> ids = new HashSet<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        ids.add(Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length)))__                    }_                }_            }_            return ids__        }_    };gets,all,doc,id,from,the,given,engine;public,static,set,string,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,set,string,ids,new,hash,set,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,ids,add,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,return,ids
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1536828374;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        final long primaryTerm__                        if (primaryTermDocValues.advanceExact(i)) {_                            primaryTerm = primaryTermDocValues.longValue()__                        } else {_                            primaryTerm = 0_ _                        }_                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,final,long,primary,term,if,primary,term,doc,values,advance,exact,i,primary,term,primary,term,doc,values,long,value,else,primary,term,0,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1537806831;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        final long primaryTerm__                        if (primaryTermDocValues.advanceExact(i)) {_                            primaryTerm = primaryTermDocValues.longValue()__                        } else {_                            primaryTerm = 0_ _                        }_                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,final,long,primary,term,if,primary,term,doc,values,advance,exact,i,primary,term,primary,term,doc,values,long,value,else,primary,term,0,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1538067637;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        final long primaryTerm__                        if (primaryTermDocValues.advanceExact(i)) {_                            primaryTerm = primaryTermDocValues.longValue()__                        } else {_                            primaryTerm = 0_ _                        }_                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,final,long,primary,term,if,primary,term,doc,values,advance,exact,i,primary,term,primary,term,doc,values,long,value,else,primary,term,0,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1538424609;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        final long primaryTerm__                        if (primaryTermDocValues.advanceExact(i)) {_                            primaryTerm = primaryTermDocValues.longValue()__                        } else {_                            primaryTerm = 0_ _                        }_                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,final,long,primary,term,if,primary,term,doc,values,advance,exact,i,primary,term,primary,term,doc,values,long,value,else,primary,term,0,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1539615817;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1540238977;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1541335413;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1541618615;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1543940134;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1543942400;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1544203340;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1544684920;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1545678410;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1546875837;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1546927432;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1547174095;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1547332999;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1548342168;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1548593396;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1548944389;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1549059559;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1549663373;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparing(DocIdSeqNoAndTerm::getId)_                .thenComparingLong(DocIdSeqNoAndTerm::getSeqNo).thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,doc,id,seq,no,and,term,get,id,then,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1549989658;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparingLong(DocIdSeqNoAndTerm::getSeqNo)_                .thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm)_                .thenComparing((DocIdSeqNoAndTerm::getId)))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,then,comparing,doc,id,seq,no,and,term,get,id,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1550256122;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparingLong(DocIdSeqNoAndTerm::getSeqNo)_                .thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm)_                .thenComparing((DocIdSeqNoAndTerm::getId)))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,then,comparing,doc,id,seq,no,and,term,get,id,return,docs
EngineTestCase -> public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException;1551110274;Gets a collection of tuples of docId, sequence number, and primary term of all live documents in the provided engine.;public static List<DocIdSeqNoAndTerm> getDocIds(Engine engine, boolean refresh) throws IOException {_        if (refresh) {_            engine.refresh("test_get_doc_ids")__        }_        try (Engine.Searcher searcher = engine.acquireSearcher("test_get_doc_ids")) {_            List<DocIdSeqNoAndTerm> docs = new ArrayList<>()__            for (LeafReaderContext leafContext : searcher.reader().leaves()) {_                LeafReader reader = leafContext.reader()__                NumericDocValues seqNoDocValues = reader.getNumericDocValues(SeqNoFieldMapper.NAME)__                NumericDocValues primaryTermDocValues = reader.getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME)__                Bits liveDocs = reader.getLiveDocs()__                for (int i = 0_ i < reader.maxDoc()_ i++) {_                    if (liveDocs == null || liveDocs.get(i)) {_                        if (primaryTermDocValues.advanceExact(i) == false) {_                            _                            continue__                        }_                        final long primaryTerm = primaryTermDocValues.longValue()__                        Document uuid = reader.document(i, Collections.singleton(IdFieldMapper.NAME))__                        BytesRef binaryID = uuid.getBinaryValue(IdFieldMapper.NAME)__                        String id = Uid.decodeId(Arrays.copyOfRange(binaryID.bytes, binaryID.offset, binaryID.offset + binaryID.length))__                        if (seqNoDocValues.advanceExact(i) == false) {_                            throw new AssertionError("seqNoDocValues not found for doc[" + i + "] id[" + id + "]")__                        }_                        final long seqNo = seqNoDocValues.longValue()__                        docs.add(new DocIdSeqNoAndTerm(id, seqNo, primaryTerm))__                    }_                }_            }_            docs.sort(Comparator.comparingLong(DocIdSeqNoAndTerm::getSeqNo)_                .thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm)_                .thenComparing((DocIdSeqNoAndTerm::getId)))__            return docs__        }_    };gets,a,collection,of,tuples,of,doc,id,sequence,number,and,primary,term,of,all,live,documents,in,the,provided,engine;public,static,list,doc,id,seq,no,and,term,get,doc,ids,engine,engine,boolean,refresh,throws,ioexception,if,refresh,engine,refresh,try,engine,searcher,searcher,engine,acquire,searcher,list,doc,id,seq,no,and,term,docs,new,array,list,for,leaf,reader,context,leaf,context,searcher,reader,leaves,leaf,reader,reader,leaf,context,reader,numeric,doc,values,seq,no,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,name,numeric,doc,values,primary,term,doc,values,reader,get,numeric,doc,values,seq,no,field,mapper,bits,live,docs,reader,get,live,docs,for,int,i,0,i,reader,max,doc,i,if,live,docs,null,live,docs,get,i,if,primary,term,doc,values,advance,exact,i,false,continue,final,long,primary,term,primary,term,doc,values,long,value,document,uuid,reader,document,i,collections,singleton,id,field,mapper,name,bytes,ref,binary,id,uuid,get,binary,value,id,field,mapper,name,string,id,uid,decode,id,arrays,copy,of,range,binary,id,bytes,binary,id,offset,binary,id,offset,binary,id,length,if,seq,no,doc,values,advance,exact,i,false,throw,new,assertion,error,seq,no,doc,values,not,found,for,doc,i,id,id,final,long,seq,no,seq,no,doc,values,long,value,docs,add,new,doc,id,seq,no,and,term,id,seq,no,primary,term,docs,sort,comparator,comparing,long,doc,id,seq,no,and,term,get,seq,no,then,comparing,long,doc,id,seq,no,and,term,get,primary,term,then,comparing,doc,id,seq,no,and,term,get,id,return,docs
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1535723122;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1536314350;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1536611444;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1536828374;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1537806831;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1538067637;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1538424609;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1539615817;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1540238977;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1541335413;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1541618615;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1543940134;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1543942400;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1544203340;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1544684920;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1545678410;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1546875837;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1546927432;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1547174095;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1547332999;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1548342168;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1548593396;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1548944389;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1549059559;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1549663373;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1549989658;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1550256122;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier();1551110274;Creates a tombstone document that only includes uid, seq#, term and version fields.;public static EngineConfig.TombstoneDocSupplier tombstoneDocSupplier(){_        return new EngineConfig.TombstoneDocSupplier() {_            @Override_            public ParsedDocument newDeleteTombstoneDoc(String type, String id) {_                final ParseContext.Document doc = new ParseContext.Document()__                Field uidField = new Field(IdFieldMapper.NAME, Uid.encodeId(id), IdFieldMapper.Defaults.FIELD_TYPE)__                doc.add(uidField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                return new ParsedDocument(versionField, seqID, id, type, null,_                    Collections.singletonList(doc), new BytesArray("{}"), XContentType.JSON, null)__            }__            @Override_            public ParsedDocument newNoopTombstoneDoc(String reason) {_                final ParseContext.Document doc = new ParseContext.Document()__                SeqNoFieldMapper.SequenceIDFields seqID = SeqNoFieldMapper.SequenceIDFields.emptySeqID()__                doc.add(seqID.seqNo)__                doc.add(seqID.seqNoDocValue)__                doc.add(seqID.primaryTerm)__                seqID.tombstoneField.setLongValue(1)__                doc.add(seqID.tombstoneField)__                Field versionField = new NumericDocValuesField(VersionFieldMapper.NAME, 0)__                doc.add(versionField)__                BytesRef byteRef = new BytesRef(reason)__                doc.add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length))__                return new ParsedDocument(versionField, seqID, null, null, null,_                    Collections.singletonList(doc), null, XContentType.JSON, null)__            }_        }__    };creates,a,tombstone,document,that,only,includes,uid,seq,term,and,version,fields;public,static,engine,config,tombstone,doc,supplier,tombstone,doc,supplier,return,new,engine,config,tombstone,doc,supplier,override,public,parsed,document,new,delete,tombstone,doc,string,type,string,id,final,parse,context,document,doc,new,parse,context,document,field,uid,field,new,field,id,field,mapper,name,uid,encode,id,id,id,field,mapper,defaults,doc,add,uid,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,return,new,parsed,document,version,field,seq,id,id,type,null,collections,singleton,list,doc,new,bytes,array,xcontent,type,json,null,override,public,parsed,document,new,noop,tombstone,doc,string,reason,final,parse,context,document,doc,new,parse,context,document,seq,no,field,mapper,sequence,idfields,seq,id,seq,no,field,mapper,sequence,idfields,empty,seq,id,doc,add,seq,id,seq,no,doc,add,seq,id,seq,no,doc,value,doc,add,seq,id,primary,term,seq,id,tombstone,field,set,long,value,1,doc,add,seq,id,tombstone,field,field,version,field,new,numeric,doc,values,field,version,field,mapper,name,0,doc,add,version,field,bytes,ref,byte,ref,new,bytes,ref,reason,doc,add,new,stored,field,source,field,mapper,name,byte,ref,bytes,byte,ref,offset,byte,ref,length,return,new,parsed,document,version,field,seq,id,null,null,null,collections,singleton,list,doc,null,xcontent,type,json,null
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1535723122;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1536314350;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1536611444;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1536828374;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1537806831;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1538067637;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1538424609;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1539615817;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1540238977;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1541335413;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1541618615;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1543940134;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1543942400;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1544203340;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1544684920;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1545678410;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1546875837;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1546927432;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1547174095;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1547332999;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1548342168;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1548593396;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1548944389;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1549059559;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1549663373;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1549989658;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1550256122;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException;1551110274;Reads all engine operations that have been processed by the engine from Lucene index._The returned operations are sorted and de-duplicated, thus each sequence number will be have at most one operation.;public static List<Translog.Operation> readAllOperationsInLucene(Engine engine, MapperService mapper) throws IOException {_        final List<Translog.Operation> operations = new ArrayList<>()__        long maxSeqNo = Math.max(0, ((InternalEngine)engine).getLocalCheckpointTracker().getMaxSeqNo())__        try (Translog.Snapshot snapshot = engine.newChangesSnapshot("test", mapper, 0, maxSeqNo, false)) {_            Translog.Operation op__            while ((op = snapshot.next()) != null){_                operations.add(op)__            }_        }_        return operations__    };reads,all,engine,operations,that,have,been,processed,by,the,engine,from,lucene,index,the,returned,operations,are,sorted,and,de,duplicated,thus,each,sequence,number,will,be,have,at,most,one,operation;public,static,list,translog,operation,read,all,operations,in,lucene,engine,engine,mapper,service,mapper,throws,ioexception,final,list,translog,operation,operations,new,array,list,long,max,seq,no,math,max,0,internal,engine,engine,get,local,checkpoint,tracker,get,max,seq,no,try,translog,snapshot,snapshot,engine,new,changes,snapshot,test,mapper,0,max,seq,no,false,translog,operation,op,while,op,snapshot,next,null,operations,add,op,return,operations
EngineTestCase -> public static Translog getTranslog(Engine engine);1524684173;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        return engine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,return,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1528706846;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        return engine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,return,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1528762805;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1531910483;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1533738061;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1535046779;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1535723122;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1536314350;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1536611444;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1536828374;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1537806831;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1538067637;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1538424609;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1539615817;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1540238977;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1541335413;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1541618615;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1543940134;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1543942400;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1544203340;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1544684920;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1545678410;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1546875837;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1546927432;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1547174095;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1547332999;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1548342168;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1548593396;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1548944389;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1549059559;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1549663373;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1549989658;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1550256122;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static Translog getTranslog(Engine engine);1551110274;Exposes a translog associated with the given engine for testing purpose.;public static Translog getTranslog(Engine engine) {_        assert engine instanceof InternalEngine : "only InternalEngines have translogs, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getTranslog()__    };exposes,a,translog,associated,with,the,given,engine,for,testing,purpose;public,static,translog,get,translog,engine,engine,assert,engine,instanceof,internal,engine,only,internal,engines,have,translogs,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,translog
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1528706846;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1528762805;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1531910483;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1533738061;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1535046779;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1535723122;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1536314350;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1536611444;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1536828374;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1537806831;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1538067637;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1538424609;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1539615817;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1540238977;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1541335413;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1541618615;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1543940134;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1543942400;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1544203340;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1544684920;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1545678410;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1546875837;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1546927432;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1547174095;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1547332999;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1548342168;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1548593396;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1548944389;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1549059559;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1549663373;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1549989658;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1550256122;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
EngineTestCase -> public static long generateNewSeqNo(final Engine engine);1551110274;Generate a new sequence number and return it. Only works on InternalEngines;public static long generateNewSeqNo(final Engine engine) {_        assert engine instanceof InternalEngine : "expected InternalEngine, got: " + engine.getClass()__        InternalEngine internalEngine = (InternalEngine) engine__        return internalEngine.getLocalCheckpointTracker().generateSeqNo()__    };generate,a,new,sequence,number,and,return,it,only,works,on,internal,engines;public,static,long,generate,new,seq,no,final,engine,engine,assert,engine,instanceof,internal,engine,expected,internal,engine,got,engine,get,class,internal,engine,internal,engine,internal,engine,engine,return,internal,engine,get,local,checkpoint,tracker,generate,seq,no
