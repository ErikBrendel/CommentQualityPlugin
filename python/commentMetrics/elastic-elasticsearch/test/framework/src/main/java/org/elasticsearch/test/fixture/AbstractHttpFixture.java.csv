commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;78;/**  * Opens a {@link HttpServer} and start listening on a random port.  */ ;/**  * Opens a {@link HttpServer} and start listening on a random port.  */ public final void listen() throws IOException, InterruptedException {     final InetSocketAddress socketAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0).     final HttpServer httpServer = HttpServer.create(socketAddress, 0).     try {         // / Writes the PID of the current Java process in a `pid` file located in the working directory         writeFile(workingDirectory, "pid", ManagementFactory.getRuntimeMXBean().getName().split("@")[0]).         final String addressAndPort = addressToString(httpServer.getAddress()).         // Writes the address and port of the http server in a `ports` file located in the working directory         writeFile(workingDirectory, "ports", addressAndPort).         httpServer.createContext("/", exchange -> {             try {                 Response response.                 // Check if this is a request made by the AntFixture                 final String userAgent = exchange.getRequestHeaders().getFirst("User-Agent").                 if (userAgent != null && userAgent.startsWith("Apache Ant") && "GET".equals(exchange.getRequestMethod()) && "/".equals(exchange.getRequestURI().getPath())) {                     response = new Response(200, TEXT_PLAIN_CONTENT_TYPE, "OK".getBytes(UTF_8)).                 } else {                     try {                         final long requestId = requests.getAndIncrement().                         final String method = exchange.getRequestMethod().                         final Map<String, String> headers = new HashMap<>().                         for (Map.Entry<String, List<String>> header : exchange.getRequestHeaders().entrySet()) {                             headers.put(header.getKey(), exchange.getRequestHeaders().getFirst(header.getKey())).                         }                         final ByteArrayOutputStream body = new ByteArrayOutputStream().                         try (InputStream requestBody = exchange.getRequestBody()) {                             final byte[] buffer = new byte[1024].                             int i.                             while ((i = requestBody.read(buffer, 0, buffer.length)) != -1) {                                 body.write(buffer, 0, i).                             }                             body.flush().                         }                         final Request request = new Request(requestId, method, exchange.getRequestURI(), headers, body.toByteArray()).                         response = handle(request).                     } catch (Exception e) {                         final String error = e.getMessage() != null ? e.getMessage() : "Exception when processing the request".                         response = new Response(500, singletonMap("Content-Type", "text/plain. charset=utf-8"), error.getBytes(UTF_8)).                     }                 }                 if (response == null) {                     response = new Response(400, TEXT_PLAIN_CONTENT_TYPE, EMPTY_BYTE).                 }                 response.headers.forEach((k, v) -> exchange.getResponseHeaders().put(k, singletonList(v))).                 if (response.body.length > 0) {                     exchange.sendResponseHeaders(response.status, response.body.length).                     exchange.getResponseBody().write(response.body).                 } else {                     exchange.sendResponseHeaders(response.status, -1).                 }             } finally {                 exchange.close().             }         }).         httpServer.start().         // Wait to be killed         Thread.sleep(Long.MAX_VALUE).     } finally {         httpServer.stop(0).     } }
false;protected,abstract;1;1;;protected abstract Response handle(Request request) throws IOException.
false;;1;1;;Response handle(Request request) throws IOException.
false;public;0;3;;public int getStatus() {     return status. }
false;public;0;3;;public Map<String, String> getHeaders() {     return headers. }
false;public;0;3;;public byte[] getBody() {     return body. }
false;public;0;8;;public String getContentType() {     for (String header : headers.keySet()) {         if (header.equalsIgnoreCase("Content-Type")) {             return headers.get(header).         }     }     return null. }
false;public;0;8;;@Override public String toString() {     return "Response{" + "status=" + status + ", headers=" + headers + ", body=" + new String(body, UTF_8) + '}'. }
false;public;0;3;;public long getId() {     return id. }
false;public;0;3;;public String getMethod() {     return method. }
false;public;0;3;;public Map<String, String> getHeaders() {     return headers. }
false;public;1;8;;public String getHeader(final String headerName) {     for (String header : headers.keySet()) {         if (header.equalsIgnoreCase(headerName)) {             return headers.get(header).         }     }     return null. }
false;public;0;3;;public byte[] getBody() {     return body. }
false;public;0;3;;public String getPath() {     return uri.getRawPath(). }
false;public;0;3;;public Map<String, String> getParameters() {     return parameters. }
false;public;1;8;;public String getParam(final String paramName) {     for (String param : parameters.keySet()) {         if (param.equals(paramName)) {             return parameters.get(param).         }     }     return null. }
false;public;0;3;;public String getContentType() {     return getHeader("Content-Type"). }
false;public;0;10;;@Override public String toString() {     return "Request{" + "method='" + method + '\'' + ", uri=" + uri + ", parameters=" + parameters + ", headers=" + headers + ", body=" + body + '}'. }
false;private,static;3;5;;private static void writeFile(final Path dir, final String fileName, final String content) throws IOException {     final Path tempPidFile = Files.createTempFile(dir, null, null).     Files.write(tempPidFile, singleton(content)).     Files.move(tempPidFile, dir.resolve(fileName), StandardCopyOption.ATOMIC_MOVE). }
false;private,static;1;8;;private static String addressToString(final SocketAddress address) {     final InetSocketAddress inetSocketAddress = (InetSocketAddress) address.     if (inetSocketAddress.getAddress() instanceof Inet6Address) {         return "[" + inetSocketAddress.getHostString() + "]:" + inetSocketAddress.getPort().     } else {         return inetSocketAddress.getHostString() + ":" + inetSocketAddress.getPort().     } }
false;protected,static;1;3;;protected static Map<String, String> contentType(final String contentType) {     return singletonMap("Content-Type", contentType). }
