commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isFlushOnCloseDisabled() {     return disableFlushOnClose. }
true;public;1;16;/**  * Returns the CloseAction to execute on the actual engine. Note this method changes the state on  * the first call and treats subsequent calls as if the engine passed is already closed.  */ ;/**  * Returns the CloseAction to execute on the actual engine. Note this method changes the state on  * the first call and treats subsequent calls as if the engine passed is already closed.  */ public CloseAction flushOrClose(CloseAction originalAction) throws IOException {     /*          * only do the random thing if we are the first call to this since          * super.flushOnClose() calls #close() again and then we might end          * up with a stackoverflow.          */     if (closing.compareAndSet(false, true)) {         if (mockContext.random.nextBoolean()) {             return CloseAction.FLUSH_AND_CLOSE.         } else {             return CloseAction.CLOSE.         }     } else {         return originalAction.     } }
false;public;1;14;;public AssertingIndexSearcher newSearcher(Engine.Searcher searcher) throws EngineException {     IndexReader reader = searcher.reader().     IndexReader wrappedReader = reader.     assert reader != null.     if (reader instanceof DirectoryReader && mockContext.wrapReader) {         wrappedReader = wrapReader((DirectoryReader) reader).     }     // this executes basic query checks and asserts that weights are normalized only once etc.     final AssertingIndexSearcher assertingIndexSearcher = new AssertingIndexSearcher(mockContext.random, wrappedReader).     assertingIndexSearcher.setSimilarity(searcher.searcher().getSimilarity()).     assertingIndexSearcher.setQueryCache(filterCache).     assertingIndexSearcher.setQueryCachingPolicy(filterCachingPolicy).     return assertingIndexSearcher. }
false;private;1;23;;private DirectoryReader wrapReader(DirectoryReader reader) {     try {         Constructor<?>[] constructors = mockContext.wrapper.getConstructors().         Constructor<?> nonRandom = null.         for (Constructor<?> constructor : constructors) {             Class<?>[] parameterTypes = constructor.getParameterTypes().             if (parameterTypes.length > 0 && parameterTypes[0] == DirectoryReader.class) {                 if (parameterTypes.length == 1) {                     nonRandom = constructor.                 } else if (parameterTypes.length == 2 && parameterTypes[1] == Settings.class) {                     return (DirectoryReader) constructor.newInstance(reader, mockContext.indexSettings).                 }             }         }         if (nonRandom != null) {             return (DirectoryReader) nonRandom.newInstance(reader).         }     } catch (Exception e) {         throw new ElasticsearchException("Can not wrap reader", e).     }     return reader. }
false;public;1;14;;public Engine.Searcher wrapSearcher(Engine.Searcher engineSearcher) {     final AssertingIndexSearcher assertingIndexSearcher = newSearcher(engineSearcher).     assertingIndexSearcher.setSimilarity(engineSearcher.searcher().getSimilarity()).     /*          * pass the original searcher to the super.newSearcher() method to          * make sure this is the searcher that will be released later on.          * If we wrap an index reader here must not pass the wrapped version          * to the manager on release otherwise the reader will be closed too          * early. - good news, stuff will fail all over the place if we don't          * get this right here          */     SearcherCloseable closeable = new SearcherCloseable(engineSearcher, logger, inFlightSearchers).     return new Engine.Searcher(engineSearcher.source(), assertingIndexSearcher, closeable). }
false;public,synchronized;0;10;;@Override public synchronized void close() {     if (openSearchers.isEmpty() == false) {         AssertionError error = new AssertionError("Unreleased searchers found").         for (RuntimeException ex : openSearchers.values()) {             error.addSuppressed(ex).         }         throw error.     } }
false;;2;6;;void add(Object key, String source) {     final RuntimeException ex = new RuntimeException("Unreleased Searcher, source [" + source + "]").     synchronized (this) {         openSearchers.put(key, ex).     } }
false;synchronized;1;3;;synchronized void remove(Object key) {     openSearchers.remove(key). }
false;public;0;28;;@Override public void close() {     synchronized (lock) {         if (closed.compareAndSet(false, true)) {             inFlightSearchers.remove(this).             firstReleaseStack = new RuntimeException().             final int refCount = wrappedSearcher.reader().getRefCount().             /*                      * this assert seems to be paranoid but given LUCENE-5362 we                      * better add some assertions here to make sure we catch any                      * potential problems.                      */             assert refCount > 0 : "IndexReader#getRefCount() was [" + refCount + "] expected a value > [0] - reader is already " + " closed. Initial refCount was: [" + initialRefCount + "]".             try {                 wrappedSearcher.close().             } catch (RuntimeException ex) {                 logger.debug("Failed to release searcher", ex).                 throw ex.             }         } else {             AssertionError error = new AssertionError("Released Searcher more than once, source [" + wrappedSearcher.source() + "]").             error.initCause(firstReleaseStack).             throw error.         }     } }
