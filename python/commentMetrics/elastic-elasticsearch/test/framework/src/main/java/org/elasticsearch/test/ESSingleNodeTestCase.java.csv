commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;23;;protected void startNode(long seed) throws Exception {     assert NODE == null.     NODE = RandomizedContext.current().runWithPrivateRandomness(seed, this::newNode).     // we must wait for the node to actually be up and running. otherwise the node might have started,     // elected itself master but might not yet have removed the     // SERVICE_UNAVAILABLE/1/state not recovered / initialized block     ClusterHealthResponse clusterHealthResponse = client().admin().cluster().prepareHealth().setWaitForGreenStatus().get().     assertFalse(clusterHealthResponse.isTimedOut()).     client().admin().indices().preparePutTemplate("one_shard_index_template").setPatterns(Collections.singletonList("*")).setOrder(0).setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)).get().     client().admin().indices().preparePutTemplate("random-soft-deletes-template").setPatterns(Collections.singletonList("*")).setOrder(0).setSettings(Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), randomBoolean()).put(IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.getKey(), randomBoolean() ? IndexSettings.INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING.get(Settings.EMPTY) : between(0, 1000))).get(). }
false;private,static;0;5;;private static void stopNode() throws IOException {     Node node = NODE.     NODE = null.     IOUtils.close(node). }
false;public;0;11;;@Override public void setUp() throws Exception {     super.setUp().     // the seed has to be created regardless of whether it will be used or not, for repeatability     long seed = random().nextLong().     // only the cluster name. This allows us to have overridden properties for plugins and the version to use.     if (NODE == null) {         startNode(seed).     } }
false;public;0;20;;@Override public void tearDown() throws Exception {     logger.trace("[{}#{}]: cleaning up after test", getTestClass().getSimpleName(), getTestName()).     super.tearDown().     assertAcked(client().admin().indices().prepareDelete("*").get()).     MetaData metaData = client().admin().cluster().prepareState().get().getState().getMetaData().     assertThat("test leaves persistent cluster metadata behind: " + metaData.persistentSettings().keySet(), metaData.persistentSettings().size(), equalTo(0)).     assertThat("test leaves transient cluster metadata behind: " + metaData.transientSettings().keySet(), metaData.transientSettings().size(), equalTo(0)).     GetIndexResponse indices = client().admin().indices().prepareGetIndex().addIndices("*").get().     assertThat("test leaves indices that were not deleted: " + Strings.arrayToCommaDelimitedString(indices.indices()), indices.indices(), equalTo(Strings.EMPTY_ARRAY)).     if (resetNodeAfterTest()) {         assert NODE != null.         stopNode().         // the seed can be created within this if as it will either be executed before every test method or will never be.         startNode(random().nextLong()).     } }
false;public,static;0;4;;@BeforeClass public static void setUpClass() throws Exception {     stopNode(). }
false;public,static;0;4;;@AfterClass public static void tearDownClass() throws IOException {     stopNode(). }
true;protected;0;3;/**  * This method returns <code>true</code> if the node that is used in the background should be reset  * after each test. This is useful if the test changes the cluster state metadata etc. The default is  * <code>false</code>.  */ ;/**  * This method returns <code>true</code> if the node that is used in the background should be reset  * after each test. This is useful if the test changes the cluster state metadata etc. The default is  * <code>false</code>.  */ protected boolean resetNodeAfterTest() {     return false. }
true;protected;0;3;/**  * The plugin classes that should be added to the node.  */ ;/**  * The plugin classes that should be added to the node.  */ protected Collection<Class<? extends Plugin>> getPlugins() {     return Collections.emptyList(). }
true;protected,final;1;5;/**  * Helper method to create list of plugins without specifying generic types.  */ ;/**  * Helper method to create list of plugins without specifying generic types.  */ @SafeVarargs // due to type erasure, the varargs type is non-reifiable, which causes this warning @SuppressWarnings("varargs") protected final Collection<Class<? extends Plugin>> pluginList(Class<? extends Plugin>... plugins) {     return Arrays.asList(plugins). }
true;protected;0;3;/**  * Additional settings to add when creating the node. Also allows overriding the default settings.  */ ;/**  * Additional settings to add when creating the node. Also allows overriding the default settings.  */ protected Settings nodeSettings() {     return Settings.EMPTY. }
true;protected;0;3;/**  * True if a dummy http transport should be used, or false if the real http transport should be used.  */ ;/**  * True if a dummy http transport should be used, or false if the real http transport should be used.  */ protected boolean addMockHttpTransport() {     return true. }
false;private;0;45;;private Node newNode() {     final Path tempDir = createTempDir().     final String nodeName = nodeSettings().get(Node.NODE_NAME_SETTING.getKey(), "node_s_0").     Settings settings = Settings.builder().put(ClusterName.CLUSTER_NAME_SETTING.getKey(), InternalTestCluster.clusterName("single-node-cluster", random().nextLong())).put(Environment.PATH_HOME_SETTING.getKey(), tempDir).put(Environment.PATH_REPO_SETTING.getKey(), tempDir.resolve("repo")).put(Environment.PATH_SHARED_DATA_SETTING.getKey(), createTempDir().getParent()).put(Node.NODE_NAME_SETTING.getKey(), nodeName).put(ScriptService.SCRIPT_MAX_COMPILATIONS_RATE.getKey(), "1000/1m").put(EsExecutors.PROCESSORS_SETTING.getKey(), // limit the number of threads created     1).put("transport.type", getTestTransportType()).put(Node.NODE_DATA_SETTING.getKey(), true).put(NodeEnvironment.NODE_ID_SEED_SETTING.getKey(), random().nextLong()).put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), "1b").put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), "1b").put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), "1b").put(HierarchyCircuitBreakerService.USE_REAL_MEMORY_USAGE_SETTING.getKey(), false).putList(// empty list disables a port scan for other nodes     DISCOVERY_SEED_HOSTS_SETTING.getKey()).putList(INITIAL_MASTER_NODES_SETTING.getKey(), nodeName).put(// allow test cases to provide their own settings or override these     nodeSettings()).build().     Collection<Class<? extends Plugin>> plugins = getPlugins().     if (plugins.contains(getTestTransportPlugin()) == false) {         plugins = new ArrayList<>(plugins).         plugins.add(getTestTransportPlugin()).     }     if (addMockHttpTransport()) {         plugins.add(MockHttpTransport.TestPlugin.class).     }     Node node = new MockNode(settings, plugins, forbidPrivateIndexSettings()).     try {         node.start().     } catch (NodeValidationException e) {         throw new RuntimeException(e).     }     return node. }
true;public;0;3;/**  * Returns a client to the single-node cluster.  */ ;/**  * Returns a client to the single-node cluster.  */ public Client client() {     return wrapClient(NODE.client()). }
false;public;1;3;;public Client wrapClient(final Client client) {     return client. }
true;protected;0;3;/**  * Return a reference to the singleton node.  */ ;/**  * Return a reference to the singleton node.  */ protected Node node() {     return NODE. }
true;protected;1;3;/**  * Get an instance for a particular class using the injector of the singleton node.  */ ;/**  * Get an instance for a particular class using the injector of the singleton node.  */ protected <T> T getInstanceFromNode(Class<T> clazz) {     return NODE.injector().getInstance(clazz). }
true;protected;1;3;/**  * Create a new index on the singleton node with empty index settings.  */ ;/**  * Create a new index on the singleton node with empty index settings.  */ protected IndexService createIndex(String index) {     return createIndex(index, Settings.EMPTY). }
true;protected;2;3;/**  * Create a new index on the singleton node with the provided index settings.  */ ;/**  * Create a new index on the singleton node with the provided index settings.  */ protected IndexService createIndex(String index, Settings settings) {     return createIndex(index, settings, null, (XContentBuilder) null). }
true;protected;4;7;/**  * Create a new index on the singleton node with the provided index settings.  */ ;/**  * Create a new index on the singleton node with the provided index settings.  */ protected IndexService createIndex(String index, Settings settings, String type, XContentBuilder mappings) {     CreateIndexRequestBuilder createIndexRequestBuilder = client().admin().indices().prepareCreate(index).setSettings(settings).     if (type != null && mappings != null) {         createIndexRequestBuilder.addMapping(type, mappings).     }     return createIndex(index, createIndexRequestBuilder). }
true;protected;4;7;/**  * Create a new index on the singleton node with the provided index settings.  */ ;/**  * Create a new index on the singleton node with the provided index settings.  */ protected IndexService createIndex(String index, Settings settings, String type, Object... mappings) {     CreateIndexRequestBuilder createIndexRequestBuilder = client().admin().indices().prepareCreate(index).setSettings(settings).     if (type != null) {         createIndexRequestBuilder.addMapping(type, mappings).     }     return createIndex(index, createIndexRequestBuilder). }
false;protected;2;12;;protected IndexService createIndex(String index, CreateIndexRequestBuilder createIndexRequestBuilder) {     assertAcked(createIndexRequestBuilder.get()).     // Wait for the index to be allocated so that cluster state updates don't override     // changes that would have been done locally     ClusterHealthResponse health = client().admin().cluster().health(Requests.clusterHealthRequest(index).waitForYellowStatus().waitForEvents(Priority.LANGUID).waitForNoRelocatingShards(true)).actionGet().     assertThat(health.getStatus(), lessThanOrEqualTo(ClusterHealthStatus.YELLOW)).     assertThat("Cluster must be a single node cluster", health.getNumberOfDataNodes(), equalTo(1)).     IndicesService instanceFromNode = getInstanceFromNode(IndicesService.class).     return instanceFromNode.indexServiceSafe(resolveIndex(index)). }
false;public;1;6;;public Index resolveIndex(String index) {     GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(index).get().     assertTrue("index " + index + " not found", getIndexResponse.getSettings().containsKey(index)).     String uuid = getIndexResponse.getSettings().get(index).get(IndexMetaData.SETTING_INDEX_UUID).     return new Index(index, uuid). }
true;protected;1;4;/**  * Create a new search context.  */ ;/**  * Create a new search context.  */ protected SearchContext createSearchContext(IndexService indexService) {     BigArrays bigArrays = indexService.getBigArrays().     return new TestSearchContext(bigArrays, indexService). }
true;public;1;3;/**  * Ensures the cluster has a green state via the cluster health API. This method will also wait for relocations.  * It is useful to ensure that all action on the cluster have finished and all shards that were currently relocating  * are now allocated and started.  */ ;/**  * Ensures the cluster has a green state via the cluster health API. This method will also wait for relocations.  * It is useful to ensure that all action on the cluster have finished and all shards that were currently relocating  * are now allocated and started.  */ public ClusterHealthStatus ensureGreen(String... indices) {     return ensureGreen(TimeValue.timeValueSeconds(30), indices). }
true;public;2;13;/**  * Ensures the cluster has a green state via the cluster health API. This method will also wait for relocations.  * It is useful to ensure that all action on the cluster have finished and all shards that were currently relocating  * are now allocated and started.  *  * @param timeout time out value to set on {@link org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest}  */ ;/**  * Ensures the cluster has a green state via the cluster health API. This method will also wait for relocations.  * It is useful to ensure that all action on the cluster have finished and all shards that were currently relocating  * are now allocated and started.  *  * @param timeout time out value to set on {@link org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest}  */ public ClusterHealthStatus ensureGreen(TimeValue timeout, String... indices) {     ClusterHealthResponse actionGet = client().admin().cluster().health(Requests.clusterHealthRequest(indices).timeout(timeout).waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForNoRelocatingShards(true)).actionGet().     if (actionGet.isTimedOut()) {         logger.info("ensureGreen timed out, cluster state:\n{}\n{}", client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get()).         assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false)).     }     assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN)).     logger.debug("indices {} are green", indices.length == 0 ? "[_all]" : indices).     return actionGet.getStatus(). }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return getInstanceFromNode(NamedXContentRegistry.class). }
false;protected;0;3;;protected boolean forbidPrivateIndexSettings() {     return true. }
