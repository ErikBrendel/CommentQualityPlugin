commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@AfterClass public static void resetPortCounter() {     portGenerator.set(0). }
false;public;1;9;;@Override public void append(LogEvent event) {     String message = event.getMessage().getFormattedMessage().     if (Level.ERROR.equals(event.getLevel()) && message.contains("LEAK:")) {         synchronized (nettyLoggedLeaks) {             nettyLoggedLeaks.add(message).         }     } }
false;private,static;0;8;;@SuppressForbidden(reason = "force log4j and netty sysprops") private static void setTestSysProps() {     System.setProperty("log4j.shutdownHookEnabled", "false").     System.setProperty("log4j2.disable.jmx", "true").     // Enable Netty leak detection and monitor logger for logged leak errors     System.setProperty("io.netty.leakDetection.level", "paranoid"). }
false;protected;0;4;;@Override protected void afterIfSuccessful() throws Throwable {     ESTestCase.this.afterIfSuccessful(). }
false;protected;1;16;;@Override protected void afterAlways(List<Throwable> errors) throws Throwable {     if (errors != null && errors.isEmpty() == false) {         boolean allAssumption = true.         for (Throwable error : errors) {             if (false == error instanceof AssumptionViolatedException) {                 allAssumption = false.                 break.             }         }         if (false == allAssumption) {             ESTestCase.this.afterIfFailed(errors).         }     }     super.afterAlways(errors). }
true;public,static;0;3;/**  * Generates a new transport address using {@link TransportAddress#META_ADDRESS} with an incrementing port number.  * The port number starts at 0 and is reset after each test suite run.  */ ;/**  * Generates a new transport address using {@link TransportAddress#META_ADDRESS} with an incrementing port number.  * The port number starts at 0 and is reset after each test suite run.  */ public static TransportAddress buildNewFakeTransportAddress() {     return new TransportAddress(TransportAddress.META_ADDRESS, portGenerator.incrementAndGet()). }
true;protected;1;2;/**  * Called when a test fails, supplying the errors it generated. Not called when the test fails because assumptions are violated.  */ ;/**  * Called when a test fails, supplying the errors it generated. Not called when the test fails because assumptions are violated.  */ protected void afterIfFailed(List<Throwable> errors) { }
true;protected;0;2;/**  * called after a test is finished, but only if successful  */ ;/**  * called after a test is finished, but only if successful  */ protected void afterIfSuccessful() throws Exception { }
false;public,static;0;4;;// setup mock filesystems for this test run. we change PathUtils // so that all accesses are plumbed thru any mock wrappers @BeforeClass public static void setFileSystem() throws Exception {     PathUtilsForTesting.setup(). }
false;public,static;0;4;;@AfterClass public static void restoreFileSystem() throws Exception {     PathUtilsForTesting.teardown(). }
false;public,static;0;5;;// randomize content type for request builders @BeforeClass public static void setContentType() throws Exception {     Requests.CONTENT_TYPE = randomFrom(XContentType.values()).     Requests.INDEX_CONTENT_TYPE = randomFrom(XContentType.values()). }
false;public,static;0;5;;@AfterClass public static void restoreContentType() {     Requests.CONTENT_TYPE = XContentType.SMILE.     Requests.INDEX_CONTENT_TYPE = XContentType.JSON. }
false;public,static;0;9;;@BeforeClass public static void ensureSupportedLocale() {     if (isUnusableLocale()) {         Logger logger = LogManager.getLogger(ESTestCase.class).         logger.warn("Attempting to run tests in an unusable locale in a FIPS JVM. Certificate expiration validation will fail, " + "switching to English. See: https://github.com/bcgit/bc-java/issues/405").         Locale.setDefault(Locale.ENGLISH).     } }
false;public,final;0;9;;@Before public final void before() {     logger.info("{}before test", getTestParamsForLogging()).     assertNull("Thread context initialized twice", threadContext).     if (enableWarningsCheck()) {         this.threadContext = new ThreadContext(Settings.EMPTY).         DeprecationLogger.setThreadContext(threadContext).     } }
true;protected;0;3;/**  * Whether or not we check after each test whether it has left warnings behind. That happens if any deprecated feature or syntax  * was used by the test and the test didn't assert on it using {@link #assertWarnings(String...)}.  */ ;/**  * Whether or not we check after each test whether it has left warnings behind. That happens if any deprecated feature or syntax  * was used by the test and the test didn't assert on it using {@link #assertWarnings(String...)}.  */ protected boolean enableWarningsCheck() {     return true. }
false;public,final;0;15;;@After public final void after() throws Exception {     checkStaticState(false).     // initialized     if (threadContext != null) {         ensureNoWarnings().         assert threadContext == null.     }     ensureAllSearchContextsReleased().     ensureCheckIndexPassed().     logger.info("{}after test", getTestParamsForLogging()). }
false;private;0;8;;private String getTestParamsForLogging() {     String name = getTestName().     int start = name.indexOf('{').     if (start < 0)         return "".     int end = name.lastIndexOf('}').     if (end < 0)         return "".     return "[" + name.substring(start + 1, end) + "] ". }
false;private;0;10;;private void ensureNoWarnings() {     // appropriate test     try {         final List<String> warnings = threadContext.getResponseHeaders().get("Warning").         assertNull("unexpected warning headers", warnings).     } finally {         resetDeprecationLogger(false).     } }
true;protected,final;2;3;/**  * Convenience method to assert warnings for settings deprecations and general deprecation warnings.  *  * @param settings the settings that are expected to be deprecated  * @param warnings other expected general deprecation warnings  */ ;/**  * Convenience method to assert warnings for settings deprecations and general deprecation warnings.  *  * @param settings the settings that are expected to be deprecated  * @param warnings other expected general deprecation warnings  */ protected final void assertSettingDeprecationsAndWarnings(final Setting<?>[] settings, final String... warnings) {     assertSettingDeprecationsAndWarnings(Arrays.stream(settings).map(Setting::getKey).toArray(String[]::new), warnings). }
false;protected,final;2;10;;protected final void assertSettingDeprecationsAndWarnings(final String[] settings, final String... warnings) {     assertWarnings(Stream.concat(Arrays.stream(settings).map(k -> "[" + k + "] setting was deprecated in Elasticsearch and will be removed in a future release! " + "See the breaking changes documentation for the next major version."), Arrays.stream(warnings)).toArray(String[]::new)). }
false;protected,final;1;19;;protected final void assertWarnings(String... expectedWarnings) {     if (enableWarningsCheck() == false) {         throw new IllegalStateException("unable to check warning headers if the test is not set to do so").     }     try {         final List<String> actualWarnings = threadContext.getResponseHeaders().get("Warning").         assertNotNull("no warnings, expected: " + Arrays.asList(expectedWarnings), actualWarnings).         final Set<String> actualWarningValues = actualWarnings.stream().map(DeprecationLogger::extractWarningValueFromWarningHeader).collect(Collectors.toSet()).         for (String msg : expectedWarnings) {             assertThat(actualWarningValues, hasItem(DeprecationLogger.escapeAndEncode(msg))).         }         assertEquals("Expected " + expectedWarnings.length + " warnings but found " + actualWarnings.size() + "\nExpected: " + Arrays.asList(expectedWarnings) + "\nActual: " + actualWarnings, expectedWarnings.length, actualWarnings.size()).     } finally {         resetDeprecationLogger(true).     } }
true;private;1;17;/**  * Reset the deprecation logger by removing the current thread context, and setting a new thread context if {@code setNewThreadContext}  * is set to {@code true} and otherwise clearing the current thread context.  *  * @param setNewThreadContext whether or not to attach a new thread context to the deprecation logger  */ ;/**  * Reset the deprecation logger by removing the current thread context, and setting a new thread context if {@code setNewThreadContext}  * is set to {@code true} and otherwise clearing the current thread context.  *  * @param setNewThreadContext whether or not to attach a new thread context to the deprecation logger  */ private void resetDeprecationLogger(final boolean setNewThreadContext) {     // "clear" current warning headers by setting a new ThreadContext     DeprecationLogger.removeThreadContext(this.threadContext).     try {         this.threadContext.close().     // catch IOException to avoid that call sites have to deal with it. It is only declared because this class implements Closeable     // but it is impossible that this implementation will ever throw an IOException.     } catch (IOException ex) {         throw new AssertionError("IOException thrown while closing deprecation logger's thread context", ex).     }     if (setNewThreadContext) {         this.threadContext = new ThreadContext(Settings.EMPTY).         DeprecationLogger.setThreadContext(this.threadContext).     } else {         this.threadContext = null.     } }
false;public;1;6;;@Override public void log(StatusData data) {     synchronized (statusData) {         statusData.add(data).     } }
true;protected,static;1;28;// separate method so that this can be checked again after suite scoped cluster is shut down ;// separate method so that this can be checked again after suite scoped cluster is shut down protected static void checkStaticState(boolean afterClass) throws Exception {     if (afterClass) {         MockPageCacheRecycler.ensureAllPagesAreReleased().     }     MockBigArrays.ensureAllArraysAreReleased().     // ensure no one changed the status logger level on us     assertThat(StatusLogger.getLogger().getLevel(), equalTo(Level.WARN)).     synchronized (statusData) {         try {             // ensure that there are no status logger messages which would indicate a problem with our Log4j usage. we map the             // StatusData instances to Strings as otherwise their toString output is useless             assertThat(statusData.stream().map(status -> status.getMessage().getFormattedMessage()).collect(Collectors.toList()), empty()).         } finally {             // we clear the list so that status data from other tests do not interfere with tests within the same JVM             statusData.clear().         }     }     synchronized (nettyLoggedLeaks) {         try {             assertThat(nettyLoggedLeaks, empty()).         } finally {             nettyLoggedLeaks.clear().         }     } }
true;public,final;0;3;// this must be a separate method from other ensure checks above so suite scoped integ tests can call...TODO: fix that ;// this must be a separate method from other ensure checks above so suite scoped integ tests can call...TODO: fix that public final void ensureAllSearchContextsReleased() throws Exception {     assertBusy(() -> MockSearchService.assertNoInFlightContext()). }
false;public,final;0;4;;@Before public final void resetCheckIndexStatus() throws Exception {     checkIndexFailed = false. }
false;public,final;0;3;;public final void ensureCheckIndexPassed() {     assertFalse("at least one shard failed CheckIndex", checkIndexFailed). }
true;public,static;2;3;/**  * Returns a "scaled" random number between min and max (inclusive).  *  * @see RandomizedTest#scaledRandomIntBetween(int, int)  */ ;// ----------------------------------------------------------------- // Test facilities and facades for subclasses. // ----------------------------------------------------------------- // TODO: decide on one set of naming for between/scaledBetween and remove others // TODO: replace frequently() with usually() /**  * Returns a "scaled" random number between min and max (inclusive).  *  * @see RandomizedTest#scaledRandomIntBetween(int, int)  */ public static int scaledRandomIntBetween(int min, int max) {     return RandomizedTest.scaledRandomIntBetween(min, max). }
true;public,static;2;3;/**  * A random integer from <code>min</code> to <code>max</code> (inclusive).  *  * @see #scaledRandomIntBetween(int, int)  */ ;/**  * A random integer from <code>min</code> to <code>max</code> (inclusive).  *  * @see #scaledRandomIntBetween(int, int)  */ public static int randomIntBetween(int min, int max) {     return RandomNumbers.randomIntBetween(random(), min, max). }
true;public,static;2;3;/**  * A random long number between min (inclusive) and max (inclusive).  */ ;/**  * A random long number between min (inclusive) and max (inclusive).  */ public static long randomLongBetween(long min, long max) {     return RandomNumbers.randomLongBetween(random(), min, max). }
true;public,static;2;3;/**  * Returns a "scaled" number of iterations for loops which can have a variable  * iteration count. This method is effectively  * an alias to {@link #scaledRandomIntBetween(int, int)}.  */ ;/**  * Returns a "scaled" number of iterations for loops which can have a variable  * iteration count. This method is effectively  * an alias to {@link #scaledRandomIntBetween(int, int)}.  */ public static int iterations(int min, int max) {     return scaledRandomIntBetween(min, max). }
true;public,static;2;3;/**  * An alias for {@link #randomIntBetween(int, int)}.  *  * @see #scaledRandomIntBetween(int, int)  */ ;/**  * An alias for {@link #randomIntBetween(int, int)}.  *  * @see #scaledRandomIntBetween(int, int)  */ public static int between(int min, int max) {     return randomIntBetween(min, max). }
true;public,static;0;3;/**  * The exact opposite of {@link #rarely()}.  */ ;/**  * The exact opposite of {@link #rarely()}.  */ public static boolean frequently() {     return !rarely(). }
false;public,static;0;3;;public static boolean randomBoolean() {     return random().nextBoolean(). }
false;public,static;0;3;;public static byte randomByte() {     return (byte) random().nextInt(). }
true;public,static;1;7;/**  * Helper method to create a byte array of a given length populated with random byte values  *  * @see #randomByte()  */ ;/**  * Helper method to create a byte array of a given length populated with random byte values  *  * @see #randomByte()  */ public static byte[] randomByteArrayOfLength(int size) {     byte[] bytes = new byte[size].     for (int i = 0. i < size. i++) {         bytes[i] = randomByte().     }     return bytes. }
false;public,static;0;3;;public static short randomShort() {     return (short) random().nextInt(). }
false;public,static;0;3;;public static int randomInt() {     return random().nextInt(). }
true;public,static;0;4;/**  * @return a <code>long</code> between <code>0</code> and <code>Long.MAX_VALUE</code> (inclusive) chosen uniformly at random.  */ ;/**  * @return a <code>long</code> between <code>0</code> and <code>Long.MAX_VALUE</code> (inclusive) chosen uniformly at random.  */ public static long randomNonNegativeLong() {     long randomLong = randomLong().     return randomLong == Long.MIN_VALUE ? 0 : Math.abs(randomLong). }
false;public,static;0;3;;public static float randomFloat() {     return random().nextFloat(). }
false;public,static;0;3;;public static double randomDouble() {     return random().nextDouble(). }
true;public,static;3;20;/**  * Returns a double value in the interval [start, end) if lowerInclusive is  * set to true, (start, end) otherwise.  *  * @param start          lower bound of interval to draw uniformly distributed random numbers from  * @param end            upper bound  * @param lowerInclusive whether or not to include lower end of the interval  */ ;/**  * Returns a double value in the interval [start, end) if lowerInclusive is  * set to true, (start, end) otherwise.  *  * @param start          lower bound of interval to draw uniformly distributed random numbers from  * @param end            upper bound  * @param lowerInclusive whether or not to include lower end of the interval  */ public static double randomDoubleBetween(double start, double end, boolean lowerInclusive) {     double result = 0.0.     if (start == -Double.MAX_VALUE || end == Double.MAX_VALUE) {         // formula below does not work with very large doubles         result = Double.longBitsToDouble(randomLong()).         while (result < start || result > end || Double.isNaN(result)) {             result = Double.longBitsToDouble(randomLong()).         }     } else {         result = randomDouble().         if (lowerInclusive == false) {             while (result <= 0.0) {                 result = randomDouble().             }         }         result = result * end + (1.0 - result) * start.     }     return result. }
false;public,static;0;3;;public static long randomLong() {     return random().nextLong(). }
true;public,static;1;3;/**  * A random integer from 0..max (inclusive).  */ ;/**  * A random integer from 0..max (inclusive).  */ public static int randomInt(int max) {     return RandomizedTest.randomInt(max). }
true;public,static;1;3;/**  * Pick a random object from the given array. The array must not be empty.  */ ;/**  * Pick a random object from the given array. The array must not be empty.  */ public static <T> T randomFrom(T... array) {     return randomFrom(random(), array). }
true;public,static;2;3;/**  * Pick a random object from the given array. The array must not be empty.  */ ;/**  * Pick a random object from the given array. The array must not be empty.  */ public static <T> T randomFrom(Random random, T... array) {     return RandomPicks.randomFrom(random, array). }
true;public,static;1;3;/**  * Pick a random object from the given list.  */ ;/**  * Pick a random object from the given list.  */ public static <T> T randomFrom(List<T> list) {     return RandomPicks.randomFrom(random(), list). }
true;public,static;1;3;/**  * Pick a random object from the given collection.  */ ;/**  * Pick a random object from the given collection.  */ public static <T> T randomFrom(Collection<T> collection) {     return randomFrom(random(), collection). }
true;public,static;2;3;/**  * Pick a random object from the given collection.  */ ;/**  * Pick a random object from the given collection.  */ public static <T> T randomFrom(Random random, Collection<T> collection) {     return RandomPicks.randomFrom(random, collection). }
false;public,static;2;3;;public static String randomAlphaOfLengthBetween(int minCodeUnits, int maxCodeUnits) {     return RandomizedTest.randomAsciiOfLengthBetween(minCodeUnits, maxCodeUnits). }
false;public,static;1;3;;public static String randomAlphaOfLength(int codeUnits) {     return RandomizedTest.randomAsciiOfLength(codeUnits). }
false;public,static;2;3;;public static String randomUnicodeOfLengthBetween(int minCodeUnits, int maxCodeUnits) {     return RandomizedTest.randomUnicodeOfLengthBetween(minCodeUnits, maxCodeUnits). }
false;public,static;1;3;;public static String randomUnicodeOfLength(int codeUnits) {     return RandomizedTest.randomUnicodeOfLength(codeUnits). }
false;public,static;2;3;;public static String randomUnicodeOfCodepointLengthBetween(int minCodePoints, int maxCodePoints) {     return RandomizedTest.randomUnicodeOfCodepointLengthBetween(minCodePoints, maxCodePoints). }
false;public,static;1;3;;public static String randomUnicodeOfCodepointLength(int codePoints) {     return RandomizedTest.randomUnicodeOfCodepointLength(codePoints). }
false;public,static;2;3;;public static String randomRealisticUnicodeOfLengthBetween(int minCodeUnits, int maxCodeUnits) {     return RandomizedTest.randomRealisticUnicodeOfLengthBetween(minCodeUnits, maxCodeUnits). }
false;public,static;1;3;;public static String randomRealisticUnicodeOfLength(int codeUnits) {     return RandomizedTest.randomRealisticUnicodeOfLength(codeUnits). }
false;public,static;2;3;;public static String randomRealisticUnicodeOfCodepointLengthBetween(int minCodePoints, int maxCodePoints) {     return RandomizedTest.randomRealisticUnicodeOfCodepointLengthBetween(minCodePoints, maxCodePoints). }
false;public,static;1;3;;public static String randomRealisticUnicodeOfCodepointLength(int codePoints) {     return RandomizedTest.randomRealisticUnicodeOfCodepointLength(codePoints). }
false;public,static;4;11;;public static String[] generateRandomStringArray(int maxArraySize, int stringSize, boolean allowNull, boolean allowEmpty) {     if (allowNull && random().nextBoolean()) {         return null.     }     int arraySize = randomIntBetween(allowEmpty ? 0 : 1, maxArraySize).     String[] array = new String[arraySize].     for (int i = 0. i < arraySize. i++) {         array[i] = RandomStrings.randomAsciiOfLength(random(), stringSize).     }     return array. }
false;public,static;3;3;;public static String[] generateRandomStringArray(int maxArraySize, int stringSize, boolean allowNull) {     return generateRandomStringArray(maxArraySize, stringSize, allowNull, true). }
false;public,static;3;3;;public static <T> T[] randomArray(int maxArraySize, IntFunction<T[]> arrayConstructor, Supplier<T> valueConstructor) {     return randomArray(0, maxArraySize, arrayConstructor, valueConstructor). }
false;public,static;4;8;;public static <T> T[] randomArray(int minArraySize, int maxArraySize, IntFunction<T[]> arrayConstructor, Supplier<T> valueConstructor) {     final int size = randomIntBetween(minArraySize, maxArraySize).     final T[] array = arrayConstructor.apply(size).     for (int i = 0. i < array.length. i++) {         array[i] = valueConstructor.get().     }     return array. }
false;public,static;3;3;;public static String randomTimeValue(int lower, int upper, String... suffixes) {     return randomIntBetween(lower, upper) + randomFrom(suffixes). }
false;public,static;2;3;;public static String randomTimeValue(int lower, int upper) {     return randomTimeValue(lower, upper, TIME_SUFFIXES). }
false;public,static;0;3;;public static String randomTimeValue() {     return randomTimeValue(0, 1000). }
false;public,static;0;3;;public static String randomPositiveTimeValue() {     return randomTimeValue(1, 1000). }
true;public,static;0;3;/**  * generate a random DateTimeZone from the ones available in joda library  */ ;/**  * generate a random DateTimeZone from the ones available in joda library  */ public static DateTimeZone randomDateTimeZone() {     return DateTimeZone.forID(randomFrom(JODA_TIMEZONE_IDS)). }
true;public,static;0;3;/**  * generate a random TimeZone from the ones available in java.util  */ ;/**  * generate a random TimeZone from the ones available in java.util  */ public static TimeZone randomTimeZone() {     return TimeZone.getTimeZone(randomFrom(JAVA_TIMEZONE_IDS)). }
true;public,static;0;13;/**  * generate a random TimeZone from the ones available in java.time  */ ;/**  * generate a random TimeZone from the ones available in java.time  */ public static ZoneId randomZone() {     // see https://bugs.openjdk.java.net/browse/JDK-8138664     if (JavaVersion.current().getVersion().get(0) == 8) {         ZoneId timeZone.         do {             timeZone = ZoneId.of(randomFrom(JAVA_ZONE_IDS)).         } while (timeZone.equals(ZoneId.of("GMT0"))).         return timeZone.     } else {         return ZoneId.of(randomFrom(JAVA_ZONE_IDS)).     } }
true;public,static;2;5;/**  * helper to randomly perform on <code>consumer</code> with <code>value</code>  */ ;/**  * helper to randomly perform on <code>consumer</code> with <code>value</code>  */ public static <T> void maybeSet(Consumer<T> consumer, T value) {     if (randomBoolean()) {         consumer.accept(value).     } }
true;public,static;2;3;/**  * helper to get a random value in a certain range that's different from the input  */ ;/**  * helper to get a random value in a certain range that's different from the input  */ public static <T> T randomValueOtherThan(T input, Supplier<T> randomSupplier) {     return randomValueOtherThanMany(v -> Objects.equals(input, v), randomSupplier). }
true;public,static;2;7;/**  * helper to get a random value in a certain range that's different from the input  */ ;/**  * helper to get a random value in a certain range that's different from the input  */ public static <T> T randomValueOtherThanMany(Predicate<T> input, Supplier<T> randomSupplier) {     T randomValue = null.     do {         randomValue = randomSupplier.get().     } while (input.test(randomValue)).     return randomValue. }
true;public,static;1;3;/**  * Runs the code block for 10 seconds waiting for no assertion to trip.  */ ;/**  * Runs the code block for 10 seconds waiting for no assertion to trip.  */ public static void assertBusy(CheckedRunnable<Exception> codeBlock) throws Exception {     assertBusy(codeBlock, 10, TimeUnit.SECONDS). }
true;public,static;3;28;/**  * Runs the code block for the provided interval, waiting for no assertions to trip.  */ ;/**  * Runs the code block for the provided interval, waiting for no assertions to trip.  */ public static void assertBusy(CheckedRunnable<Exception> codeBlock, long maxWaitTime, TimeUnit unit) throws Exception {     long maxTimeInMillis = TimeUnit.MILLISECONDS.convert(maxWaitTime, unit).     long iterations = Math.max(Math.round(Math.log10(maxTimeInMillis) / Math.log10(2)), 1).     long timeInMillis = 1.     long sum = 0.     List<AssertionError> failures = new ArrayList<>().     for (int i = 0. i < iterations. i++) {         try {             codeBlock.run().             return.         } catch (AssertionError e) {             failures.add(e).         }         sum += timeInMillis.         Thread.sleep(timeInMillis).         timeInMillis *= 2.     }     timeInMillis = maxTimeInMillis - sum.     Thread.sleep(Math.max(timeInMillis, 0)).     try {         codeBlock.run().     } catch (AssertionError e) {         for (AssertionError failure : failures) {             e.addSuppressed(failure).         }         throw e.     } }
false;public,static;1;3;;public static boolean awaitBusy(BooleanSupplier breakSupplier) throws InterruptedException {     return awaitBusy(breakSupplier, 10, TimeUnit.SECONDS). }
false;public,static;3;16;;public static boolean awaitBusy(BooleanSupplier breakSupplier, long maxWaitTime, TimeUnit unit) throws InterruptedException {     long maxTimeInMillis = TimeUnit.MILLISECONDS.convert(maxWaitTime, unit).     long timeInMillis = 1.     long sum = 0.     while (sum + timeInMillis < maxTimeInMillis) {         if (breakSupplier.getAsBoolean()) {             return true.         }         Thread.sleep(timeInMillis).         sum += timeInMillis.         timeInMillis = Math.min(AWAIT_BUSY_THRESHOLD, timeInMillis * 2).     }     timeInMillis = maxTimeInMillis - sum.     Thread.sleep(Math.max(timeInMillis, 0)).     return breakSupplier.getAsBoolean(). }
false;public,static;1;9;;public static boolean terminate(ExecutorService... services) {     boolean terminated = true.     for (ExecutorService service : services) {         if (service != null) {             terminated &= ThreadPool.terminate(service, 10, TimeUnit.SECONDS).         }     }     return terminated. }
false;public,static;1;3;;public static boolean terminate(ThreadPool threadPool) {     return ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS). }
true;public;1;11;/**  * Returns a {@link java.nio.file.Path} pointing to the class path relative resource given  * as the first argument. In contrast to  * <code>getClass().getResource(...).getFile()</code> this method will not  * return URL encoded paths if the parent path contains spaces or other  * non-standard characters.  */ ;/**  * Returns a {@link java.nio.file.Path} pointing to the class path relative resource given  * as the first argument. In contrast to  * <code>getClass().getResource(...).getFile()</code> this method will not  * return URL encoded paths if the parent path contains spaces or other  * non-standard characters.  */ @Override public Path getDataPath(String relativePath) {     // (e.g. FileSystemUtils, and likely some tests)     try {         return PathUtils.get(getClass().getResource(relativePath).toURI()).     } catch (Exception e) {         throw new RuntimeException("resource not found: " + relativePath, e).     } }
false;public;0;3;;public Path getBwcIndicesPath() {     return getDataPath("/indices/bwc"). }
true;public;0;8;/**  * Returns a random number of temporary paths.  */ ;/**  * Returns a random number of temporary paths.  */ public String[] tmpPaths() {     final int numPaths = TestUtil.nextInt(random(), 1, 3).     final String[] absPaths = new String[numPaths].     for (int i = 0. i < numPaths. i++) {         absPaths[i] = createTempDir().toAbsolutePath().toString().     }     return absPaths. }
false;public;0;3;;public NodeEnvironment newNodeEnvironment() throws IOException {     return newNodeEnvironment(Settings.EMPTY). }
false;public;1;6;;public Settings buildEnvSettings(Settings settings) {     return Settings.builder().put(settings).put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toAbsolutePath()).putList(Environment.PATH_DATA_SETTING.getKey(), tmpPaths()).build(). }
false;public;1;4;;public NodeEnvironment newNodeEnvironment(Settings settings) throws IOException {     Settings build = buildEnvSettings(settings).     return new NodeEnvironment(build, TestEnvironment.newEnvironment(build)). }
true;public,static;1;4;/**  * Return consistent index settings for the provided index version.  */ ;/**  * Return consistent index settings for the provided index version.  */ public static Settings.Builder settings(Version version) {     Settings.Builder builder = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, version).     return builder. }
true;public,static;2;4;/**  * Returns size random values  */ ;/**  * Returns size random values  */ public static <T> List<T> randomSubsetOf(int size, T... values) {     List<T> list = arrayAsArrayList(values).     return randomSubsetOf(size, list). }
true;public,static;1;3;/**  * Returns a random subset of values (including a potential empty list, or the full original list)  */ ;/**  * Returns a random subset of values (including a potential empty list, or the full original list)  */ public static <T> List<T> randomSubsetOf(Collection<T> collection) {     return randomSubsetOf(randomInt(collection.size()), collection). }
true;public,static;2;9;/**  * Returns size random values  */ ;/**  * Returns size random values  */ public static <T> List<T> randomSubsetOf(int size, Collection<T> collection) {     if (size > collection.size()) {         throw new IllegalArgumentException("Can\'t pick " + size + " random objects from a collection of " + collection.size() + " objects").     }     List<T> tempList = new ArrayList<>(collection).     Collections.shuffle(tempList, random()).     return tempList.subList(0, size). }
true;public,static;2;12;/**  * Builds a set of unique items. Usually you'll get the requested count but you might get less than that number if the supplier returns  * lots of repeats. Make sure that the items properly implement equals and hashcode.  */ ;/**  * Builds a set of unique items. Usually you'll get the requested count but you might get less than that number if the supplier returns  * lots of repeats. Make sure that the items properly implement equals and hashcode.  */ public static <T> Set<T> randomUnique(Supplier<T> supplier, int targetCount) {     Set<T> things = new HashSet<>().     int maxTries = targetCount * 10.     for (int t = 0. t < maxTries. t++) {         if (things.size() == targetCount) {             return things.         }         things.add(supplier.get()).     }     // Oh well, we didn't get enough unique things. It'll be ok.     return things. }
false;public,static;2;3;;public static String randomGeohash(int minPrecision, int maxPrecision) {     return geohashGenerator.ofStringLength(random(), minPrecision, maxPrecision). }
false;public,static;0;3;;public static String getTestTransportType() {     return MockNioTransportPlugin.MOCK_NIO_TRANSPORT_NAME. }
false;public,static;0;3;;public static Class<? extends Plugin> getTestTransportPlugin() {     return MockNioTransportPlugin.class. }
true;protected,final;5;4;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns. Shuffles the keys to make sure that parsing never relies on keys ordering.  */ ;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns. Shuffles the keys to make sure that parsing never relies on keys ordering.  */ protected final BytesReference toShuffledXContent(ToXContent toXContent, XContentType xContentType, ToXContent.Params params, boolean humanReadable, String... exceptFieldNames) throws IOException {     return toShuffledXContent(toXContent, xContentType, params, humanReadable, this::createParser, exceptFieldNames). }
true;protected,static;6;12;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns. Shuffles the keys to make sure that parsing never relies on keys ordering.  */ ;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns. Shuffles the keys to make sure that parsing never relies on keys ordering.  */ protected static BytesReference toShuffledXContent(ToXContent toXContent, XContentType xContentType, ToXContent.Params params, boolean humanReadable, CheckedBiFunction<XContent, BytesReference, XContentParser, IOException> parserFunction, String... exceptFieldNames) throws IOException {     BytesReference bytes = XContentHelper.toXContent(toXContent, xContentType, params, humanReadable).     try (XContentParser parser = parserFunction.apply(xContentType.xContent(), bytes)) {         try (XContentBuilder builder = shuffleXContent(parser, rarely(), exceptFieldNames)) {             return BytesReference.bytes(builder).         }     } }
true;protected,final;2;5;/**  * Randomly shuffles the fields inside objects in the {@link XContentBuilder} passed in.  * Recursively goes through inner objects and also shuffles them. Exceptions for this  * recursive shuffling behavior can be made by passing in the names of fields which  * internally should stay untouched.  */ ;/**  * Randomly shuffles the fields inside objects in the {@link XContentBuilder} passed in.  * Recursively goes through inner objects and also shuffles them. Exceptions for this  * recursive shuffling behavior can be made by passing in the names of fields which  * internally should stay untouched.  */ protected final XContentBuilder shuffleXContent(XContentBuilder builder, String... exceptFieldNames) throws IOException {     try (XContentParser parser = createParser(builder)) {         return shuffleXContent(parser, builder.isPrettyPrint(), exceptFieldNames).     } }
true;public,static;3;16;/**  * Randomly shuffles the fields inside objects parsed using the {@link XContentParser} passed in.  * Recursively goes through inner objects and also shuffles them. Exceptions for this  * recursive shuffling behavior can be made by passing in the names of fields which  * internally should stay untouched.  */ ;/**  * Randomly shuffles the fields inside objects parsed using the {@link XContentParser} passed in.  * Recursively goes through inner objects and also shuffles them. Exceptions for this  * recursive shuffling behavior can be made by passing in the names of fields which  * internally should stay untouched.  */ public static XContentBuilder shuffleXContent(XContentParser parser, boolean prettyPrint, String... exceptFieldNames) throws IOException {     XContentBuilder xContentBuilder = XContentFactory.contentBuilder(parser.contentType()).     if (prettyPrint) {         xContentBuilder.prettyPrint().     }     Token token = parser.currentToken() == null ? parser.nextToken() : parser.currentToken().     if (token == Token.START_ARRAY) {         List<Object> shuffledList = shuffleList(parser.listOrderedMap(), new HashSet<>(Arrays.asList(exceptFieldNames))).         return xContentBuilder.value(shuffledList).     }     // we need a sorted map for reproducibility, as we are going to shuffle its keys and write XContent back     Map<String, Object> shuffledMap = shuffleMap((LinkedHashMap<String, Object>) parser.mapOrdered(), new HashSet<>(Arrays.asList(exceptFieldNames))).     return xContentBuilder.map(shuffledMap). }
true;private,static;2;15;// shuffle fields of objects in the list, but not the list itself ;// shuffle fields of objects in the list, but not the list itself @SuppressWarnings("unchecked") private static List<Object> shuffleList(List<Object> list, Set<String> exceptFields) {     List<Object> targetList = new ArrayList<>().     for (Object value : list) {         if (value instanceof Map) {             LinkedHashMap<String, Object> valueMap = (LinkedHashMap<String, Object>) value.             targetList.add(shuffleMap(valueMap, exceptFields)).         } else if (value instanceof List) {             targetList.add(shuffleList((List) value, exceptFields)).         } else {             targetList.add(value).         }     }     return targetList. }
false;public,static;2;18;;@SuppressWarnings("unchecked") public static LinkedHashMap<String, Object> shuffleMap(LinkedHashMap<String, Object> map, Set<String> exceptFields) {     List<String> keys = new ArrayList<>(map.keySet()).     LinkedHashMap<String, Object> targetMap = new LinkedHashMap<>().     Collections.shuffle(keys, random()).     for (String key : keys) {         Object value = map.get(key).         if (value instanceof Map && exceptFields.contains(key) == false) {             LinkedHashMap<String, Object> valueMap = (LinkedHashMap<String, Object>) value.             targetMap.put(key, shuffleMap(valueMap, exceptFields)).         } else if (value instanceof List && exceptFields.contains(key) == false) {             targetMap.put(key, shuffleList((List) value, exceptFields)).         } else {             targetMap.put(key, value).         }     }     return targetMap. }
true;public,static;3;4;/**  * Create a copy of an original {@link Writeable} object by running it through a {@link BytesStreamOutput} and  * reading it in again using a provided {@link Writeable.Reader}. The stream that is wrapped around the {@link StreamInput}  * potentially need to use a {@link NamedWriteableRegistry}, so this needs to be provided too (although it can be  * empty if the object that is streamed doesn't contain any {@link NamedWriteable} objects itself.  */ ;/**  * Create a copy of an original {@link Writeable} object by running it through a {@link BytesStreamOutput} and  * reading it in again using a provided {@link Writeable.Reader}. The stream that is wrapped around the {@link StreamInput}  * potentially need to use a {@link NamedWriteableRegistry}, so this needs to be provided too (although it can be  * empty if the object that is streamed doesn't contain any {@link NamedWriteable} objects itself.  */ public static <T extends Writeable> T copyWriteable(T original, NamedWriteableRegistry namedWriteableRegistry, Writeable.Reader<T> reader) throws IOException {     return copyWriteable(original, namedWriteableRegistry, reader, Version.CURRENT). }
true;public,static;4;4;/**  * Same as {@link #copyWriteable(Writeable, NamedWriteableRegistry, Writeable.Reader)} but also allows to provide  * a {@link Version} argument which will be used to write and read back the object.  */ ;/**  * Same as {@link #copyWriteable(Writeable, NamedWriteableRegistry, Writeable.Reader)} but also allows to provide  * a {@link Version} argument which will be used to write and read back the object.  */ public static <T extends Writeable> T copyWriteable(T original, NamedWriteableRegistry namedWriteableRegistry, Writeable.Reader<T> reader, Version version) throws IOException {     return copyInstance(original, namedWriteableRegistry, (out, value) -> value.writeTo(out), reader, version). }
true;public,static;4;5;/**  * Create a copy of an original {@link Streamable} object by running it through a {@link BytesStreamOutput} and  * reading it in again using a provided {@link Writeable.Reader}. The stream that is wrapped around the {@link StreamInput}  * potentially need to use a {@link NamedWriteableRegistry}, so this needs to be provided too (although it can be  * empty if the object that is streamed doesn't contain any {@link NamedWriteable} objects itself.  */ ;/**  * Create a copy of an original {@link Streamable} object by running it through a {@link BytesStreamOutput} and  * reading it in again using a provided {@link Writeable.Reader}. The stream that is wrapped around the {@link StreamInput}  * potentially need to use a {@link NamedWriteableRegistry}, so this needs to be provided too (although it can be  * empty if the object that is streamed doesn't contain any {@link NamedWriteable} objects itself.  */ public static <T extends Streamable> T copyStreamable(T original, NamedWriteableRegistry namedWriteableRegistry, Supplier<T> supplier, Version version) throws IOException {     return copyInstance(original, namedWriteableRegistry, (out, value) -> value.writeTo(out), Streamable.newWriteableReader(supplier), version). }
false;protected,static;5;11;;protected static <T> T copyInstance(T original, NamedWriteableRegistry namedWriteableRegistry, Writeable.Writer<T> writer, Writeable.Reader<T> reader, Version version) throws IOException {     try (BytesStreamOutput output = new BytesStreamOutput()) {         output.setVersion(version).         writer.write(output, original).         try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {             in.setVersion(version).             return reader.read(in).         }     } }
false;public;1;6;;public void assertAllIndicesRemovedAndDeletionCompleted(Iterable<IndicesService> indicesServices) throws Exception {     for (IndicesService indicesService : indicesServices) {         assertBusy(() -> assertFalse(indicesService.iterator().hasNext()), 1, TimeUnit.MINUTES).         assertBusy(() -> assertFalse(indicesService.hasUncompletedPendingDeletes()), 1, TimeUnit.MINUTES).     } }
true;public;1;28;/**  * Asserts that there are no files in the specified path  */ ;/**  * Asserts that there are no files in the specified path  */ public void assertPathHasBeenCleared(Path path) {     logger.info("--> checking that [{}] has been cleared", path).     int count = 0.     StringBuilder sb = new StringBuilder().     sb.append("[").     if (Files.exists(path)) {         try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {             for (Path file : stream) {                 // Skip files added by Lucene's ExtraFS                 if (file.getFileName().toString().startsWith("extra")) {                     continue.                 }                 logger.info("--> found file: [{}]", file.toAbsolutePath().toString()).                 if (Files.isDirectory(file)) {                     assertPathHasBeenCleared(file).                 } else if (Files.isRegularFile(file)) {                     count++.                     sb.append(file.toAbsolutePath().toString()).                     sb.append("\n").                 }             }         } catch (IOException e) {             throw new UncheckedIOException(e).         }     }     sb.append("]").     assertThat(count + " files exist that should have been cleaned:\n" + sb.toString(), count, equalTo(0)). }
true;public,static;2;27;/**  * Assert that two objects are equals, calling {@link ToXContent#toXContent(XContentBuilder, ToXContent.Params)} to print out their  * differences if they aren't equal.  */ ;/**  * Assert that two objects are equals, calling {@link ToXContent#toXContent(XContentBuilder, ToXContent.Params)} to print out their  * differences if they aren't equal.  */ public static <T extends ToXContent> void assertEqualsWithErrorMessageFromXContent(T expected, T actual) {     if (Objects.equals(expected, actual)) {         return.     }     if (expected == null) {         throw new AssertionError("Expected null be actual was [" + actual.toString() + "]").     }     if (actual == null) {         throw new AssertionError("Didn't expect null but actual was [null]").     }     try (XContentBuilder actualJson = JsonXContent.contentBuilder().         XContentBuilder expectedJson = JsonXContent.contentBuilder()) {         actualJson.startObject().         actual.toXContent(actualJson, ToXContent.EMPTY_PARAMS).         actualJson.endObject().         expectedJson.startObject().         expected.toXContent(expectedJson, ToXContent.EMPTY_PARAMS).         expectedJson.endObject().         NotEqualMessageBuilder message = new NotEqualMessageBuilder().         message.compareMaps(XContentHelper.convertToMap(BytesReference.bytes(actualJson), false).v2(), XContentHelper.convertToMap(BytesReference.bytes(expectedJson), false).v2()).         throw new AssertionError("Didn't match expected value:\n" + message).     } catch (IOException e) {         throw new AssertionError("IOException while building failure message", e).     } }
true;protected,final;1;4;/**  * Create a new {@link XContentParser}.  */ ;/**  * Create a new {@link XContentParser}.  */ protected final XContentParser createParser(XContentBuilder builder) throws IOException {     return builder.generator().contentType().xContent().createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(builder).streamInput()). }
true;protected,final;2;3;/**  * Create a new {@link XContentParser}.  */ ;/**  * Create a new {@link XContentParser}.  */ protected final XContentParser createParser(XContent xContent, String data) throws IOException {     return xContent.createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, data). }
true;protected,final;2;3;/**  * Create a new {@link XContentParser}.  */ ;/**  * Create a new {@link XContentParser}.  */ protected final XContentParser createParser(XContent xContent, InputStream data) throws IOException {     return xContent.createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, data). }
true;protected,final;2;3;/**  * Create a new {@link XContentParser}.  */ ;/**  * Create a new {@link XContentParser}.  */ protected final XContentParser createParser(XContent xContent, byte[] data) throws IOException {     return xContent.createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, data). }
true;protected,final;2;3;/**  * Create a new {@link XContentParser}.  */ ;/**  * Create a new {@link XContentParser}.  */ protected final XContentParser createParser(XContent xContent, BytesReference data) throws IOException {     return xContent.createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, data.streamInput()). }
true;protected;0;3;/**  * The {@link NamedXContentRegistry} to use for this test. Subclasses should override and use liberally.  */ ;/**  * The {@link NamedXContentRegistry} to use for this test. Subclasses should override and use liberally.  */ protected NamedXContentRegistry xContentRegistry() {     return new NamedXContentRegistry(ClusterModule.getNamedXWriteables()). }
true;protected;0;3;/**  * The {@link NamedWriteableRegistry} to use for this test. Subclasses should override and use liberally.  */ ;/**  * The {@link NamedWriteableRegistry} to use for this test. Subclasses should override and use liberally.  */ protected NamedWriteableRegistry writableRegistry() {     return new NamedWriteableRegistry(ClusterModule.getNamedWriteables()). }
true;public,static,final;1;3;/**  * Create a "mock" script for use either with {@link MockScriptEngine} or anywhere where you need a script but don't really care about  * its contents.  */ ;/**  * Create a "mock" script for use either with {@link MockScriptEngine} or anywhere where you need a script but don't really care about  * its contents.  */ public static final Script mockScript(String id) {     return new Script(ScriptType.INLINE, MockScriptEngine.NAME, id, emptyMap()). }
true;public,static;0;3;/**  * Returns the suite failure marker: internal use only!  */ ;/**  * Returns the suite failure marker: internal use only!  */ public static TestRuleMarkFailure getSuiteFailureMarker() {     return suiteFailureMarker. }
true;public,static;2;6;/**  * Compares two stack traces, ignoring module (which is not yet serialized)  */ ;/**  * Compares two stack traces, ignoring module (which is not yet serialized)  */ public static void assertArrayEquals(StackTraceElement[] expected, StackTraceElement[] actual) {     assertEquals(expected.length, actual.length).     for (int i = 0. i < expected.length. i++) {         assertEquals(expected[i], actual[i]).     } }
true;public,static;2;7;/**  * Compares two stack trace elements, ignoring module (which is not yet serialized)  */ ;/**  * Compares two stack trace elements, ignoring module (which is not yet serialized)  */ public static void assertEquals(StackTraceElement expected, StackTraceElement actual) {     assertEquals(expected.getClassName(), actual.getClassName()).     assertEquals(expected.getMethodName(), actual.getMethodName()).     assertEquals(expected.getFileName(), actual.getFileName()).     assertEquals(expected.getLineNumber(), actual.getLineNumber()).     assertEquals(expected.isNativeMethod(), actual.isNativeMethod()). }
false;protected,static;0;3;;protected static long spinForAtLeastOneMillisecond() {     return spinForAtLeastNMilliseconds(1). }
false;protected,static;1;13;;protected static long spinForAtLeastNMilliseconds(final long ms) {     long nanosecondsInMillisecond = TimeUnit.NANOSECONDS.convert(ms, TimeUnit.MILLISECONDS).     /*          * Force at least ms milliseconds to elapse, but ensure the clock has enough resolution to          * observe the passage of time.          */     long start = System.nanoTime().     long elapsed.     while ((elapsed = (System.nanoTime() - start)) < nanosecondsInMillisecond) {     // busy spin     }     return elapsed. }
true;public,static;3;5;/**  * Creates an TestAnalysis with all the default analyzers configured.  */ ;/**  * Creates an TestAnalysis with all the default analyzers configured.  */ public static TestAnalysis createTestAnalysis(Index index, Settings settings, AnalysisPlugin... analysisPlugins) throws IOException {     Settings nodeSettings = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir()).build().     return createTestAnalysis(index, nodeSettings, settings, analysisPlugins). }
true;public,static;4;7;/**  * Creates an TestAnalysis with all the default analyzers configured.  */ ;/**  * Creates an TestAnalysis with all the default analyzers configured.  */ public static TestAnalysis createTestAnalysis(Index index, Settings nodeSettings, Settings settings, AnalysisPlugin... analysisPlugins) throws IOException {     Settings indexSettings = Settings.builder().put(settings).put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build().     return createTestAnalysis(IndexSettingsModule.newIndexSettings(index, indexSettings), nodeSettings, analysisPlugins). }
true;public,static;3;10;/**  * Creates an TestAnalysis with all the default analyzers configured.  */ ;/**  * Creates an TestAnalysis with all the default analyzers configured.  */ public static TestAnalysis createTestAnalysis(IndexSettings indexSettings, Settings nodeSettings, AnalysisPlugin... analysisPlugins) throws IOException {     Environment env = TestEnvironment.newEnvironment(nodeSettings).     AnalysisModule analysisModule = new AnalysisModule(env, Arrays.asList(analysisPlugins)).     AnalysisRegistry analysisRegistry = analysisModule.getAnalysisRegistry().     return new TestAnalysis(analysisRegistry.build(indexSettings), analysisRegistry.buildTokenFilterFactories(indexSettings), analysisRegistry.buildTokenizerFactories(indexSettings), analysisRegistry.buildCharFilterFactories(indexSettings)). }
false;public;2;4;;@Override public ScriptEngine getScriptEngine(Settings settings, Collection<ScriptContext<?>> contexts) {     return new MockScriptEngine(MockScriptEngine.NAME, Collections.singletonMap("1", script -> "1"), Collections.emptyMap()). }
false;public,static;0;8;;public static ScriptModule newTestScriptModule() {     return new ScriptModule(Settings.EMPTY, singletonList(new ScriptPlugin() {          @Override         public ScriptEngine getScriptEngine(Settings settings, Collection<ScriptContext<?>> contexts) {             return new MockScriptEngine(MockScriptEngine.NAME, Collections.singletonMap("1", script -> "1"), Collections.emptyMap()).         }     })). }
false;public;0;4;;@Override public Map<String, Mapper.TypeParser> getMappers() {     return extraMappers. }
false;public;0;4;;@Override public Map<String, MetadataFieldMapper.TypeParser> getMetadataMappers() {     return extraMetadataMappers. }
true;public,static;2;15;/**  * Creates an IndicesModule for testing with the given mappers and metadata mappers.  */ ;/**  * Creates an IndicesModule for testing with the given mappers and metadata mappers.  */ public static IndicesModule newTestIndicesModule(Map<String, Mapper.TypeParser> extraMappers, Map<String, MetadataFieldMapper.TypeParser> extraMetadataMappers) {     return new IndicesModule(Collections.singletonList(new MapperPlugin() {          @Override         public Map<String, Mapper.TypeParser> getMappers() {             return extraMappers.         }          @Override         public Map<String, MetadataFieldMapper.TypeParser> getMetadataMappers() {             return extraMetadataMappers.         }     })). }
false;private,static;0;5;;private static boolean isUnusableLocale() {     return inFipsJvm() && (Locale.getDefault().toLanguageTag().equals("th-TH") || Locale.getDefault().toLanguageTag().equals("ja-JP-u-ca-japanese-x-lvariant-JP") || Locale.getDefault().toLanguageTag().equals("th-TH-u-nu-thai-x-lvariant-TH")). }
false;public,static;0;3;;public static boolean inFipsJvm() {     return Security.getProviders()[0].getName().toLowerCase(Locale.ROOT).contains("fips"). }
