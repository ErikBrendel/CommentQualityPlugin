# id;timestamp;commentText;codeText;commentWords;codeWords
XContentTestUtils -> public static String differenceBetweenMapsIgnoringArrayOrder(Map<String, Object> first, Map<String, Object> second);1524684173;Compares to maps generated from XContentObjects. The order of elements in arrays is ignored.__@return null if maps are equal or path to the element where the difference was found;public static String differenceBetweenMapsIgnoringArrayOrder(Map<String, Object> first, Map<String, Object> second) {_        return differenceBetweenMapsIgnoringArrayOrder("", first, second)__    };compares,to,maps,generated,from,xcontent,objects,the,order,of,elements,in,arrays,is,ignored,return,null,if,maps,are,equal,or,path,to,the,element,where,the,difference,was,found;public,static,string,difference,between,maps,ignoring,array,order,map,string,object,first,map,string,object,second,return,difference,between,maps,ignoring,array,order,first,second
XContentTestUtils -> public static String differenceBetweenMapsIgnoringArrayOrder(Map<String, Object> first, Map<String, Object> second);1525162917;Compares to maps generated from XContentObjects. The order of elements in arrays is ignored.__@return null if maps are equal or path to the element where the difference was found;public static String differenceBetweenMapsIgnoringArrayOrder(Map<String, Object> first, Map<String, Object> second) {_        return differenceBetweenMapsIgnoringArrayOrder("", first, second)__    };compares,to,maps,generated,from,xcontent,objects,the,order,of,elements,in,arrays,is,ignored,return,null,if,maps,are,equal,or,path,to,the,element,where,the,difference,was,found;public,static,string,difference,between,maps,ignoring,array,order,map,string,object,first,map,string,object,second,return,difference,between,maps,ignoring,array,order,first,second
XContentTestUtils -> public static String differenceBetweenMapsIgnoringArrayOrder(Map<String, Object> first, Map<String, Object> second);1528804324;Compares two maps generated from XContentObjects. The order of elements in arrays is ignored.__@return null if maps are equal or path to the element where the difference was found;public static String differenceBetweenMapsIgnoringArrayOrder(Map<String, Object> first, Map<String, Object> second) {_        return differenceBetweenMapsIgnoringArrayOrder("", first, second)__    };compares,two,maps,generated,from,xcontent,objects,the,order,of,elements,in,arrays,is,ignored,return,null,if,maps,are,equal,or,path,to,the,element,where,the,difference,was,found;public,static,string,difference,between,maps,ignoring,array,order,map,string,object,first,map,string,object,second,return,difference,between,maps,ignoring,array,order,first,second
XContentTestUtils -> public static XContentBuilder insertIntoXContent(XContent xContent, BytesReference original, List<String> paths, Supplier<String> key,             Supplier<Object> value) throws IOException;1524684173;Inserts key/value pairs into xContent passed in as {@link BytesReference} and returns a new {@link XContentBuilder}_The paths argument uses dot separated fieldnames and numbers for array indices, similar to what we do in_{@link ObjectPath}._The key/value arguments can suppliers that either return fixed or random values.;public static XContentBuilder insertIntoXContent(XContent xContent, BytesReference original, List<String> paths, Supplier<String> key,_            Supplier<Object> value) throws IOException {_        ObjectPath object = ObjectPath.createFromXContent(xContent, original)__        for (String path : paths) {_            Map<String, Object> insertMap = object.evaluate(path)__            insertMap.put(key.get(), value.get())__        }_        return object.toXContentBuilder(xContent)__    };inserts,key,value,pairs,into,x,content,passed,in,as,link,bytes,reference,and,returns,a,new,link,xcontent,builder,the,paths,argument,uses,dot,separated,fieldnames,and,numbers,for,array,indices,similar,to,what,we,do,in,link,object,path,the,key,value,arguments,can,suppliers,that,either,return,fixed,or,random,values;public,static,xcontent,builder,insert,into,xcontent,xcontent,x,content,bytes,reference,original,list,string,paths,supplier,string,key,supplier,object,value,throws,ioexception,object,path,object,object,path,create,from,xcontent,x,content,original,for,string,path,paths,map,string,object,insert,map,object,evaluate,path,insert,map,put,key,get,value,get,return,object,to,xcontent,builder,x,content
XContentTestUtils -> public static XContentBuilder insertIntoXContent(XContent xContent, BytesReference original, List<String> paths, Supplier<String> key,             Supplier<Object> value) throws IOException;1525162917;Inserts key/value pairs into xContent passed in as {@link BytesReference} and returns a new {@link XContentBuilder}_The paths argument uses dot separated fieldnames and numbers for array indices, similar to what we do in_{@link ObjectPath}._The key/value arguments can suppliers that either return fixed or random values.;public static XContentBuilder insertIntoXContent(XContent xContent, BytesReference original, List<String> paths, Supplier<String> key,_            Supplier<Object> value) throws IOException {_        ObjectPath object = ObjectPath.createFromXContent(xContent, original)__        for (String path : paths) {_            Map<String, Object> insertMap = object.evaluate(path)__            insertMap.put(key.get(), value.get())__        }_        return object.toXContentBuilder(xContent)__    };inserts,key,value,pairs,into,x,content,passed,in,as,link,bytes,reference,and,returns,a,new,link,xcontent,builder,the,paths,argument,uses,dot,separated,fieldnames,and,numbers,for,array,indices,similar,to,what,we,do,in,link,object,path,the,key,value,arguments,can,suppliers,that,either,return,fixed,or,random,values;public,static,xcontent,builder,insert,into,xcontent,xcontent,x,content,bytes,reference,original,list,string,paths,supplier,string,key,supplier,object,value,throws,ioexception,object,path,object,object,path,create,from,xcontent,x,content,original,for,string,path,paths,map,string,object,insert,map,object,evaluate,path,insert,map,put,key,get,value,get,return,object,to,xcontent,builder,x,content
XContentTestUtils -> public static XContentBuilder insertIntoXContent(XContent xContent, BytesReference original, List<String> paths, Supplier<String> key,             Supplier<Object> value) throws IOException;1528804324;Inserts key/value pairs into xContent passed in as {@link BytesReference} and returns a new {@link XContentBuilder}_The paths argument uses dot separated fieldnames and numbers for array indices, similar to what we do in_{@link ObjectPath}._The key/value arguments can suppliers that either return fixed or random values.;public static XContentBuilder insertIntoXContent(XContent xContent, BytesReference original, List<String> paths, Supplier<String> key,_            Supplier<Object> value) throws IOException {_        ObjectPath object = ObjectPath.createFromXContent(xContent, original)__        for (String path : paths) {_            Map<String, Object> insertMap = object.evaluate(path)__            insertMap.put(key.get(), value.get())__        }_        return object.toXContentBuilder(xContent)__    };inserts,key,value,pairs,into,x,content,passed,in,as,link,bytes,reference,and,returns,a,new,link,xcontent,builder,the,paths,argument,uses,dot,separated,fieldnames,and,numbers,for,array,indices,similar,to,what,we,do,in,link,object,path,the,key,value,arguments,can,suppliers,that,either,return,fixed,or,random,values;public,static,xcontent,builder,insert,into,xcontent,xcontent,x,content,bytes,reference,original,list,string,paths,supplier,string,key,supplier,object,value,throws,ioexception,object,path,object,object,path,create,from,xcontent,x,content,original,for,string,path,paths,map,string,object,insert,map,object,evaluate,path,insert,map,put,key,get,value,get,return,object,to,xcontent,builder,x,content
XContentTestUtils -> static List<String> getInsertPaths(XContentParser parser, Stack<String> currentPath) throws IOException;1524684173;This utility method takes an XContentParser and walks the xContent structure to find all_possible paths to where a new object or array starts. This can be used in tests that add random_xContent values to test parsing code for errors or to check their robustness against new fields.__The path uses dot separated fieldnames and numbers for array indices, similar to what we do in_{@link ObjectPath}.__The {@link Stack} passed in should initially be empty, it gets pushed to by recursive calls__As an example, the following json xContent:_<pre>__"foo" : "bar",_"foo1" : [ 1, { "foo2" : "baz" }, 3, 4]_"foo3" : {_"foo4" : {_"foo5": "buzz"____</pre>__Would return the following list:__<ul>_<li>"" (the empty string is the path to the root object)</li>_<li>"foo1.1"</li>_<li>"foo3</li>_<li>"foo3.foo4</li>_</ul>;static List<String> getInsertPaths(XContentParser parser, Stack<String> currentPath) throws IOException {_        assert parser.currentToken() == XContentParser.Token.START_OBJECT || parser.currentToken() == XContentParser.Token.START_ARRAY :_            "should only be called when new objects or arrays start"__        List<String> validPaths = new ArrayList<>()__        _        if (parser.currentName() != null) {_            _            currentPath.push(parser.currentName().replaceAll("\\.", "\\\\."))__        }_        if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_            validPaths.add(String.join(".", currentPath.toArray(new String[currentPath.size()])))__            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                if (parser.currentToken() == XContentParser.Token.START_OBJECT_                        || parser.currentToken() == XContentParser.Token.START_ARRAY) {_                    validPaths.addAll(getInsertPaths(parser, currentPath))__                }_            }_        } else if (parser.currentToken() == XContentParser.Token.START_ARRAY) {_            int itemCount = 0__            while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                if (parser.currentToken() == XContentParser.Token.START_OBJECT_                        || parser.currentToken() == XContentParser.Token.START_ARRAY) {_                    currentPath.push(Integer.toString(itemCount))__                    validPaths.addAll(getInsertPaths(parser, currentPath))__                    currentPath.pop()__                }_                itemCount++__            }_        }_        if (parser.currentName() != null) {_            currentPath.pop()__        }_        return validPaths__    };this,utility,method,takes,an,xcontent,parser,and,walks,the,x,content,structure,to,find,all,possible,paths,to,where,a,new,object,or,array,starts,this,can,be,used,in,tests,that,add,random,x,content,values,to,test,parsing,code,for,errors,or,to,check,their,robustness,against,new,fields,the,path,uses,dot,separated,fieldnames,and,numbers,for,array,indices,similar,to,what,we,do,in,link,object,path,the,link,stack,passed,in,should,initially,be,empty,it,gets,pushed,to,by,recursive,calls,as,an,example,the,following,json,x,content,pre,foo,bar,foo1,1,foo2,baz,3,4,foo3,foo4,foo5,buzz,pre,would,return,the,following,list,ul,li,the,empty,string,is,the,path,to,the,root,object,li,li,foo1,1,li,li,foo3,li,li,foo3,foo4,li,ul;static,list,string,get,insert,paths,xcontent,parser,parser,stack,string,current,path,throws,ioexception,assert,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,should,only,be,called,when,new,objects,or,arrays,start,list,string,valid,paths,new,array,list,if,parser,current,name,null,current,path,push,parser,current,name,replace,all,if,parser,current,token,xcontent,parser,token,valid,paths,add,string,join,current,path,to,array,new,string,current,path,size,while,parser,next,token,xcontent,parser,token,if,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,valid,paths,add,all,get,insert,paths,parser,current,path,else,if,parser,current,token,xcontent,parser,token,int,item,count,0,while,parser,next,token,xcontent,parser,token,if,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,current,path,push,integer,to,string,item,count,valid,paths,add,all,get,insert,paths,parser,current,path,current,path,pop,item,count,if,parser,current,name,null,current,path,pop,return,valid,paths
XContentTestUtils -> static List<String> getInsertPaths(XContentParser parser, Stack<String> currentPath) throws IOException;1525162917;This utility method takes an XContentParser and walks the xContent structure to find all_possible paths to where a new object or array starts. This can be used in tests that add random_xContent values to test parsing code for errors or to check their robustness against new fields.__The path uses dot separated fieldnames and numbers for array indices, similar to what we do in_{@link ObjectPath}.__The {@link Stack} passed in should initially be empty, it gets pushed to by recursive calls__As an example, the following json xContent:_<pre>__"foo" : "bar",_"foo1" : [ 1, { "foo2" : "baz" }, 3, 4]_"foo3" : {_"foo4" : {_"foo5": "buzz"____</pre>__Would return the following list:__<ul>_<li>"" (the empty string is the path to the root object)</li>_<li>"foo1.1"</li>_<li>"foo3</li>_<li>"foo3.foo4</li>_</ul>;static List<String> getInsertPaths(XContentParser parser, Stack<String> currentPath) throws IOException {_        assert parser.currentToken() == XContentParser.Token.START_OBJECT || parser.currentToken() == XContentParser.Token.START_ARRAY :_            "should only be called when new objects or arrays start"__        List<String> validPaths = new ArrayList<>()__        _        if (parser.currentName() != null) {_            _            currentPath.push(parser.currentName().replaceAll("\\.", "\\\\."))__        }_        if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_            validPaths.add(String.join(".", currentPath.toArray(new String[currentPath.size()])))__            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                if (parser.currentToken() == XContentParser.Token.START_OBJECT_                        || parser.currentToken() == XContentParser.Token.START_ARRAY) {_                    validPaths.addAll(getInsertPaths(parser, currentPath))__                }_            }_        } else if (parser.currentToken() == XContentParser.Token.START_ARRAY) {_            int itemCount = 0__            while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                if (parser.currentToken() == XContentParser.Token.START_OBJECT_                        || parser.currentToken() == XContentParser.Token.START_ARRAY) {_                    currentPath.push(Integer.toString(itemCount))__                    validPaths.addAll(getInsertPaths(parser, currentPath))__                    currentPath.pop()__                }_                itemCount++__            }_        }_        if (parser.currentName() != null) {_            currentPath.pop()__        }_        return validPaths__    };this,utility,method,takes,an,xcontent,parser,and,walks,the,x,content,structure,to,find,all,possible,paths,to,where,a,new,object,or,array,starts,this,can,be,used,in,tests,that,add,random,x,content,values,to,test,parsing,code,for,errors,or,to,check,their,robustness,against,new,fields,the,path,uses,dot,separated,fieldnames,and,numbers,for,array,indices,similar,to,what,we,do,in,link,object,path,the,link,stack,passed,in,should,initially,be,empty,it,gets,pushed,to,by,recursive,calls,as,an,example,the,following,json,x,content,pre,foo,bar,foo1,1,foo2,baz,3,4,foo3,foo4,foo5,buzz,pre,would,return,the,following,list,ul,li,the,empty,string,is,the,path,to,the,root,object,li,li,foo1,1,li,li,foo3,li,li,foo3,foo4,li,ul;static,list,string,get,insert,paths,xcontent,parser,parser,stack,string,current,path,throws,ioexception,assert,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,should,only,be,called,when,new,objects,or,arrays,start,list,string,valid,paths,new,array,list,if,parser,current,name,null,current,path,push,parser,current,name,replace,all,if,parser,current,token,xcontent,parser,token,valid,paths,add,string,join,current,path,to,array,new,string,current,path,size,while,parser,next,token,xcontent,parser,token,if,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,valid,paths,add,all,get,insert,paths,parser,current,path,else,if,parser,current,token,xcontent,parser,token,int,item,count,0,while,parser,next,token,xcontent,parser,token,if,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,current,path,push,integer,to,string,item,count,valid,paths,add,all,get,insert,paths,parser,current,path,current,path,pop,item,count,if,parser,current,name,null,current,path,pop,return,valid,paths
XContentTestUtils -> static List<String> getInsertPaths(XContentParser parser, Stack<String> currentPath) throws IOException;1528804324;This utility method takes an XContentParser and walks the xContent structure to find all_possible paths to where a new object or array starts. This can be used in tests that add random_xContent values to test parsing code for errors or to check their robustness against new fields.__The path uses dot separated fieldnames and numbers for array indices, similar to what we do in_{@link ObjectPath}.__The {@link Stack} passed in should initially be empty, it gets pushed to by recursive calls__As an example, the following json xContent:_<pre>__"foo" : "bar",_"foo1" : [ 1, { "foo2" : "baz" }, 3, 4]_"foo3" : {_"foo4" : {_"foo5": "buzz"____</pre>__Would return the following list:__<ul>_<li>"" (the empty string is the path to the root object)</li>_<li>"foo1.1"</li>_<li>"foo3</li>_<li>"foo3.foo4</li>_</ul>;static List<String> getInsertPaths(XContentParser parser, Stack<String> currentPath) throws IOException {_        assert parser.currentToken() == XContentParser.Token.START_OBJECT || parser.currentToken() == XContentParser.Token.START_ARRAY :_            "should only be called when new objects or arrays start"__        List<String> validPaths = new ArrayList<>()__        _        if (parser.currentName() != null) {_            _            currentPath.push(parser.currentName().replaceAll("\\.", "\\\\."))__        }_        if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_            validPaths.add(String.join(".", currentPath.toArray(new String[currentPath.size()])))__            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                if (parser.currentToken() == XContentParser.Token.START_OBJECT_                        || parser.currentToken() == XContentParser.Token.START_ARRAY) {_                    validPaths.addAll(getInsertPaths(parser, currentPath))__                }_            }_        } else if (parser.currentToken() == XContentParser.Token.START_ARRAY) {_            int itemCount = 0__            while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                if (parser.currentToken() == XContentParser.Token.START_OBJECT_                        || parser.currentToken() == XContentParser.Token.START_ARRAY) {_                    currentPath.push(Integer.toString(itemCount))__                    validPaths.addAll(getInsertPaths(parser, currentPath))__                    currentPath.pop()__                }_                itemCount++__            }_        }_        if (parser.currentName() != null) {_            currentPath.pop()__        }_        return validPaths__    };this,utility,method,takes,an,xcontent,parser,and,walks,the,x,content,structure,to,find,all,possible,paths,to,where,a,new,object,or,array,starts,this,can,be,used,in,tests,that,add,random,x,content,values,to,test,parsing,code,for,errors,or,to,check,their,robustness,against,new,fields,the,path,uses,dot,separated,fieldnames,and,numbers,for,array,indices,similar,to,what,we,do,in,link,object,path,the,link,stack,passed,in,should,initially,be,empty,it,gets,pushed,to,by,recursive,calls,as,an,example,the,following,json,x,content,pre,foo,bar,foo1,1,foo2,baz,3,4,foo3,foo4,foo5,buzz,pre,would,return,the,following,list,ul,li,the,empty,string,is,the,path,to,the,root,object,li,li,foo1,1,li,li,foo3,li,li,foo3,foo4,li,ul;static,list,string,get,insert,paths,xcontent,parser,parser,stack,string,current,path,throws,ioexception,assert,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,should,only,be,called,when,new,objects,or,arrays,start,list,string,valid,paths,new,array,list,if,parser,current,name,null,current,path,push,parser,current,name,replace,all,if,parser,current,token,xcontent,parser,token,valid,paths,add,string,join,current,path,to,array,new,string,current,path,size,while,parser,next,token,xcontent,parser,token,if,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,valid,paths,add,all,get,insert,paths,parser,current,path,else,if,parser,current,token,xcontent,parser,token,int,item,count,0,while,parser,next,token,xcontent,parser,token,if,parser,current,token,xcontent,parser,token,parser,current,token,xcontent,parser,token,current,path,push,integer,to,string,item,count,valid,paths,add,all,get,insert,paths,parser,current,path,current,path,pop,item,count,if,parser,current,name,null,current,path,pop,return,valid,paths
XContentTestUtils -> public static BytesReference insertRandomFields(XContentType contentType, BytesReference xContent, Predicate<String> excludeFilter,             Random random) throws IOException;1524684173;This method takes the input xContent data and adds a random field value, inner object or array into each_json object. This can e.g. be used to test if parsers that handle the resulting xContent can handle the_augmented xContent correctly, for example when testing lenient parsing.__If the xContent output contains objects that should be skipped of such treatment, an optional filtering_{@link Predicate} can be supplied that checks xContent paths that should be excluded from this treatment.__This predicate should check the xContent path that we want to insert to and return <tt>true</tt> if the_path should be excluded. Paths are string concatenating field names and array indices, so e.g. in:__<pre>__"foo1 : {_"bar" : [_{ ... },_{ ... },__"baz" : {_// insert here______</pre>__"foo1.bar.2.baz" would point to the desired insert location.__To exclude inserting into the "foo1" object we would user a {@link Predicate} like_<pre>_{@code_(path) -> path.endsWith("foo1")__</pre>__or if we don't want any random insertions in the "foo1" tree we could use_<pre>_{@code_(path) -> path.contains("foo1")__</pre>;public static BytesReference insertRandomFields(XContentType contentType, BytesReference xContent, Predicate<String> excludeFilter,_            Random random) throws IOException {_        List<String> insertPaths___        _        try (XContentParser parser = createParser(NamedXContentRegistry.EMPTY,_            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, xContent, contentType)) {_            parser.nextToken()__            List<String> possiblePaths = XContentTestUtils.getInsertPaths(parser, new Stack<>())__            if (excludeFilter == null) {_                insertPaths = possiblePaths__            } else {_                insertPaths = new ArrayList<>()__                possiblePaths.stream().filter(excludeFilter.negate()).forEach(insertPaths::add)__            }_        }__        Supplier<Object> value = () -> {_            List<Object> randomValues = RandomObjects.randomStoredFieldValues(random, contentType).v1()__            if (random.nextBoolean()) {_                return randomValues.get(0)__            } else {_                if (random.nextBoolean()) {_                    return randomValues.stream().collect(Collectors.toMap(obj -> randomAsciiOfLength(random, 10), obj -> obj))__                } else {_                    return randomValues__                }_            }_        }__        return BytesReference.bytes(XContentTestUtils_                .insertIntoXContent(contentType.xContent(), xContent, insertPaths, () -> randomAsciiOfLength(random, 10), value))__    };this,method,takes,the,input,x,content,data,and,adds,a,random,field,value,inner,object,or,array,into,each,json,object,this,can,e,g,be,used,to,test,if,parsers,that,handle,the,resulting,x,content,can,handle,the,augmented,x,content,correctly,for,example,when,testing,lenient,parsing,if,the,x,content,output,contains,objects,that,should,be,skipped,of,such,treatment,an,optional,filtering,link,predicate,can,be,supplied,that,checks,x,content,paths,that,should,be,excluded,from,this,treatment,this,predicate,should,check,the,x,content,path,that,we,want,to,insert,to,and,return,tt,true,tt,if,the,path,should,be,excluded,paths,are,string,concatenating,field,names,and,array,indices,so,e,g,in,pre,foo1,bar,baz,insert,here,pre,foo1,bar,2,baz,would,point,to,the,desired,insert,location,to,exclude,inserting,into,the,foo1,object,we,would,user,a,link,predicate,like,pre,code,path,path,ends,with,foo1,pre,or,if,we,don,t,want,any,random,insertions,in,the,foo1,tree,we,could,use,pre,code,path,path,contains,foo1,pre;public,static,bytes,reference,insert,random,fields,xcontent,type,content,type,bytes,reference,x,content,predicate,string,exclude,filter,random,random,throws,ioexception,list,string,insert,paths,try,xcontent,parser,parser,create,parser,named,xcontent,registry,empty,deprecation,handler,x,content,content,type,parser,next,token,list,string,possible,paths,xcontent,test,utils,get,insert,paths,parser,new,stack,if,exclude,filter,null,insert,paths,possible,paths,else,insert,paths,new,array,list,possible,paths,stream,filter,exclude,filter,negate,for,each,insert,paths,add,supplier,object,value,list,object,random,values,random,objects,random,stored,field,values,random,content,type,v1,if,random,next,boolean,return,random,values,get,0,else,if,random,next,boolean,return,random,values,stream,collect,collectors,to,map,obj,random,ascii,of,length,random,10,obj,obj,else,return,random,values,return,bytes,reference,bytes,xcontent,test,utils,insert,into,xcontent,content,type,x,content,x,content,insert,paths,random,ascii,of,length,random,10,value
XContentTestUtils -> public static BytesReference insertRandomFields(XContentType contentType, BytesReference xContent, Predicate<String> excludeFilter,             Random random) throws IOException;1525162917;This method takes the input xContent data and adds a random field value, inner object or array into each_json object. This can e.g. be used to test if parsers that handle the resulting xContent can handle the_augmented xContent correctly, for example when testing lenient parsing.__If the xContent output contains objects that should be skipped of such treatment, an optional filtering_{@link Predicate} can be supplied that checks xContent paths that should be excluded from this treatment.__This predicate should check the xContent path that we want to insert to and return {@code true} if the_path should be excluded. Paths are string concatenating field names and array indices, so e.g. in:__<pre>__"foo1 : {_"bar" : [_{ ... },_{ ... },__"baz" : {_// insert here______</pre>__"foo1.bar.2.baz" would point to the desired insert location.__To exclude inserting into the "foo1" object we would user a {@link Predicate} like_<pre>_{@code_(path) -> path.endsWith("foo1")__</pre>__or if we don't want any random insertions in the "foo1" tree we could use_<pre>_{@code_(path) -> path.contains("foo1")__</pre>;public static BytesReference insertRandomFields(XContentType contentType, BytesReference xContent, Predicate<String> excludeFilter,_            Random random) throws IOException {_        List<String> insertPaths___        _        try (XContentParser parser = createParser(NamedXContentRegistry.EMPTY,_            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, xContent, contentType)) {_            parser.nextToken()__            List<String> possiblePaths = XContentTestUtils.getInsertPaths(parser, new Stack<>())__            if (excludeFilter == null) {_                insertPaths = possiblePaths__            } else {_                insertPaths = new ArrayList<>()__                possiblePaths.stream().filter(excludeFilter.negate()).forEach(insertPaths::add)__            }_        }__        Supplier<Object> value = () -> {_            List<Object> randomValues = RandomObjects.randomStoredFieldValues(random, contentType).v1()__            if (random.nextBoolean()) {_                return randomValues.get(0)__            } else {_                if (random.nextBoolean()) {_                    return randomValues.stream().collect(Collectors.toMap(obj -> randomAsciiOfLength(random, 10), obj -> obj))__                } else {_                    return randomValues__                }_            }_        }__        return BytesReference.bytes(XContentTestUtils_                .insertIntoXContent(contentType.xContent(), xContent, insertPaths, () -> randomAsciiOfLength(random, 10), value))__    };this,method,takes,the,input,x,content,data,and,adds,a,random,field,value,inner,object,or,array,into,each,json,object,this,can,e,g,be,used,to,test,if,parsers,that,handle,the,resulting,x,content,can,handle,the,augmented,x,content,correctly,for,example,when,testing,lenient,parsing,if,the,x,content,output,contains,objects,that,should,be,skipped,of,such,treatment,an,optional,filtering,link,predicate,can,be,supplied,that,checks,x,content,paths,that,should,be,excluded,from,this,treatment,this,predicate,should,check,the,x,content,path,that,we,want,to,insert,to,and,return,code,true,if,the,path,should,be,excluded,paths,are,string,concatenating,field,names,and,array,indices,so,e,g,in,pre,foo1,bar,baz,insert,here,pre,foo1,bar,2,baz,would,point,to,the,desired,insert,location,to,exclude,inserting,into,the,foo1,object,we,would,user,a,link,predicate,like,pre,code,path,path,ends,with,foo1,pre,or,if,we,don,t,want,any,random,insertions,in,the,foo1,tree,we,could,use,pre,code,path,path,contains,foo1,pre;public,static,bytes,reference,insert,random,fields,xcontent,type,content,type,bytes,reference,x,content,predicate,string,exclude,filter,random,random,throws,ioexception,list,string,insert,paths,try,xcontent,parser,parser,create,parser,named,xcontent,registry,empty,deprecation,handler,x,content,content,type,parser,next,token,list,string,possible,paths,xcontent,test,utils,get,insert,paths,parser,new,stack,if,exclude,filter,null,insert,paths,possible,paths,else,insert,paths,new,array,list,possible,paths,stream,filter,exclude,filter,negate,for,each,insert,paths,add,supplier,object,value,list,object,random,values,random,objects,random,stored,field,values,random,content,type,v1,if,random,next,boolean,return,random,values,get,0,else,if,random,next,boolean,return,random,values,stream,collect,collectors,to,map,obj,random,ascii,of,length,random,10,obj,obj,else,return,random,values,return,bytes,reference,bytes,xcontent,test,utils,insert,into,xcontent,content,type,x,content,x,content,insert,paths,random,ascii,of,length,random,10,value
XContentTestUtils -> public static BytesReference insertRandomFields(XContentType contentType, BytesReference xContent, Predicate<String> excludeFilter,             Random random) throws IOException;1528804324;This method takes the input xContent data and adds a random field value, inner object or array into each_json object. This can e.g. be used to test if parsers that handle the resulting xContent can handle the_augmented xContent correctly, for example when testing lenient parsing.__If the xContent output contains objects that should be skipped of such treatment, an optional filtering_{@link Predicate} can be supplied that checks xContent paths that should be excluded from this treatment.__This predicate should check the xContent path that we want to insert to and return {@code true} if the_path should be excluded. Paths are string concatenating field names and array indices, so e.g. in:__<pre>__"foo1 : {_"bar" : [_{ ... },_{ ... },__"baz" : {_// insert here______</pre>__"foo1.bar.2.baz" would point to the desired insert location.__To exclude inserting into the "foo1" object we would user a {@link Predicate} like_<pre>_{@code_(path) -> path.endsWith("foo1")__</pre>__or if we don't want any random insertions in the "foo1" tree we could use_<pre>_{@code_(path) -> path.contains("foo1")__</pre>;public static BytesReference insertRandomFields(XContentType contentType, BytesReference xContent, Predicate<String> excludeFilter,_            Random random) throws IOException {_        List<String> insertPaths___        _        try (XContentParser parser = createParser(NamedXContentRegistry.EMPTY,_            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, xContent, contentType)) {_            parser.nextToken()__            List<String> possiblePaths = XContentTestUtils.getInsertPaths(parser, new Stack<>())__            if (excludeFilter == null) {_                insertPaths = possiblePaths__            } else {_                insertPaths = new ArrayList<>()__                possiblePaths.stream().filter(excludeFilter.negate()).forEach(insertPaths::add)__            }_        }__        Supplier<Object> value = () -> {_            List<Object> randomValues = RandomObjects.randomStoredFieldValues(random, contentType).v1()__            if (random.nextBoolean()) {_                return randomValues.get(0)__            } else {_                if (random.nextBoolean()) {_                    return randomValues.stream().collect(Collectors.toMap(obj -> randomAsciiOfLength(random, 10), obj -> obj))__                } else {_                    return randomValues__                }_            }_        }__        return BytesReference.bytes(XContentTestUtils_                .insertIntoXContent(contentType.xContent(), xContent, insertPaths, () -> randomAsciiOfLength(random, 10), value))__    };this,method,takes,the,input,x,content,data,and,adds,a,random,field,value,inner,object,or,array,into,each,json,object,this,can,e,g,be,used,to,test,if,parsers,that,handle,the,resulting,x,content,can,handle,the,augmented,x,content,correctly,for,example,when,testing,lenient,parsing,if,the,x,content,output,contains,objects,that,should,be,skipped,of,such,treatment,an,optional,filtering,link,predicate,can,be,supplied,that,checks,x,content,paths,that,should,be,excluded,from,this,treatment,this,predicate,should,check,the,x,content,path,that,we,want,to,insert,to,and,return,code,true,if,the,path,should,be,excluded,paths,are,string,concatenating,field,names,and,array,indices,so,e,g,in,pre,foo1,bar,baz,insert,here,pre,foo1,bar,2,baz,would,point,to,the,desired,insert,location,to,exclude,inserting,into,the,foo1,object,we,would,user,a,link,predicate,like,pre,code,path,path,ends,with,foo1,pre,or,if,we,don,t,want,any,random,insertions,in,the,foo1,tree,we,could,use,pre,code,path,path,contains,foo1,pre;public,static,bytes,reference,insert,random,fields,xcontent,type,content,type,bytes,reference,x,content,predicate,string,exclude,filter,random,random,throws,ioexception,list,string,insert,paths,try,xcontent,parser,parser,create,parser,named,xcontent,registry,empty,deprecation,handler,x,content,content,type,parser,next,token,list,string,possible,paths,xcontent,test,utils,get,insert,paths,parser,new,stack,if,exclude,filter,null,insert,paths,possible,paths,else,insert,paths,new,array,list,possible,paths,stream,filter,exclude,filter,negate,for,each,insert,paths,add,supplier,object,value,list,object,random,values,random,objects,random,stored,field,values,random,content,type,v1,if,random,next,boolean,return,random,values,get,0,else,if,random,next,boolean,return,random,values,stream,collect,collectors,to,map,obj,random,ascii,of,length,random,10,obj,obj,else,return,random,values,return,bytes,reference,bytes,xcontent,test,utils,insert,into,xcontent,content,type,x,content,x,content,insert,paths,random,ascii,of,length,random,10,value
