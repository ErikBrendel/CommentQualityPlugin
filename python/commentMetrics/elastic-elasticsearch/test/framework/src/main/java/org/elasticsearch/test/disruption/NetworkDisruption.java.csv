commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public DisruptedLinks getDisruptedLinks() {     return disruptedLinks. }
false;public;0;3;;public NetworkLinkDisruptionType getNetworkLinkDisruptionType() {     return networkLinkDisruptionType. }
false;public;1;4;;@Override public void applyToCluster(InternalTestCluster cluster) {     this.cluster = cluster. }
false;public;1;4;;@Override public void removeFromCluster(InternalTestCluster cluster) {     stopDisrupting(). }
false;public;1;5;;@Override public void removeAndEnsureHealthy(InternalTestCluster cluster) {     removeFromCluster(cluster).     ensureHealthy(cluster). }
true;public;1;5;/**  * ensures the cluster is healthy after the disruption  */ ;/**  * ensures the cluster is healthy after the disruption  */ public void ensureHealthy(InternalTestCluster cluster) {     assert activeDisruption == false.     ensureNodeCount(cluster).     ensureFullyConnectedCluster(cluster). }
true;public,static;1;6;/**  * Ensures that all nodes in the cluster are connected to each other.  *  * Some network disruptions may leave nodes that are not the master disconnected from each other.  * {@link org.elasticsearch.cluster.NodeConnectionsService} will eventually reconnect but it's  * handy to be able to ensure this happens faster  */ ;/**  * Ensures that all nodes in the cluster are connected to each other.  *  * Some network disruptions may leave nodes that are not the master disconnected from each other.  * {@link org.elasticsearch.cluster.NodeConnectionsService} will eventually reconnect but it's  * handy to be able to ensure this happens faster  */ public static void ensureFullyConnectedCluster(InternalTestCluster cluster) {     for (String node : cluster.getNodeNames()) {         ClusterState stateOnNode = cluster.getInstance(ClusterService.class, node).state().         cluster.getInstance(NodeConnectionsService.class, node).connectToNodes(stateOnNode.nodes()).     } }
false;protected;1;6;;protected void ensureNodeCount(InternalTestCluster cluster) {     assertFalse("cluster failed to form after disruption was healed", cluster.client().admin().cluster().prepareHealth().setWaitForNodes(String.valueOf(cluster.size())).setWaitForNoRelocatingShards(true).get().isTimedOut()). }
false;public,synchronized;2;4;;@Override public synchronized void applyToNode(String node, InternalTestCluster cluster) { }
false;public,synchronized;2;6;;@Override public synchronized void removeFromNode(String node1, InternalTestCluster cluster) {     logger.info("stop disrupting node (disruption type: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks).     applyToNodes(new String[] { node1 }, cluster.getNodeNames(), networkLinkDisruptionType::removeDisruption).     applyToNodes(cluster.getNodeNames(), new String[] { node1 }, networkLinkDisruptionType::removeDisruption). }
false;public,synchronized;0;4;;@Override public synchronized void testClusterClosed() { }
false;public,synchronized;0;6;;@Override public synchronized void startDisrupting() {     logger.info("start disrupting (disruption type: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks).     applyToNodes(cluster.getNodeNames(), cluster.getNodeNames(), networkLinkDisruptionType::applyDisruption).     activeDisruption = true. }
false;public,synchronized;0;9;;@Override public synchronized void stopDisrupting() {     if (!activeDisruption) {         return.     }     logger.info("stop disrupting (disruption scheme: {}, disrupted links: {})", networkLinkDisruptionType, disruptedLinks).     applyToNodes(cluster.getNodeNames(), cluster.getNodeNames(), networkLinkDisruptionType::removeDisruption).     activeDisruption = false. }
true;private;3;15;/**  * Applies action to all disrupted links between two sets of nodes.  */ ;/**  * Applies action to all disrupted links between two sets of nodes.  */ private void applyToNodes(String[] nodes1, String[] nodes2, BiConsumer<MockTransportService, MockTransportService> consumer) {     for (String node1 : nodes1) {         if (disruptedLinks.nodes().contains(node1)) {             for (String node2 : nodes2) {                 if (disruptedLinks.nodes().contains(node2)) {                     if (node1.equals(node2) == false) {                         if (disruptedLinks.disrupt(node1, node2)) {                             consumer.accept(transport(node1), transport(node2)).                         }                     }                 }             }         }     } }
false;public;0;4;;@Override public TimeValue expectedTimeToHeal() {     return networkLinkDisruptionType.expectedTimeToHeal(). }
false;private;1;3;;private MockTransportService transport(String node) {     return (MockTransportService) cluster.getInstance(TransportService.class, node). }
false;public;0;4;;@Override public String toString() {     return "network disruption (disruption type: " + networkLinkDisruptionType + ", disrupted links: " + disruptedLinks + ")". }
true;public;0;3;/**  * Set of all nodes that can participate in disruptions  */ ;/**  * Set of all nodes that can participate in disruptions  */ public Set<String> nodes() {     return nodes. }
true;public,abstract;2;1;/**  * Returns true iff network should be disrupted between the two nodes  */ ;/**  * Returns true iff network should be disrupted between the two nodes  */ public abstract boolean disrupt(String node1, String node2).
false;public,static;2;3;;public static TwoPartitions random(Random random, String... nodes) {     return random(random, Sets.newHashSet(nodes)). }
false;public,static;2;17;;public static TwoPartitions random(Random random, Set<String> nodes) {     assert nodes.size() >= 2 : "two partitions topology requires at least 2 nodes".     Set<String> nodesSideOne = new HashSet<>().     Set<String> nodesSideTwo = new HashSet<>().     for (String node : nodes) {         if (nodesSideOne.isEmpty()) {             nodesSideOne.add(node).         } else if (nodesSideTwo.isEmpty()) {             nodesSideTwo.add(node).         } else if (random.nextBoolean()) {             nodesSideOne.add(node).         } else {             nodesSideTwo.add(node).         }     }     return new TwoPartitions(nodesSideOne, nodesSideTwo). }
false;public;2;10;;@Override public boolean disrupt(String node1, String node2) {     if (nodesSideOne.contains(node1) && nodesSideTwo.contains(node2)) {         return true.     }     if (nodesSideOne.contains(node2) && nodesSideTwo.contains(node1)) {         return true.     }     return false. }
false;public;0;3;;public Set<String> getNodesSideOne() {     return Collections.unmodifiableSet(nodesSideOne). }
false;public;0;3;;public Set<String> getNodesSideTwo() {     return Collections.unmodifiableSet(nodesSideTwo). }
false;public;0;7;;public Collection<String> getMajoritySide() {     if (nodesSideOne.size() >= nodesSideTwo.size()) {         return getNodesSideOne().     } else {         return getNodesSideTwo().     } }
false;public;0;7;;public Collection<String> getMinoritySide() {     if (nodesSideOne.size() >= nodesSideTwo.size()) {         return getNodesSideTwo().     } else {         return getNodesSideOne().     } }
false;public;0;4;;@Override public String toString() {     return "two partitions (partition 1: " + nodesSideOne + " and partition 2: " + nodesSideTwo + ")". }
false;public,static;2;3;;public static Bridge random(Random random, String... nodes) {     return random(random, Sets.newHashSet(nodes)). }
false;public,static;2;20;;public static Bridge random(Random random, Set<String> nodes) {     assert nodes.size() >= 3 : "bridge topology requires at least 3 nodes".     String bridgeNode = RandomPicks.randomFrom(random, nodes).     Set<String> nodesSideOne = new HashSet<>().     Set<String> nodesSideTwo = new HashSet<>().     for (String node : nodes) {         if (node.equals(bridgeNode) == false) {             if (nodesSideOne.isEmpty()) {                 nodesSideOne.add(node).             } else if (nodesSideTwo.isEmpty()) {                 nodesSideTwo.add(node).             } else if (random.nextBoolean()) {                 nodesSideOne.add(node).             } else {                 nodesSideTwo.add(node).             }         }     }     return new Bridge(bridgeNode, nodesSideOne, nodesSideTwo). }
false;public;2;10;;@Override public boolean disrupt(String node1, String node2) {     if (nodesSideOne.contains(node1) && nodesSideTwo.contains(node2)) {         return true.     }     if (nodesSideOne.contains(node2) && nodesSideTwo.contains(node1)) {         return true.     }     return false. }
false;public;0;3;;public String getBridgeNode() {     return bridgeNode. }
false;public;0;3;;public Set<String> getNodesSideOne() {     return nodesSideOne. }
false;public;0;3;;public Set<String> getNodesSideTwo() {     return nodesSideTwo. }
false;public;0;4;;public String toString() {     return "bridge partition (super connected node: [" + bridgeNode + "], partition 1: " + nodesSideOne + " and partition 2: " + nodesSideTwo + ")". }
false;public;2;4;;@Override public boolean disrupt(String node1, String node2) {     return true. }
true;public,abstract;2;1;/**  * Applies network disruption for requests send from the node represented by the source transport service to the node represented  * by the target transport service.  *  * @param sourceTransportService source transport service from which requests are sent  * @param targetTransportService target transport service to which requests are sent  */ ;/**  * Applies network disruption for requests send from the node represented by the source transport service to the node represented  * by the target transport service.  *  * @param sourceTransportService source transport service from which requests are sent  * @param targetTransportService target transport service to which requests are sent  */ public abstract void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService).
true;public;2;3;/**  * Removes network disruption that was added by {@link #applyDisruption}.  *  * @param sourceTransportService source transport service from which requests are sent  * @param targetTransportService target transport service to which requests are sent  */ ;/**  * Removes network disruption that was added by {@link #applyDisruption}.  *  * @param sourceTransportService source transport service from which requests are sent  * @param targetTransportService target transport service to which requests are sent  */ public void removeDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {     sourceTransportService.clearRule(targetTransportService). }
true;public;0;3;/**  * Returns expected time to heal after disruption has been removed. Defaults to instant healing.  */ ;/**  * Returns expected time to heal after disruption has been removed. Defaults to instant healing.  */ public TimeValue expectedTimeToHeal() {     return TimeValue.timeValueMillis(0). }
false;public;2;4;;@Override public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {     sourceTransportService.addFailToSendNoConnectRule(targetTransportService). }
false;public;0;4;;@Override public String toString() {     return "network disconnects". }
false;public;2;4;;@Override public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {     sourceTransportService.addUnresponsiveRule(targetTransportService). }
false;public;0;4;;@Override public String toString() {     return "network unresponsive". }
true;public,static;1;3;/**  * Delays requests by a random but fixed time value between {@link #DEFAULT_DELAY_MIN} and {@link #DEFAULT_DELAY_MAX}.  *  * @param random instance to use for randomization of delay  */ ;/**  * Delays requests by a random but fixed time value between {@link #DEFAULT_DELAY_MIN} and {@link #DEFAULT_DELAY_MAX}.  *  * @param random instance to use for randomization of delay  */ public static NetworkDelay random(Random random) {     return random(random, DEFAULT_DELAY_MIN, DEFAULT_DELAY_MAX). }
true;public,static;3;5;/**  * Delays requests by a random but fixed time value between delayMin and delayMax.  *  * @param random   instance to use for randomization of delay  * @param delayMin minimum delay  * @param delayMax maximum delay  */ ;/**  * Delays requests by a random but fixed time value between delayMin and delayMax.  *  * @param random   instance to use for randomization of delay  * @param delayMin minimum delay  * @param delayMax maximum delay  */ public static NetworkDelay random(Random random, TimeValue delayMin, TimeValue delayMax) {     return new NetworkDelay(TimeValue.timeValueMillis(delayMin.millis() == delayMax.millis() ? delayMin.millis() : delayMin.millis() + random.nextInt((int) (delayMax.millis() - delayMin.millis())))). }
false;public;2;4;;@Override public void applyDisruption(MockTransportService sourceTransportService, MockTransportService targetTransportService) {     sourceTransportService.addUnresponsiveRule(targetTransportService, delay). }
false;public;0;4;;@Override public TimeValue expectedTimeToHeal() {     return delay. }
false;public;0;4;;@Override public String toString() {     return "network delays for [" + delay + "]". }
