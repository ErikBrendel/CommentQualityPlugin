# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractQueryTestCase -> public void testUnknownField();1524684173;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(queryAsString))__        _        assertThat(e.getMessage(), containsString("bogusField"))__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,parsing,exception,e,expect,throws,parsing,exception,class,parse,query,query,as,string,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField();1526510804;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(queryAsString))__        _        assertThat(e.getMessage(), containsString("bogusField"))__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,parsing,exception,e,expect,throws,parsing,exception,class,parse,query,query,as,string,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1524684173;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1526510804;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1528167589;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1531179852;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1531937412;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1532685069;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1539723533;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1541156195;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1543252559;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1543834151;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1546434630;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1547002001;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> public final void testQueryWrappedInArray();1551176390;Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}_This causes unexpected situations in parser code that may not be handled properly.;public final void testQueryWrappedInArray() {_        QB queryBuilder = createTestQueryBuilder()__        String queryName = queryBuilder.getName()__        String validQuery = queryBuilder.toString()__        queryWrappedInArrayTest(queryName, validQuery)__        for (String query : getAlternateVersions().keySet()) {_            queryWrappedInArrayTest(queryName, query)__        }_    };test,that,wraps,the,randomly,generated,query,into,an,array,as,follows,this,causes,unexpected,situations,in,parser,code,that,may,not,be,handled,properly;public,final,void,test,query,wrapped,in,array,qb,query,builder,create,test,query,builder,string,query,name,query,builder,get,name,string,valid,query,query,builder,to,string,query,wrapped,in,array,test,query,name,valid,query,for,string,query,get,alternate,versions,key,set,query,wrapped,in,array,test,query,name,query
AbstractQueryTestCase -> protected boolean supportsBoost();1543252559;Few queries allow you to set the boost on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsBoost() {_        return true__    };few,queries,allow,you,to,set,the,boost,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,boost,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,boost,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,boost,return,true
AbstractQueryTestCase -> protected boolean supportsBoost();1543834151;Few queries allow you to set the boost on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsBoost() {_        return true__    };few,queries,allow,you,to,set,the,boost,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,boost,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,boost,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,boost,return,true
AbstractQueryTestCase -> protected boolean supportsBoost();1546434630;Few queries allow you to set the boost on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsBoost() {_        return true__    };few,queries,allow,you,to,set,the,boost,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,boost,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,boost,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,boost,return,true
AbstractQueryTestCase -> protected boolean supportsBoost();1547002001;Few queries allow you to set the boost on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsBoost() {_        return true__    };few,queries,allow,you,to,set,the,boost,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,boost,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,boost,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,boost,return,true
AbstractQueryTestCase -> protected boolean supportsBoost();1551176390;Few queries allow you to set the boost on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsBoost() {_        return true__    };few,queries,allow,you,to,set,the,boost,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,boost,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,boost,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,boost,return,true
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1524684173;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1526510804;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1528167589;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1531179852;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1531937412;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1532685069;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1539723533;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1541156195;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1543252559;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1543834151;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1546434630;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1547002001;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static String getRandomRewriteMethod();1551176390;Helper method to return a random rewrite method;protected static String getRandomRewriteMethod() {_        String rewrite__        if (randomBoolean()) {_            rewrite = randomFrom(QueryParsers.CONSTANT_SCORE,_                    QueryParsers.SCORING_BOOLEAN,_                    QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName()__        } else {_            rewrite = randomFrom(QueryParsers.TOP_TERMS,_                    QueryParsers.TOP_TERMS_BOOST,_                    QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1"__        }_        return rewrite__    };helper,method,to,return,a,random,rewrite,method;protected,static,string,get,random,rewrite,method,string,rewrite,if,random,boolean,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,else,rewrite,random,from,query,parsers,query,parsers,query,parsers,get,preferred,name,1,return,rewrite
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1524684173;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1526510804;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1528167589;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1531179852;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1531937412;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1532685069;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1539723533;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1541156195;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1543252559;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1543834151;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1546434630;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1547002001;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> protected static Object getRandomValueForFieldName(String fieldName);1551176390;create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},_{@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or_{@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default;protected static Object getRandomValueForFieldName(String fieldName) {_        Object value__        switch (fieldName) {_            case STRING_FIELD_NAME:_            case STRING_ALIAS_FIELD_NAME:_                if (rarely()) {_                    _                    JsonStringEncoder encoder = JsonStringEncoder.getInstance()__                    value = new String(encoder.quoteAsString(randomUnicodeOfLength(10)))__                } else {_                    value = randomAlphaOfLengthBetween(1, 10)__                }_                break__            case INT_FIELD_NAME:_                value = randomIntBetween(0, 10)__                break__            case DOUBLE_FIELD_NAME:_                value = 1 + randomDouble() * 9__                break__            case BOOLEAN_FIELD_NAME:_                value = randomBoolean()__                break__            case DATE_FIELD_NAME:_                value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString()__                break__            default:_                value = randomAlphaOfLengthBetween(1, 10)__        }_        return value__    };create,a,random,value,for,either,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,link,abstract,query,test,case,or,link,abstract,query,test,case,or,a,string,value,by,default;protected,static,object,get,random,value,for,field,name,string,field,name,object,value,switch,field,name,case,case,if,rarely,json,string,encoder,encoder,json,string,encoder,get,instance,value,new,string,encoder,quote,as,string,random,unicode,of,length,10,else,value,random,alpha,of,length,between,1,10,break,case,value,random,int,between,0,10,break,case,value,1,random,double,9,break,case,value,random,boolean,break,case,value,new,date,time,system,current,time,millis,date,time,zone,utc,to,string,break,default,value,random,alpha,of,length,between,1,10,return,value
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1524684173;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1526510804;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1528167589;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1531179852;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1531937412;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1532685069;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1539723533;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1541156195;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1543252559;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1543834151;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1546434630;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1547002001;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public void testValidOutput() throws IOException;1551176390;Generic test that checks that the <code>Strings.toString()</code> method_renders the XContent correctly.;public void testValidOutput() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = XContentType.JSON__            String toString = Strings.toString(testQuery)__            assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery)__            BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false)__            assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery)__        }_    };generic,test,that,checks,that,the,code,strings,to,string,code,method,renders,the,xcontent,correctly;public,void,test,valid,output,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,xcontent,type,json,string,to,string,strings,to,string,test,query,assert,parsed,query,create,parser,x,content,type,x,content,to,string,test,query,bytes,reference,bytes,xcontent,helper,to,xcontent,test,query,x,content,type,false,assert,parsed,query,create,parser,x,content,type,x,content,bytes,test,query
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1524684173;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1526510804;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1528167589;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1531179852;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1531937412;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1532685069;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1539723533;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1541156195;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1543252559;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1543834151;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1546434630;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1547002001;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException;1551176390;Call this method to check a valid json string representing the query under test against_it's generated json.__Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl_reference docs mirroring examples there. Here's how the queries were generated:__<ul>_<li> Take a reference documentation example._<li> Stick it into the createParseableQueryJson method of the respective query test._<li> Manually check that what the QueryBuilder generates equals the input json ignoring default options._<li> Put the manual checks into the assertQueryParsedFromJson method._<li> Now copy the generated json including default options into createParseableQueryJson_<li> By now the roundtrip check for the json should be happy._</ul>;public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {_        _        XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint()__        source.toXContent(builder, ToXContent.EMPTY_PARAMS)__        assertEquals(_                msg(expected, Strings.toString(builder)),_                expected.replaceAll("\\s+", ""),_                Strings.toString(builder).replaceAll("\\s+", ""))__    };call,this,method,to,check,a,valid,json,string,representing,the,query,under,test,against,it,s,generated,json,note,by,the,time,of,this,writing,nov,2015,all,queries,are,taken,from,the,query,dsl,reference,docs,mirroring,examples,there,here,s,how,the,queries,were,generated,ul,li,take,a,reference,documentation,example,li,stick,it,into,the,create,parseable,query,json,method,of,the,respective,query,test,li,manually,check,that,what,the,query,builder,generates,equals,the,input,json,ignoring,default,options,li,put,the,manual,checks,into,the,assert,query,parsed,from,json,method,li,now,copy,the,generated,json,including,default,options,into,create,parseable,query,json,li,by,now,the,roundtrip,check,for,the,json,should,be,happy,ul;public,static,void,check,generated,json,string,expected,query,builder,source,throws,ioexception,xcontent,builder,builder,xcontent,factory,json,builder,pretty,print,source,to,xcontent,builder,to,xcontent,assert,equals,msg,expected,strings,to,string,builder,expected,replace,all,s,strings,to,string,builder,replace,all,s
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1526510804;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1528167589;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1531179852;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1531937412;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1532685069;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1539723533;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1541156195;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1543252559;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1543834151;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1546434630;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1547002001;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException;1551176390;Serialize the given query builder and asserts that both are equal;protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {_        try (BytesStreamOutput output = new BytesStreamOutput()) {_            output.setVersion(version)__            output.writeNamedWriteable(testQuery)__            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {_                in.setVersion(version)__                QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class)__                assertEquals(testQuery, deserializedQuery)__                assertEquals(testQuery.hashCode(), deserializedQuery.hashCode())__                assertNotSame(testQuery, deserializedQuery)__                return deserializedQuery__            }_        }_    };serialize,the,given,query,builder,and,asserts,that,both,are,equal;protected,query,builder,assert,serialization,query,builder,test,query,version,version,throws,ioexception,try,bytes,stream,output,output,new,bytes,stream,output,output,set,version,version,output,write,named,writeable,test,query,try,stream,input,in,new,named,writeable,aware,stream,input,output,bytes,stream,input,named,writeable,registry,in,set,version,version,query,builder,deserialized,query,in,read,named,writeable,query,builder,class,assert,equals,test,query,deserialized,query,assert,equals,test,query,hash,code,deserialized,query,hash,code,assert,not,same,test,query,deserialized,query,return,deserialized,query
AbstractQueryTestCase -> protected boolean supportsQueryName();1543252559;Few queries allow you to set the query name on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsQueryName() {_        return true__    };few,queries,allow,you,to,set,the,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsQueryName();1543834151;Few queries allow you to set the query name on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsQueryName() {_        return true__    };few,queries,allow,you,to,set,the,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsQueryName();1546434630;Few queries allow you to set the query name on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsQueryName() {_        return true__    };few,queries,allow,you,to,set,the,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsQueryName();1547002001;Few queries allow you to set the query name on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsQueryName() {_        return true__    };few,queries,allow,you,to,set,the,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsQueryName();1551176390;Few queries allow you to set the query name on the Java API, although the corresponding parser_doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries._Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:_wrapper query and {@code match_none}.;protected boolean supportsQueryName() {_        return true__    };few,queries,allow,you,to,set,the,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,it,as,it,isn,t,supported,this,method,allows,to,disable,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,code,as,they,don,t,apply,to,the,specific,query,wrapper,query,and,code;protected,boolean,supports,query,name,return,true
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1524684173;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1526510804;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1528167589;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1531179852;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1531937412;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1532685069;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1539723533;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1541156195;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1543252559;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1543834151;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1546434630;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1547002001;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException;1551176390;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to_{@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.;private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {_        if (queryBuilder.queryName() != null) {_            Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName())__            assertThat(namedQuery, equalTo(query))__        }_        if (query != null) {_            if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {_                assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class)))__                if (query instanceof SpanBoostQuery) {_                    SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query__                    assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = spanBoostQuery.getQuery()__                } else {_                    BoostQuery boostQuery = (BoostQuery) query__                    assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost()))__                    query = boostQuery.getQuery()__                }_            }_        }_        doAssertLuceneQuery(queryBuilder, query, context)__    };checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,verifies,that,named,queries,and,boost,are,properly,handled,and,delegates,to,link,do,assert,lucene,query,abstract,query,builder,query,search,context,for,query,specific,checks;private,void,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception,if,query,builder,query,name,null,query,named,query,context,get,query,shard,context,copy,named,queries,get,query,builder,query,name,assert,that,named,query,equal,to,query,if,query,null,if,query,builder,boost,abstract,query,builder,assert,that,query,either,instance,of,boost,query,class,or,instance,of,span,boost,query,class,if,query,instanceof,span,boost,query,span,boost,query,span,boost,query,span,boost,query,query,assert,that,span,boost,query,get,boost,equal,to,query,builder,boost,query,span,boost,query,get,query,else,boost,query,boost,query,boost,query,query,assert,that,boost,query,get,boost,equal,to,query,builder,boost,query,boost,query,get,query,do,assert,lucene,query,query,builder,query,context
AbstractQueryTestCase -> private void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1547002001;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1551176390;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1524684173;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1526510804;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1528167589;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1531179852;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1531937412;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1532685069;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1539723533;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1541156195;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1543252559;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1543834151;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1546434630;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1547002001;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException;1551176390;Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder};protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(queryAsString)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,string,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;protected,void,assert,parsed,query,string,query,as,string,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,query,as,string,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1524684173;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1526510804;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1528167589;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1531179852;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1531937412;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1532685069;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1539723533;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1541156195;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1543252559;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1543834151;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1546434630;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1547002001;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected boolean builderGeneratesCacheableQueries();1551176390;Whether the queries produced by this builder are expected to be cacheable.;protected boolean builderGeneratesCacheableQueries() {_        return true__    };whether,the,queries,produced,by,this,builder,are,expected,to,be,cacheable;protected,boolean,builder,generates,cacheable,queries,return,true
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1524684173;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1526510804;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1528167589;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1531179852;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1531937412;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1532685069;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1539723533;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1541156195;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1543252559;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1543834151;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1546434630;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1547002001;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;1551176390;Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}_and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.;protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException_;checks,the,result,of,link,query,builder,to,query,query,shard,context,given,the,original,link,query,builder,and,link,query,shard,context,contains,the,query,specific,checks,to,be,implemented,by,subclasses;protected,abstract,void,do,assert,lucene,query,qb,query,builder,query,query,search,context,context,throws,ioexception
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1524684173;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1526510804;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1528167589;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1531179852;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1531937412;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1532685069;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1539723533;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1541156195;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1543252559;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1543834151;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1546434630;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1547002001;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> protected Set<String> getObjectsHoldingArbitraryContent();1551176390;Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown_objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden_by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects_that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such_cases no exception would get thrown.;protected Set<String> getObjectsHoldingArbitraryContent() {_        return Collections.emptySet()__    };returns,a,set,of,object,names,that,won,t,trigger,any,exception,uncluding,their,children,when,testing,that,unknown,objects,cause,parse,exceptions,through,link,test,unknown,object,exception,default,is,an,empty,set,can,be,overridden,by,subclasses,that,test,queries,which,contain,objects,that,get,parsed,on,the,data,nodes,e,g,score,functions,or,objects,that,can,contain,arbitrary,content,e,g,documents,for,percolate,or,more,like,this,query,params,for,scripts,in,such,cases,no,exception,would,get,thrown;protected,set,string,get,objects,holding,arbitrary,content,return,collections,empty,set
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1524684173;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1526510804;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1528167589;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1531179852;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1531937412;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1532685069;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1539723533;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1541156195;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1543252559;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1543834151;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1546434630;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1547002001;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> public final void testUnknownObjectException() throws IOException;1551176390;Test that adding an additional object within each object of the otherwise correct query always triggers some kind of_parse exception. Some specific objects do not cause any exception as they can hold arbitrary content_ they can be_declared by overriding {@link #getObjectsHoldingArbitraryContent()}.;public final void testUnknownObjectException() throws IOException {_        Set<String> candidates = new HashSet<>()__        _        candidates.add(createTestQueryBuilder().toString())__        _        candidates.addAll(getAlternateVersions().keySet())___        List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent())__        for (Tuple<String, Boolean> testQuery : testQueries) {_            boolean expectedException = testQuery.v2()__            try {_                parseQuery(testQuery.v1())__                if (expectedException) {_                    fail("some parsing exception expected for query: " + testQuery)__                }_            } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {_                _                _                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_            } catch (IllegalArgumentException e) {_                if (expectedException == false) {_                    throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e)__                }_                assertThat(e.getMessage(), containsString("unknown field [newField], parser not found"))__            }_        }_    };test,that,adding,an,additional,object,within,each,object,of,the,otherwise,correct,query,always,triggers,some,kind,of,parse,exception,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,can,be,declared,by,overriding,link,get,objects,holding,arbitrary,content;public,final,void,test,unknown,object,exception,throws,ioexception,set,string,candidates,new,hash,set,candidates,add,create,test,query,builder,to,string,candidates,add,all,get,alternate,versions,key,set,list,tuple,string,boolean,test,queries,alterate,queries,candidates,get,objects,holding,arbitrary,content,for,tuple,string,boolean,test,query,test,queries,boolean,expected,exception,test,query,v2,try,parse,query,test,query,v1,if,expected,exception,fail,some,parsing,exception,expected,for,query,test,query,catch,parsing,exception,elasticsearch,parse,exception,xcontent,parse,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,catch,illegal,argument,exception,e,if,expected,exception,false,throw,new,assertion,error,unexpected,exception,when,parsing,query,n,test,query,e,assert,that,e,get,message,contains,string,unknown,field,new,field,parser,not,found
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1524684173;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1526510804;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1528167589;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1531179852;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1531937412;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1532685069;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1539723533;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1541156195;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1543252559;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1543834151;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1546434630;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1547002001;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected String[] shuffleProtectedFields();1551176390;Subclasses can override this method and return an array of fieldnames which should be protected from_recursive random shuffling in the {@link #testFromXContent()} test case;protected String[] shuffleProtectedFields() {_        return Strings.EMPTY_ARRAY__    };subclasses,can,override,this,method,and,return,an,array,of,fieldnames,which,should,be,protected,from,recursive,random,shuffling,in,the,link,test,from,xcontent,test,case;protected,string,shuffle,protected,fields,return,strings
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1524684173;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1526510804;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1528167589;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1531179852;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1531937412;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1532685069;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1539723533;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1541156195;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1543252559;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1543834151;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1546434630;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1547002001;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> protected abstract QB doCreateTestQueryBuilder()_;1551176390;Create the query that is being tested;protected abstract QB doCreateTestQueryBuilder()_;create,the,query,that,is,being,tested;protected,abstract,qb,do,create,test,query,builder
AbstractQueryTestCase -> public void testSerialization() throws IOException;1524684173;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1526510804;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1528167589;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1531179852;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1531937412;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1532685069;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1539723533;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1541156195;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1543252559;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1543834151;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1546434630;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1547002001;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> public void testSerialization() throws IOException;1551176390;Test serialization and deserialization of the test query.;public void testSerialization() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            assertSerialization(testQuery)__        }_    };test,serialization,and,deserialization,of,the,test,query;public,void,test,serialization,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,assert,serialization,test,query
AbstractQueryTestCase -> protected static String getRandomFieldName();1524684173;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (currentTypes.length == 0 || randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        }_        return randomFrom(MAPPED_LEAF_FIELD_NAMES)__    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,current,types,length,0,random,boolean,return,random,alpha,of,length,between,1,10,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1526510804;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (getCurrentTypes().length == 0 || randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        }_        return randomFrom(MAPPED_LEAF_FIELD_NAMES)__    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,get,current,types,length,0,random,boolean,return,random,alpha,of,length,between,1,10,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1528167589;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (getCurrentTypes().length == 0 || randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        }_        return randomFrom(MAPPED_LEAF_FIELD_NAMES)__    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,get,current,types,length,0,random,boolean,return,random,alpha,of,length,between,1,10,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1531179852;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (getCurrentTypes().length == 0 || randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        }_        return randomFrom(MAPPED_LEAF_FIELD_NAMES)__    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,get,current,types,length,0,random,boolean,return,random,alpha,of,length,between,1,10,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1531937412;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (getCurrentTypes().length == 0 || randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        }_        return randomFrom(MAPPED_LEAF_FIELD_NAMES)__    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,get,current,types,length,0,random,boolean,return,random,alpha,of,length,between,1,10,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1532685069;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1539723533;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1541156195;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1543252559;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1543834151;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1546434630;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1547002001;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected static String getRandomFieldName();1551176390;Helper method to return a mapped or a random field;protected static String getRandomFieldName() {_        _        if (randomBoolean()) {_            return randomAlphaOfLengthBetween(1, 10)__        } else {_            return randomFrom(MAPPED_LEAF_FIELD_NAMES)__        }_    };helper,method,to,return,a,mapped,or,a,random,field;protected,static,string,get,random,field,name,if,random,boolean,return,random,alpha,of,length,between,1,10,else,return,random,from
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1524684173;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1526510804;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1528167589;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1531179852;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1531937412;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1532685069;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1539723533;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> protected boolean supportsBoostAndQueryName();1541156195;Few queries allow you to set the boost and queryName on the java api, although the corresponding parser_doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries._Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:_wrapper query and match_none;protected boolean supportsBoostAndQueryName() {_        return true__    };few,queries,allow,you,to,set,the,boost,and,query,name,on,the,java,api,although,the,corresponding,parser,doesn,t,parse,them,as,they,are,not,supported,this,method,allows,to,disable,boost,and,query,name,related,tests,for,those,queries,those,queries,are,easy,to,identify,their,parsers,don,t,parse,boost,and,as,they,don,t,apply,to,the,specific,query,wrapper,query,and;protected,boolean,supports,boost,and,query,name,return,true
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1524684173;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1526510804;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1528167589;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1531179852;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1531937412;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1532685069;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1539723533;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1541156195;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1543252559;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1543834151;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1546434630;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1547002001;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> public void testFromXContent() throws IOException;1551176390;Generic test that creates new query from the test query and checks both for equality_and asserts equality on the two queries.;public void testFromXContent() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QB testQuery = createTestQueryBuilder()__            XContentType xContentType = randomFrom(XContentType.values())__            BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(),_                    shuffleProtectedFields())__            assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery)__            for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {_                String queryAsString = alternateVersion.getKey()__                assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue())__            }_        }_    };generic,test,that,creates,new,query,from,the,test,query,and,checks,both,for,equality,and,asserts,equality,on,the,two,queries;public,void,test,from,xcontent,throws,ioexception,for,int,runs,0,runs,runs,qb,test,query,create,test,query,builder,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,shuffled,xcontent,to,shuffled,xcontent,test,query,x,content,type,to,xcontent,random,boolean,shuffle,protected,fields,assert,parsed,query,create,parser,x,content,type,x,content,shuffled,xcontent,test,query,for,map,entry,string,qb,alternate,version,get,alternate,versions,entry,set,string,query,as,string,alternate,version,get,key,assert,parsed,query,create,parser,json,xcontent,json,xcontent,query,as,string,alternate,version,get,value
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1524684173;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1526510804;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1528167589;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1531179852;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1531937412;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1532685069;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1539723533;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1541156195;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1543252559;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1543834151;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1546434630;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1547002001;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException;1551176390;Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each_object encountered.__For instance given the following valid term query:__"term" : {_"field" : {_"value" : "foo"_____The following two mutations will be generated, and an exception is expected when trying to parse them:__"term" : {_"newField" : {_"field" : {_"value" : "foo"_______"term" : {_"field" : {_"newField" : {_"value" : "foo"______Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not_for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content_ they are passed using the_arbitraryMarkers parameter.;static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {_        List<Tuple<String, Boolean>> results = new ArrayList<>()___        _        boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false)___        for (String query : queries) {_            _            int mutation = 0___            while (true) {_                boolean expectException = true___                BytesStreamOutput out = new BytesStreamOutput()__                try (_                    XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out)__                    XContentParser parser = JsonXContent.jsonXContent_                        .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)__                ) {_                    int objectIndex = -1__                    Deque<String> levels = new LinkedList<>()___                    _                    XContentParser.Token token__                    while ((token = parser.nextToken()) != null) {_                        if (token == XContentParser.Token.START_ARRAY) {_                            levels.addLast(parser.currentName())__                        } else if (token == XContentParser.Token.START_OBJECT) {_                            objectIndex++__                            levels.addLast(parser.currentName())___                            if (objectIndex == mutation) {_                                _                                generator.writeStartObject()__                                generator.writeFieldName("newField")__                                generator.copyCurrentStructure(parser)__                                generator.writeEndObject()___                                if (hasArbitraryContent) {_                                    _                                    _                                    for (String marker : arbitraryMarkers) {_                                        if (levels.contains(marker)) {_                                            expectException = false__                                            break__                                        }_                                    }_                                }__                                _                                continue__                            }_                        } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {_                            levels.removeLast()__                        }__                        _                        generator.copyCurrentEvent(parser)__                    }__                    if (objectIndex < mutation) {_                        _                        break__                    } else {_                        _                        mutation++__                    }_                }__                results.add(new Tuple<>(out.bytes().utf8ToString(), expectException))__            }_        }_        return results__    };traverses,the,json,tree,of,the,valid,query,provided,as,argument,and,mutates,it,one,or,more,times,by,adding,one,object,within,each,object,encountered,for,instance,given,the,following,valid,term,query,term,field,value,foo,the,following,two,mutations,will,be,generated,and,an,exception,is,expected,when,trying,to,parse,them,term,new,field,field,value,foo,term,field,new,field,value,foo,every,mutation,is,then,added,to,the,list,of,results,with,a,boolean,flag,indicating,if,a,parsing,exception,is,expected,or,not,for,the,mutation,some,specific,objects,do,not,cause,any,exception,as,they,can,hold,arbitrary,content,they,are,passed,using,the,arbitrary,markers,parameter;static,list,tuple,string,boolean,alterate,queries,set,string,queries,set,string,arbitrary,markers,throws,ioexception,list,tuple,string,boolean,results,new,array,list,boolean,has,arbitrary,content,arbitrary,markers,null,arbitrary,markers,is,empty,false,for,string,query,queries,int,mutation,0,while,true,boolean,expect,exception,true,bytes,stream,output,out,new,bytes,stream,output,try,xcontent,generator,generator,xcontent,type,json,x,content,create,generator,out,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,deprecation,handler,query,int,object,index,1,deque,string,levels,new,linked,list,xcontent,parser,token,token,while,token,parser,next,token,null,if,token,xcontent,parser,token,levels,add,last,parser,current,name,else,if,token,xcontent,parser,token,object,index,levels,add,last,parser,current,name,if,object,index,mutation,generator,write,start,object,generator,write,field,name,new,field,generator,copy,current,structure,parser,generator,write,end,object,if,has,arbitrary,content,for,string,marker,arbitrary,markers,if,levels,contains,marker,expect,exception,false,break,continue,else,if,token,xcontent,parser,token,token,xcontent,parser,token,levels,remove,last,generator,copy,current,event,parser,if,object,index,mutation,break,else,mutation,results,add,new,tuple,out,bytes,utf8to,string,expect,exception,return,results
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1524684173;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1526510804;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1528167589;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1531179852;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1531937412;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1532685069;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1539723533;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1541156195;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1543252559;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1543834151;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1546434630;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1547002001;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testMustRewrite() throws IOException;1551176390;This test ensures that queries that need to be rewritten have dedicated tests._These queries must override this method accordingly.;public void testMustRewrite() throws IOException {_        QueryShardContext context = createShardContext()__        context.setAllowUnmappedFields(true)__        QB queryBuilder = createTestQueryBuilder()__        queryBuilder.toQuery(context)__    };this,test,ensures,that,queries,that,need,to,be,rewritten,have,dedicated,tests,these,queries,must,override,this,method,accordingly;public,void,test,must,rewrite,throws,ioexception,query,shard,context,context,create,shard,context,context,set,allow,unmapped,fields,true,qb,query,builder,create,test,query,builder,query,builder,to,query,context
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1528167589;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test._@throws IOException;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test,throws,ioexception;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1531179852;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1531937412;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1532685069;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1539723533;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1541156195;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1543252559;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1543834151;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1546434630;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1547002001;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> public void testUnknownField() throws IOException;1551176390;Test that unknown field trigger ParsingException._To find the right position in the root query, we add a marker as `queryName` which_all query builders support. The added bogus field after that should trigger the exception._Queries that allow arbitrary field names at this level need to override this test.;public void testUnknownField() throws IOException {_        String marker = "#marker#"__        QB testQuery__        do {_            testQuery = createTestQueryBuilder()__        } while (testQuery.toString().contains(marker))__        testQuery.queryName(marker)_ _        String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"")__        try {_            parseQuery(queryAsString)__            fail("expected ParsingException or XContentParsingException")__        } catch (ParsingException | XContentParseException e) {_            _            assertThat(e.getMessage(), containsString("bogusField"))__        }__    };test,that,unknown,field,trigger,parsing,exception,to,find,the,right,position,in,the,root,query,we,add,a,marker,as,query,name,which,all,query,builders,support,the,added,bogus,field,after,that,should,trigger,the,exception,queries,that,allow,arbitrary,field,names,at,this,level,need,to,override,this,test;public,void,test,unknown,field,throws,ioexception,string,marker,marker,qb,test,query,do,test,query,create,test,query,builder,while,test,query,to,string,contains,marker,test,query,query,name,marker,string,query,as,string,test,query,to,string,replace,marker,marker,bogus,field,some,value,try,parse,query,query,as,string,fail,expected,parsing,exception,or,xcontent,parsing,exception,catch,parsing,exception,xcontent,parse,exception,e,assert,that,e,get,message,contains,string,bogus,field
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1524684173;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1526510804;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1528167589;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1531179852;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1531937412;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1532685069;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1539723533;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1541156195;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1543252559;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1543834151;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1546434630;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1547002001;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> protected Map<String, QB> getAlternateVersions();1551176390;Returns alternate string representation of the query that need to be tested as they are never used as output_of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.;protected Map<String, QB> getAlternateVersions() {_        return Collections.emptyMap()__    };returns,alternate,string,representation,of,the,query,that,need,to,be,tested,as,they,are,never,used,as,output,of,link,query,builder,to,xcontent,xcontent,builder,to,xcontent,params,by,default,there,are,no,alternate,versions;protected,map,string,qb,get,alternate,versions,return,collections,empty,map
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1524684173;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1526510804;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1528167589;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1531179852;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1531937412;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1532685069;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1539723533;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1541156195;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1543252559;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1543834151;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException;1546434630;Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder};private static void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {_        QueryBuilder newQuery = parseQuery(parser)__        assertNotSame(newQuery, expectedQuery)__        assertEquals(expectedQuery, newQuery)__        assertEquals(expectedQuery.hashCode(), newQuery.hashCode())__    };parses,the,query,provided,as,bytes,argument,and,compares,it,with,the,expected,result,provided,as,argument,as,a,link,query,builder;private,static,void,assert,parsed,query,xcontent,parser,parser,query,builder,expected,query,throws,ioexception,query,builder,new,query,parse,query,parser,assert,not,same,new,query,expected,query,assert,equals,expected,query,new,query,assert,equals,expected,query,hash,code,new,query,hash,code
AbstractQueryTestCase -> public void testToQuery() throws IOException;1524684173;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(randomTypes, context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(randomTypes, context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,random,types,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,random,types,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1526510804;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(randomTypes, context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(randomTypes, context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,random,types,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,random,types,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1528167589;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(randomTypes, context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(randomTypes, context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,random,types,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,random,types,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1531179852;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(randomTypes, context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(randomTypes, context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,random,types,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,random,types,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1531937412;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(randomTypes, context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(randomTypes, context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,random,types,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,random,types,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1532685069;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1541156195;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoostAndQueryName()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,and,query,name,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1543252559;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoost()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }__            _            boolean filterFlag = randomBoolean()__            context.setIsFilter(filterFlag)__            rewriteQuery(firstQuery, context).toQuery(context)__            assertEquals("isFilter should be unchanged", filterFlag, context.isFilter())__        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query,boolean,filter,flag,random,boolean,context,set,is,filter,filter,flag,rewrite,query,first,query,context,to,query,context,assert,equals,is,filter,should,be,unchanged,filter,flag,context,is,filter
AbstractQueryTestCase -> public void testToQuery() throws IOException;1543834151;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCachable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCachable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCachable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoost()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }_        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cachable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cachable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cachable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cachable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query
AbstractQueryTestCase -> public void testToQuery() throws IOException;1546434630;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCacheable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCacheable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCacheable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCacheable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoost()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }_        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cacheable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cacheable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cacheable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cacheable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query
AbstractQueryTestCase -> public void testToQuery() throws IOException;1547002001;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCacheable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCacheable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCacheable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCacheable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoost()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }_        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cacheable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cacheable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cacheable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cacheable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query
AbstractQueryTestCase -> public void testToQuery() throws IOException;1551176390;Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the_assertions being made on the result to the implementing subclass.;public void testToQuery() throws IOException {_        for (int runs = 0_ runs < NUMBER_OF_TESTQUERIES_ runs++) {_            QueryShardContext context = createShardContext()__            assert context.isCacheable()__            context.setAllowUnmappedFields(true)__            QB firstQuery = createTestQueryBuilder()__            QB controlQuery = copyQuery(firstQuery)__            SearchContext searchContext = getSearchContext(context)__            _            QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context))__            Query firstLuceneQuery = rewritten.toQuery(context)__            if (isCacheable(firstQuery)) {_                assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: "_                        + firstQuery.toString(), context.isCacheable())__            } else {_                assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: "_                        + firstQuery.toString(), context.isCacheable())__            }_            assertNotNull("toQuery should not return null", firstLuceneQuery)__            assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext)__            _            assertTrue(_                    "query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    firstQuery.equals(controlQuery))__            assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery,_                    controlQuery.equals(firstQuery))__            assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery_                    + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode()))___            QB secondQuery = copyQuery(firstQuery)__            _            if (randomBoolean()) {_                secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName()_                        + randomAlphaOfLengthBetween(1, 10))__            }_            searchContext = getSearchContext(context)__            Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__            assertNotNull("toQuery should not return null", secondLuceneQuery)__            assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext)___            if (builderGeneratesCacheableQueries()) {_                assertEquals("two equivalent query builders lead to different lucene queries",_                        rewrite(secondLuceneQuery), rewrite(firstLuceneQuery))__            }__            if (supportsBoost()) {_                secondQuery.boost(firstQuery.boost() + 1f + randomFloat())__                Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context)__                assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery),_                        rewrite(thirdLuceneQuery))__            }_        }_    };test,creates,the,link,query,from,the,link,query,builder,under,test,and,delegates,the,assertions,being,made,on,the,result,to,the,implementing,subclass;public,void,test,to,query,throws,ioexception,for,int,runs,0,runs,runs,query,shard,context,context,create,shard,context,assert,context,is,cacheable,context,set,allow,unmapped,fields,true,qb,first,query,create,test,query,builder,qb,control,query,copy,query,first,query,search,context,search,context,get,search,context,context,query,builder,rewritten,rewrite,query,first,query,new,query,shard,context,context,query,first,lucene,query,rewritten,to,query,context,if,is,cacheable,first,query,assert,true,query,was,marked,as,not,cacheable,in,the,context,but,this,test,indicates,it,should,be,cacheable,first,query,to,string,context,is,cacheable,else,assert,false,query,was,marked,as,cacheable,in,the,context,but,this,test,indicates,it,should,not,be,cacheable,first,query,to,string,context,is,cacheable,assert,not,null,to,query,should,not,return,null,first,lucene,query,assert,lucene,query,first,query,first,lucene,query,search,context,assert,true,query,is,not,equal,to,its,copy,after,calling,to,query,first,query,first,query,second,query,control,query,first,query,equals,control,query,assert,true,equals,is,not,symmetric,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,equals,first,query,assert,that,query,copy,s,hashcode,is,different,from,original,hashcode,after,calling,to,query,first,query,first,query,second,query,control,query,control,query,hash,code,equal,to,first,query,hash,code,qb,second,query,copy,query,first,query,if,random,boolean,second,query,query,name,second,query,query,name,null,random,alpha,of,length,between,1,30,second,query,query,name,random,alpha,of,length,between,1,10,search,context,get,search,context,context,query,second,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,null,to,query,should,not,return,null,second,lucene,query,assert,lucene,query,second,query,second,lucene,query,search,context,if,builder,generates,cacheable,queries,assert,equals,two,equivalent,query,builders,lead,to,different,lucene,queries,rewrite,second,lucene,query,rewrite,first,lucene,query,if,supports,boost,second,query,boost,first,query,boost,1f,random,float,query,third,lucene,query,rewrite,query,second,query,context,to,query,context,assert,not,equals,modifying,the,boost,doesn,t,affect,the,corresponding,lucene,query,rewrite,first,lucene,query,rewrite,third,lucene,query
