commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;3;;public final QB createTestQueryBuilder() {     return createTestQueryBuilder(supportsBoost(), supportsQueryName()). }
false;public,final;2;10;;public final QB createTestQueryBuilder(boolean supportsBoost, boolean supportsQueryName) {     QB query = doCreateTestQueryBuilder().     if (supportsBoost && randomBoolean()) {         query.boost(2.0f / randomIntBetween(1, 20)).     }     if (supportsQueryName && randomBoolean()) {         query.queryName(createUniqueRandomName()).     }     return query. }
true;protected,abstract;0;1;/**  * Create the query that is being tested  */ ;/**  * Create the query that is being tested  */ protected abstract QB doCreateTestQueryBuilder().
false;public;0;6;;public void testNegativeBoosts() {     QB testQuery = createTestQueryBuilder().     IllegalArgumentException exc = expectThrows(IllegalArgumentException.class, () -> testQuery.boost(-0.5f)).     assertThat(exc.getMessage(), containsString("negative [boost]")). }
true;public;0;13;/**  * Generic test that creates new query from the test query and checks both for equality  * and asserts equality on the two queries.  */ ;/**  * Generic test that creates new query from the test query and checks both for equality  * and asserts equality on the two queries.  */ public void testFromXContent() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTQUERIES. runs++) {         QB testQuery = createTestQueryBuilder().         XContentType xContentType = randomFrom(XContentType.values()).         BytesReference shuffledXContent = toShuffledXContent(testQuery, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean(), shuffleProtectedFields()).         assertParsedQuery(createParser(xContentType.xContent(), shuffledXContent), testQuery).         for (Map.Entry<String, QB> alternateVersion : getAlternateVersions().entrySet()) {             String queryAsString = alternateVersion.getKey().             assertParsedQuery(createParser(JsonXContent.jsonXContent, queryAsString), alternateVersion.getValue()).         }     } }
true;protected;0;3;/**  * Subclasses can override this method and return an array of fieldnames which should be protected from  * recursive random shuffling in the {@link #testFromXContent()} test case  */ ;/**  * Subclasses can override this method and return an array of fieldnames which should be protected from  * recursive random shuffling in the {@link #testFromXContent()} test case  */ protected String[] shuffleProtectedFields() {     return Strings.EMPTY_ARRAY. }
true;public;0;17;/**  * Test that unknown field trigger ParsingException.  * To find the right position in the root query, we add a marker as `queryName` which  * all query builders support. The added bogus field after that should trigger the exception.  * Queries that allow arbitrary field names at this level need to override this test.  */ ;/**  * Test that unknown field trigger ParsingException.  * To find the right position in the root query, we add a marker as `queryName` which  * all query builders support. The added bogus field after that should trigger the exception.  * Queries that allow arbitrary field names at this level need to override this test.  */ public void testUnknownField() throws IOException {     String marker = "#marker#".     QB testQuery.     do {         testQuery = createTestQueryBuilder().     } while (testQuery.toString().contains(marker)).     // to find root query to add additional bogus field there     testQuery.queryName(marker).     String queryAsString = testQuery.toString().replace("\"" + marker + "\"", "\"" + marker + "\", \"bogusField\" : \"someValue\"").     try {         parseQuery(queryAsString).         fail("expected ParsingException or XContentParsingException").     } catch (ParsingException | XContentParseException e) {         // we'd like to see the offending field name here         assertThat(e.getMessage(), containsString("bogusField")).     } }
true;public,final;0;29;/**  * Test that adding an additional object within each object of the otherwise correct query always triggers some kind of  * parse exception. Some specific objects do not cause any exception as they can hold arbitrary content. they can be  * declared by overriding {@link #getObjectsHoldingArbitraryContent()}.  */ ;/**  * Test that adding an additional object within each object of the otherwise correct query always triggers some kind of  * parse exception. Some specific objects do not cause any exception as they can hold arbitrary content. they can be  * declared by overriding {@link #getObjectsHoldingArbitraryContent()}.  */ public final void testUnknownObjectException() throws IOException {     Set<String> candidates = new HashSet<>().     // Adds the valid query to the list of queries to modify and test     candidates.add(createTestQueryBuilder().toString()).     // Adds the alternates versions of the query too     candidates.addAll(getAlternateVersions().keySet()).     List<Tuple<String, Boolean>> testQueries = alterateQueries(candidates, getObjectsHoldingArbitraryContent()).     for (Tuple<String, Boolean> testQuery : testQueries) {         boolean expectedException = testQuery.v2().         try {             parseQuery(testQuery.v1()).             if (expectedException) {                 fail("some parsing exception expected for query: " + testQuery).             }         } catch (ParsingException | ElasticsearchParseException | XContentParseException e) {             // of mutation, so no simple asserts possible here             if (expectedException == false) {                 throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e).             }         } catch (IllegalArgumentException e) {             if (expectedException == false) {                 throw new AssertionError("unexpected exception when parsing query:\n" + testQuery, e).             }             assertThat(e.getMessage(), containsString("unknown field [newField], parser not found")).         }     } }
true;static;2;74;/**  * Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each  * object encountered.  *  * For instance given the following valid term query:  * {  *     "term" : {  *         "field" : {  *             "value" : "foo"  *         }  *     }  * }  *  * The following two mutations will be generated, and an exception is expected when trying to parse them:  * {  *     "term" : {  *         "newField" : {  *             "field" : {  *                 "value" : "foo"  *             }  *         }  *     }  * }  *  * {  *     "term" : {  *         "field" : {  *             "newField" : {  *                 "value" : "foo"  *             }  *         }  *     }  * }  *  * Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not  * for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content. they are passed using the  * arbitraryMarkers parameter.  */ ;/**  * Traverses the json tree of the valid query provided as argument and mutates it one or more times by adding one object within each  * object encountered.  *  * For instance given the following valid term query:  * {  *     "term" : {  *         "field" : {  *             "value" : "foo"  *         }  *     }  * }  *  * The following two mutations will be generated, and an exception is expected when trying to parse them:  * {  *     "term" : {  *         "newField" : {  *             "field" : {  *                 "value" : "foo"  *             }  *         }  *     }  * }  *  * {  *     "term" : {  *         "field" : {  *             "newField" : {  *                 "value" : "foo"  *             }  *         }  *     }  * }  *  * Every mutation is then added to the list of results with a boolean flag indicating if a parsing exception is expected or not  * for the mutation. Some specific objects do not cause any exception as they can hold arbitrary content. they are passed using the  * arbitraryMarkers parameter.  */ static List<Tuple<String, Boolean>> alterateQueries(Set<String> queries, Set<String> arbitraryMarkers) throws IOException {     List<Tuple<String, Boolean>> results = new ArrayList<>().     // Indicate if a part of the query can hold any arbitrary content     boolean hasArbitraryContent = (arbitraryMarkers != null && arbitraryMarkers.isEmpty() == false).     for (String query : queries) {         // Track the number of query mutations         int mutation = 0.         while (true) {             boolean expectException = true.             BytesStreamOutput out = new BytesStreamOutput().             try (XContentGenerator generator = XContentType.JSON.xContent().createGenerator(out).                 XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, query)) {                 int objectIndex = -1.                 Deque<String> levels = new LinkedList<>().                 // Parse the valid query and inserts a new object level called "newField"                 XContentParser.Token token.                 while ((token = parser.nextToken()) != null) {                     if (token == XContentParser.Token.START_ARRAY) {                         levels.addLast(parser.currentName()).                     } else if (token == XContentParser.Token.START_OBJECT) {                         objectIndex++.                         levels.addLast(parser.currentName()).                         if (objectIndex == mutation) {                             // We reached the place in the object tree where we want to insert a new object level                             generator.writeStartObject().                             generator.writeFieldName("newField").                             generator.copyCurrentStructure(parser).                             generator.writeEndObject().                             if (hasArbitraryContent) {                                 // field is one (or a child) of those, no exception is expected when parsing the mutated query.                                 for (String marker : arbitraryMarkers) {                                     if (levels.contains(marker)) {                                         expectException = false.                                         break.                                     }                                 }                             }                             // Jump to next token                             continue.                         }                     } else if (token == XContentParser.Token.END_OBJECT || token == XContentParser.Token.END_ARRAY) {                         levels.removeLast().                     }                     // We are walking through the object tree, so we can safely copy the current node                     generator.copyCurrentEvent(parser).                 }                 if (objectIndex < mutation) {                     // We did not reach the insertion point, there's no more mutations to try                     break.                 } else {                     // We reached the expected insertion point, so next time we'll try one step further                     mutation++.                 }             }             results.add(new Tuple<>(out.bytes().utf8ToString(), expectException)).         }     }     return results. }
true;protected;0;3;/**  * Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown  * objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden  * by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects  * that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such  * cases no exception would get thrown.  */ ;/**  * Returns a set of object names that won't trigger any exception (uncluding their children) when testing that unknown  * objects cause parse exceptions through {@link #testUnknownObjectException()}. Default is an empty set. Can be overridden  * by subclasses that test queries which contain objects that get parsed on the data nodes (e.g. score functions) or objects  * that can contain arbitrary content (e.g. documents for percolate or more like this query, params for scripts). In such  * cases no exception would get thrown.  */ protected Set<String> getObjectsHoldingArbitraryContent() {     return Collections.emptySet(). }
true;public,final;0;9;/**  * Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}  * This causes unexpected situations in parser code that may not be handled properly.  */ ;/**  * Test that wraps the randomly generated query into an array as follows: { "query_name" : [{}]}  * This causes unexpected situations in parser code that may not be handled properly.  */ public final void testQueryWrappedInArray() {     QB queryBuilder = createTestQueryBuilder().     String queryName = queryBuilder.getName().     String validQuery = queryBuilder.toString().     queryWrappedInArrayTest(queryName, validQuery).     for (String query : getAlternateVersions().keySet()) {         queryWrappedInArrayTest(queryName, query).     } }
false;private;2;26;;private void queryWrappedInArrayTest(String queryName, String validQuery) {     int i = validQuery.indexOf("\"" + queryName + "\"").     assertThat(i, greaterThan(0)).     int insertionPosition.     for (insertionPosition = i. insertionPosition < validQuery.length(). insertionPosition++) {         if (validQuery.charAt(insertionPosition) == ':') {             break.         }     }     insertionPosition++.     int endArrayPosition.     for (endArrayPosition = validQuery.length() - 1. endArrayPosition >= 0. endArrayPosition--) {         if (validQuery.charAt(endArrayPosition) == '}') {             break.         }     }     String testQuery = validQuery.substring(0, insertionPosition) + "[" + validQuery.substring(insertionPosition, endArrayPosition) + "]" + validQuery.substring(endArrayPosition, validQuery.length()).     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(testQuery)).     assertEquals("[" + queryName + "] query malformed, no start_object after query name", e.getMessage()). }
true;protected;0;3;/**  * Returns alternate string representation of the query that need to be tested as they are never used as output  * of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.  */ ;/**  * Returns alternate string representation of the query that need to be tested as they are never used as output  * of {@link QueryBuilder#toXContent(XContentBuilder, ToXContent.Params)}. By default there are no alternate versions.  */ protected Map<String, QB> getAlternateVersions() {     return Collections.emptyMap(). }
true;protected;2;6;/**  * Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder}  */ ;/**  * Parses the query provided as string argument and compares it with the expected result provided as argument as a {@link QueryBuilder}  */ protected void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {     QueryBuilder newQuery = parseQuery(queryAsString).     assertNotSame(newQuery, expectedQuery).     assertEquals(expectedQuery, newQuery).     assertEquals(expectedQuery.hashCode(), newQuery.hashCode()). }
true;private;2;6;/**  * Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder}  */ ;/**  * Parses the query provided as bytes argument and compares it with the expected result provided as argument as a {@link QueryBuilder}  */ private void assertParsedQuery(XContentParser parser, QueryBuilder expectedQuery) throws IOException {     QueryBuilder newQuery = parseQuery(parser).     assertNotSame(newQuery, expectedQuery).     assertEquals(expectedQuery, newQuery).     assertEquals(expectedQuery.hashCode(), newQuery.hashCode()). }
false;protected;1;4;;protected QueryBuilder parseQuery(AbstractQueryBuilder<?> builder) throws IOException {     BytesReference bytes = XContentHelper.toXContent(builder, XContentType.JSON, false).     return parseQuery(createParser(JsonXContent.jsonXContent, bytes)). }
false;protected;1;4;;protected QueryBuilder parseQuery(String queryAsString) throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, queryAsString).     return parseQuery(parser). }
false;protected;1;5;;protected QueryBuilder parseQuery(XContentParser parser) throws IOException {     QueryBuilder parseInnerQueryBuilder = parseInnerQueryBuilder(parser).     assertNull(parser.nextToken()).     return parseInnerQueryBuilder. }
true;protected;0;3;/**  * Whether the queries produced by this builder are expected to be cacheable.  */ ;/**  * Whether the queries produced by this builder are expected to be cacheable.  */ protected boolean builderGeneratesCacheableQueries() {     return true. }
true;public;0;55;/**  * Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the  * assertions being made on the result to the implementing subclass.  */ ;/**  * Test creates the {@link Query} from the {@link QueryBuilder} under test and delegates the  * assertions being made on the result to the implementing subclass.  */ public void testToQuery() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTQUERIES. runs++) {         QueryShardContext context = createShardContext().         assert context.isCacheable().         context.setAllowUnmappedFields(true).         QB firstQuery = createTestQueryBuilder().         QB controlQuery = copyQuery(firstQuery).         SearchContext searchContext = getSearchContext(context).         /* we use a private rewrite context here since we want the most realistic way of asserting that we are cacheable or not.              * We do it this way in SearchService where              * we first rewrite the query with a private context, then reset the context and then build the actual lucene query*/         QueryBuilder rewritten = rewriteQuery(firstQuery, new QueryShardContext(context)).         Query firstLuceneQuery = rewritten.toQuery(context).         if (isCacheable(firstQuery)) {             assertTrue("query was marked as not cacheable in the context but this test indicates it should be cacheable: " + firstQuery.toString(), context.isCacheable()).         } else {             assertFalse("query was marked as cacheable in the context but this test indicates it should not be cacheable: " + firstQuery.toString(), context.isCacheable()).         }         assertNotNull("toQuery should not return null", firstLuceneQuery).         assertLuceneQuery(firstQuery, firstLuceneQuery, searchContext).         // remove after assertLuceneQuery since the assertLuceneQuery impl might access the context as well         assertTrue("query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery, firstQuery.equals(controlQuery)).         assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery, controlQuery.equals(firstQuery)).         assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: " + controlQuery, controlQuery.hashCode(), equalTo(firstQuery.hashCode())).         QB secondQuery = copyQuery(firstQuery).         // query _name never should affect the result of toQuery, we randomly set it to make sure         if (randomBoolean()) {             secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName() + randomAlphaOfLengthBetween(1, 10)).         }         searchContext = getSearchContext(context).         Query secondLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context).         assertNotNull("toQuery should not return null", secondLuceneQuery).         assertLuceneQuery(secondQuery, secondLuceneQuery, searchContext).         if (builderGeneratesCacheableQueries()) {             assertEquals("two equivalent query builders lead to different lucene queries", rewrite(secondLuceneQuery), rewrite(firstLuceneQuery)).         }         if (supportsBoost()) {             secondQuery.boost(firstQuery.boost() + 1f + randomFloat()).             Query thirdLuceneQuery = rewriteQuery(secondQuery, context).toQuery(context).             assertNotEquals("modifying the boost doesn't affect the corresponding lucene query", rewrite(firstLuceneQuery), rewrite(thirdLuceneQuery)).         }     } }
false;private;2;6;;private QueryBuilder rewriteQuery(QB queryBuilder, QueryRewriteContext rewriteContext) throws IOException {     QueryBuilder rewritten = rewriteAndFetch(queryBuilder, rewriteContext).     // extra safety to fail fast - serialize the rewritten version to ensure it's serializable.     assertSerialization(rewritten).     return rewritten. }
false;protected;1;3;;protected boolean isCacheable(QB queryBuilder) {     return true. }
true;protected;0;3;/**  * Few queries allow you to set the boost on the Java API, although the corresponding parser  * doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries.  * Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:  * wrapper query and {@code match_none}.  */ ;/**  * Few queries allow you to set the boost on the Java API, although the corresponding parser  * doesn't parse it as it isn't supported. This method allows to disable boost related tests for those queries.  * Those queries are easy to identify: their parsers don't parse {@code boost} as they don't apply to the specific query:  * wrapper query and {@code match_none}.  */ protected boolean supportsBoost() {     return true. }
true;protected;0;3;/**  * Few queries allow you to set the query name on the Java API, although the corresponding parser  * doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries.  * Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:  * wrapper query and {@code match_none}.  */ ;/**  * Few queries allow you to set the query name on the Java API, although the corresponding parser  * doesn't parse it as it isn't supported. This method allows to disable query name related tests for those queries.  * Those queries are easy to identify: their parsers don't parse {@code _name} as they don't apply to the specific query:  * wrapper query and {@code match_none}.  */ protected boolean supportsQueryName() {     return true. }
true;private;3;21;/**  * Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}  * and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to  * {@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.  */ ;/**  * Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}  * and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to  * {@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, SearchContext)} for query specific checks.  */ private void assertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException {     if (queryBuilder.queryName() != null) {         Query namedQuery = context.getQueryShardContext().copyNamedQueries().get(queryBuilder.queryName()).         assertThat(namedQuery, equalTo(query)).     }     if (query != null) {         if (queryBuilder.boost() != AbstractQueryBuilder.DEFAULT_BOOST) {             assertThat(query, either(instanceOf(BoostQuery.class)).or(instanceOf(SpanBoostQuery.class))).             if (query instanceof SpanBoostQuery) {                 SpanBoostQuery spanBoostQuery = (SpanBoostQuery) query.                 assertThat(spanBoostQuery.getBoost(), equalTo(queryBuilder.boost())).                 query = spanBoostQuery.getQuery().             } else {                 BoostQuery boostQuery = (BoostQuery) query.                 assertThat(boostQuery.getBoost(), equalTo(queryBuilder.boost())).                 query = boostQuery.getQuery().             }         }     }     doAssertLuceneQuery(queryBuilder, query, context). }
true;protected,abstract;3;1;/**  * Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}  * and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.  */ ;/**  * Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}  * and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses.  */ protected abstract void doAssertLuceneQuery(QB queryBuilder, Query query, SearchContext context) throws IOException.
false;protected;4;9;;protected void assertTermOrBoostQuery(Query query, String field, String value, float fieldBoost) {     if (fieldBoost != AbstractQueryBuilder.DEFAULT_BOOST) {         assertThat(query, instanceOf(BoostQuery.class)).         BoostQuery boostQuery = (BoostQuery) query.         assertThat(boostQuery.getBoost(), equalTo(fieldBoost)).         query = boostQuery.getQuery().     }     assertTermQuery(query, field, value). }
false;protected;3;8;;protected void assertTermQuery(Query query, String field, String value) {     assertThat(query, instanceOf(TermQuery.class)).     TermQuery termQuery = (TermQuery) query.     String expectedFieldName = expectedFieldName(field).     assertThat(termQuery.getTerm().field(), equalTo(expectedFieldName)).     assertThat(termQuery.getTerm().text().toLowerCase(Locale.ROOT), equalTo(value.toLowerCase(Locale.ROOT))). }
true;public;0;6;/**  * Test serialization and deserialization of the test query.  */ ;/**  * Test serialization and deserialization of the test query.  */ public void testSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTQUERIES. runs++) {         QB testQuery = createTestQueryBuilder().         assertSerialization(testQuery).     } }
false;protected;1;3;;protected QueryBuilder assertSerialization(QueryBuilder testQuery) throws IOException {     return assertSerialization(testQuery, Version.CURRENT). }
true;protected;2;14;/**  * Serialize the given query builder and asserts that both are equal  */ ;/**  * Serialize the given query builder and asserts that both are equal  */ protected QueryBuilder assertSerialization(QueryBuilder testQuery, Version version) throws IOException {     try (BytesStreamOutput output = new BytesStreamOutput()) {         output.setVersion(version).         output.writeNamedWriteable(testQuery).         try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry())) {             in.setVersion(version).             QueryBuilder deserializedQuery = in.readNamedWriteable(QueryBuilder.class).             assertEquals(testQuery, deserializedQuery).             assertEquals(testQuery.hashCode(), deserializedQuery.hashCode()).             assertNotSame(testQuery, deserializedQuery).             return deserializedQuery.         }     } }
false;public;0;7;;public void testEqualsAndHashcode() {     for (int runs = 0. runs < NUMBER_OF_TESTQUERIES. runs++) {         // TODO we only change name and boost, we should extend by any sub-test supplying a "mutate" method that randomly changes one         // aspect of the object under test         checkEqualsAndHashCode(createTestQueryBuilder(), this::copyQuery, this::mutateInstance).     } }
false;public;1;3;;public QB mutateInstance(QB instance) throws IOException {     return changeNameOrBoost(instance). }
true;public;0;10;/**  * Generic test that checks that the <code>Strings.toString()</code> method  * renders the XContent correctly.  */ ;/**  * Generic test that checks that the <code>Strings.toString()</code> method  * renders the XContent correctly.  */ public void testValidOutput() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTQUERIES. runs++) {         QB testQuery = createTestQueryBuilder().         XContentType xContentType = XContentType.JSON.         String toString = Strings.toString(testQuery).         assertParsedQuery(createParser(xContentType.xContent(), toString), testQuery).         BytesReference bytes = XContentHelper.toXContent(testQuery, xContentType, false).         assertParsedQuery(createParser(xContentType.xContent(), bytes), testQuery).     } }
false;protected;1;10;;protected QB changeNameOrBoost(QB original) throws IOException {     QB secondQuery = copyQuery(original).     if (randomBoolean()) {         secondQuery.queryName(secondQuery.queryName() == null ? randomAlphaOfLengthBetween(1, 30) : secondQuery.queryName() + randomAlphaOfLengthBetween(1, 10)).     } else {         secondQuery.boost(original.boost() + 1f + randomFloat()).     }     return secondQuery. }
true;private;1;5;// we use the streaming infra to create a copy of the query provided as argument ;// we use the streaming infra to create a copy of the query provided as argument @SuppressWarnings("unchecked") private QB copyQuery(QB query) throws IOException {     Reader<QB> reader = (Reader<QB>) namedWriteableRegistry().getReader(QueryBuilder.class, query.getWriteableName()).     return copyWriteable(query, namedWriteableRegistry(), reader). }
true;protected,static;1;30;/**  * create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},  * {@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or  * {@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default  */ ;/**  * create a random value for either {@link AbstractQueryTestCase#BOOLEAN_FIELD_NAME}, {@link AbstractQueryTestCase#INT_FIELD_NAME},  * {@link AbstractQueryTestCase#DOUBLE_FIELD_NAME}, {@link AbstractQueryTestCase#STRING_FIELD_NAME} or  * {@link AbstractQueryTestCase#DATE_FIELD_NAME}, or a String value by default  */ protected static Object getRandomValueForFieldName(String fieldName) {     Object value.     switch(fieldName) {         case STRING_FIELD_NAME:         case STRING_ALIAS_FIELD_NAME:             if (rarely()) {                 // unicode in 10% cases                 JsonStringEncoder encoder = JsonStringEncoder.getInstance().                 value = new String(encoder.quoteAsString(randomUnicodeOfLength(10))).             } else {                 value = randomAlphaOfLengthBetween(1, 10).             }             break.         case INT_FIELD_NAME:             value = randomIntBetween(0, 10).             break.         case DOUBLE_FIELD_NAME:             value = 1 + randomDouble() * 9.             break.         case BOOLEAN_FIELD_NAME:             value = randomBoolean().             break.         case DATE_FIELD_NAME:             value = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC).toString().             break.         default:             value = randomAlphaOfLengthBetween(1, 10).     }     return value. }
false;protected,static;0;8;;protected static String getRandomQueryText() {     int terms = randomIntBetween(0, 3).     StringBuilder builder = new StringBuilder().     for (int i = 0. i < terms. i++) {         builder.append(randomAlphaOfLengthBetween(1, 10)).append(" ").     }     return builder.toString().trim(). }
true;protected,static;0;8;/**  * Helper method to return a mapped or a random field  */ ;/**  * Helper method to return a mapped or a random field  */ protected static String getRandomFieldName() {     // if no type is set then return a random field name     if (randomBoolean()) {         return randomAlphaOfLengthBetween(1, 10).     } else {         return randomFrom(MAPPED_LEAF_FIELD_NAMES).     } }
true;protected,static;0;13;/**  * Helper method to return a random rewrite method  */ ;/**  * Helper method to return a random rewrite method  */ protected static String getRandomRewriteMethod() {     String rewrite.     if (randomBoolean()) {         rewrite = randomFrom(QueryParsers.CONSTANT_SCORE, QueryParsers.SCORING_BOOLEAN, QueryParsers.CONSTANT_SCORE_BOOLEAN).getPreferredName().     } else {         rewrite = randomFrom(QueryParsers.TOP_TERMS, QueryParsers.TOP_TERMS_BOOST, QueryParsers.TOP_TERMS_BLENDED_FREQS).getPreferredName() + "1".     }     return rewrite. }
false;protected,static;1;15;;protected static Fuzziness randomFuzziness(String fieldName) {     switch(fieldName) {         case INT_FIELD_NAME:             return Fuzziness.build(randomIntBetween(3, 100)).         case DOUBLE_FIELD_NAME:             return Fuzziness.build(1 + randomFloat() * 10).         case DATE_FIELD_NAME:             return Fuzziness.build(randomTimeValue()).         default:             if (randomBoolean()) {                 return Fuzziness.fromEdits(randomIntBetween(0, 2)).             }             return Fuzziness.AUTO.     } }
false;protected,static;0;3;;protected static String randomAnalyzer() {     return randomFrom("simple", "standard", "keyword", "whitespace"). }
false;protected,static;0;3;;protected static String randomMinimumShouldMatch() {     return randomFrom("1", "-1", "75%", "-25%", "2<75%", "2<-25%"). }
true;public,static;2;9;/**  * Call this method to check a valid json string representing the query under test against  * it's generated json.  *  * Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl  * reference docs mirroring examples there. Here's how the queries were generated:  *  * <ul>  * <li> Take a reference documentation example.  * <li> Stick it into the createParseableQueryJson method of the respective query test.  * <li> Manually check that what the QueryBuilder generates equals the input json ignoring default options.  * <li> Put the manual checks into the assertQueryParsedFromJson method.  * <li> Now copy the generated json including default options into createParseableQueryJson  * <li> By now the roundtrip check for the json should be happy.  * </ul>  */ ;/**  * Call this method to check a valid json string representing the query under test against  * it's generated json.  *  * Note: By the time of this writing (Nov 2015) all queries are taken from the query dsl  * reference docs mirroring examples there. Here's how the queries were generated:  *  * <ul>  * <li> Take a reference documentation example.  * <li> Stick it into the createParseableQueryJson method of the respective query test.  * <li> Manually check that what the QueryBuilder generates equals the input json ignoring default options.  * <li> Put the manual checks into the assertQueryParsedFromJson method.  * <li> Now copy the generated json including default options into createParseableQueryJson  * <li> By now the roundtrip check for the json should be happy.  * </ul>  */ public static void checkGeneratedJson(String expected, QueryBuilder source) throws IOException {     // now assert that we actually generate the same JSON     XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint().     source.toXContent(builder, ToXContent.EMPTY_PARAMS).     assertEquals(msg(expected, Strings.toString(builder)), expected.replaceAll("\\s+", ""), Strings.toString(builder).replaceAll("\\s+", "")). }
false;private,static;2;24;;private static String msg(String left, String right) {     int size = Math.min(left.length(), right.length()).     StringBuilder builder = new StringBuilder("size: " + left.length() + " vs. " + right.length()).     builder.append(" content: <<").     for (int i = 0. i < size. i++) {         if (left.charAt(i) == right.charAt(i)) {             builder.append(left.charAt(i)).         } else {             builder.append(">> ").append("until offset: ").append(i).append(" [").append(left.charAt(i)).append(" vs.").append(right.charAt(i)).append("] [").append((int) left.charAt(i)).append(" vs.").append((int) right.charAt(i)).append(']').             return builder.toString().         }     }     if (left.length() != right.length()) {         int leftEnd = Math.max(size, left.length()) - 1.         int rightEnd = Math.max(size, right.length()) - 1.         builder.append(">> ").append("until offset: ").append(size).append(" [").append(left.charAt(leftEnd)).append(" vs.").append(right.charAt(rightEnd)).append("] [").append((int) left.charAt(leftEnd)).append(" vs.").append((int) right.charAt(rightEnd)).append(']').         return builder.toString().     }     return "". }
true;public;0;6;/**  * This test ensures that queries that need to be rewritten have dedicated tests.  * These queries must override this method accordingly.  */ ;/**  * This test ensures that queries that need to be rewritten have dedicated tests.  * These queries must override this method accordingly.  */ public void testMustRewrite() throws IOException {     QueryShardContext context = createShardContext().     context.setAllowUnmappedFields(true).     QB queryBuilder = createTestQueryBuilder().     queryBuilder.toQuery(context). }
false;protected;1;3;;protected Query rewrite(Query query) throws IOException {     return query. }
false;protected;2;5;;protected QueryBuilder rewriteAndFetch(QueryBuilder builder, QueryRewriteContext context) {     PlainActionFuture<QueryBuilder> future = new PlainActionFuture<>().     Rewriteable.rewriteAndFetch(builder, context, future).     return future.actionGet(). }
false;public;1;3;;public boolean isTextField(String fieldName) {     return fieldName.equals(STRING_FIELD_NAME) || fieldName.equals(STRING_ALIAS_FIELD_NAME). }
