commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;18;;@Override protected AsyncShardFetch.FetchResult<NodeGatewayStartedShards> fetchData(ShardRouting shard, RoutingAllocation allocation) {     // for now always return immediately what we know     final ShardId shardId = shard.shardId().     final Set<String> ignoreNodes = allocation.getIgnoreNodes(shardId).     Map<DiscoveryNode, NodeGatewayStartedShards> foundShards = knownAllocations.values().stream().flatMap(shardMap -> shardMap.values().stream()).filter(ks -> ks.shardId().equals(shardId)).filter(ks -> ignoreNodes.contains(ks.currentNodeId()) == false).filter(ks -> currentNodes.nodeExists(ks.currentNodeId())).collect(Collectors.toMap(routing -> currentNodes.get(routing.currentNodeId()), routing -> new NodeGatewayStartedShards(currentNodes.get(routing.currentNodeId()), routing.allocationId().getId(), routing.primary()))).     return new AsyncShardFetch.FetchResult<>(shardId, foundShards, ignoreNodes). }
false;protected;2;6;;@Override protected AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> fetchData(ShardRouting shard, RoutingAllocation allocation) {     // for now, just pretend no node has data     final ShardId shardId = shard.shardId().     return new AsyncShardFetch.FetchResult<>(shardId, Collections.emptyMap(), allocation.getIgnoreNodes(shardId)). }
false;protected;1;4;;@Override protected boolean hasInitiatedFetching(ShardRouting shard) {     return true. }
false;public;2;5;;@Override public void applyStartedShards(RoutingAllocation allocation, List<ShardRouting> startedShards) {     currentNodes = allocation.nodes().     allocation.routingNodes().shards(ShardRouting::active).forEach(this::addKnownAllocation). }
false;public;2;14;;@Override public void applyFailedShards(RoutingAllocation allocation, List<FailedShard> failedShards) {     currentNodes = allocation.nodes().     for (FailedShard failedShard : failedShards) {         final ShardRouting failedRouting = failedShard.getRoutingEntry().         Map<ShardId, ShardRouting> nodeAllocations = knownAllocations.get(failedRouting.currentNodeId()).         if (nodeAllocations != null) {             nodeAllocations.remove(failedRouting.shardId()).             if (nodeAllocations.isEmpty()) {                 knownAllocations.remove(failedRouting.currentNodeId()).             }         }     } }
false;public;1;5;;@Override public void allocateUnassigned(RoutingAllocation allocation) {     currentNodes = allocation.nodes().     innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator). }
true;public;1;4;/**  * manually add a specific shard to the allocations the gateway keeps track of  */ ;/**  * manually add a specific shard to the allocations the gateway keeps track of  */ public void addKnownAllocation(ShardRouting shard) {     knownAllocations.computeIfAbsent(shard.currentNodeId(), id -> new HashMap<>()).put(shard.shardId(), shard). }
