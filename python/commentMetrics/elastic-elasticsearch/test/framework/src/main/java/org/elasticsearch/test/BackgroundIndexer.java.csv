commented;modifiers;parameterAmount;loc;comment;code
false;public;0;69;;@Override public void run() {     long id = -1.     try {         startLatch.await().         logger.info("**** starting indexing thread {}", indexerId).         while (!stop.get()) {             if (batch) {                 int batchSize = threadRandom.nextInt(20) + 1.                 if (hasBudget.get()) {                     // always try to get at least one                     batchSize = Math.max(Math.min(batchSize, availableBudget.availablePermits()), 1).                     if (!availableBudget.tryAcquire(batchSize, 250, TimeUnit.MILLISECONDS)) {                         // time out -> check if we have to stop.                         continue.                     }                 }                 BulkRequestBuilder bulkRequest = client.prepareBulk().                 for (int i = 0. i < batchSize. i++) {                     id = idGenerator.incrementAndGet().                     if (useAutoGeneratedIDs) {                         bulkRequest.add(client.prepareIndex(index, type).setSource(generateSource(id, threadRandom))).                     } else {                         bulkRequest.add(client.prepareIndex(index, type, Long.toString(id)).setSource(generateSource(id, threadRandom))).                     }                 }                 BulkResponse bulkResponse = bulkRequest.get().                 for (BulkItemResponse bulkItemResponse : bulkResponse) {                     if (bulkItemResponse.isFailed() == false) {                         boolean add = ids.add(bulkItemResponse.getId()).                         assert add : "ID: " + bulkItemResponse.getId() + " already used".                     } else {                         failures.add(bulkItemResponse.getFailure().getCause()).                     }                 }             } else {                 if (hasBudget.get() && !availableBudget.tryAcquire(250, TimeUnit.MILLISECONDS)) {                     // time out -> check if we have to stop.                     continue.                 }                 id = idGenerator.incrementAndGet().                 if (useAutoGeneratedIDs) {                     IndexResponse indexResponse = client.prepareIndex(index, type).setSource(generateSource(id, threadRandom)).get().                     boolean add = ids.add(indexResponse.getId()).                     assert add : "ID: " + indexResponse.getId() + " already used".                 } else {                     IndexResponse indexResponse = client.prepareIndex(index, type, Long.toString(id)).setSource(generateSource(id, threadRandom)).get().                     boolean add = ids.add(indexResponse.getId()).                     assert add : "ID: " + indexResponse.getId() + " already used".                 }             }         }         logger.info("**** done indexing thread {}  stop: {} numDocsIndexed: {}", indexerId, stop.get(), ids.size()).     } catch (Exception e) {         failures.add(e).         final long docId = id.         logger.warn((Supplier<?>) () -> new ParameterizedMessage("**** failed indexing thread {} on doc id {}", indexerId, docId), e).     } finally {         stopLatch.countDown().     } }
false;private;2;15;;private XContentBuilder generateSource(long id, Random random) throws IOException {     int contentLength = RandomNumbers.randomIntBetween(random, minFieldSize, maxFieldSize).     StringBuilder text = new StringBuilder(contentLength).     while (text.length() < contentLength) {         int tokenLength = RandomNumbers.randomIntBetween(random, 1, Math.min(contentLength - text.length(), 10)).         text.append(" ").append(RandomStrings.randomRealisticUnicodeOfCodepointLength(random, tokenLength)).     }     XContentBuilder builder = XContentFactory.smileBuilder().     builder.startObject().field("test", "value" + id).field("text", text.toString()).field("id", id).endObject().     return builder. }
false;private;1;10;;private void setBudget(int numOfDocs) {     logger.debug("updating budget to [{}]", numOfDocs).     if (numOfDocs >= 0) {         hasBudget.set(true).         availableBudget.release(numOfDocs).     } else {         hasBudget.set(false).     } }
true;public;1;5;/**  * Start indexing  *  * @param numOfDocs number of document to index before pausing. Set to -1 to have no limit.  */ ;/**  * Start indexing  *  * @param numOfDocs number of document to index before pausing. Set to -1 to have no limit.  */ public void start(int numOfDocs) {     assert !stop.get() : "background indexer can not be started after it has stopped".     setBudget(numOfDocs).     startLatch.countDown(). }
true;public;0;4;/**  * Pausing indexing by setting current document limit to 0  */ ;/**  * Pausing indexing by setting current document limit to 0  */ public void pauseIndexing() {     availableBudget.drainPermits().     setBudget(0). }
true;public;1;3;/**  * Continue indexing after it has paused.  *  * @param numOfDocs number of document to index before pausing. Set to -1 to have no limit.  */ ;/**  * Continue indexing after it has paused.  *  * @param numOfDocs number of document to index before pausing. Set to -1 to have no limit.  */ public void continueIndexing(int numOfDocs) {     setBudget(numOfDocs). }
true;public;0;10;/**  * Stop all background threads *  */ ;/**  * Stop all background threads *  */ public void stop() throws InterruptedException {     if (stop.get()) {         return.     }     stop.set(true).     Assert.assertThat("timeout while waiting for indexing threads to stop", stopLatch.await(6, TimeUnit.MINUTES), equalTo(true)).     if (assertNoFailuresOnStop) {         assertNoFailures().     } }
false;public;0;3;;public long totalIndexedDocs() {     return ids.size(). }
false;public;0;3;;public Throwable[] getFailures() {     return failures.toArray(new Throwable[failures.size()]). }
false;public;0;3;;public void assertNoFailures() {     Assert.assertThat(failures, emptyIterable()). }
false;public;1;3;;public void setAssertNoFailuresOnStop(final boolean assertNoFailuresOnStop) {     this.assertNoFailuresOnStop = assertNoFailuresOnStop. }
false;public;0;4;;@Override public void close() throws Exception {     stop(). }
false;public;0;3;;public Client getClient() {     return client. }
true;public;0;3;/**  * Returns the ID set of all documents indexed by this indexer run  */ ;/**  * Returns the ID set of all documents indexed by this indexer run  */ public Set<String> getIds() {     return this.ids. }
