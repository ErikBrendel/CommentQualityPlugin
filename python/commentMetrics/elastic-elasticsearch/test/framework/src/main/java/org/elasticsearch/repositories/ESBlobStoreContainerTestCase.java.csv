commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;public void testReadNonExistingPath() throws IOException {     try (BlobStore store = newBlobStore()) {         final BlobContainer container = store.blobContainer(new BlobPath()).         expectThrows(NoSuchFileException.class, () -> {             try (InputStream is = container.readBlob("non-existing")) {                 is.read().             }         }).     } }
false;public;0;23;;public void testWriteRead() throws IOException {     try (BlobStore store = newBlobStore()) {         final BlobContainer container = store.blobContainer(new BlobPath()).         byte[] data = randomBytes(randomIntBetween(10, scaledRandomIntBetween(1024, 1 << 16))).         writeBlob(container, "foobar", new BytesArray(data), randomBoolean()).         if (randomBoolean()) {             // override file, to check if we get latest contents             data = randomBytes(randomIntBetween(10, scaledRandomIntBetween(1024, 1 << 16))).             writeBlob(container, "foobar", new BytesArray(data), false).         }         try (InputStream stream = container.readBlob("foobar")) {             BytesRefBuilder target = new BytesRefBuilder().             while (target.length() < data.length) {                 byte[] buffer = new byte[scaledRandomIntBetween(1, data.length - target.length())].                 int offset = scaledRandomIntBetween(0, buffer.length - 1).                 int read = stream.read(buffer, offset, buffer.length - offset).                 target.append(new BytesRef(buffer, offset, read)).             }             assertEquals(data.length, target.length()).             assertArrayEquals(data, Arrays.copyOfRange(target.bytes(), 0, target.length())).         }     } }
false;public;0;38;;public void testList() throws IOException {     try (BlobStore store = newBlobStore()) {         final BlobContainer container = store.blobContainer(new BlobPath()).         assertThat(container.listBlobs().size(), equalTo(0)).         int numberOfFooBlobs = randomIntBetween(0, 10).         int numberOfBarBlobs = randomIntBetween(3, 20).         Map<String, Long> generatedBlobs = new HashMap<>().         for (int i = 0. i < numberOfFooBlobs. i++) {             int length = randomIntBetween(10, 100).             String name = "foo-" + i + "-".             generatedBlobs.put(name, (long) length).             writeRandomBlob(container, name, length).         }         for (int i = 1. i < numberOfBarBlobs. i++) {             int length = randomIntBetween(10, 100).             String name = "bar-" + i + "-".             generatedBlobs.put(name, (long) length).             writeRandomBlob(container, name, length).         }         int length = randomIntBetween(10, 100).         String name = "bar-0-".         generatedBlobs.put(name, (long) length).         writeRandomBlob(container, name, length).         Map<String, BlobMetaData> blobs = container.listBlobs().         assertThat(blobs.size(), equalTo(numberOfFooBlobs + numberOfBarBlobs)).         for (Map.Entry<String, Long> generated : generatedBlobs.entrySet()) {             BlobMetaData blobMetaData = blobs.get(generated.getKey()).             assertThat(generated.getKey(), blobMetaData, notNullValue()).             assertThat(blobMetaData.name(), equalTo(generated.getKey())).             assertThat(blobMetaData.length(), equalTo(generated.getValue())).         }         assertThat(container.listBlobsByPrefix("foo-").size(), equalTo(numberOfFooBlobs)).         assertThat(container.listBlobsByPrefix("bar-").size(), equalTo(numberOfBarBlobs)).         assertThat(container.listBlobsByPrefix("baz-").size(), equalTo(0)).     } }
false;public;0;15;;public void testDeleteBlob() throws IOException {     try (BlobStore store = newBlobStore()) {         final String blobName = "foobar".         final BlobContainer container = store.blobContainer(new BlobPath()).         expectThrows(NoSuchFileException.class, () -> container.deleteBlob(blobName)).         byte[] data = randomBytes(randomIntBetween(10, scaledRandomIntBetween(1024, 1 << 16))).         final BytesArray bytesArray = new BytesArray(data).         writeBlob(container, blobName, bytesArray, randomBoolean()).         // should not raise         container.deleteBlob(blobName).         // blob deleted, so should raise again         expectThrows(NoSuchFileException.class, () -> container.deleteBlob(blobName)).     } }
false;public;0;11;;public void testDeleteBlobIgnoringIfNotExists() throws IOException {     try (BlobStore store = newBlobStore()) {         BlobPath blobPath = new BlobPath().         if (randomBoolean()) {             blobPath = blobPath.add(randomAlphaOfLengthBetween(1, 10)).         }         final BlobContainer container = store.blobContainer(blobPath).         container.deleteBlobIgnoringIfNotExists("does_not_exist").     } }
false;public;0;13;;public void testVerifyOverwriteFails() throws IOException {     try (BlobStore store = newBlobStore()) {         final String blobName = "foobar".         final BlobContainer container = store.blobContainer(new BlobPath()).         byte[] data = randomBytes(randomIntBetween(10, scaledRandomIntBetween(1024, 1 << 16))).         final BytesArray bytesArray = new BytesArray(data).         writeBlob(container, blobName, bytesArray, true).         // should not be able to overwrite existing blob         expectThrows(FileAlreadyExistsException.class, () -> writeBlob(container, blobName, bytesArray, true)).         container.deleteBlob(blobName).         // after deleting the previous blob, we should be able to write to it again         writeBlob(container, blobName, bytesArray, true).     } }
false;protected;4;10;;protected void writeBlob(final BlobContainer container, final String blobName, final BytesArray bytesArray, boolean failIfAlreadyExists) throws IOException {     try (InputStream stream = bytesArray.streamInput()) {         if (randomBoolean()) {             container.writeBlob(blobName, stream, bytesArray.length(), failIfAlreadyExists).         } else {             container.writeBlobAtomic(blobName, stream, bytesArray.length(), failIfAlreadyExists).         }     } }
false;protected,abstract;0;1;;protected abstract BlobStore newBlobStore() throws IOException.
