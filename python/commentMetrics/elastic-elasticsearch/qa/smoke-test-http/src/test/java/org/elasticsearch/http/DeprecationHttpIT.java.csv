commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;1;11;;@Override protected Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(TEST_DEPRECATED_SETTING_TRUE1.getKey(), !TEST_DEPRECATED_SETTING_TRUE1.getDefault(Settings.EMPTY)).put(TEST_DEPRECATED_SETTING_TRUE2.getKey(), !TEST_DEPRECATED_SETTING_TRUE2.getDefault(Settings.EMPTY)).put(TEST_NOT_DEPRECATED_SETTING.getKey(), !TEST_NOT_DEPRECATED_SETTING.getDefault(Settings.EMPTY)).build(). }
false;protected;0;6;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     ArrayList<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins()).     plugins.add(TestDeprecationPlugin.class).     return plugins. }
true;public;0;40;/**  * Attempts to do a scatter/gather request that expects unique responses per sub-request.  */ ;/**  * Attempts to do a scatter/gather request that expects unique responses per sub-request.  */ @AwaitsFix(bugUrl = "https://github.com/elastic/elasticsearch/issues/19222") public void testUniqueDeprecationResponsesMergedTogether() throws IOException {     final String[] indices = new String[randomIntBetween(2, 5)].     // add at least one document for each index     for (int i = 0. i < indices.length. ++i) {         indices[i] = "test" + i.         // create indices with a single shard to reduce noise. the query only deprecates uniquely by index anyway         assertTrue(prepareCreate(indices[i]).setSettings(Settings.builder().put("number_of_shards", 1)).get().isAcknowledged()).         int randomDocCount = randomIntBetween(1, 2).         for (int j = 0. j < randomDocCount. ++j) {             index(indices[i], "type", Integer.toString(j), "{\"field\":" + j + "}").         }     }     refresh(indices).     final String commaSeparatedIndices = Stream.of(indices).collect(Collectors.joining(",")).     // trigger all index deprecations     Request request = new Request("GET", "/" + commaSeparatedIndices + "/_search").     request.setJsonEntity("{\"query\":{\"bool\":{\"filter\":[{\"" + TestDeprecatedQueryBuilder.NAME + "\":{}}]}}}").     Response response = getRestClient().performRequest(request).     assertThat(response.getStatusLine().getStatusCode(), equalTo(OK.getStatus())).     final List<String> deprecatedWarnings = getWarningHeaders(response.getHeaders()).     final List<Matcher<String>> headerMatchers = new ArrayList<>(indices.length).     for (String index : indices) {         headerMatchers.add(containsString(LoggerMessageFormat.format("[{}] index", (Object) index))).     }     assertThat(deprecatedWarnings, hasSize(headerMatchers.size())).     for (Matcher<String> headerMatcher : headerMatchers) {         assertThat(deprecatedWarnings, hasItem(headerMatcher)).     } }
false;public;0;3;;public void testDeprecationWarningsAppearInHeaders() throws Exception {     doTestDeprecationWarningsAppearInHeaders(). }
false;public;0;7;;public void testDeprecationHeadersDoNotGetStuck() throws Exception {     doTestDeprecationWarningsAppearInHeaders().     doTestDeprecationWarningsAppearInHeaders().     if (rarely()) {         doTestDeprecationWarningsAppearInHeaders().     } }
true;private;0;49;/**  * Run a request that receives a predictably randomized number of deprecation warnings.  * <p>  * Re-running this back-to-back helps to ensure that warnings are not being maintained across requests.  */ ;/**  * Run a request that receives a predictably randomized number of deprecation warnings.  * <p>  * Re-running this back-to-back helps to ensure that warnings are not being maintained across requests.  */ private void doTestDeprecationWarningsAppearInHeaders() throws IOException {     final boolean useDeprecatedField = randomBoolean().     final boolean useNonDeprecatedSetting = randomBoolean().     // deprecated settings should also trigger a deprecation warning     final List<Setting<Boolean>> settings = new ArrayList<>(3).     settings.add(TEST_DEPRECATED_SETTING_TRUE1).     if (randomBoolean()) {         settings.add(TEST_DEPRECATED_SETTING_TRUE2).     }     if (useNonDeprecatedSetting) {         settings.add(TEST_NOT_DEPRECATED_SETTING).     }     Collections.shuffle(settings, random()).     // trigger all deprecations     Request request = new Request("GET", "/_test_cluster/deprecated_settings").     request.setEntity(buildSettingsRequest(settings, useDeprecatedField)).     Response response = getRestClient().performRequest(request).     assertThat(response.getStatusLine().getStatusCode(), equalTo(OK.getStatus())).     final List<String> deprecatedWarnings = getWarningHeaders(response.getHeaders()).     final List<Matcher<String>> headerMatchers = new ArrayList<>(4).     headerMatchers.add(equalTo(TestDeprecationHeaderRestAction.DEPRECATED_ENDPOINT)).     if (useDeprecatedField) {         headerMatchers.add(equalTo(TestDeprecationHeaderRestAction.DEPRECATED_USAGE)).     }     for (Setting<?> setting : settings) {         if (setting.isDeprecated()) {             headerMatchers.add(equalTo("[" + setting.getKey() + "] setting was deprecated in Elasticsearch and will be removed in a future release! " + "See the breaking changes documentation for the next major version.")).         }     }     assertThat(deprecatedWarnings, hasSize(headerMatchers.size())).     for (final String deprecatedWarning : deprecatedWarnings) {         assertThat(deprecatedWarning, matches(WARNING_HEADER_PATTERN.pattern())).     }     final List<String> actualWarningValues = deprecatedWarnings.stream().map(DeprecationLogger::extractWarningValueFromWarningHeader).collect(Collectors.toList()).     for (Matcher<String> headerMatcher : headerMatchers) {         assertThat(actualWarningValues, hasItem(headerMatcher)).     } }
false;private;1;11;;private List<String> getWarningHeaders(Header[] headers) {     List<String> warnings = new ArrayList<>().     for (Header header : headers) {         if (header.getName().equals("Warning")) {             warnings.add(header.getValue()).         }     }     return warnings. }
false;private;2;13;;private HttpEntity buildSettingsRequest(List<Setting<Boolean>> settings, boolean useDeprecatedField) throws IOException {     XContentBuilder builder = JsonXContent.contentBuilder().     builder.startObject().startArray(useDeprecatedField ? "deprecated_settings" : "settings").     for (Setting<Boolean> setting : settings) {         builder.value(setting.getKey()).     }     builder.endArray().endObject().     return new StringEntity(Strings.toString(builder), ContentType.APPLICATION_JSON). }
