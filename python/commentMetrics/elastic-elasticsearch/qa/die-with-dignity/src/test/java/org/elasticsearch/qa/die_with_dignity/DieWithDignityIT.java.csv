commented;modifiers;parameterAmount;loc;comment;code
false;public;0;69;;public void testDieWithDignity() throws Exception {     // deleting the PID file prevents stopping the cluster from failing since it occurs if and only if the PID file exists     final Path pidFile = PathUtils.get(System.getProperty("pidfile")).     final List<String> pidFileLines = Files.readAllLines(pidFile).     assertThat(pidFileLines, hasSize(1)).     final int pid = Integer.parseInt(pidFileLines.get(0)).     Files.delete(pidFile).     IOException e = expectThrows(IOException.class, () -> client().performRequest(new Request("GET", "/_die_with_dignity"))).     Matcher<IOException> failureMatcher = instanceOf(ConnectionClosedException.class).     if (Constants.WINDOWS) {         /*              * If the other side closes the connection while we're waiting to fill our buffer              * we can get IOException with the message below. It seems to only come up on              * Windows and it *feels* like it could be a ConnectionClosedException but              * upstream does not consider this a bug:              * https://issues.apache.org/jira/browse/HTTPASYNC-134              *              * So we catch it here and consider it "ok".              */         failureMatcher = either(failureMatcher).or(hasToString(containsString("An existing connection was forcibly closed by the remote host"))).     }     assertThat(e, failureMatcher).     // the Elasticsearch process should die and disappear from the output of jps     assertBusy(() -> {         final String jpsPath = PathUtils.get(System.getProperty("runtime.java.home"), "bin/jps").toString().         final Process process = new ProcessBuilder().command(jpsPath).start().         assertThat(process.waitFor(), equalTo(0)).         try (InputStream is = process.getInputStream().             BufferedReader in = new BufferedReader(new InputStreamReader(is, "UTF-8"))) {             String line.             while ((line = in.readLine()) != null) {                 final int currentPid = Integer.parseInt(line.split("\\s+")[0]).                 assertThat(line, pid, not(equalTo(currentPid))).             }         }     }).     try {         // parse the logs and ensure that Elasticsearch died with the expected cause         Path path = PathUtils.get(System.getProperty("log")).         try (Stream<JsonLogLine> stream = JsonLogsStream.from(path)) {             final Iterator<JsonLogLine> it = stream.iterator().             boolean fatalError = false.             boolean fatalErrorInThreadExiting = false.             while (it.hasNext() && (fatalError == false || fatalErrorInThreadExiting == false)) {                 final JsonLogLine line = it.next().                 if (isFatalError(line)) {                     fatalError = true.                 } else if (isFatalErrorInThreadExiting(line) || isWarnExceptionReceived(line)) {                     fatalErrorInThreadExiting = true.                     assertThat(line.stacktrace(), hasItem(Matchers.containsString("java.lang.OutOfMemoryError: die with dignity"))).                 }             }             assertTrue(fatalError).             assertTrue(fatalErrorInThreadExiting).         }     } catch (AssertionError ae) {         Path path = PathUtils.get(System.getProperty("log")).         debugLogs(path).         throw ae.     } }
false;private;1;6;;private boolean isWarnExceptionReceived(JsonLogLine line) {     return line.level().equals("WARN") && line.component().equals("o.e.h.AbstractHttpServerTransport") && line.nodeName().equals("node-0") && line.message().contains("caught exception while handling client http traffic"). }
false;private;1;6;;private void debugLogs(Path path) throws IOException {     try (BufferedReader reader = Files.newBufferedReader(path)) {         Terminal terminal = Terminal.DEFAULT.         reader.lines().forEach(line -> terminal.println(line)).     } }
false;private;1;6;;private boolean isFatalErrorInThreadExiting(JsonLogLine line) {     return line.level().equals("ERROR") && line.component().equals("o.e.b.ElasticsearchUncaughtExceptionHandler") && line.nodeName().equals("node-0") && line.message().matches("fatal error in thread \\[Thread-\\d+\\], exiting$"). }
false;private;1;6;;private boolean isFatalError(JsonLogLine line) {     return line.level().equals("ERROR") && line.component().equals("o.e.ExceptionsHelper") && line.nodeName().equals("node-0") && line.message().contains("fatal error"). }
false;protected;0;5;;@Override protected boolean preserveClusterUponCompletion() {     // as the cluster is dead its state can not be wiped successfully so we have to bypass wiping the cluster     return true. }
