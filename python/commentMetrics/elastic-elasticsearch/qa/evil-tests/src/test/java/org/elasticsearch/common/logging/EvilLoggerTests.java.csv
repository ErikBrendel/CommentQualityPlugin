commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void setUp() throws Exception {     super.setUp().     LogConfigurator.registerErrorListener(). }
false;public;0;6;;@Override public void tearDown() throws Exception {     LoggerContext context = (LoggerContext) LogManager.getContext(false).     Configurator.shutdown(context).     super.tearDown(). }
false;public;0;25;;public void testLocationInfoTest() throws IOException, UserException {     setupLogging("location_info").     final Logger testLogger = LogManager.getLogger("test").     testLogger.error("This is an error message").     testLogger.warn("This is a warning message").     testLogger.info("This is an info message").     testLogger.debug("This is a debug message").     testLogger.trace("This is a trace message").     final String path = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + ".log".     final List<String> events = Files.readAllLines(PathUtils.get(path)).     assertThat(events.size(), equalTo(5)).     final String location = "org.elasticsearch.common.logging.EvilLoggerTests.testLocationInfoTest".     // the first message is a warning for unsupported configuration files     assertLogLine(events.get(0), Level.ERROR, location, "This is an error message").     assertLogLine(events.get(1), Level.WARN, location, "This is a warning message").     assertLogLine(events.get(2), Level.INFO, location, "This is an info message").     assertLogLine(events.get(3), Level.DEBUG, location, "This is a debug message").     assertLogLine(events.get(4), Level.TRACE, location, "This is a trace message"). }
false;public;0;26;;public void testDeprecationLogger() throws IOException, UserException {     setupLogging("deprecation").     final DeprecationLogger deprecationLogger = new DeprecationLogger(LogManager.getLogger("deprecation")).     final int deprecatedIterations = randomIntBetween(0, 256).     for (int i = 0. i < deprecatedIterations. i++) {         deprecationLogger.deprecated("This is a deprecation message").         assertWarnings("This is a deprecation message").     }     final String deprecationPath = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + "_deprecation.log".     final List<String> deprecationEvents = Files.readAllLines(PathUtils.get(deprecationPath)).     assertThat(deprecationEvents.size(), equalTo(deprecatedIterations)).     for (int i = 0. i < deprecatedIterations. i++) {         assertLogLine(deprecationEvents.get(i), Level.WARN, "org.elasticsearch.common.logging.DeprecationLogger\\$2\\.run", "This is a deprecation message").     } }
false;public;0;78;;public void testConcurrentDeprecationLogger() throws IOException, UserException, BrokenBarrierException, InterruptedException {     setupLogging("deprecation").     final DeprecationLogger deprecationLogger = new DeprecationLogger(LogManager.getLogger("deprecation")).     final int numberOfThreads = randomIntBetween(2, 4).     final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfThreads).     final List<Thread> threads = new ArrayList<>().     final int iterations = randomIntBetween(1, 4).     for (int i = 0. i < numberOfThreads. i++) {         final Thread thread = new Thread(() -> {             final List<Integer> ids = IntStream.range(0, 128).boxed().collect(Collectors.toList()).             Randomness.shuffle(ids).             final ThreadContext threadContext = new ThreadContext(Settings.EMPTY).             DeprecationLogger.setThreadContext(threadContext).             try {                 barrier.await().             } catch (final BrokenBarrierException | InterruptedException e) {                 throw new RuntimeException(e).             }             for (int j = 0. j < iterations. j++) {                 for (final Integer id : ids) {                     deprecationLogger.deprecatedAndMaybeLog(Integer.toString(id), "This is a maybe logged deprecation message" + id).                 }             }             /*                  * We have to manually check that each thread has the right warning headers in the thread context because the act of doing                  * this through the test framework on one thread would otherwise clear the thread context and we would be unable to assert                  * on the other threads.                  */             final List<String> warnings = threadContext.getResponseHeaders().get("Warning").             final Set<String> actualWarningValues = warnings.stream().map(DeprecationLogger::extractWarningValueFromWarningHeader).collect(Collectors.toSet()).             for (int j = 0. j < 128. j++) {                 assertThat(actualWarningValues, hasItem(DeprecationLogger.escapeAndEncode("This is a maybe logged deprecation message" + j))).             }             try {                 barrier.await().             } catch (final BrokenBarrierException | InterruptedException e) {                 throw new RuntimeException(e).             }         }).         threads.add(thread).         thread.start().     }     // synchronize the start of all threads     barrier.await().     // wait for all threads to complete their iterations     barrier.await().     final String deprecationPath = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + "_deprecation.log".     final List<String> deprecationEvents = Files.readAllLines(PathUtils.get(deprecationPath)).     // we appended an integer to each log message, use that for sorting     deprecationEvents.sort(Comparator.comparingInt(s -> Integer.parseInt(s.split("message")[1]))).     assertThat(deprecationEvents.size(), equalTo(128)).     for (int i = 0. i < 128. i++) {         assertLogLine(deprecationEvents.get(i), Level.WARN, "org.elasticsearch.common.logging.DeprecationLogger\\$2\\.run", "This is a maybe logged deprecation message" + i).     }     for (final Thread thread : threads) {         thread.join().     } }
false;public;0;42;;public void testDeprecationLoggerMaybeLog() throws IOException, UserException {     setupLogging("deprecation").     final DeprecationLogger deprecationLogger = new DeprecationLogger(LogManager.getLogger("deprecation")).     final int iterations = randomIntBetween(1, 16).     for (int i = 0. i < iterations. i++) {         deprecationLogger.deprecatedAndMaybeLog("key", "This is a maybe logged deprecation message").         assertWarnings("This is a maybe logged deprecation message").     }     for (int k = 0. k < 128. k++) {         for (int i = 0. i < iterations. i++) {             deprecationLogger.deprecatedAndMaybeLog("key" + k, "This is a maybe logged deprecation message" + k).             assertWarnings("This is a maybe logged deprecation message" + k).         }     }     for (int i = 0. i < iterations. i++) {         deprecationLogger.deprecatedAndMaybeLog("key", "This is a maybe logged deprecation message").         assertWarnings("This is a maybe logged deprecation message").     }     final String deprecationPath = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + "_deprecation.log".     final List<String> deprecationEvents = Files.readAllLines(PathUtils.get(deprecationPath)).     assertThat(deprecationEvents.size(), equalTo(1 + 128 + 1)).     assertLogLine(deprecationEvents.get(0), Level.WARN, "org.elasticsearch.common.logging.DeprecationLogger\\$2\\.run", "This is a maybe logged deprecation message").     for (int k = 0. k < 128. k++) {         assertLogLine(deprecationEvents.get(1 + k), Level.WARN, "org.elasticsearch.common.logging.DeprecationLogger\\$2\\.run", "This is a maybe logged deprecation message" + k).     } }
false;public;0;28;;public void testDeprecatedSettings() throws IOException, UserException {     setupLogging("settings").     final Setting<Boolean> setting = Setting.boolSetting("deprecated.foo", false, Setting.Property.Deprecated).     final Settings settings = Settings.builder().put("deprecated.foo", true).build().     final int iterations = randomIntBetween(0, 128).     for (int i = 0. i < iterations. i++) {         setting.get(settings).         assertSettingDeprecationsAndWarnings(new Setting<?>[] { setting }).     }     final String deprecationPath = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + "_deprecation.log".     final List<String> deprecationEvents = Files.readAllLines(PathUtils.get(deprecationPath)).     if (iterations > 0) {         assertThat(deprecationEvents.size(), equalTo(1)).         assertLogLine(deprecationEvents.get(0), Level.WARN, "org.elasticsearch.common.logging.DeprecationLogger\\$2\\.run", "\\[deprecated.foo\\] setting was deprecated in Elasticsearch and will be removed in a future release! " + "See the breaking changes documentation for the next major version.").     } }
false;public;0;13;;public void testFindAppender() throws IOException, UserException {     setupLogging("find_appender").     final Logger hasConsoleAppender = LogManager.getLogger("has_console_appender").     final Appender testLoggerConsoleAppender = Loggers.findAppender(hasConsoleAppender, ConsoleAppender.class).     assertNotNull(testLoggerConsoleAppender).     assertThat(testLoggerConsoleAppender.getName(), equalTo("console")).     final Logger hasCountingNoOpAppender = LogManager.getLogger("has_counting_no_op_appender").     assertNull(Loggers.findAppender(hasCountingNoOpAppender, ConsoleAppender.class)).     final Appender countingNoOpAppender = Loggers.findAppender(hasCountingNoOpAppender, CountingNoOpAppender.class).     assertThat(countingNoOpAppender.getName(), equalTo("counting_no_op")). }
false;public;0;28;;public void testPrefixLogger() throws IOException, IllegalAccessException, UserException {     setupLogging("prefix").     final String prefix = randomAlphaOfLength(16).     final Logger logger = new PrefixLogger(LogManager.getLogger("prefix_test"), prefix).     logger.info("test").     logger.info("{}", "test").     final Exception e = new Exception("exception").     logger.info(new ParameterizedMessage("{}", "test"), e).     final String path = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + ".log".     final List<String> events = Files.readAllLines(PathUtils.get(path)).     final StringWriter sw = new StringWriter().     final PrintWriter pw = new PrintWriter(sw).     e.printStackTrace(pw).     final int stackTraceLength = sw.toString().split(System.getProperty("line.separator")).length.     final int expectedLogLines = 3.     assertThat(events.size(), equalTo(expectedLogLines + stackTraceLength)).     for (int i = 0. i < expectedLogLines. i++) {         assertThat("Contents of [" + path + "] are wrong", events.get(i), startsWith("[" + getTestName() + "]" + prefix + " test")).     } }
false;public;0;12;;public void testPrefixLoggerMarkersCanBeCollected() throws IOException, UserException {     setupLogging("prefix").     // to ensure enough markers that the GC should collect some when we force a GC below     final int prefixes = 1 << 19.     for (int i = 0. i < prefixes. i++) {         // this has the side effect of caching a marker with this prefix         new PrefixLogger(LogManager.getLogger("logger" + i), "prefix" + i).     }     // this will free the weakly referenced keys in the marker cache     System.gc().     assertThat(PrefixLogger.markersSize(), lessThan(prefixes)). }
false;public;0;12;;public void testProperties() throws IOException, UserException {     final Settings settings = Settings.builder().put("cluster.name", randomAlphaOfLength(16)).put("node.name", randomAlphaOfLength(16)).build().     setupLogging("minimal", settings).     assertNotNull(System.getProperty("es.logs.base_path")).     assertThat(System.getProperty("es.logs.cluster_name"), equalTo(ClusterName.CLUSTER_NAME_SETTING.get(settings).value())).     assertThat(System.getProperty("es.logs.node_name"), equalTo(Node.NODE_NAME_SETTING.get(settings))). }
false;public;0;22;;public void testNoNodeNameInPatternWarning() throws IOException, UserException {     String nodeName = randomAlphaOfLength(16).     LogConfigurator.setNodeName(nodeName).     setupLogging("no_node_name").     final String path = System.getProperty("es.logs.base_path") + System.getProperty("file.separator") + System.getProperty("es.logs.cluster_name") + ".log".     final List<String> events = Files.readAllLines(PathUtils.get(path)).     assertThat(events.size(), equalTo(2)).     final String location = "org.elasticsearch.common.logging.LogConfigurator".     // the first message is a warning for unsupported configuration files     assertLogLine(events.get(0), Level.WARN, location, "\\[" + nodeName + "\\] Some logging configurations have " + "%marker but don't have %node_name. We will automatically add %node_name to the pattern to ease the " + "migration for users who customize log4j2.properties but will stop this behavior in 7.0. You should " + "manually replace `%node_name` with `\\[%node_name\\]%marker ` in these locations:").     if (Constants.WINDOWS) {         assertThat(events.get(1), endsWith("no_node_name\\log4j2.properties")).     } else {         assertThat(events.get(1), endsWith("no_node_name/log4j2.properties")).     } }
false;private;1;3;;private void setupLogging(final String config) throws IOException, UserException {     setupLogging(config, Settings.EMPTY). }
false;private;2;11;;private void setupLogging(final String config, final Settings settings) throws IOException, UserException {     assert !Environment.PATH_HOME_SETTING.exists(settings).     final Path configDir = getDataPath(config).     final Settings mergedSettings = Settings.builder().put(settings).put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build().     // need to use custom config path so we can use a custom log4j2.properties file for the test     final Environment environment = new Environment(mergedSettings, configDir).     LogConfigurator.configure(environment). }
false;private;4;7;;private void assertLogLine(final String logLine, final Level level, final String location, final String message) {     final Matcher matcher = Pattern.compile("\\[(.*)\\]\\[(.*)\\(.*\\)\\] (.*)").matcher(logLine).     assertTrue(logLine, matcher.matches()).     assertThat(matcher.group(1), equalTo(level.toString())).     assertThat(matcher.group(2), RegexMatcher.matches(location)).     assertThat(matcher.group(3), RegexMatcher.matches(message)). }
