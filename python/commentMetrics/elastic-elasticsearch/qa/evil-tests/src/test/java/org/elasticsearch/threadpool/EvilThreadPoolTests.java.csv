commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setUpThreadPool() {     threadPool = new TestThreadPool(EvilThreadPoolTests.class.getName()). }
false;public;0;4;;@After public void tearDownThreadPool() {     terminate(threadPool). }
false;public;0;7;;public void testExecutionErrorOnDefaultThreadPoolTypes() throws InterruptedException {     for (String executor : ThreadPool.THREAD_POOL_TYPES.keySet()) {         checkExecutionError(getExecuteRunner(threadPool.executor(executor))).         checkExecutionError(getSubmitRunner(threadPool.executor(executor))).         checkExecutionError(getScheduleRunner(executor)).     } }
false;public;0;5;;public void testExecutionErrorOnDirectExecutorService() throws InterruptedException {     final ExecutorService directExecutorService = EsExecutors.newDirectExecutorService().     checkExecutionError(getExecuteRunner(directExecutorService)).     checkExecutionError(getSubmitRunner(directExecutorService)). }
false;public;0;10;;public void testExecutionErrorOnFixedESThreadPoolExecutor() throws InterruptedException {     final EsThreadPoolExecutor fixedExecutor = EsExecutors.newFixed("test", 1, 1, EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext()).     try {         checkExecutionError(getExecuteRunner(fixedExecutor)).         checkExecutionError(getSubmitRunner(fixedExecutor)).     } finally {         ThreadPool.terminate(fixedExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;10;;public void testExecutionErrorOnScalingESThreadPoolExecutor() throws InterruptedException {     final EsThreadPoolExecutor scalingExecutor = EsExecutors.newScaling("test", 1, 1, 10, TimeUnit.SECONDS, EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext()).     try {         checkExecutionError(getExecuteRunner(scalingExecutor)).         checkExecutionError(getSubmitRunner(scalingExecutor)).     } finally {         ThreadPool.terminate(scalingExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;10;;public void testExecutionErrorOnAutoQueueFixedESThreadPoolExecutor() throws InterruptedException {     final EsThreadPoolExecutor autoQueueFixedExecutor = EsExecutors.newAutoQueueFixed("test", 1, 1, 1, 1, 1, TimeValue.timeValueSeconds(10), EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext()).     try {         checkExecutionError(getExecuteRunner(autoQueueFixedExecutor)).         checkExecutionError(getSubmitRunner(autoQueueFixedExecutor)).     } finally {         ThreadPool.terminate(autoQueueFixedExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;16;;public void testExecutionErrorOnSinglePrioritizingThreadPoolExecutor() throws InterruptedException {     final PrioritizedEsThreadPoolExecutor prioritizedExecutor = EsExecutors.newSinglePrioritizing("test", EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext(), threadPool.scheduler()).     try {         checkExecutionError(getExecuteRunner(prioritizedExecutor)).         checkExecutionError(getSubmitRunner(prioritizedExecutor)).         // bias towards timeout         checkExecutionError(r -> prioritizedExecutor.execute(delayMillis(r, 10), TimeValue.ZERO, r)).         // race whether timeout or success (but typically biased towards success)         checkExecutionError(r -> prioritizedExecutor.execute(r, TimeValue.ZERO, r)).         // bias towards no timeout.         checkExecutionError(r -> prioritizedExecutor.execute(r, TimeValue.timeValueMillis(10), r)).     } finally {         ThreadPool.terminate(prioritizedExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;10;;public void testExecutionErrorOnScheduler() throws InterruptedException {     final ScheduledThreadPoolExecutor scheduler = Scheduler.initScheduler(Settings.EMPTY).     try {         checkExecutionError(getExecuteRunner(scheduler)).         checkExecutionError(getSubmitRunner(scheduler)).         checkExecutionError(r -> scheduler.schedule(r, randomFrom(0, 1), TimeUnit.MILLISECONDS)).     } finally {         Scheduler.terminate(scheduler, 10, TimeUnit.SECONDS).     } }
false;public;1;4;;@Override public void onFailure(Exception e) { }
false;protected;0;4;;@Override protected void doRun() {     throw new Error("future error"). }
false;private;1;30;;private void checkExecutionError(Consumer<Runnable> runner) throws InterruptedException {     logger.info("checking error for {}", runner).     final Runnable runnable.     if (randomBoolean()) {         runnable = () -> {             throw new Error("future error").         }.     } else {         runnable = new AbstractRunnable() {              @Override             public void onFailure(Exception e) {             }              @Override             protected void doRun() {                 throw new Error("future error").             }         }.     }     runExecutionTest(runner, runnable, true, o -> {         assertTrue(o.isPresent()).         assertThat(o.get(), instanceOf(Error.class)).         assertThat(o.get(), hasToString(containsString("future error"))).     }). }
false;public;0;18;;public void testExecutionExceptionOnDefaultThreadPoolTypes() throws InterruptedException {     for (String executor : ThreadPool.THREAD_POOL_TYPES.keySet()) {         final boolean expectExceptionOnExecute = // TODO: this is dangerous as it will silently swallow exceptions, and possibly miss calling a response listener         ThreadPool.THREAD_POOL_TYPES.get(executor) != ThreadPool.ThreadPoolType.FIXED_AUTO_QUEUE_SIZE.         checkExecutionException(getExecuteRunner(threadPool.executor(executor)), expectExceptionOnExecute).         // here, it's ok for the exception not to bubble up. Accessing the future will yield the exception         checkExecutionException(getSubmitRunner(threadPool.executor(executor)), false).         final boolean expectExceptionOnSchedule = // TODO: this is dangerous as it will silently swallow exceptions, and possibly miss calling a response listener         ThreadPool.THREAD_POOL_TYPES.get(executor) != ThreadPool.ThreadPoolType.FIXED_AUTO_QUEUE_SIZE.         checkExecutionException(getScheduleRunner(executor), expectExceptionOnSchedule).     } }
false;public;0;5;;public void testExecutionExceptionOnDirectExecutorService() throws InterruptedException {     final ExecutorService directExecutorService = EsExecutors.newDirectExecutorService().     checkExecutionException(getExecuteRunner(directExecutorService), true).     checkExecutionException(getSubmitRunner(directExecutorService), false). }
false;public;0;10;;public void testExecutionExceptionOnFixedESThreadPoolExecutor() throws InterruptedException {     final EsThreadPoolExecutor fixedExecutor = EsExecutors.newFixed("test", 1, 1, EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext()).     try {         checkExecutionException(getExecuteRunner(fixedExecutor), true).         checkExecutionException(getSubmitRunner(fixedExecutor), false).     } finally {         ThreadPool.terminate(fixedExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;10;;public void testExecutionExceptionOnScalingESThreadPoolExecutor() throws InterruptedException {     final EsThreadPoolExecutor scalingExecutor = EsExecutors.newScaling("test", 1, 1, 10, TimeUnit.SECONDS, EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext()).     try {         checkExecutionException(getExecuteRunner(scalingExecutor), true).         checkExecutionException(getSubmitRunner(scalingExecutor), false).     } finally {         ThreadPool.terminate(scalingExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;12;;public void testExecutionExceptionOnAutoQueueFixedESThreadPoolExecutor() throws InterruptedException {     final EsThreadPoolExecutor autoQueueFixedExecutor = EsExecutors.newAutoQueueFixed("test", 1, 1, 1, 1, 1, TimeValue.timeValueSeconds(10), EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext()).     try {         // fixed_auto_queue_size wraps stuff into TimedRunnable, which is an AbstractRunnable         // TODO: this is dangerous as it will silently swallow exceptions, and possibly miss calling a response listener         checkExecutionException(getExecuteRunner(autoQueueFixedExecutor), false).         checkExecutionException(getSubmitRunner(autoQueueFixedExecutor), false).     } finally {         ThreadPool.terminate(autoQueueFixedExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;17;;public void testExecutionExceptionOnSinglePrioritizingThreadPoolExecutor() throws InterruptedException {     final PrioritizedEsThreadPoolExecutor prioritizedExecutor = EsExecutors.newSinglePrioritizing("test", EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext(), threadPool.scheduler()).     try {         checkExecutionException(getExecuteRunner(prioritizedExecutor), true).         checkExecutionException(getSubmitRunner(prioritizedExecutor), false).         // bias towards timeout         checkExecutionException(r -> prioritizedExecutor.execute(delayMillis(r, 10), TimeValue.ZERO, r), true).         // race whether timeout or success (but typically biased towards success)         checkExecutionException(r -> prioritizedExecutor.execute(r, TimeValue.ZERO, r), true).         // bias towards no timeout.         checkExecutionException(r -> prioritizedExecutor.execute(r, TimeValue.timeValueMillis(10), r), true).     } finally {         ThreadPool.terminate(prioritizedExecutor, 10, TimeUnit.SECONDS).     } }
false;public;0;13;;public void testExecutionExceptionOnScheduler() throws InterruptedException {     final ScheduledThreadPoolExecutor scheduler = Scheduler.initScheduler(Settings.EMPTY).     try {         checkExecutionException(getExecuteRunner(scheduler), true).         // while submit does return a Future, we choose to log exceptions anyway,         // since this is the semi-internal SafeScheduledThreadPoolExecutor that is being used,         // which also logs exceptions for schedule calls.         checkExecutionException(getSubmitRunner(scheduler), true).         checkExecutionException(r -> scheduler.schedule(r, randomFrom(0, 1), TimeUnit.MILLISECONDS), true).     } finally {         Scheduler.terminate(scheduler, 10, TimeUnit.SECONDS).     } }
false;private;2;10;;private Runnable delayMillis(Runnable r, int ms) {     return () -> {         try {             Thread.sleep(ms).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().         }         r.run().     }. }
false;public;1;4;;@Override public void onFailure(Exception e) { }
false;protected;0;4;;@Override protected void doRun() {     throw new IllegalStateException("future exception"). }
false;private;2;37;;private void checkExecutionException(Consumer<Runnable> runner, boolean expectException) throws InterruptedException {     final Runnable runnable.     final boolean willThrow.     if (randomBoolean()) {         logger.info("checking direct exception for {}", runner).         runnable = () -> {             throw new IllegalStateException("future exception").         }.         willThrow = expectException.     } else {         logger.info("checking abstract runnable exception for {}", runner).         runnable = new AbstractRunnable() {              @Override             public void onFailure(Exception e) {             }              @Override             protected void doRun() {                 throw new IllegalStateException("future exception").             }         }.         willThrow = false.     }     runExecutionTest(runner, runnable, willThrow, o -> {         assertEquals(willThrow, o.isPresent()).         if (willThrow) {             if (o.get() instanceof Error)                 throw (Error) o.get().             assertThat(o.get(), instanceOf(IllegalStateException.class)).             assertThat(o.get(), hasToString(containsString("future exception"))).         }     }). }
false;public;1;4;;@Override public void accept(Runnable runnable) {     executor.execute(runnable). }
false;public;0;4;;@Override public String toString() {     return "executor(" + executor + ").execute()". }
false;;1;13;;Consumer<Runnable> getExecuteRunner(ExecutorService executor) {     return new Consumer<Runnable>() {          @Override         public void accept(Runnable runnable) {             executor.execute(runnable).         }          @Override         public String toString() {             return "executor(" + executor + ").execute()".         }     }. }
false;public;1;4;;@Override public void accept(Runnable runnable) {     executor.submit(runnable). }
false;public;0;4;;@Override public String toString() {     return "executor(" + executor + ").submit()". }
false;;1;13;;Consumer<Runnable> getSubmitRunner(ExecutorService executor) {     return new Consumer<Runnable>() {          @Override         public void accept(Runnable runnable) {             executor.submit(runnable).         }          @Override         public String toString() {             return "executor(" + executor + ").submit()".         }     }. }
false;public;1;4;;@Override public void accept(Runnable runnable) {     threadPool.schedule(runnable, randomFrom(TimeValue.ZERO, TimeValue.timeValueMillis(1)), executor). }
false;public;0;4;;@Override public String toString() {     return "schedule(" + executor + ")". }
false;;1;13;;Consumer<Runnable> getScheduleRunner(String executor) {     return new Consumer<Runnable>() {          @Override         public void accept(Runnable runnable) {             threadPool.schedule(runnable, randomFrom(TimeValue.ZERO, TimeValue.timeValueMillis(1)), executor).         }          @Override         public String toString() {             return "schedule(" + executor + ")".         }     }. }
false;private;4;42;;private void runExecutionTest(final Consumer<Runnable> runner, final Runnable runnable, final boolean expectThrowable, final Consumer<Optional<Throwable>> consumer) throws InterruptedException {     final AtomicReference<Throwable> throwableReference = new AtomicReference<>().     final Thread.UncaughtExceptionHandler uncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler().     final CountDownLatch uncaughtExceptionHandlerLatch = new CountDownLatch(1).     try {         Thread.setDefaultUncaughtExceptionHandler((t, e) -> {             assertTrue(expectThrowable).             assertTrue("Only one message allowed", throwableReference.compareAndSet(null, e)).             uncaughtExceptionHandlerLatch.countDown().         }).         final CountDownLatch supplierLatch = new CountDownLatch(1).         try {             runner.accept(() -> {                 try {                     runnable.run().                 } finally {                     supplierLatch.countDown().                 }             }).         } catch (Throwable t) {             consumer.accept(Optional.of(t)).             return.         }         supplierLatch.await().         if (expectThrowable) {             uncaughtExceptionHandlerLatch.await().         }         consumer.accept(Optional.ofNullable(throwableReference.get())).     } finally {         Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler).     } }
