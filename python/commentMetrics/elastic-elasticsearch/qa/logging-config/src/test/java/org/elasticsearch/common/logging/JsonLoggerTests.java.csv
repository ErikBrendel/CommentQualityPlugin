commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void initNodeName() {     LogConfigurator.setNodeName("sample-name"). }
false;public;0;6;;@Override public void setUp() throws Exception {     super.setUp().     LogConfigurator.registerErrorListener().     setupLogging("json_layout"). }
false;public;0;6;;@Override public void tearDown() throws Exception {     LoggerContext context = (LoggerContext) LogManager.getContext(false).     Configurator.shutdown(context).     super.tearDown(). }
false;public;0;22;;@SuppressWarnings("unchecked") public void testJsonLayout() throws IOException {     final Logger testLogger = LogManager.getLogger("test").     testLogger.error("This is an error message").     testLogger.warn("This is a warning message").     testLogger.info("This is an info message").     testLogger.debug("This is a debug message").     testLogger.trace("This is a trace message").     final Path path = clusterLogsPath().     try (Stream<JsonLogLine> stream = JsonLogsStream.from(path)) {         List<JsonLogLine> jsonLogs = collectLines(stream).         assertThat(jsonLogs, Matchers.contains(logLine("file", Level.ERROR, "sample-name", "test", "This is an error message"), logLine("file", Level.WARN, "sample-name", "test", "This is a warning message"), logLine("file", Level.INFO, "sample-name", "test", "This is an info message"), logLine("file", Level.DEBUG, "sample-name", "test", "This is a debug message"), logLine("file", Level.TRACE, "sample-name", "test", "This is a trace message"))).     } }
false;public;0;17;;@SuppressWarnings("unchecked") public void testPrefixLoggerInJson() throws IOException {     Logger shardIdLogger = Loggers.getLogger("shardIdLogger", ShardId.fromString("[indexName][123]")).     shardIdLogger.info("This is an info message with a shardId").     Logger prefixLogger = new PrefixLogger(LogManager.getLogger("prefixLogger"), "PREFIX").     prefixLogger.info("This is an info message with a prefix").     final Path path = clusterLogsPath().     try (Stream<JsonLogLine> stream = JsonLogsStream.from(path)) {         List<JsonLogLine> jsonLogs = collectLines(stream).         assertThat(jsonLogs, Matchers.contains(logLine("file", Level.INFO, "sample-name", "shardIdLogger", "[indexName][123] This is an info message with a shardId"), logLine("file", Level.INFO, "sample-name", "prefixLogger", "PREFIX This is an info message with a prefix"))).     } }
false;public;0;23;;public void testJsonInMessage() throws IOException {     final Logger testLogger = LogManager.getLogger("test").     String json = "{" + LINE_SEPARATOR + "  \"terms\" : {" + LINE_SEPARATOR + "    \"user\" : [" + LINE_SEPARATOR + "      \"u1\"," + LINE_SEPARATOR + "      \"u2\"," + LINE_SEPARATOR + "      \"u3\"" + LINE_SEPARATOR + "    ]," + LINE_SEPARATOR + "    \"boost\" : 1.0" + LINE_SEPARATOR + "  }" + LINE_SEPARATOR + "}".     testLogger.info(json).     final Path path = clusterLogsPath().     try (Stream<JsonLogLine> stream = JsonLogsStream.from(path)) {         List<JsonLogLine> jsonLogs = collectLines(stream).         assertThat(jsonLogs, Matchers.contains(logLine("file", Level.INFO, "sample-name", "test", json))).     } }
false;public;0;16;;public void testStacktrace() throws IOException {     final Logger testLogger = LogManager.getLogger("test").     testLogger.error("error message", new Exception("exception message", new RuntimeException("cause message"))).     final Path path = clusterLogsPath().     try (Stream<JsonLogLine> stream = JsonLogsStream.from(path)) {         List<JsonLogLine> jsonLogs = collectLines(stream).         assertThat(jsonLogs, Matchers.contains(Matchers.allOf(logLine("file", Level.ERROR, "sample-name", "test", "error message"), stacktraceWith("java.lang.Exception: exception message"), stacktraceWith("Caused by: java.lang.RuntimeException: cause message")))).     } }
false;public;0;30;;public void testJsonInStacktraceMessageIsSplitted() throws IOException {     final Logger testLogger = LogManager.getLogger("test").     String json = "{" + LINE_SEPARATOR + "  \"terms\" : {" + LINE_SEPARATOR + "    \"user\" : [" + LINE_SEPARATOR + "      \"u1\"," + LINE_SEPARATOR + "      \"u2\"," + LINE_SEPARATOR + "      \"u3\"" + LINE_SEPARATOR + "    ]," + LINE_SEPARATOR + "    \"boost\" : 1.0" + LINE_SEPARATOR + "  }" + LINE_SEPARATOR + "}".     testLogger.error("error message " + json, new Exception(json)).     final Path path = clusterLogsPath().     try (Stream<JsonLogLine> stream = JsonLogsStream.from(path)) {         List<JsonLogLine> jsonLogs = collectLines(stream).         assertThat(jsonLogs, Matchers.contains(Matchers.allOf(// message field will have a single line with json escaped         logLine("file", Level.ERROR, "sample-name", "test", "error message " + json), // stacktrace field will have each json line will in a separate array element         stacktraceWith(("java.lang.Exception: " + json).split("\n"))))).     } }
false;private;1;5;;private List<JsonLogLine> collectLines(Stream<JsonLogLine> stream) {     return stream.skip(// skip the first line from super class     1).collect(Collectors.toList()). }
false;private;0;3;;private Path clusterLogsPath() {     return PathUtils.get(System.getProperty("es.logs.base_path"), System.getProperty("es.logs.cluster_name") + ".log"). }
false;private;1;3;;private void setupLogging(final String config) throws IOException, UserException {     setupLogging(config, Settings.EMPTY). }
false;private;2;11;;private void setupLogging(final String config, final Settings settings) throws IOException, UserException {     assertFalse("Environment path.home variable should not be set", Environment.PATH_HOME_SETTING.exists(settings)).     final Path configDir = getDataPath(config).     final Settings mergedSettings = Settings.builder().put(settings).put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build().     // need to use custom config path so we can use a custom log4j2.properties file for the test     final Environment environment = new Environment(mergedSettings, configDir).     LogConfigurator.configure(environment). }
false;protected;1;8;;@Override protected Boolean featureValueOf(JsonLogLine actual) {     return actual.type().equals(type) && actual.level().equals(level.toString()) && actual.nodeName().equals(nodeName) && actual.component().equals(component) && actual.message().equals(message). }
false;private;5;13;;private Matcher<JsonLogLine> logLine(String type, Level level, String nodeName, String component, String message) {     return new FeatureMatcher<JsonLogLine, Boolean>(Matchers.is(true), "logLine", "logLine") {          @Override         protected Boolean featureValueOf(JsonLogLine actual) {             return actual.type().equals(type) && actual.level().equals(level.toString()) && actual.nodeName().equals(nodeName) && actual.component().equals(component) && actual.message().equals(message).         }     }. }
false;protected;1;4;;@Override protected List<String> featureValueOf(JsonLogLine actual) {     return actual.stacktrace(). }
false;private;1;10;;private Matcher<JsonLogLine> stacktraceWith(String... lines) {     return new FeatureMatcher<JsonLogLine, List<String>>(Matchers.hasItems(lines), "stacktrace", "stacktrace") {          @Override         protected List<String> featureValueOf(JsonLogLine actual) {             return actual.stacktrace().         }     }. }
