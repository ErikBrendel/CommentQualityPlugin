commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, String> getEnv() {     return env. }
true;public;1;3;/**  * Run the provided string as a shell script. On Linux the {@code bash -c [script]} syntax will be used, and on Windows  * the {@code powershell.exe -Command [script]} syntax will be used. Throws an exception if the exit code of the script is nonzero  */ ;/**  * Run the provided string as a shell script. On Linux the {@code bash -c [script]} syntax will be used, and on Windows  * the {@code powershell.exe -Command [script]} syntax will be used. Throws an exception if the exit code of the script is nonzero  */ public Result run(String script) {     return runScript(getScriptCommand(script)). }
true;public;1;3;/**  * Same as {@link #run(String)}, but does not throw an exception if the exit code of the script is nonzero  */ ;/**  * Same as {@link #run(String)}, but does not throw an exception if the exit code of the script is nonzero  */ public Result runIgnoreExitCode(String script) {     return runScriptIgnoreExitCode(getScriptCommand(script)). }
false;private;1;7;;private String[] getScriptCommand(String script) {     if (Platforms.WINDOWS) {         return powershellCommand(script).     } else {         return bashCommand(script).     } }
false;private,static;1;3;;private static String[] bashCommand(String script) {     return Stream.concat(Stream.of("bash", "-c"), Stream.of(script)).toArray(String[]::new). }
false;private,static;1;3;;private static String[] powershellCommand(String script) {     return Stream.concat(Stream.of("powershell.exe", "-Command"), Stream.of(script)).toArray(String[]::new). }
false;private;1;7;;private Result runScript(String[] command) {     Result result = runScriptIgnoreExitCode(command).     if (result.isSuccess() == false) {         throw new RuntimeException("Command was not successful: [" + String.join(" ", command) + "] result: " + result.toString()).     }     return result. }
false;private;1;38;;private Result runScriptIgnoreExitCode(String[] command) {     ProcessBuilder builder = new ProcessBuilder().     builder.command(command).     if (workingDirectory != null) {         setWorkingDirectory(builder, workingDirectory).     }     if (env != null && env.isEmpty() == false) {         for (Map.Entry<String, String> entry : env.entrySet()) {             builder.environment().put(entry.getKey(), entry.getValue()).         }     }     try {         Process process = builder.start().         StringBuilder stdout = new StringBuilder().         StringBuilder stderr = new StringBuilder().         Thread stdoutThread = new Thread(new StreamCollector(process.getInputStream(), stdout)).         Thread stderrThread = new Thread(new StreamCollector(process.getErrorStream(), stderr)).         stdoutThread.start().         stderrThread.start().         stdoutThread.join().         stderrThread.join().         int exitCode = process.waitFor().         return new Result(exitCode, stdout.toString(), stderr.toString()).     } catch (IOException | InterruptedException e) {         throw new RuntimeException(e).     } }
false;private,static;2;4;;@SuppressForbidden(reason = "ProcessBuilder expects java.io.File") private static void setWorkingDirectory(ProcessBuilder builder, Path path) {     builder.directory(path.toFile()). }
false;public;0;14;;public String toString() {     return new StringBuilder().append("<").append(this.getClass().getName()).append(" ").append("env = [").append(env).append("]").append("workingDirectory = [").append(workingDirectory).append("]").append(">").toString(). }
false;public;0;3;;public boolean isSuccess() {     return exitCode == 0. }
false;public;0;19;;public String toString() {     return new StringBuilder().append("<").append(this.getClass().getName()).append(" ").append("exitCode = [").append(exitCode).append("]").append(" ").append("stdout = [").append(stdout).append("]").append(" ").append("stderr = [").append(stderr).append("]").append(">").toString(). }
false;public;0;15;;public void run() {     try {         BufferedReader reader = new BufferedReader(reader(input)).         String line.         while ((line = reader.readLine()) != null) {             appendable.append(line).             appendable.append("\n").         }     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;private,static;1;4;;@SuppressForbidden(reason = "the system's default character set is a best guess of what subprocesses will use") private static InputStreamReader reader(InputStream inputStream) {     return new InputStreamReader(inputStream). }
