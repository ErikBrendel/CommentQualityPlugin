commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;13;;public static List<Path> lsGlob(Path directory, String glob) {     List<Path> paths = new ArrayList<>().     try (DirectoryStream<Path> stream = Files.newDirectoryStream(directory, glob)) {         for (Path path : stream) {             paths.add(path).         }         return paths.     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public,static;1;7;;public static void rm(Path... paths) {     try {         IOUtils.rm(paths).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public,static;1;7;;public static Path mkdir(Path path) {     try {         return Files.createDirectories(path).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public,static;2;7;;public static Path cp(Path source, Path target) {     try {         return Files.copy(source, target).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public,static;2;7;;public static Path mv(Path source, Path target) {     try {         return Files.move(source, target).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public,static;2;9;;public static void append(Path file, String text) {     try (BufferedWriter writer = Files.newBufferedWriter(file, StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {         writer.write(text).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public,static;1;7;;public static String slurp(Path file) {     try {         return String.join("\n", Files.readAllLines(file, StandardCharsets.UTF_8)).     } catch (IOException e) {         throw new RuntimeException(e).     } }
true;public,static;1;8;/**  * Gets the owner of a file in a way that should be supported by all filesystems that have a concept of file owner  */ ;/**  * Gets the owner of a file in a way that should be supported by all filesystems that have a concept of file owner  */ public static String getFileOwner(Path path) {     try {         FileOwnerAttributeView view = Files.getFileAttributeView(path, FileOwnerAttributeView.class).         return view.getOwner().getName().     } catch (IOException e) {         throw new RuntimeException(e).     } }
true;public,static;1;7;/**  * Gets attributes that are supported by all filesystems  */ ;/**  * Gets attributes that are supported by all filesystems  */ public static BasicFileAttributes getBasicFileAttributes(Path path) {     try {         return Files.readAttributes(path, BasicFileAttributes.class).     } catch (IOException e) {         throw new RuntimeException(e).     } }
true;public,static;1;7;/**  * Gets attributes that are supported by posix filesystems  */ ;/**  * Gets attributes that are supported by posix filesystems  */ public static PosixFileAttributes getPosixFileAttributes(Path path) {     try {         return Files.readAttributes(path, PosixFileAttributes.class).     } catch (IOException e) {         throw new RuntimeException(e).     } }
true;public,static;0;3;// vagrant creates /tmp for us in windows so we use that to avoid long paths ;// vagrant creates /tmp for us in windows so we use that to avoid long paths public static Path getTempDir() {     return Paths.get("/tmp"). }
false;public,static;0;3;;public static Path getDefaultArchiveInstallPath() {     return getTempDir().resolve("elasticsearch"). }
false;public,static;0;3;;public static String getCurrentVersion() {     return slurp(getPackagingArchivesDir().resolve("version")). }
false;public,static;0;5;;public static Path getPackagingArchivesDir() {     String fromEnv = System.getenv("PACKAGING_ARCHIVES").     assertThat(fromEnv, not(isEmptyOrNullString())).     return Paths.get(fromEnv). }
false;public,static;1;3;;public static Path getDistributionFile(Distribution distribution) {     return getDistributionFile(distribution, getCurrentVersion()). }
false;public,static;2;3;;public static Path getDistributionFile(Distribution distribution, String version) {     return getPackagingArchivesDir().resolve(distribution.filename(version)). }
false;public,static;1;3;;public static void assertPathsExist(Path... paths) {     Arrays.stream(paths).forEach(path -> assertTrue(path + " should exist", Files.exists(path))). }
false;public,static;1;3;;public static void assertPathsDontExist(Path... paths) {     Arrays.stream(paths).forEach(path -> assertFalse(path + " should not exist", Files.exists(path))). }
