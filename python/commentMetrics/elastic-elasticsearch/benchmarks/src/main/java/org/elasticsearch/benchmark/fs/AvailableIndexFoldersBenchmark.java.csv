commented;modifiers;parameterAmount;loc;comment;code
false;public;0;27;;@Setup public void setup() throws IOException {     Path path = Files.createTempDirectory("test").     String[] paths = new String[] { path.toString() }.     nodePath = new NodeEnvironment.NodePath(path).     LogConfigurator.setNodeName("test").     Settings settings = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), path).putList(Environment.PATH_DATA_SETTING.getKey(), paths).build().     nodeEnv = new NodeEnvironment(settings, new Environment(settings, null)).     Files.createDirectories(nodePath.indicesPath).     excludedDirs = new HashSet<>().     int numIndices = 5000.     for (int i = 0. i < numIndices. i++) {         String dirName = "dir" + i.         Files.createDirectory(nodePath.indicesPath.resolve(dirName)).         excludedDirs.add(dirName).     }     if (nodeEnv.availableIndexFoldersForPath(nodePath).size() != numIndices) {         throw new IllegalStateException("bad size").     }     if (nodeEnv.availableIndexFoldersForPath(nodePath, excludedDirs::contains).size() != 0) {         throw new IllegalStateException("bad size").     } }
false;public;0;4;;@Benchmark public Set<String> availableIndexFolderNaive() throws IOException {     return nodeEnv.availableIndexFoldersForPath(nodePath). }
false;public;0;4;;@Benchmark public Set<String> availableIndexFolderOptimized() throws IOException {     return nodeEnv.availableIndexFoldersForPath(nodePath, excludedDirs::contains). }
