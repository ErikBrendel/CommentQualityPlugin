commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public NioSelector getSelector() {     return selector. }
false;public;0;4;;@Override public NioSocketChannel getChannel() {     return channel. }
false;public;1;3;;public void addConnectListener(BiConsumer<Void, Exception> listener) {     connectContext.addListener(listener). }
false;public;0;3;;public boolean isConnectComplete() {     return connectContext.isDone() && connectContext.isCompletedExceptionally() == false. }
true;public;0;29;/**  * This method will attempt to complete the connection process for this channel. It should be called for  * new channels or for a channel that has produced a OP_CONNECT event. If this method returns true then  * the connection is complete and the channel is ready for reads and writes. If it returns false, the  * channel is not yet connected and this method should be called again when a OP_CONNECT event is  * received.  *  * @return true if the connection process is complete  * @throws IOException if an I/O error occurs  */ ;/**  * This method will attempt to complete the connection process for this channel. It should be called for  * new channels or for a channel that has produced a OP_CONNECT event. If this method returns true then  * the connection is complete and the channel is ready for reads and writes. If it returns false, the  * channel is not yet connected and this method should be called again when a OP_CONNECT event is  * received.  *  * @return true if the connection process is complete  * @throws IOException if an I/O error occurs  */ public boolean connect() throws IOException {     if (isConnectComplete()) {         return true.     } else if (connectContext.isCompletedExceptionally()) {         Exception exception = connectException.         if (exception == null) {             throw new AssertionError("Should have received connection exception").         } else if (exception instanceof IOException) {             throw (IOException) exception.         } else {             throw (RuntimeException) exception.         }     }     boolean isConnected = rawChannel.isConnected().     if (isConnected == false) {         try {             isConnected = rawChannel.finishConnect().         } catch (IOException | RuntimeException e) {             connectException = e.             connectContext.completeExceptionally(e).             throw e.         }     }     if (isConnected) {         connectContext.complete(null).     }     return isConnected. }
false;public;2;16;;public void sendMessage(Object message, BiConsumer<Void, Exception> listener) {     if (isClosing.get()) {         listener.accept(null, new ClosedChannelException()).         return.     }     WriteOperation writeOperation = readWriteHandler.createWriteOperation(this, message, listener).     NioSelector selector = getSelector().     if (selector.isOnCurrentThread() == false) {         selector.queueWrite(writeOperation).         return.     }     selector.writeToChannel(writeOperation). }
false;public;1;4;;public void queueWriteOperation(WriteOperation writeOperation) {     getSelector().assertOnSelectorThread().     pendingFlushes.addAll(readWriteHandler.writeToBytes(writeOperation)). }
false;public,abstract;0;1;;public abstract int read() throws IOException.
false;public,abstract;0;1;;public abstract void flushChannel() throws IOException.
false;protected;1;4;;protected void currentFlushOperationFailed(IOException e) {     FlushOperation flushOperation = pendingFlushes.pollFirst().     getSelector().executeFailedListener(flushOperation.getListener(), e). }
false;protected;0;4;;protected void currentFlushOperationComplete() {     FlushOperation flushOperation = pendingFlushes.pollFirst().     getSelector().executeListener(flushOperation.getListener(), null). }
false;protected;0;3;;protected FlushOperation getPendingFlush() {     return pendingFlushes.peekFirst(). }
false;protected;0;7;;@Override protected void register() throws IOException {     super.register().     if (allowChannelPredicate.test(channel) == false) {         closeNow = true.     } }
false;public;0;32;;@Override public void closeFromSelector() throws IOException {     getSelector().assertOnSelectorThread().     if (isOpen()) {         ArrayList<IOException> closingExceptions = new ArrayList<>(3).         try {             super.closeFromSelector().         } catch (IOException e) {             closingExceptions.add(e).         }         // Set to true in order to reject new writes before queuing with selector         isClosing.set(true).         // Poll for new flush operations to close         pendingFlushes.addAll(readWriteHandler.pollFlushOperations()).         FlushOperation flushOperation.         while ((flushOperation = pendingFlushes.pollFirst()) != null) {             selector.executeFailedListener(flushOperation.getListener(), new ClosedChannelException()).         }         try {             readWriteHandler.close().         } catch (IOException e) {             closingExceptions.add(e).         }         channelBuffer.close().         if (closingExceptions.isEmpty() == false) {             ExceptionsHelper.rethrowAndSuppress(closingExceptions).         }     } }
false;protected;0;10;;protected void handleReadBytes() throws IOException {     int bytesConsumed = Integer.MAX_VALUE.     while (isOpen() && bytesConsumed > 0 && channelBuffer.getIndex() > 0) {         bytesConsumed = readWriteHandler.consumeReads(channelBuffer).         channelBuffer.release(bytesConsumed).     }     // Some protocols might produce messages to flush during a read operation.     pendingFlushes.addAll(readWriteHandler.pollFlushOperations()). }
false;public;0;4;;public boolean readyForFlush() {     getSelector().assertOnSelectorThread().     return pendingFlushes.isEmpty() == false. }
true;public,abstract;0;1;/**  * This method indicates if a selector should close this channel.  *  * @return a boolean indicating if the selector should close  */ ;/**  * This method indicates if a selector should close this channel.  *  * @return a boolean indicating if the selector should close  */ public abstract boolean selectorShouldClose().
false;protected;0;3;;protected boolean closeNow() {     return closeNow. }
false;protected;0;3;;protected void setCloseNow() {     closeNow = true. }
false;protected;1;19;;// When you read or write to a nio socket in java, the heap memory passed down must be copied to/from // direct memory. The JVM internally does some buffering of the direct memory, however we can save space // by reusing a thread-local direct buffer (provided by the NioSelector). //  // Each network event loop is given a 64kb DirectByteBuffer. When we read we use this buffer and copy the // data after the read. When we go to write, we copy the data to the direct memory before calling write. // The choice of 64KB is rather arbitrary. We can explore different sizes in the future. However, any // data that is copied to the buffer for a write, but not successfully flushed immediately, must be // copied again on the next call. protected int readFromChannel(ByteBuffer buffer) throws IOException {     ByteBuffer ioBuffer = getSelector().getIoBuffer().     ioBuffer.limit(Math.min(buffer.remaining(), ioBuffer.limit())).     int bytesRead.     try {         bytesRead = rawChannel.read(ioBuffer).     } catch (IOException e) {         closeNow = true.         throw e.     }     if (bytesRead < 0) {         closeNow = true.         return 0.     } else {         ioBuffer.flip().         buffer.put(ioBuffer).         return bytesRead.     } }
false;protected;1;25;;protected int readFromChannel(InboundChannelBuffer channelBuffer) throws IOException {     ByteBuffer ioBuffer = getSelector().getIoBuffer().     int bytesRead.     try {         bytesRead = rawChannel.read(ioBuffer).     } catch (IOException e) {         closeNow = true.         throw e.     }     if (bytesRead < 0) {         closeNow = true.         return 0.     } else {         ioBuffer.flip().         channelBuffer.ensureCapacity(channelBuffer.getIndex() + ioBuffer.remaining()).         ByteBuffer[] buffers = channelBuffer.sliceBuffersFrom(channelBuffer.getIndex()).         int j = 0.         while (j < buffers.length && ioBuffer.remaining() > 0) {             ByteBuffer buffer = buffers[j++].             copyBytes(ioBuffer, buffer).         }         channelBuffer.incrementIndex(bytesRead).         return bytesRead.     } }
false;protected;1;17;;protected int flushToChannel(ByteBuffer buffer) throws IOException {     int initialPosition = buffer.position().     ByteBuffer ioBuffer = getSelector().getIoBuffer().     ioBuffer.limit(Math.min(WRITE_LIMIT, ioBuffer.limit())).     copyBytes(buffer, ioBuffer).     ioBuffer.flip().     int bytesWritten.     try {         bytesWritten = rawChannel.write(ioBuffer).     } catch (IOException e) {         closeNow = true.         buffer.position(initialPosition).         throw e.     }     buffer.position(initialPosition + bytesWritten).     return bytesWritten. }
false;protected;1;28;;protected int flushToChannel(FlushOperation flushOperation) throws IOException {     ByteBuffer ioBuffer = getSelector().getIoBuffer().     boolean continueFlush = flushOperation.isFullyFlushed() == false.     int totalBytesFlushed = 0.     while (continueFlush) {         ioBuffer.clear().         ioBuffer.limit(Math.min(WRITE_LIMIT, ioBuffer.limit())).         int j = 0.         ByteBuffer[] buffers = flushOperation.getBuffersToWrite().         while (j < buffers.length && ioBuffer.remaining() > 0) {             ByteBuffer buffer = buffers[j++].             copyBytes(buffer, ioBuffer).         }         ioBuffer.flip().         int bytesFlushed.         try {             bytesFlushed = rawChannel.write(ioBuffer).         } catch (IOException e) {             closeNow = true.             throw e.         }         flushOperation.incrementIndex(bytesFlushed).         totalBytesFlushed += bytesFlushed.         continueFlush = ioBuffer.hasRemaining() == false && flushOperation.isFullyFlushed() == false.     }     return totalBytesFlushed. }
false;private;2;7;;private void copyBytes(ByteBuffer from, ByteBuffer to) {     int nBytesToCopy = Math.min(to.remaining(), from.remaining()).     int initialLimit = from.limit().     from.limit(from.position() + nBytesToCopy).     to.put(from).     from.limit(initialLimit). }
