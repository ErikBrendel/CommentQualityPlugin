# id;timestamp;commentText;codeText;commentWords;codeWords
NioSelector -> public void runLoop();1528706846;Starts this selector. The selector will run until {@link #close()} is called.;public void runLoop() {_        if (runLock.tryLock()) {_            isRunningFuture.complete(null)__            try {_                setThread()__                while (isOpen()) {_                    singleLoop()__                }_            } finally {_                try {_                    cleanupAndCloseChannels()__                } finally {_                    try {_                        selector.close()__                    } catch (IOException e) {_                        eventHandler.selectorException(e)__                    } finally {_                        runLock.unlock()__                        exitedLoop.countDown()__                    }_                }_            }_        } else {_            throw new IllegalStateException("selector is already running")__        }_    };starts,this,selector,the,selector,will,run,until,link,close,is,called;public,void,run,loop,if,run,lock,try,lock,is,running,future,complete,null,try,set,thread,while,is,open,single,loop,finally,try,cleanup,and,close,channels,finally,try,selector,close,catch,ioexception,e,event,handler,selector,exception,e,finally,run,lock,unlock,exited,loop,count,down,else,throw,new,illegal,state,exception,selector,is,already,running
NioSelector -> public void runLoop();1528930607;Starts this selector. The selector will run until {@link #close()} is called.;public void runLoop() {_        if (runLock.tryLock()) {_            isRunningFuture.complete(null)__            try {_                setThread()__                while (isOpen()) {_                    singleLoop()__                }_            } finally {_                try {_                    cleanupAndCloseChannels()__                } finally {_                    try {_                        selector.close()__                    } catch (IOException e) {_                        eventHandler.selectorException(e)__                    } finally {_                        runLock.unlock()__                        exitedLoop.countDown()__                    }_                }_            }_        } else {_            throw new IllegalStateException("selector is already running")__        }_    };starts,this,selector,the,selector,will,run,until,link,close,is,called;public,void,run,loop,if,run,lock,try,lock,is,running,future,complete,null,try,set,thread,while,is,open,single,loop,finally,try,cleanup,and,close,channels,finally,try,selector,close,catch,ioexception,e,event,handler,selector,exception,e,finally,run,lock,unlock,exited,loop,count,down,else,throw,new,illegal,state,exception,selector,is,already,running
NioSelector -> public void runLoop();1544144947;Starts this selector. The selector will run until {@link #close()} is called.;public void runLoop() {_        if (runLock.tryLock()) {_            isRunningFuture.complete(null)__            try {_                setThread()__                while (isOpen()) {_                    singleLoop()__                }_            } finally {_                try {_                    cleanupAndCloseChannels()__                } finally {_                    try {_                        selector.close()__                    } catch (IOException e) {_                        eventHandler.selectorException(e)__                    } finally {_                        runLock.unlock()__                        exitedLoop.countDown()__                    }_                }_            }_        } else {_            throw new IllegalStateException("selector is already running")__        }_    };starts,this,selector,the,selector,will,run,until,link,close,is,called;public,void,run,loop,if,run,lock,try,lock,is,running,future,complete,null,try,set,thread,while,is,open,single,loop,finally,try,cleanup,and,close,channels,finally,try,selector,close,catch,ioexception,e,event,handler,selector,exception,e,finally,run,lock,unlock,exited,loop,count,down,else,throw,new,illegal,state,exception,selector,is,already,running
NioSelector -> public void runLoop();1547059584;Starts this selector. The selector will run until {@link #close()} is called.;public void runLoop() {_        if (runLock.tryLock()) {_            isRunningFuture.complete(null)__            try {_                setThread()__                while (isOpen()) {_                    singleLoop()__                }_            } finally {_                try {_                    cleanupAndCloseChannels()__                } finally {_                    try {_                        selector.close()__                    } catch (IOException e) {_                        eventHandler.selectorException(e)__                    } finally {_                        runLock.unlock()__                        exitedLoop.countDown()__                    }_                }_            }_        } else {_            throw new IllegalStateException("selector is already running")__        }_    };starts,this,selector,the,selector,will,run,until,link,close,is,called;public,void,run,loop,if,run,lock,try,lock,is,running,future,complete,null,try,set,thread,while,is,open,single,loop,finally,try,cleanup,and,close,channels,finally,try,selector,close,catch,ioexception,e,event,handler,selector,exception,e,finally,run,lock,unlock,exited,loop,count,down,else,throw,new,illegal,state,exception,selector,is,already,running
NioSelector -> public void runLoop();1547137040;Starts this selector. The selector will run until {@link #close()} is called.;public void runLoop() {_        if (runLock.tryLock()) {_            isRunningFuture.complete(null)__            try {_                setThread()__                while (isOpen()) {_                    singleLoop()__                }_            } finally {_                try {_                    cleanupAndCloseChannels()__                } finally {_                    try {_                        selector.close()__                    } catch (IOException e) {_                        eventHandler.selectorException(e)__                    } finally {_                        runLock.unlock()__                        exitedLoop.countDown()__                    }_                }_            }_        } else {_            throw new IllegalStateException("selector is already running")__        }_    };starts,this,selector,the,selector,will,run,until,link,close,is,called;public,void,run,loop,if,run,lock,try,lock,is,running,future,complete,null,try,set,thread,while,is,open,single,loop,finally,try,cleanup,and,close,channels,finally,try,selector,close,catch,ioexception,e,event,handler,selector,exception,e,finally,run,lock,unlock,exited,loop,count,down,else,throw,new,illegal,state,exception,selector,is,already,running
NioSelector -> public void runLoop();1550637215;Starts this selector. The selector will run until {@link #close()} is called.;public void runLoop() {_        if (runLock.tryLock()) {_            isRunningFuture.complete(null)__            try {_                setThread()__                while (isOpen()) {_                    singleLoop()__                }_            } finally {_                try {_                    cleanupAndCloseChannels()__                } finally {_                    try {_                        selector.close()__                    } catch (IOException e) {_                        eventHandler.selectorException(e)__                    } finally {_                        runLock.unlock()__                        exitedLoop.countDown()__                    }_                }_            }_        } else {_            throw new IllegalStateException("selector is already running")__        }_    };starts,this,selector,the,selector,will,run,until,link,close,is,called;public,void,run,loop,if,run,lock,try,lock,is,running,future,complete,null,try,set,thread,while,is,open,single,loop,finally,try,cleanup,and,close,channels,finally,try,selector,close,catch,ioexception,e,event,handler,selector,exception,e,finally,run,lock,unlock,exited,loop,count,down,else,throw,new,illegal,state,exception,selector,is,already,running
NioSelector -> public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception);1528706846;Executes a failed listener with consistent exception handling. This can only be called from current_selector thread.__@param listener  to be executed_@param exception to provide to listener;public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception) {_        assertOnSelectorThread()__        try {_            listener.accept(null, exception)__        } catch (Exception e) {_            eventHandler.listenerException(e)__        }_    };executes,a,failed,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,exception,to,provide,to,listener;public,v,void,execute,failed,listener,bi,consumer,v,exception,listener,exception,exception,assert,on,selector,thread,try,listener,accept,null,exception,catch,exception,e,event,handler,listener,exception,e
NioSelector -> public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception);1528930607;Executes a failed listener with consistent exception handling. This can only be called from current_selector thread.__@param listener  to be executed_@param exception to provide to listener;public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception) {_        assertOnSelectorThread()__        try {_            listener.accept(null, exception)__        } catch (Exception e) {_            eventHandler.listenerException(e)__        }_    };executes,a,failed,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,exception,to,provide,to,listener;public,v,void,execute,failed,listener,bi,consumer,v,exception,listener,exception,exception,assert,on,selector,thread,try,listener,accept,null,exception,catch,exception,e,event,handler,listener,exception,e
NioSelector -> public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception);1544144947;Executes a failed listener with consistent exception handling. This can only be called from current_selector thread.__@param listener  to be executed_@param exception to provide to listener;public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception) {_        assertOnSelectorThread()__        try {_            listener.accept(null, exception)__        } catch (Exception e) {_            eventHandler.listenerException(e)__        }_    };executes,a,failed,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,exception,to,provide,to,listener;public,v,void,execute,failed,listener,bi,consumer,v,exception,listener,exception,exception,assert,on,selector,thread,try,listener,accept,null,exception,catch,exception,e,event,handler,listener,exception,e
NioSelector -> public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception);1547059584;Executes a failed listener with consistent exception handling. This can only be called from current_selector thread.__@param listener  to be executed_@param exception to provide to listener;public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception) {_        assertOnSelectorThread()__        try {_            listener.accept(null, exception)__        } catch (Exception e) {_            eventHandler.taskException(e)__        }_    };executes,a,failed,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,exception,to,provide,to,listener;public,v,void,execute,failed,listener,bi,consumer,v,exception,listener,exception,exception,assert,on,selector,thread,try,listener,accept,null,exception,catch,exception,e,event,handler,task,exception,e
NioSelector -> public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception);1547137040;Executes a failed listener with consistent exception handling. This can only be called from current_selector thread.__@param listener  to be executed_@param exception to provide to listener;public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception) {_        assertOnSelectorThread()__        try {_            listener.accept(null, exception)__        } catch (Exception e) {_            eventHandler.taskException(e)__        }_    };executes,a,failed,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,exception,to,provide,to,listener;public,v,void,execute,failed,listener,bi,consumer,v,exception,listener,exception,exception,assert,on,selector,thread,try,listener,accept,null,exception,catch,exception,e,event,handler,task,exception,e
NioSelector -> public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception);1550637215;Executes a failed listener with consistent exception handling. This can only be called from current_selector thread.__@param listener  to be executed_@param exception to provide to listener;public <V> void executeFailedListener(BiConsumer<V, Exception> listener, Exception exception) {_        assertOnSelectorThread()__        try {_            listener.accept(null, exception)__        } catch (Exception e) {_            eventHandler.taskException(e)__        }_    };executes,a,failed,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,exception,to,provide,to,listener;public,v,void,execute,failed,listener,bi,consumer,v,exception,listener,exception,exception,assert,on,selector,thread,try,listener,accept,null,exception,catch,exception,e,event,handler,task,exception,e
NioSelector -> public ByteBuffer getIoBuffer();1544144947;Returns a cached direct byte buffer for network operations. It is cleared on every get call.__@return the byte buffer;public ByteBuffer getIoBuffer() {_        assertOnSelectorThread()__        ioBuffer.clear()__        return ioBuffer__    };returns,a,cached,direct,byte,buffer,for,network,operations,it,is,cleared,on,every,get,call,return,the,byte,buffer;public,byte,buffer,get,io,buffer,assert,on,selector,thread,io,buffer,clear,return,io,buffer
NioSelector -> public ByteBuffer getIoBuffer();1547059584;Returns a cached direct byte buffer for network operations. It is cleared on every get call.__@return the byte buffer;public ByteBuffer getIoBuffer() {_        assertOnSelectorThread()__        ioBuffer.clear()__        return ioBuffer__    };returns,a,cached,direct,byte,buffer,for,network,operations,it,is,cleared,on,every,get,call,return,the,byte,buffer;public,byte,buffer,get,io,buffer,assert,on,selector,thread,io,buffer,clear,return,io,buffer
NioSelector -> public ByteBuffer getIoBuffer();1547137040;Returns a cached direct byte buffer for network operations. It is cleared on every get call.__@return the byte buffer;public ByteBuffer getIoBuffer() {_        assertOnSelectorThread()__        ioBuffer.clear()__        return ioBuffer__    };returns,a,cached,direct,byte,buffer,for,network,operations,it,is,cleared,on,every,get,call,return,the,byte,buffer;public,byte,buffer,get,io,buffer,assert,on,selector,thread,io,buffer,clear,return,io,buffer
NioSelector -> public ByteBuffer getIoBuffer();1550637215;Returns a cached direct byte buffer for network operations. It is cleared on every get call.__@return the byte buffer;public ByteBuffer getIoBuffer() {_        assertOnSelectorThread()__        ioBuffer.clear()__        return ioBuffer__    };returns,a,cached,direct,byte,buffer,for,network,operations,it,is,cleared,on,every,get,call,return,the,byte,buffer;public,byte,buffer,get,io,buffer,assert,on,selector,thread,io,buffer,clear,return,io,buffer
NioSelector -> public <V> void executeListener(BiConsumer<V, Exception> listener, V value);1528706846;Executes a success listener with consistent exception handling. This can only be called from current_selector thread.__@param listener to be executed_@param value    to provide to listener;public <V> void executeListener(BiConsumer<V, Exception> listener, V value) {_        assertOnSelectorThread()__        try {_            listener.accept(value, null)__        } catch (Exception e) {_            eventHandler.listenerException(e)__        }_    };executes,a,success,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,value,to,provide,to,listener;public,v,void,execute,listener,bi,consumer,v,exception,listener,v,value,assert,on,selector,thread,try,listener,accept,value,null,catch,exception,e,event,handler,listener,exception,e
NioSelector -> public <V> void executeListener(BiConsumer<V, Exception> listener, V value);1528930607;Executes a success listener with consistent exception handling. This can only be called from current_selector thread.__@param listener to be executed_@param value    to provide to listener;public <V> void executeListener(BiConsumer<V, Exception> listener, V value) {_        assertOnSelectorThread()__        try {_            listener.accept(value, null)__        } catch (Exception e) {_            eventHandler.listenerException(e)__        }_    };executes,a,success,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,value,to,provide,to,listener;public,v,void,execute,listener,bi,consumer,v,exception,listener,v,value,assert,on,selector,thread,try,listener,accept,value,null,catch,exception,e,event,handler,listener,exception,e
NioSelector -> public <V> void executeListener(BiConsumer<V, Exception> listener, V value);1544144947;Executes a success listener with consistent exception handling. This can only be called from current_selector thread.__@param listener to be executed_@param value    to provide to listener;public <V> void executeListener(BiConsumer<V, Exception> listener, V value) {_        assertOnSelectorThread()__        try {_            listener.accept(value, null)__        } catch (Exception e) {_            eventHandler.listenerException(e)__        }_    };executes,a,success,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,value,to,provide,to,listener;public,v,void,execute,listener,bi,consumer,v,exception,listener,v,value,assert,on,selector,thread,try,listener,accept,value,null,catch,exception,e,event,handler,listener,exception,e
NioSelector -> public <V> void executeListener(BiConsumer<V, Exception> listener, V value);1547059584;Executes a success listener with consistent exception handling. This can only be called from current_selector thread.__@param listener to be executed_@param value    to provide to listener;public <V> void executeListener(BiConsumer<V, Exception> listener, V value) {_        assertOnSelectorThread()__        try {_            listener.accept(value, null)__        } catch (Exception e) {_            eventHandler.taskException(e)__        }_    };executes,a,success,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,value,to,provide,to,listener;public,v,void,execute,listener,bi,consumer,v,exception,listener,v,value,assert,on,selector,thread,try,listener,accept,value,null,catch,exception,e,event,handler,task,exception,e
NioSelector -> public <V> void executeListener(BiConsumer<V, Exception> listener, V value);1547137040;Executes a success listener with consistent exception handling. This can only be called from current_selector thread.__@param listener to be executed_@param value    to provide to listener;public <V> void executeListener(BiConsumer<V, Exception> listener, V value) {_        assertOnSelectorThread()__        try {_            listener.accept(value, null)__        } catch (Exception e) {_            eventHandler.taskException(e)__        }_    };executes,a,success,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,value,to,provide,to,listener;public,v,void,execute,listener,bi,consumer,v,exception,listener,v,value,assert,on,selector,thread,try,listener,accept,value,null,catch,exception,e,event,handler,task,exception,e
NioSelector -> public <V> void executeListener(BiConsumer<V, Exception> listener, V value);1550637215;Executes a success listener with consistent exception handling. This can only be called from current_selector thread.__@param listener to be executed_@param value    to provide to listener;public <V> void executeListener(BiConsumer<V, Exception> listener, V value) {_        assertOnSelectorThread()__        try {_            listener.accept(value, null)__        } catch (Exception e) {_            eventHandler.taskException(e)__        }_    };executes,a,success,listener,with,consistent,exception,handling,this,can,only,be,called,from,current,selector,thread,param,listener,to,be,executed,param,value,to,provide,to,listener;public,v,void,execute,listener,bi,consumer,v,exception,listener,v,value,assert,on,selector,thread,try,listener,accept,value,null,catch,exception,e,event,handler,task,exception,e
NioSelector -> public void queueWrite(WriteOperation writeOperation);1528706846;Queues a write operation to be handled by the event loop. This can be called by any thread and is the_api available for non-selector threads to schedule writes.__@param writeOperation to be queued;public void queueWrite(WriteOperation writeOperation) {_        queuedWrites.offer(writeOperation)__        if (isOpen() == false) {_            boolean wasRemoved = queuedWrites.remove(writeOperation)__            if (wasRemoved) {_                writeOperation.getListener().accept(null, new ClosedSelectorException())__            }_        } else {_            wakeup()__        }_    };queues,a,write,operation,to,be,handled,by,the,event,loop,this,can,be,called,by,any,thread,and,is,the,api,available,for,non,selector,threads,to,schedule,writes,param,write,operation,to,be,queued;public,void,queue,write,write,operation,write,operation,queued,writes,offer,write,operation,if,is,open,false,boolean,was,removed,queued,writes,remove,write,operation,if,was,removed,write,operation,get,listener,accept,null,new,closed,selector,exception,else,wakeup
NioSelector -> public void queueWrite(WriteOperation writeOperation);1528930607;Queues a write operation to be handled by the event loop. This can be called by any thread and is the_api available for non-selector threads to schedule writes.__@param writeOperation to be queued;public void queueWrite(WriteOperation writeOperation) {_        queuedWrites.offer(writeOperation)__        if (isOpen() == false) {_            boolean wasRemoved = queuedWrites.remove(writeOperation)__            if (wasRemoved) {_                writeOperation.getListener().accept(null, new ClosedSelectorException())__            }_        } else {_            wakeup()__        }_    };queues,a,write,operation,to,be,handled,by,the,event,loop,this,can,be,called,by,any,thread,and,is,the,api,available,for,non,selector,threads,to,schedule,writes,param,write,operation,to,be,queued;public,void,queue,write,write,operation,write,operation,queued,writes,offer,write,operation,if,is,open,false,boolean,was,removed,queued,writes,remove,write,operation,if,was,removed,write,operation,get,listener,accept,null,new,closed,selector,exception,else,wakeup
NioSelector -> public void queueWrite(WriteOperation writeOperation);1544144947;Queues a write operation to be handled by the event loop. This can be called by any thread and is the_api available for non-selector threads to schedule writes.__@param writeOperation to be queued;public void queueWrite(WriteOperation writeOperation) {_        queuedWrites.offer(writeOperation)__        if (isOpen() == false) {_            boolean wasRemoved = queuedWrites.remove(writeOperation)__            if (wasRemoved) {_                writeOperation.getListener().accept(null, new ClosedSelectorException())__            }_        } else {_            wakeup()__        }_    };queues,a,write,operation,to,be,handled,by,the,event,loop,this,can,be,called,by,any,thread,and,is,the,api,available,for,non,selector,threads,to,schedule,writes,param,write,operation,to,be,queued;public,void,queue,write,write,operation,write,operation,queued,writes,offer,write,operation,if,is,open,false,boolean,was,removed,queued,writes,remove,write,operation,if,was,removed,write,operation,get,listener,accept,null,new,closed,selector,exception,else,wakeup
NioSelector -> public void queueWrite(WriteOperation writeOperation);1547059584;Queues a write operation to be handled by the event loop. This can be called by any thread and is the_api available for non-selector threads to schedule writes.__@param writeOperation to be queued;public void queueWrite(WriteOperation writeOperation) {_        queuedWrites.offer(writeOperation)__        if (isOpen() == false) {_            boolean wasRemoved = queuedWrites.remove(writeOperation)__            if (wasRemoved) {_                writeOperation.getListener().accept(null, new ClosedSelectorException())__            }_        } else {_            wakeup()__        }_    };queues,a,write,operation,to,be,handled,by,the,event,loop,this,can,be,called,by,any,thread,and,is,the,api,available,for,non,selector,threads,to,schedule,writes,param,write,operation,to,be,queued;public,void,queue,write,write,operation,write,operation,queued,writes,offer,write,operation,if,is,open,false,boolean,was,removed,queued,writes,remove,write,operation,if,was,removed,write,operation,get,listener,accept,null,new,closed,selector,exception,else,wakeup
NioSelector -> public void queueWrite(WriteOperation writeOperation);1547137040;Queues a write operation to be handled by the event loop. This can be called by any thread and is the_api available for non-selector threads to schedule writes.__@param writeOperation to be queued;public void queueWrite(WriteOperation writeOperation) {_        queuedWrites.offer(writeOperation)__        if (isOpen() == false) {_            boolean wasRemoved = queuedWrites.remove(writeOperation)__            if (wasRemoved) {_                writeOperation.getListener().accept(null, new ClosedSelectorException())__            }_        } else {_            wakeup()__        }_    };queues,a,write,operation,to,be,handled,by,the,event,loop,this,can,be,called,by,any,thread,and,is,the,api,available,for,non,selector,threads,to,schedule,writes,param,write,operation,to,be,queued;public,void,queue,write,write,operation,write,operation,queued,writes,offer,write,operation,if,is,open,false,boolean,was,removed,queued,writes,remove,write,operation,if,was,removed,write,operation,get,listener,accept,null,new,closed,selector,exception,else,wakeup
NioSelector -> public void queueWrite(WriteOperation writeOperation);1550637215;Queues a write operation to be handled by the event loop. This can be called by any thread and is the_api available for non-selector threads to schedule writes.__@param writeOperation to be queued;public void queueWrite(WriteOperation writeOperation) {_        queuedWrites.offer(writeOperation)__        if (isOpen() == false) {_            boolean wasRemoved = queuedWrites.remove(writeOperation)__            if (wasRemoved) {_                writeOperation.getListener().accept(null, new ClosedSelectorException())__            }_        } else {_            wakeup()__        }_    };queues,a,write,operation,to,be,handled,by,the,event,loop,this,can,be,called,by,any,thread,and,is,the,api,available,for,non,selector,threads,to,schedule,writes,param,write,operation,to,be,queued;public,void,queue,write,write,operation,write,operation,queued,writes,offer,write,operation,if,is,open,false,boolean,was,removed,queued,writes,remove,write,operation,if,was,removed,write,operation,get,listener,accept,null,new,closed,selector,exception,else,wakeup
NioSelector -> private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded);1528706846;This is a convenience method to be called after some object (normally channels) are enqueued with this_selector. This method will check if the selector is still open. If it is open, normal operation can_proceed.__If the selector is closed, then we attempt to remove the object from the queue. If the removal_succeeds then we throw an {@link IllegalStateException} indicating that normal operation failed. If_the object cannot be removed from the queue, then the object has already been handled by the selector_and operation can proceed normally.__If this method is called from the selector thread, we will not allow the queuing to occur as the_selector thread can manipulate its queues internally even if it is no longer open.__@param queue the queue to which the object was added_@param objectAdded the objected added_@param <O> the object type;private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded) {_        if (isOpen() == false && isOnCurrentThread() == false) {_            if (queue.remove(objectAdded)) {_                throw new IllegalStateException("selector is already closed")__            }_        }_    };this,is,a,convenience,method,to,be,called,after,some,object,normally,channels,are,enqueued,with,this,selector,this,method,will,check,if,the,selector,is,still,open,if,it,is,open,normal,operation,can,proceed,if,the,selector,is,closed,then,we,attempt,to,remove,the,object,from,the,queue,if,the,removal,succeeds,then,we,throw,an,link,illegal,state,exception,indicating,that,normal,operation,failed,if,the,object,cannot,be,removed,from,the,queue,then,the,object,has,already,been,handled,by,the,selector,and,operation,can,proceed,normally,if,this,method,is,called,from,the,selector,thread,we,will,not,allow,the,queuing,to,occur,as,the,selector,thread,can,manipulate,its,queues,internally,even,if,it,is,no,longer,open,param,queue,the,queue,to,which,the,object,was,added,param,object,added,the,objected,added,param,o,the,object,type;private,o,void,ensure,selector,open,for,enqueuing,concurrent,linked,queue,o,queue,o,object,added,if,is,open,false,is,on,current,thread,false,if,queue,remove,object,added,throw,new,illegal,state,exception,selector,is,already,closed
NioSelector -> private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded);1528930607;This is a convenience method to be called after some object (normally channels) are enqueued with this_selector. This method will check if the selector is still open. If it is open, normal operation can_proceed.__If the selector is closed, then we attempt to remove the object from the queue. If the removal_succeeds then we throw an {@link IllegalStateException} indicating that normal operation failed. If_the object cannot be removed from the queue, then the object has already been handled by the selector_and operation can proceed normally.__If this method is called from the selector thread, we will not allow the queuing to occur as the_selector thread can manipulate its queues internally even if it is no longer open.__@param queue the queue to which the object was added_@param objectAdded the objected added_@param <O> the object type;private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded) {_        if (isOpen() == false && isOnCurrentThread() == false) {_            if (queue.remove(objectAdded)) {_                throw new IllegalStateException("selector is already closed")__            }_        }_    };this,is,a,convenience,method,to,be,called,after,some,object,normally,channels,are,enqueued,with,this,selector,this,method,will,check,if,the,selector,is,still,open,if,it,is,open,normal,operation,can,proceed,if,the,selector,is,closed,then,we,attempt,to,remove,the,object,from,the,queue,if,the,removal,succeeds,then,we,throw,an,link,illegal,state,exception,indicating,that,normal,operation,failed,if,the,object,cannot,be,removed,from,the,queue,then,the,object,has,already,been,handled,by,the,selector,and,operation,can,proceed,normally,if,this,method,is,called,from,the,selector,thread,we,will,not,allow,the,queuing,to,occur,as,the,selector,thread,can,manipulate,its,queues,internally,even,if,it,is,no,longer,open,param,queue,the,queue,to,which,the,object,was,added,param,object,added,the,objected,added,param,o,the,object,type;private,o,void,ensure,selector,open,for,enqueuing,concurrent,linked,queue,o,queue,o,object,added,if,is,open,false,is,on,current,thread,false,if,queue,remove,object,added,throw,new,illegal,state,exception,selector,is,already,closed
NioSelector -> private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded);1544144947;This is a convenience method to be called after some object (normally channels) are enqueued with this_selector. This method will check if the selector is still open. If it is open, normal operation can_proceed.__If the selector is closed, then we attempt to remove the object from the queue. If the removal_succeeds then we throw an {@link IllegalStateException} indicating that normal operation failed. If_the object cannot be removed from the queue, then the object has already been handled by the selector_and operation can proceed normally.__If this method is called from the selector thread, we will not allow the queuing to occur as the_selector thread can manipulate its queues internally even if it is no longer open.__@param queue the queue to which the object was added_@param objectAdded the objected added_@param <O> the object type;private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded) {_        if (isOpen() == false && isOnCurrentThread() == false) {_            if (queue.remove(objectAdded)) {_                throw new IllegalStateException("selector is already closed")__            }_        }_    };this,is,a,convenience,method,to,be,called,after,some,object,normally,channels,are,enqueued,with,this,selector,this,method,will,check,if,the,selector,is,still,open,if,it,is,open,normal,operation,can,proceed,if,the,selector,is,closed,then,we,attempt,to,remove,the,object,from,the,queue,if,the,removal,succeeds,then,we,throw,an,link,illegal,state,exception,indicating,that,normal,operation,failed,if,the,object,cannot,be,removed,from,the,queue,then,the,object,has,already,been,handled,by,the,selector,and,operation,can,proceed,normally,if,this,method,is,called,from,the,selector,thread,we,will,not,allow,the,queuing,to,occur,as,the,selector,thread,can,manipulate,its,queues,internally,even,if,it,is,no,longer,open,param,queue,the,queue,to,which,the,object,was,added,param,object,added,the,objected,added,param,o,the,object,type;private,o,void,ensure,selector,open,for,enqueuing,concurrent,linked,queue,o,queue,o,object,added,if,is,open,false,is,on,current,thread,false,if,queue,remove,object,added,throw,new,illegal,state,exception,selector,is,already,closed
NioSelector -> private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded);1547059584;This is a convenience method to be called after some object (normally channels) are enqueued with this_selector. This method will check if the selector is still open. If it is open, normal operation can_proceed.__If the selector is closed, then we attempt to remove the object from the queue. If the removal_succeeds then we throw an {@link IllegalStateException} indicating that normal operation failed. If_the object cannot be removed from the queue, then the object has already been handled by the selector_and operation can proceed normally.__If this method is called from the selector thread, we will not allow the queuing to occur as the_selector thread can manipulate its queues internally even if it is no longer open.__@param queue the queue to which the object was added_@param objectAdded the objected added_@param <O> the object type;private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded) {_        if (isOpen() == false && isOnCurrentThread() == false) {_            if (queue.remove(objectAdded)) {_                throw new IllegalStateException("selector is already closed")__            }_        }_    };this,is,a,convenience,method,to,be,called,after,some,object,normally,channels,are,enqueued,with,this,selector,this,method,will,check,if,the,selector,is,still,open,if,it,is,open,normal,operation,can,proceed,if,the,selector,is,closed,then,we,attempt,to,remove,the,object,from,the,queue,if,the,removal,succeeds,then,we,throw,an,link,illegal,state,exception,indicating,that,normal,operation,failed,if,the,object,cannot,be,removed,from,the,queue,then,the,object,has,already,been,handled,by,the,selector,and,operation,can,proceed,normally,if,this,method,is,called,from,the,selector,thread,we,will,not,allow,the,queuing,to,occur,as,the,selector,thread,can,manipulate,its,queues,internally,even,if,it,is,no,longer,open,param,queue,the,queue,to,which,the,object,was,added,param,object,added,the,objected,added,param,o,the,object,type;private,o,void,ensure,selector,open,for,enqueuing,concurrent,linked,queue,o,queue,o,object,added,if,is,open,false,is,on,current,thread,false,if,queue,remove,object,added,throw,new,illegal,state,exception,selector,is,already,closed
NioSelector -> private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded);1547137040;This is a convenience method to be called after some object (normally channels) are enqueued with this_selector. This method will check if the selector is still open. If it is open, normal operation can_proceed.__If the selector is closed, then we attempt to remove the object from the queue. If the removal_succeeds then we throw an {@link IllegalStateException} indicating that normal operation failed. If_the object cannot be removed from the queue, then the object has already been handled by the selector_and operation can proceed normally.__If this method is called from the selector thread, we will not allow the queuing to occur as the_selector thread can manipulate its queues internally even if it is no longer open.__@param queue the queue to which the object was added_@param objectAdded the objected added_@param <O> the object type;private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded) {_        if (isOpen() == false && isOnCurrentThread() == false) {_            if (queue.remove(objectAdded)) {_                throw new IllegalStateException("selector is already closed")__            }_        }_    };this,is,a,convenience,method,to,be,called,after,some,object,normally,channels,are,enqueued,with,this,selector,this,method,will,check,if,the,selector,is,still,open,if,it,is,open,normal,operation,can,proceed,if,the,selector,is,closed,then,we,attempt,to,remove,the,object,from,the,queue,if,the,removal,succeeds,then,we,throw,an,link,illegal,state,exception,indicating,that,normal,operation,failed,if,the,object,cannot,be,removed,from,the,queue,then,the,object,has,already,been,handled,by,the,selector,and,operation,can,proceed,normally,if,this,method,is,called,from,the,selector,thread,we,will,not,allow,the,queuing,to,occur,as,the,selector,thread,can,manipulate,its,queues,internally,even,if,it,is,no,longer,open,param,queue,the,queue,to,which,the,object,was,added,param,object,added,the,objected,added,param,o,the,object,type;private,o,void,ensure,selector,open,for,enqueuing,concurrent,linked,queue,o,queue,o,object,added,if,is,open,false,is,on,current,thread,false,if,queue,remove,object,added,throw,new,illegal,state,exception,selector,is,already,closed
NioSelector -> private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded);1550637215;This is a convenience method to be called after some object (normally channels) are enqueued with this_selector. This method will check if the selector is still open. If it is open, normal operation can_proceed.__If the selector is closed, then we attempt to remove the object from the queue. If the removal_succeeds then we throw an {@link IllegalStateException} indicating that normal operation failed. If_the object cannot be removed from the queue, then the object has already been handled by the selector_and operation can proceed normally.__If this method is called from the selector thread, we will not allow the queuing to occur as the_selector thread can manipulate its queues internally even if it is no longer open.__@param queue the queue to which the object was added_@param objectAdded the objected added_@param <O> the object type;private <O> void ensureSelectorOpenForEnqueuing(ConcurrentLinkedQueue<O> queue, O objectAdded) {_        if (isOpen() == false && isOnCurrentThread() == false) {_            if (queue.remove(objectAdded)) {_                throw new IllegalStateException("selector is already closed")__            }_        }_    };this,is,a,convenience,method,to,be,called,after,some,object,normally,channels,are,enqueued,with,this,selector,this,method,will,check,if,the,selector,is,still,open,if,it,is,open,normal,operation,can,proceed,if,the,selector,is,closed,then,we,attempt,to,remove,the,object,from,the,queue,if,the,removal,succeeds,then,we,throw,an,link,illegal,state,exception,indicating,that,normal,operation,failed,if,the,object,cannot,be,removed,from,the,queue,then,the,object,has,already,been,handled,by,the,selector,and,operation,can,proceed,normally,if,this,method,is,called,from,the,selector,thread,we,will,not,allow,the,queuing,to,occur,as,the,selector,thread,can,manipulate,its,queues,internally,even,if,it,is,no,longer,open,param,queue,the,queue,to,which,the,object,was,added,param,object,added,the,objected,added,param,o,the,object,type;private,o,void,ensure,selector,open,for,enqueuing,concurrent,linked,queue,o,queue,o,object,added,if,is,open,false,is,on,current,thread,false,if,queue,remove,object,added,throw,new,illegal,state,exception,selector,is,already,closed
NioSelector -> public void scheduleForRegistration(NioChannel channel);1528706846;Schedules a NioChannel to be registered with this selector. The channel will by queued and_eventually registered next time through the event loop.__@param channel to register;public void scheduleForRegistration(NioChannel channel) {_        ChannelContext<?> context = channel.getContext()__        channelsToRegister.add(context)__        ensureSelectorOpenForEnqueuing(channelsToRegister, context)__        wakeup()__    };schedules,a,nio,channel,to,be,registered,with,this,selector,the,channel,will,by,queued,and,eventually,registered,next,time,through,the,event,loop,param,channel,to,register;public,void,schedule,for,registration,nio,channel,channel,channel,context,context,channel,get,context,channels,to,register,add,context,ensure,selector,open,for,enqueuing,channels,to,register,context,wakeup
NioSelector -> public void scheduleForRegistration(NioChannel channel);1528930607;Schedules a NioChannel to be registered with this selector. The channel will by queued and_eventually registered next time through the event loop.__@param channel to register;public void scheduleForRegistration(NioChannel channel) {_        ChannelContext<?> context = channel.getContext()__        channelsToRegister.add(context)__        ensureSelectorOpenForEnqueuing(channelsToRegister, context)__        wakeup()__    };schedules,a,nio,channel,to,be,registered,with,this,selector,the,channel,will,by,queued,and,eventually,registered,next,time,through,the,event,loop,param,channel,to,register;public,void,schedule,for,registration,nio,channel,channel,channel,context,context,channel,get,context,channels,to,register,add,context,ensure,selector,open,for,enqueuing,channels,to,register,context,wakeup
NioSelector -> public void scheduleForRegistration(NioChannel channel);1544144947;Schedules a NioChannel to be registered with this selector. The channel will by queued and_eventually registered next time through the event loop.__@param channel to register;public void scheduleForRegistration(NioChannel channel) {_        ChannelContext<?> context = channel.getContext()__        channelsToRegister.add(context)__        ensureSelectorOpenForEnqueuing(channelsToRegister, context)__        wakeup()__    };schedules,a,nio,channel,to,be,registered,with,this,selector,the,channel,will,by,queued,and,eventually,registered,next,time,through,the,event,loop,param,channel,to,register;public,void,schedule,for,registration,nio,channel,channel,channel,context,context,channel,get,context,channels,to,register,add,context,ensure,selector,open,for,enqueuing,channels,to,register,context,wakeup
NioSelector -> public void scheduleForRegistration(NioChannel channel);1547059584;Schedules a NioChannel to be registered with this selector. The channel will by queued and_eventually registered next time through the event loop.__@param channel to register;public void scheduleForRegistration(NioChannel channel) {_        ChannelContext<?> context = channel.getContext()__        channelsToRegister.add(context)__        ensureSelectorOpenForEnqueuing(channelsToRegister, context)__        wakeup()__    };schedules,a,nio,channel,to,be,registered,with,this,selector,the,channel,will,by,queued,and,eventually,registered,next,time,through,the,event,loop,param,channel,to,register;public,void,schedule,for,registration,nio,channel,channel,channel,context,context,channel,get,context,channels,to,register,add,context,ensure,selector,open,for,enqueuing,channels,to,register,context,wakeup
NioSelector -> public void scheduleForRegistration(NioChannel channel);1547137040;Schedules a NioChannel to be registered with this selector. The channel will by queued and_eventually registered next time through the event loop.__@param channel to register;public void scheduleForRegistration(NioChannel channel) {_        ChannelContext<?> context = channel.getContext()__        channelsToRegister.add(context)__        ensureSelectorOpenForEnqueuing(channelsToRegister, context)__        wakeup()__    };schedules,a,nio,channel,to,be,registered,with,this,selector,the,channel,will,by,queued,and,eventually,registered,next,time,through,the,event,loop,param,channel,to,register;public,void,schedule,for,registration,nio,channel,channel,channel,context,context,channel,get,context,channels,to,register,add,context,ensure,selector,open,for,enqueuing,channels,to,register,context,wakeup
NioSelector -> public void scheduleForRegistration(NioChannel channel);1550637215;Schedules a NioChannel to be registered with this selector. The channel will by queued and_eventually registered next time through the event loop.__@param channel to register;public void scheduleForRegistration(NioChannel channel) {_        ChannelContext<?> context = channel.getContext()__        channelsToRegister.add(context)__        ensureSelectorOpenForEnqueuing(channelsToRegister, context)__        wakeup()__    };schedules,a,nio,channel,to,be,registered,with,this,selector,the,channel,will,by,queued,and,eventually,registered,next,time,through,the,event,loop,param,channel,to,register;public,void,schedule,for,registration,nio,channel,channel,channel,context,context,channel,get,context,channels,to,register,add,context,ensure,selector,open,for,enqueuing,channels,to,register,context,wakeup
NioSelector -> public void writeToChannel(WriteOperation writeOperation);1528930607;Queues a write operation directly in a channel's buffer. If this channel does not have pending writes_already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector_thread. As a result, this method should only be called by the selector thread. If this channel does_not have pending writes already, the channel will be flushed.__@param writeOperation to be queued in a channel's buffer;public void writeToChannel(WriteOperation writeOperation) {_        assertOnSelectorThread()__        SocketChannelContext context = writeOperation.getChannel()__        _        _        boolean shouldFlushAfterQueuing = context.readyForFlush() == false__        try {_            SelectionKeyUtils.setWriteInterested(context.getSelectionKey())__            context.queueWriteOperation(writeOperation)__        } catch (Exception e) {_            shouldFlushAfterQueuing = false__            executeFailedListener(writeOperation.getListener(), e)__        }__        if (shouldFlushAfterQueuing) {_            handleWrite(context)__            eventHandler.postHandling(context)__        }_    };queues,a,write,operation,directly,in,a,channel,s,buffer,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,channel,buffers,are,only,safe,to,be,accessed,by,the,selector,thread,as,a,result,this,method,should,only,be,called,by,the,selector,thread,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,param,write,operation,to,be,queued,in,a,channel,s,buffer;public,void,write,to,channel,write,operation,write,operation,assert,on,selector,thread,socket,channel,context,context,write,operation,get,channel,boolean,should,flush,after,queuing,context,ready,for,flush,false,try,selection,key,utils,set,write,interested,context,get,selection,key,context,queue,write,operation,write,operation,catch,exception,e,should,flush,after,queuing,false,execute,failed,listener,write,operation,get,listener,e,if,should,flush,after,queuing,handle,write,context,event,handler,post,handling,context
NioSelector -> public void writeToChannel(WriteOperation writeOperation);1544144947;Queues a write operation directly in a channel's buffer. If this channel does not have pending writes_already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector_thread. As a result, this method should only be called by the selector thread. If this channel does_not have pending writes already, the channel will be flushed.__@param writeOperation to be queued in a channel's buffer;public void writeToChannel(WriteOperation writeOperation) {_        assertOnSelectorThread()__        SocketChannelContext context = writeOperation.getChannel()__        _        _        boolean shouldFlushAfterQueuing = context.readyForFlush() == false__        try {_            SelectionKeyUtils.setWriteInterested(context.getSelectionKey())__            context.queueWriteOperation(writeOperation)__        } catch (Exception e) {_            shouldFlushAfterQueuing = false__            executeFailedListener(writeOperation.getListener(), e)__        }__        if (shouldFlushAfterQueuing) {_            handleWrite(context)__            eventHandler.postHandling(context)__        }_    };queues,a,write,operation,directly,in,a,channel,s,buffer,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,channel,buffers,are,only,safe,to,be,accessed,by,the,selector,thread,as,a,result,this,method,should,only,be,called,by,the,selector,thread,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,param,write,operation,to,be,queued,in,a,channel,s,buffer;public,void,write,to,channel,write,operation,write,operation,assert,on,selector,thread,socket,channel,context,context,write,operation,get,channel,boolean,should,flush,after,queuing,context,ready,for,flush,false,try,selection,key,utils,set,write,interested,context,get,selection,key,context,queue,write,operation,write,operation,catch,exception,e,should,flush,after,queuing,false,execute,failed,listener,write,operation,get,listener,e,if,should,flush,after,queuing,handle,write,context,event,handler,post,handling,context
NioSelector -> public void writeToChannel(WriteOperation writeOperation);1547059584;Queues a write operation directly in a channel's buffer. If this channel does not have pending writes_already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector_thread. As a result, this method should only be called by the selector thread. If this channel does_not have pending writes already, the channel will be flushed.__@param writeOperation to be queued in a channel's buffer;public void writeToChannel(WriteOperation writeOperation) {_        assertOnSelectorThread()__        SocketChannelContext context = writeOperation.getChannel()__        _        _        boolean shouldFlushAfterQueuing = context.readyForFlush() == false__        try {_            SelectionKeyUtils.setWriteInterested(context.getSelectionKey())__            context.queueWriteOperation(writeOperation)__        } catch (Exception e) {_            shouldFlushAfterQueuing = false__            executeFailedListener(writeOperation.getListener(), e)__        }__        if (shouldFlushAfterQueuing) {_            handleWrite(context)__            eventHandler.postHandling(context)__        }_    };queues,a,write,operation,directly,in,a,channel,s,buffer,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,channel,buffers,are,only,safe,to,be,accessed,by,the,selector,thread,as,a,result,this,method,should,only,be,called,by,the,selector,thread,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,param,write,operation,to,be,queued,in,a,channel,s,buffer;public,void,write,to,channel,write,operation,write,operation,assert,on,selector,thread,socket,channel,context,context,write,operation,get,channel,boolean,should,flush,after,queuing,context,ready,for,flush,false,try,selection,key,utils,set,write,interested,context,get,selection,key,context,queue,write,operation,write,operation,catch,exception,e,should,flush,after,queuing,false,execute,failed,listener,write,operation,get,listener,e,if,should,flush,after,queuing,handle,write,context,event,handler,post,handling,context
NioSelector -> public void writeToChannel(WriteOperation writeOperation);1547137040;Queues a write operation directly in a channel's buffer. If this channel does not have pending writes_already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector_thread. As a result, this method should only be called by the selector thread. If this channel does_not have pending writes already, the channel will be flushed.__@param writeOperation to be queued in a channel's buffer;public void writeToChannel(WriteOperation writeOperation) {_        assertOnSelectorThread()__        SocketChannelContext context = writeOperation.getChannel()__        _        _        boolean shouldFlushAfterQueuing = context.readyForFlush() == false__        try {_            SelectionKeyUtils.setWriteInterested(context.getSelectionKey())__            context.queueWriteOperation(writeOperation)__        } catch (Exception e) {_            shouldFlushAfterQueuing = false__            executeFailedListener(writeOperation.getListener(), e)__        }__        if (shouldFlushAfterQueuing) {_            handleWrite(context)__            eventHandler.postHandling(context)__        }_    };queues,a,write,operation,directly,in,a,channel,s,buffer,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,channel,buffers,are,only,safe,to,be,accessed,by,the,selector,thread,as,a,result,this,method,should,only,be,called,by,the,selector,thread,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,param,write,operation,to,be,queued,in,a,channel,s,buffer;public,void,write,to,channel,write,operation,write,operation,assert,on,selector,thread,socket,channel,context,context,write,operation,get,channel,boolean,should,flush,after,queuing,context,ready,for,flush,false,try,selection,key,utils,set,write,interested,context,get,selection,key,context,queue,write,operation,write,operation,catch,exception,e,should,flush,after,queuing,false,execute,failed,listener,write,operation,get,listener,e,if,should,flush,after,queuing,handle,write,context,event,handler,post,handling,context
NioSelector -> public void writeToChannel(WriteOperation writeOperation);1550637215;Queues a write operation directly in a channel's buffer. If this channel does not have pending writes_already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector_thread. As a result, this method should only be called by the selector thread. If this channel does_not have pending writes already, the channel will be flushed.__@param writeOperation to be queued in a channel's buffer;public void writeToChannel(WriteOperation writeOperation) {_        assertOnSelectorThread()__        SocketChannelContext context = writeOperation.getChannel()__        _        _        boolean shouldFlushAfterQueuing = context.readyForFlush() == false__        try {_            SelectionKeyUtils.setWriteInterested(context.getSelectionKey())__            context.queueWriteOperation(writeOperation)__        } catch (Exception e) {_            shouldFlushAfterQueuing = false__            executeFailedListener(writeOperation.getListener(), e)__        }__        if (shouldFlushAfterQueuing) {_            if (context.selectorShouldClose() == false) {_                handleWrite(context)__            }_            eventHandler.postHandling(context)__        }_    };queues,a,write,operation,directly,in,a,channel,s,buffer,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,channel,buffers,are,only,safe,to,be,accessed,by,the,selector,thread,as,a,result,this,method,should,only,be,called,by,the,selector,thread,if,this,channel,does,not,have,pending,writes,already,the,channel,will,be,flushed,param,write,operation,to,be,queued,in,a,channel,s,buffer;public,void,write,to,channel,write,operation,write,operation,assert,on,selector,thread,socket,channel,context,context,write,operation,get,channel,boolean,should,flush,after,queuing,context,ready,for,flush,false,try,selection,key,utils,set,write,interested,context,get,selection,key,context,queue,write,operation,write,operation,catch,exception,e,should,flush,after,queuing,false,execute,failed,listener,write,operation,get,listener,e,if,should,flush,after,queuing,if,context,selector,should,close,false,handle,write,context,event,handler,post,handling,context
NioSelector -> void preSelect();1528706846;Called immediately prior to a raw {@link Selector#select()} call. Should be used to implement_channel registration, handling queued writes, and other work that is not specifically processing_a selection key.;void preSelect() {_        setUpNewChannels()__        handleQueuedWrites()__    };called,immediately,prior,to,a,raw,link,selector,select,call,should,be,used,to,implement,channel,registration,handling,queued,writes,and,other,work,that,is,not,specifically,processing,a,selection,key;void,pre,select,set,up,new,channels,handle,queued,writes
NioSelector -> void preSelect();1528930607;Called immediately prior to a raw {@link Selector#select()} call. Should be used to implement_channel registration, handling queued writes, and other work that is not specifically processing_a selection key.;void preSelect() {_        setUpNewChannels()__        handleQueuedWrites()__    };called,immediately,prior,to,a,raw,link,selector,select,call,should,be,used,to,implement,channel,registration,handling,queued,writes,and,other,work,that,is,not,specifically,processing,a,selection,key;void,pre,select,set,up,new,channels,handle,queued,writes
NioSelector -> void preSelect();1544144947;Called immediately prior to a raw {@link Selector#select()} call. Should be used to implement_channel registration, handling queued writes, and other work that is not specifically processing_a selection key.;void preSelect() {_        setUpNewChannels()__        handleQueuedWrites()__    };called,immediately,prior,to,a,raw,link,selector,select,call,should,be,used,to,implement,channel,registration,handling,queued,writes,and,other,work,that,is,not,specifically,processing,a,selection,key;void,pre,select,set,up,new,channels,handle,queued,writes
NioSelector -> void preSelect();1547059584;Called immediately prior to a raw {@link Selector#select()} call. Should be used to implement_channel registration, handling queued writes, and other work that is not specifically processing_a selection key.;void preSelect() {_        setUpNewChannels()__        handleQueuedWrites()__    };called,immediately,prior,to,a,raw,link,selector,select,call,should,be,used,to,implement,channel,registration,handling,queued,writes,and,other,work,that,is,not,specifically,processing,a,selection,key;void,pre,select,set,up,new,channels,handle,queued,writes
NioSelector -> void preSelect();1547137040;Called immediately prior to a raw {@link Selector#select()} call. Should be used to implement_channel registration, handling queued writes, and other work that is not specifically processing_a selection key.;void preSelect() {_        setUpNewChannels()__        handleQueuedWrites()__    };called,immediately,prior,to,a,raw,link,selector,select,call,should,be,used,to,implement,channel,registration,handling,queued,writes,and,other,work,that,is,not,specifically,processing,a,selection,key;void,pre,select,set,up,new,channels,handle,queued,writes
NioSelector -> void preSelect();1550637215;Called immediately prior to a raw {@link Selector#select()} call. Should be used to implement_channel registration, handling queued writes, and other work that is not specifically processing_a selection key.;void preSelect() {_        setUpNewChannels()__        handleQueuedWrites()__    };called,immediately,prior,to,a,raw,link,selector,select,call,should,be,used,to,implement,channel,registration,handling,queued,writes,and,other,work,that,is,not,specifically,processing,a,selection,key;void,pre,select,set,up,new,channels,handle,queued,writes
