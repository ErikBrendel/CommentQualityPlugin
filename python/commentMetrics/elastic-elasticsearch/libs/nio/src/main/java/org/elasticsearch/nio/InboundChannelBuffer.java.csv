commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static InboundChannelBuffer allocatingInstance() {     return new InboundChannelBuffer(() -> new Page(ByteBuffer.allocate(PAGE_SIZE), () -> {     })). }
false;public;0;15;;@Override public void close() {     if (isClosed.compareAndSet(false, true)) {         Page page.         List<RuntimeException> closingExceptions = new ArrayList<>().         while ((page = pages.pollFirst()) != null) {             try {                 page.close().             } catch (RuntimeException e) {                 closingExceptions.add(e).             }         }         ExceptionsHelper.rethrowAndSuppress(closingExceptions).     } }
false;public;1;14;;public void ensureCapacity(long requiredCapacity) {     if (isClosed.get()) {         throw new IllegalStateException("Cannot allocate new pages if the buffer is closed.").     }     if (capacity < requiredCapacity) {         int numPages = numPages(requiredCapacity + offset).         int pagesToAdd = numPages - pages.size().         for (int i = 0. i < pagesToAdd. i++) {             Page page = pageSupplier.get().             pages.addLast(page).         }         capacity += pagesToAdd * PAGE_SIZE.     } }
true;public;1;13;/**  * This method will release bytes from the head of this buffer. If you release bytes past the current  * index the index is truncated to zero.  *  * @param bytesToRelease number of bytes to drop  */ ;/**  * This method will release bytes from the head of this buffer. If you release bytes past the current  * index the index is truncated to zero.  *  * @param bytesToRelease number of bytes to drop  */ public void release(long bytesToRelease) {     if (bytesToRelease > capacity) {         throw new IllegalArgumentException("Releasing more bytes [" + bytesToRelease + "] than buffer capacity [" + capacity + "].").     }     int pagesToRelease = pageIndex(offset + bytesToRelease).     for (int i = 0. i < pagesToRelease. i++) {         pages.removeFirst().close().     }     capacity -= bytesToRelease.     internalIndex = Math.max(internalIndex - bytesToRelease, 0).     offset = indexInPage(bytesToRelease + offset). }
true;public;1;28;/**  * This method will return an array of {@link ByteBuffer} representing the bytes from the beginning of  * this buffer up through the index argument that was passed. The buffers will be duplicates of the  * internal buffers, so any modifications to the markers {@link ByteBuffer#position()},  * {@link ByteBuffer#limit()}, etc will not modify the this class.  *  * @param to the index to slice up to  * @return the byte buffers  */ ;/**  * This method will return an array of {@link ByteBuffer} representing the bytes from the beginning of  * this buffer up through the index argument that was passed. The buffers will be duplicates of the  * internal buffers, so any modifications to the markers {@link ByteBuffer#position()},  * {@link ByteBuffer#limit()}, etc will not modify the this class.  *  * @param to the index to slice up to  * @return the byte buffers  */ public ByteBuffer[] sliceBuffersTo(long to) {     if (to > capacity) {         throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity + "], with slice parameters to [" + to + "]").     } else if (to == 0) {         return EMPTY_BYTE_BUFFER_ARRAY.     }     long indexWithOffset = to + offset.     int pageCount = pageIndex(indexWithOffset).     int finalLimit = indexInPage(indexWithOffset).     if (finalLimit != 0) {         pageCount += 1.     }     ByteBuffer[] buffers = new ByteBuffer[pageCount].     Iterator<Page> pageIterator = pages.iterator().     ByteBuffer firstBuffer = pageIterator.next().byteBuffer.duplicate().     firstBuffer.position(firstBuffer.position() + offset).     buffers[0] = firstBuffer.     for (int i = 1. i < buffers.length. i++) {         buffers[i] = pageIterator.next().byteBuffer.duplicate().     }     if (finalLimit != 0) {         buffers[buffers.length - 1].limit(finalLimit).     }     return buffers. }
true;public;1;29;/**  * This method will return an array of {@link Page} representing the bytes from the beginning of  * this buffer up through the index argument that was passed. The pages and buffers will be duplicates of  * the internal components, so any modifications to the markers {@link ByteBuffer#position()},  * {@link ByteBuffer#limit()}, etc will not modify the this class. Additionally, this will internally  * retain the underlying pages, so the pages returned by this method must be closed.  *  * @param to the index to slice up to  * @return the pages  */ ;/**  * This method will return an array of {@link Page} representing the bytes from the beginning of  * this buffer up through the index argument that was passed. The pages and buffers will be duplicates of  * the internal components, so any modifications to the markers {@link ByteBuffer#position()},  * {@link ByteBuffer#limit()}, etc will not modify the this class. Additionally, this will internally  * retain the underlying pages, so the pages returned by this method must be closed.  *  * @param to the index to slice up to  * @return the pages  */ public Page[] sliceAndRetainPagesTo(long to) {     if (to > capacity) {         throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity + "], with slice parameters to [" + to + "]").     } else if (to == 0) {         return EMPTY_BYTE_PAGE_ARRAY.     }     long indexWithOffset = to + offset.     int pageCount = pageIndex(indexWithOffset).     int finalLimit = indexInPage(indexWithOffset).     if (finalLimit != 0) {         pageCount += 1.     }     Page[] pages = new Page[pageCount].     Iterator<Page> pageIterator = this.pages.iterator().     Page firstPage = pageIterator.next().duplicate().     ByteBuffer firstBuffer = firstPage.byteBuffer.     firstBuffer.position(firstBuffer.position() + offset).     pages[0] = firstPage.     for (int i = 1. i < pages.length. i++) {         pages[i] = pageIterator.next().duplicate().     }     if (finalLimit != 0) {         pages[pages.length - 1].byteBuffer.limit(finalLimit).     }     return pages. }
true;public;1;23;/**  * This method will return an array of {@link ByteBuffer} representing the bytes from the index passed  * through the end of this buffer. The buffers will be duplicates of the internal buffers, so any  * modifications to the markers {@link ByteBuffer#position()}, {@link ByteBuffer#limit()}, etc will not  * modify the this class.  *  * @param from the index to slice from  * @return the byte buffers  */ ;/**  * This method will return an array of {@link ByteBuffer} representing the bytes from the index passed  * through the end of this buffer. The buffers will be duplicates of the internal buffers, so any  * modifications to the markers {@link ByteBuffer#position()}, {@link ByteBuffer#limit()}, etc will not  * modify the this class.  *  * @param from the index to slice from  * @return the byte buffers  */ public ByteBuffer[] sliceBuffersFrom(long from) {     if (from > capacity) {         throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity + "], with slice parameters from [" + from + "]").     } else if (from == capacity) {         return EMPTY_BYTE_BUFFER_ARRAY.     }     long indexWithOffset = from + offset.     int pageIndex = pageIndex(indexWithOffset).     int indexInPage = indexInPage(indexWithOffset).     ByteBuffer[] buffers = new ByteBuffer[pages.size() - pageIndex].     Iterator<Page> pageIterator = pages.descendingIterator().     for (int i = buffers.length - 1. i > 0. --i) {         buffers[i] = pageIterator.next().byteBuffer.duplicate().     }     ByteBuffer firstPostIndexBuffer = pageIterator.next().byteBuffer.duplicate().     firstPostIndexBuffer.position(firstPostIndexBuffer.position() + indexInPage).     buffers[0] = firstPostIndexBuffer.     return buffers. }
false;public;1;12;;public void incrementIndex(long delta) {     if (delta < 0) {         throw new IllegalArgumentException("Cannot increment an index with a negative delta [" + delta + "]").     }     long newIndex = delta + internalIndex.     if (newIndex > capacity) {         throw new IllegalArgumentException("Cannot increment an index [" + internalIndex + "] with a delta [" + delta + "] that will result in a new index [" + newIndex + "] that is greater than the capacity [" + capacity + "].").     }     internalIndex = newIndex. }
false;public;0;3;;public long getIndex() {     return internalIndex. }
false;public;0;3;;public long getCapacity() {     return capacity. }
false;public;0;5;;public long getRemaining() {     long remaining = capacity - internalIndex.     assert remaining >= 0 : "The remaining [" + remaining + "] number of bytes should not be less than zero.".     return remaining. }
false;private;1;7;;private int numPages(long capacity) {     final long numPages = (capacity + PAGE_MASK) >>> PAGE_SHIFT.     if (numPages > Integer.MAX_VALUE) {         throw new IllegalArgumentException("pageSize=" + (PAGE_MASK + 1) + " is too small for such as capacity: " + capacity).     }     return (int) numPages. }
false;private;1;3;;private int pageIndex(long index) {     return (int) (index >>> PAGE_SHIFT). }
false;private;1;3;;private int indexInPage(long index) {     return (int) (index & PAGE_MASK). }
false;private;0;4;;private Page duplicate() {     refCountedCloseable.incRef().     return new Page(byteBuffer.duplicate(), refCountedCloseable). }
false;public;0;3;;public ByteBuffer getByteBuffer() {     return byteBuffer. }
false;public;0;4;;@Override public void close() {     refCountedCloseable.decRef(). }
false;protected;0;4;;@Override protected void closeInternal() {     closeable.run(). }
