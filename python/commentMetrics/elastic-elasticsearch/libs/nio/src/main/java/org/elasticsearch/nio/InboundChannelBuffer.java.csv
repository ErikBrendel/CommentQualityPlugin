# id;timestamp;commentText;codeText;commentWords;codeWords
InboundChannelBuffer -> public void release(long bytesToRelease);1528706846;This method will release bytes from the head of this buffer. If you release bytes past the current_index the index is truncated to zero.__@param bytesToRelease number of bytes to drop;public void release(long bytesToRelease) {_        if (bytesToRelease > capacity) {_            throw new IllegalArgumentException("Releasing more bytes [" + bytesToRelease + "] than buffer capacity [" + capacity + "].")__        }__        int pagesToRelease = pageIndex(offset + bytesToRelease)__        for (int i = 0_ i < pagesToRelease_ i++) {_            pages.removeFirst().close()__        }_        capacity -= bytesToRelease__        internalIndex = Math.max(internalIndex - bytesToRelease, 0)__        offset = indexInPage(bytesToRelease + offset)__    };this,method,will,release,bytes,from,the,head,of,this,buffer,if,you,release,bytes,past,the,current,index,the,index,is,truncated,to,zero,param,bytes,to,release,number,of,bytes,to,drop;public,void,release,long,bytes,to,release,if,bytes,to,release,capacity,throw,new,illegal,argument,exception,releasing,more,bytes,bytes,to,release,than,buffer,capacity,capacity,int,pages,to,release,page,index,offset,bytes,to,release,for,int,i,0,i,pages,to,release,i,pages,remove,first,close,capacity,bytes,to,release,internal,index,math,max,internal,index,bytes,to,release,0,offset,index,in,page,bytes,to,release,offset
InboundChannelBuffer -> public void release(long bytesToRelease);1529341607;This method will release bytes from the head of this buffer. If you release bytes past the current_index the index is truncated to zero.__@param bytesToRelease number of bytes to drop;public void release(long bytesToRelease) {_        if (bytesToRelease > capacity) {_            throw new IllegalArgumentException("Releasing more bytes [" + bytesToRelease + "] than buffer capacity [" + capacity + "].")__        }__        int pagesToRelease = pageIndex(offset + bytesToRelease)__        for (int i = 0_ i < pagesToRelease_ i++) {_            pages.removeFirst().close()__        }_        capacity -= bytesToRelease__        internalIndex = Math.max(internalIndex - bytesToRelease, 0)__        offset = indexInPage(bytesToRelease + offset)__    };this,method,will,release,bytes,from,the,head,of,this,buffer,if,you,release,bytes,past,the,current,index,the,index,is,truncated,to,zero,param,bytes,to,release,number,of,bytes,to,drop;public,void,release,long,bytes,to,release,if,bytes,to,release,capacity,throw,new,illegal,argument,exception,releasing,more,bytes,bytes,to,release,than,buffer,capacity,capacity,int,pages,to,release,page,index,offset,bytes,to,release,for,int,i,0,i,pages,to,release,i,pages,remove,first,close,capacity,bytes,to,release,internal,index,math,max,internal,index,bytes,to,release,0,offset,index,in,page,bytes,to,release,offset
InboundChannelBuffer -> public void release(long bytesToRelease);1529433467;This method will release bytes from the head of this buffer. If you release bytes past the current_index the index is truncated to zero.__@param bytesToRelease number of bytes to drop;public void release(long bytesToRelease) {_        if (bytesToRelease > capacity) {_            throw new IllegalArgumentException("Releasing more bytes [" + bytesToRelease + "] than buffer capacity [" + capacity + "].")__        }__        int pagesToRelease = pageIndex(offset + bytesToRelease)__        for (int i = 0_ i < pagesToRelease_ i++) {_            pages.removeFirst().close()__        }_        capacity -= bytesToRelease__        internalIndex = Math.max(internalIndex - bytesToRelease, 0)__        offset = indexInPage(bytesToRelease + offset)__    };this,method,will,release,bytes,from,the,head,of,this,buffer,if,you,release,bytes,past,the,current,index,the,index,is,truncated,to,zero,param,bytes,to,release,number,of,bytes,to,drop;public,void,release,long,bytes,to,release,if,bytes,to,release,capacity,throw,new,illegal,argument,exception,releasing,more,bytes,bytes,to,release,than,buffer,capacity,capacity,int,pages,to,release,page,index,offset,bytes,to,release,for,int,i,0,i,pages,to,release,i,pages,remove,first,close,capacity,bytes,to,release,internal,index,math,max,internal,index,bytes,to,release,0,offset,index,in,page,bytes,to,release,offset
InboundChannelBuffer -> public ByteBuffer[] sliceBuffersFrom(long from);1528706846;This method will return an array of {@link ByteBuffer} representing the bytes from the index passed_through the end of this buffer. The buffers will be duplicates of the internal buffers, so any_modifications to the markers {@link ByteBuffer#position()}, {@link ByteBuffer#limit()}, etc will not_modify the this class.__@param from the index to slice from_@return the byte buffers;public ByteBuffer[] sliceBuffersFrom(long from) {_        if (from > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters from [" + from + "]")__        } else if (from == capacity) {_            return EMPTY_BYTE_BUFFER_ARRAY__        }_        long indexWithOffset = from + offset___        int pageIndex = pageIndex(indexWithOffset)__        int indexInPage = indexInPage(indexWithOffset)___        ByteBuffer[] buffers = new ByteBuffer[pages.size() - pageIndex]__        Iterator<Page> pageIterator = pages.descendingIterator()__        for (int i = buffers.length - 1_ i > 0_ --i) {_            buffers[i] = pageIterator.next().byteBuffer.duplicate()__        }_        ByteBuffer firstPostIndexBuffer = pageIterator.next().byteBuffer.duplicate()__        firstPostIndexBuffer.position(firstPostIndexBuffer.position() + indexInPage)__        buffers[0] = firstPostIndexBuffer___        return buffers__    };this,method,will,return,an,array,of,link,byte,buffer,representing,the,bytes,from,the,index,passed,through,the,end,of,this,buffer,the,buffers,will,be,duplicates,of,the,internal,buffers,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,param,from,the,index,to,slice,from,return,the,byte,buffers;public,byte,buffer,slice,buffers,from,long,from,if,from,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,from,from,else,if,from,capacity,return,long,index,with,offset,from,offset,int,page,index,page,index,index,with,offset,int,index,in,page,index,in,page,index,with,offset,byte,buffer,buffers,new,byte,buffer,pages,size,page,index,iterator,page,page,iterator,pages,descending,iterator,for,int,i,buffers,length,1,i,0,i,buffers,i,page,iterator,next,byte,buffer,duplicate,byte,buffer,first,post,index,buffer,page,iterator,next,byte,buffer,duplicate,first,post,index,buffer,position,first,post,index,buffer,position,index,in,page,buffers,0,first,post,index,buffer,return,buffers
InboundChannelBuffer -> public ByteBuffer[] sliceBuffersFrom(long from);1529341607;This method will return an array of {@link ByteBuffer} representing the bytes from the index passed_through the end of this buffer. The buffers will be duplicates of the internal buffers, so any_modifications to the markers {@link ByteBuffer#position()}, {@link ByteBuffer#limit()}, etc will not_modify the this class.__@param from the index to slice from_@return the byte buffers;public ByteBuffer[] sliceBuffersFrom(long from) {_        if (from > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters from [" + from + "]")__        } else if (from == capacity) {_            return EMPTY_BYTE_BUFFER_ARRAY__        }_        long indexWithOffset = from + offset___        int pageIndex = pageIndex(indexWithOffset)__        int indexInPage = indexInPage(indexWithOffset)___        ByteBuffer[] buffers = new ByteBuffer[pages.size() - pageIndex]__        Iterator<Page> pageIterator = pages.descendingIterator()__        for (int i = buffers.length - 1_ i > 0_ --i) {_            buffers[i] = pageIterator.next().byteBuffer.duplicate()__        }_        ByteBuffer firstPostIndexBuffer = pageIterator.next().byteBuffer.duplicate()__        firstPostIndexBuffer.position(firstPostIndexBuffer.position() + indexInPage)__        buffers[0] = firstPostIndexBuffer___        return buffers__    };this,method,will,return,an,array,of,link,byte,buffer,representing,the,bytes,from,the,index,passed,through,the,end,of,this,buffer,the,buffers,will,be,duplicates,of,the,internal,buffers,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,param,from,the,index,to,slice,from,return,the,byte,buffers;public,byte,buffer,slice,buffers,from,long,from,if,from,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,from,from,else,if,from,capacity,return,long,index,with,offset,from,offset,int,page,index,page,index,index,with,offset,int,index,in,page,index,in,page,index,with,offset,byte,buffer,buffers,new,byte,buffer,pages,size,page,index,iterator,page,page,iterator,pages,descending,iterator,for,int,i,buffers,length,1,i,0,i,buffers,i,page,iterator,next,byte,buffer,duplicate,byte,buffer,first,post,index,buffer,page,iterator,next,byte,buffer,duplicate,first,post,index,buffer,position,first,post,index,buffer,position,index,in,page,buffers,0,first,post,index,buffer,return,buffers
InboundChannelBuffer -> public ByteBuffer[] sliceBuffersFrom(long from);1529433467;This method will return an array of {@link ByteBuffer} representing the bytes from the index passed_through the end of this buffer. The buffers will be duplicates of the internal buffers, so any_modifications to the markers {@link ByteBuffer#position()}, {@link ByteBuffer#limit()}, etc will not_modify the this class.__@param from the index to slice from_@return the byte buffers;public ByteBuffer[] sliceBuffersFrom(long from) {_        if (from > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters from [" + from + "]")__        } else if (from == capacity) {_            return EMPTY_BYTE_BUFFER_ARRAY__        }_        long indexWithOffset = from + offset___        int pageIndex = pageIndex(indexWithOffset)__        int indexInPage = indexInPage(indexWithOffset)___        ByteBuffer[] buffers = new ByteBuffer[pages.size() - pageIndex]__        Iterator<Page> pageIterator = pages.descendingIterator()__        for (int i = buffers.length - 1_ i > 0_ --i) {_            buffers[i] = pageIterator.next().byteBuffer.duplicate()__        }_        ByteBuffer firstPostIndexBuffer = pageIterator.next().byteBuffer.duplicate()__        firstPostIndexBuffer.position(firstPostIndexBuffer.position() + indexInPage)__        buffers[0] = firstPostIndexBuffer___        return buffers__    };this,method,will,return,an,array,of,link,byte,buffer,representing,the,bytes,from,the,index,passed,through,the,end,of,this,buffer,the,buffers,will,be,duplicates,of,the,internal,buffers,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,param,from,the,index,to,slice,from,return,the,byte,buffers;public,byte,buffer,slice,buffers,from,long,from,if,from,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,from,from,else,if,from,capacity,return,long,index,with,offset,from,offset,int,page,index,page,index,index,with,offset,int,index,in,page,index,in,page,index,with,offset,byte,buffer,buffers,new,byte,buffer,pages,size,page,index,iterator,page,page,iterator,pages,descending,iterator,for,int,i,buffers,length,1,i,0,i,buffers,i,page,iterator,next,byte,buffer,duplicate,byte,buffer,first,post,index,buffer,page,iterator,next,byte,buffer,duplicate,first,post,index,buffer,position,first,post,index,buffer,position,index,in,page,buffers,0,first,post,index,buffer,return,buffers
InboundChannelBuffer -> public ByteBuffer[] sliceBuffersTo(long to);1528706846;This method will return an array of {@link ByteBuffer} representing the bytes from the beginning of_this buffer up through the index argument that was passed. The buffers will be duplicates of the_internal buffers, so any modifications to the markers {@link ByteBuffer#position()},_{@link ByteBuffer#limit()}, etc will not modify the this class.__@param to the index to slice up to_@return the byte buffers;public ByteBuffer[] sliceBuffersTo(long to) {_        if (to > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters to [" + to + "]")__        } else if (to == 0) {_            return EMPTY_BYTE_BUFFER_ARRAY__        }_        long indexWithOffset = to + offset__        int pageCount = pageIndex(indexWithOffset)__        int finalLimit = indexInPage(indexWithOffset)__        if (finalLimit != 0) {_            pageCount += 1__        }__        ByteBuffer[] buffers = new ByteBuffer[pageCount]__        Iterator<Page> pageIterator = pages.iterator()__        ByteBuffer firstBuffer = pageIterator.next().byteBuffer.duplicate()__        firstBuffer.position(firstBuffer.position() + offset)__        buffers[0] = firstBuffer__        for (int i = 1_ i < buffers.length_ i++) {_            buffers[i] = pageIterator.next().byteBuffer.duplicate()__        }_        if (finalLimit != 0) {_            buffers[buffers.length - 1].limit(finalLimit)__        }__        return buffers__    };this,method,will,return,an,array,of,link,byte,buffer,representing,the,bytes,from,the,beginning,of,this,buffer,up,through,the,index,argument,that,was,passed,the,buffers,will,be,duplicates,of,the,internal,buffers,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,param,to,the,index,to,slice,up,to,return,the,byte,buffers;public,byte,buffer,slice,buffers,to,long,to,if,to,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,to,to,else,if,to,0,return,long,index,with,offset,to,offset,int,page,count,page,index,index,with,offset,int,final,limit,index,in,page,index,with,offset,if,final,limit,0,page,count,1,byte,buffer,buffers,new,byte,buffer,page,count,iterator,page,page,iterator,pages,iterator,byte,buffer,first,buffer,page,iterator,next,byte,buffer,duplicate,first,buffer,position,first,buffer,position,offset,buffers,0,first,buffer,for,int,i,1,i,buffers,length,i,buffers,i,page,iterator,next,byte,buffer,duplicate,if,final,limit,0,buffers,buffers,length,1,limit,final,limit,return,buffers
InboundChannelBuffer -> public ByteBuffer[] sliceBuffersTo(long to);1529341607;This method will return an array of {@link ByteBuffer} representing the bytes from the beginning of_this buffer up through the index argument that was passed. The buffers will be duplicates of the_internal buffers, so any modifications to the markers {@link ByteBuffer#position()},_{@link ByteBuffer#limit()}, etc will not modify the this class.__@param to the index to slice up to_@return the byte buffers;public ByteBuffer[] sliceBuffersTo(long to) {_        if (to > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters to [" + to + "]")__        } else if (to == 0) {_            return EMPTY_BYTE_BUFFER_ARRAY__        }_        long indexWithOffset = to + offset__        int pageCount = pageIndex(indexWithOffset)__        int finalLimit = indexInPage(indexWithOffset)__        if (finalLimit != 0) {_            pageCount += 1__        }__        ByteBuffer[] buffers = new ByteBuffer[pageCount]__        Iterator<Page> pageIterator = pages.iterator()__        ByteBuffer firstBuffer = pageIterator.next().byteBuffer.duplicate()__        firstBuffer.position(firstBuffer.position() + offset)__        buffers[0] = firstBuffer__        for (int i = 1_ i < buffers.length_ i++) {_            buffers[i] = pageIterator.next().byteBuffer.duplicate()__        }_        if (finalLimit != 0) {_            buffers[buffers.length - 1].limit(finalLimit)__        }__        return buffers__    };this,method,will,return,an,array,of,link,byte,buffer,representing,the,bytes,from,the,beginning,of,this,buffer,up,through,the,index,argument,that,was,passed,the,buffers,will,be,duplicates,of,the,internal,buffers,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,param,to,the,index,to,slice,up,to,return,the,byte,buffers;public,byte,buffer,slice,buffers,to,long,to,if,to,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,to,to,else,if,to,0,return,long,index,with,offset,to,offset,int,page,count,page,index,index,with,offset,int,final,limit,index,in,page,index,with,offset,if,final,limit,0,page,count,1,byte,buffer,buffers,new,byte,buffer,page,count,iterator,page,page,iterator,pages,iterator,byte,buffer,first,buffer,page,iterator,next,byte,buffer,duplicate,first,buffer,position,first,buffer,position,offset,buffers,0,first,buffer,for,int,i,1,i,buffers,length,i,buffers,i,page,iterator,next,byte,buffer,duplicate,if,final,limit,0,buffers,buffers,length,1,limit,final,limit,return,buffers
InboundChannelBuffer -> public ByteBuffer[] sliceBuffersTo(long to);1529433467;This method will return an array of {@link ByteBuffer} representing the bytes from the beginning of_this buffer up through the index argument that was passed. The buffers will be duplicates of the_internal buffers, so any modifications to the markers {@link ByteBuffer#position()},_{@link ByteBuffer#limit()}, etc will not modify the this class.__@param to the index to slice up to_@return the byte buffers;public ByteBuffer[] sliceBuffersTo(long to) {_        if (to > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters to [" + to + "]")__        } else if (to == 0) {_            return EMPTY_BYTE_BUFFER_ARRAY__        }_        long indexWithOffset = to + offset__        int pageCount = pageIndex(indexWithOffset)__        int finalLimit = indexInPage(indexWithOffset)__        if (finalLimit != 0) {_            pageCount += 1__        }__        ByteBuffer[] buffers = new ByteBuffer[pageCount]__        Iterator<Page> pageIterator = pages.iterator()__        ByteBuffer firstBuffer = pageIterator.next().byteBuffer.duplicate()__        firstBuffer.position(firstBuffer.position() + offset)__        buffers[0] = firstBuffer__        for (int i = 1_ i < buffers.length_ i++) {_            buffers[i] = pageIterator.next().byteBuffer.duplicate()__        }_        if (finalLimit != 0) {_            buffers[buffers.length - 1].limit(finalLimit)__        }__        return buffers__    };this,method,will,return,an,array,of,link,byte,buffer,representing,the,bytes,from,the,beginning,of,this,buffer,up,through,the,index,argument,that,was,passed,the,buffers,will,be,duplicates,of,the,internal,buffers,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,param,to,the,index,to,slice,up,to,return,the,byte,buffers;public,byte,buffer,slice,buffers,to,long,to,if,to,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,to,to,else,if,to,0,return,long,index,with,offset,to,offset,int,page,count,page,index,index,with,offset,int,final,limit,index,in,page,index,with,offset,if,final,limit,0,page,count,1,byte,buffer,buffers,new,byte,buffer,page,count,iterator,page,page,iterator,pages,iterator,byte,buffer,first,buffer,page,iterator,next,byte,buffer,duplicate,first,buffer,position,first,buffer,position,offset,buffers,0,first,buffer,for,int,i,1,i,buffers,length,i,buffers,i,page,iterator,next,byte,buffer,duplicate,if,final,limit,0,buffers,buffers,length,1,limit,final,limit,return,buffers
InboundChannelBuffer -> public Page[] sliceAndRetainPagesTo(long to);1529341607;This method will return an array of {@link Page} representing the bytes from the beginning of_this buffer up through the index argument that was passed. The pages and buffers will be duplicates of_the internal components, so any modifications to the markers {@link ByteBuffer#position()},_{@link ByteBuffer#limit()}, etc will not modify the this class. Additionally, this will internally_retain the underlying pages, so the pages returned by this method must be closed.__@param to the index to slice up to_@return the pages;public Page[] sliceAndRetainPagesTo(long to) {_        if (to > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters to [" + to + "]")__        } else if (to == 0) {_            return EMPTY_BYTE_PAGE_ARRAY__        }_        long indexWithOffset = to + offset__        int pageCount = pageIndex(indexWithOffset)__        int finalLimit = indexInPage(indexWithOffset)__        if (finalLimit != 0) {_            pageCount += 1__        }__        Page[] pages = new Page[pageCount]__        Iterator<Page> pageIterator = this.pages.iterator()__        Page firstPage = pageIterator.next().duplicate()__        ByteBuffer firstBuffer = firstPage.byteBuffer__        firstBuffer.position(firstBuffer.position() + offset)__        pages[0] = firstPage__        for (int i = 1_ i < pages.length_ i++) {_            pages[i] = pageIterator.next().duplicate()__        }_        if (finalLimit != 0) {_            pages[pages.length - 1].byteBuffer.limit(finalLimit)__        }__        return pages__    };this,method,will,return,an,array,of,link,page,representing,the,bytes,from,the,beginning,of,this,buffer,up,through,the,index,argument,that,was,passed,the,pages,and,buffers,will,be,duplicates,of,the,internal,components,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,additionally,this,will,internally,retain,the,underlying,pages,so,the,pages,returned,by,this,method,must,be,closed,param,to,the,index,to,slice,up,to,return,the,pages;public,page,slice,and,retain,pages,to,long,to,if,to,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,to,to,else,if,to,0,return,long,index,with,offset,to,offset,int,page,count,page,index,index,with,offset,int,final,limit,index,in,page,index,with,offset,if,final,limit,0,page,count,1,page,pages,new,page,page,count,iterator,page,page,iterator,this,pages,iterator,page,first,page,page,iterator,next,duplicate,byte,buffer,first,buffer,first,page,byte,buffer,first,buffer,position,first,buffer,position,offset,pages,0,first,page,for,int,i,1,i,pages,length,i,pages,i,page,iterator,next,duplicate,if,final,limit,0,pages,pages,length,1,byte,buffer,limit,final,limit,return,pages
InboundChannelBuffer -> public Page[] sliceAndRetainPagesTo(long to);1529433467;This method will return an array of {@link Page} representing the bytes from the beginning of_this buffer up through the index argument that was passed. The pages and buffers will be duplicates of_the internal components, so any modifications to the markers {@link ByteBuffer#position()},_{@link ByteBuffer#limit()}, etc will not modify the this class. Additionally, this will internally_retain the underlying pages, so the pages returned by this method must be closed.__@param to the index to slice up to_@return the pages;public Page[] sliceAndRetainPagesTo(long to) {_        if (to > capacity) {_            throw new IndexOutOfBoundsException("can't slice a channel buffer with capacity [" + capacity +_                "], with slice parameters to [" + to + "]")__        } else if (to == 0) {_            return EMPTY_BYTE_PAGE_ARRAY__        }_        long indexWithOffset = to + offset__        int pageCount = pageIndex(indexWithOffset)__        int finalLimit = indexInPage(indexWithOffset)__        if (finalLimit != 0) {_            pageCount += 1__        }__        Page[] pages = new Page[pageCount]__        Iterator<Page> pageIterator = this.pages.iterator()__        Page firstPage = pageIterator.next().duplicate()__        ByteBuffer firstBuffer = firstPage.byteBuffer__        firstBuffer.position(firstBuffer.position() + offset)__        pages[0] = firstPage__        for (int i = 1_ i < pages.length_ i++) {_            pages[i] = pageIterator.next().duplicate()__        }_        if (finalLimit != 0) {_            pages[pages.length - 1].byteBuffer.limit(finalLimit)__        }__        return pages__    };this,method,will,return,an,array,of,link,page,representing,the,bytes,from,the,beginning,of,this,buffer,up,through,the,index,argument,that,was,passed,the,pages,and,buffers,will,be,duplicates,of,the,internal,components,so,any,modifications,to,the,markers,link,byte,buffer,position,link,byte,buffer,limit,etc,will,not,modify,the,this,class,additionally,this,will,internally,retain,the,underlying,pages,so,the,pages,returned,by,this,method,must,be,closed,param,to,the,index,to,slice,up,to,return,the,pages;public,page,slice,and,retain,pages,to,long,to,if,to,capacity,throw,new,index,out,of,bounds,exception,can,t,slice,a,channel,buffer,with,capacity,capacity,with,slice,parameters,to,to,else,if,to,0,return,long,index,with,offset,to,offset,int,page,count,page,index,index,with,offset,int,final,limit,index,in,page,index,with,offset,if,final,limit,0,page,count,1,page,pages,new,page,page,count,iterator,page,page,iterator,this,pages,iterator,page,first,page,page,iterator,next,duplicate,byte,buffer,first,buffer,first,page,byte,buffer,first,buffer,position,first,buffer,position,offset,pages,0,first,page,for,int,i,1,i,pages,length,i,pages,i,page,iterator,next,duplicate,if,final,limit,0,pages,pages,length,1,byte,buffer,limit,final,limit,return,pages
