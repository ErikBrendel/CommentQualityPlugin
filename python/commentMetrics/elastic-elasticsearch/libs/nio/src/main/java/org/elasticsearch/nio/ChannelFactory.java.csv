commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;public Socket openNioChannel(InetSocketAddress remoteAddress, Supplier<NioSelector> supplier) throws IOException {     SocketChannel rawChannel = rawChannelFactory.openNioChannel(remoteAddress).     NioSelector selector = supplier.get().     Socket channel = internalCreateChannel(selector, rawChannel).     scheduleChannel(channel, selector).     return channel. }
false;public;2;12;;public Socket acceptNioChannel(ServerChannelContext serverContext, Supplier<NioSelector> supplier) throws IOException {     SocketChannel rawChannel = rawChannelFactory.acceptNioChannel(serverContext).     // Null is returned if there are no pending sockets to accept     if (rawChannel == null) {         return null.     } else {         NioSelector selector = supplier.get().         Socket channel = internalCreateChannel(selector, rawChannel).         scheduleChannel(channel, selector).         return channel.     } }
false;public;2;7;;public ServerSocket openNioServerSocketChannel(InetSocketAddress address, Supplier<NioSelector> supplier) throws IOException {     ServerSocketChannel rawChannel = rawChannelFactory.openNioServerSocketChannel(address).     NioSelector selector = supplier.get().     ServerSocket serverChannel = internalCreateServerChannel(selector, rawChannel).     scheduleServerChannel(serverChannel, selector).     return serverChannel. }
true;public,abstract;2;1;/**  * This method should return a new {@link NioSocketChannel} implementation. When this method has  * returned, the channel should be fully created and setup. Read and write contexts and the channel  * exception handler should have been set.  *  * @param selector the channel will be registered with  * @param channel the raw channel  * @return the channel  * @throws IOException related to the creation of the channel  */ ;/**  * This method should return a new {@link NioSocketChannel} implementation. When this method has  * returned, the channel should be fully created and setup. Read and write contexts and the channel  * exception handler should have been set.  *  * @param selector the channel will be registered with  * @param channel the raw channel  * @return the channel  * @throws IOException related to the creation of the channel  */ public abstract Socket createChannel(NioSelector selector, SocketChannel channel) throws IOException.
true;public,abstract;2;1;/**  * This method should return a new {@link NioServerSocketChannel} implementation. When this method has  * returned, the channel should be fully created and setup.  *  * @param selector the channel will be registered with  * @param channel the raw channel  * @return the server channel  * @throws IOException related to the creation of the channel  */ ;/**  * This method should return a new {@link NioServerSocketChannel} implementation. When this method has  * returned, the channel should be fully created and setup.  *  * @param selector the channel will be registered with  * @param channel the raw channel  * @return the server channel  * @throws IOException related to the creation of the channel  */ public abstract ServerSocket createServerChannel(NioSelector selector, ServerSocketChannel channel) throws IOException.
false;private;2;15;;private Socket internalCreateChannel(NioSelector selector, SocketChannel rawChannel) throws IOException {     try {         Socket channel = createChannel(selector, rawChannel).         assert channel.getContext() != null : "channel context should have been set on channel".         return channel.     } catch (UncheckedIOException e) {         // This can happen if getRemoteAddress throws IOException.         IOException cause = e.getCause().         closeRawChannel(rawChannel, cause).         throw cause.     } catch (Exception e) {         closeRawChannel(rawChannel, e).         throw e.     } }
false;private;2;8;;private ServerSocket internalCreateServerChannel(NioSelector selector, ServerSocketChannel rawChannel) throws IOException {     try {         return createServerChannel(selector, rawChannel).     } catch (Exception e) {         closeRawChannel(rawChannel, e).         throw e.     } }
false;private;2;8;;private void scheduleChannel(Socket channel, NioSelector selector) {     try {         selector.scheduleForRegistration(channel).     } catch (IllegalStateException e) {         closeRawChannel(channel.getRawChannel(), e).         throw e.     } }
false;private;2;8;;private void scheduleServerChannel(ServerSocket channel, NioSelector selector) {     try {         selector.scheduleForRegistration(channel).     } catch (IllegalStateException e) {         closeRawChannel(channel.getRawChannel(), e).         throw e.     } }
false;private,static;2;7;;private static void closeRawChannel(Closeable c, Exception e) {     try {         c.close().     } catch (IOException closeException) {         e.addSuppressed(closeException).     } }
false;;1;11;;SocketChannel openNioChannel(InetSocketAddress remoteAddress) throws IOException {     SocketChannel socketChannel = SocketChannel.open().     try {         configureSocketChannel(socketChannel).         connect(socketChannel, remoteAddress).     } catch (IOException e) {         closeRawChannel(socketChannel, e).         throw e.     }     return socketChannel. }
false;;1;14;;SocketChannel acceptNioChannel(ServerChannelContext serverContext) throws IOException {     ServerSocketChannel rawChannel = serverContext.getChannel().getRawChannel().     SocketChannel socketChannel = accept(rawChannel).     if (socketChannel == null) {         return null.     }     try {         configureSocketChannel(socketChannel).     } catch (IOException e) {         closeRawChannel(socketChannel, e).         throw e.     }     return socketChannel. }
false;;1;13;;ServerSocketChannel openNioServerSocketChannel(InetSocketAddress address) throws IOException {     ServerSocketChannel serverSocketChannel = ServerSocketChannel.open().     serverSocketChannel.configureBlocking(false).     java.net.ServerSocket socket = serverSocketChannel.socket().     try {         socket.setReuseAddress(tcpReusedAddress).         serverSocketChannel.bind(address).     } catch (IOException e) {         closeRawChannel(serverSocketChannel, e).         throw e.     }     return serverSocketChannel. }
false;private;1;13;;private void configureSocketChannel(SocketChannel channel) throws IOException {     channel.configureBlocking(false).     java.net.Socket socket = channel.socket().     socket.setTcpNoDelay(tcpNoDelay).     socket.setKeepAlive(tcpKeepAlive).     socket.setReuseAddress(tcpReusedAddress).     if (tcpSendBufferSize > 0) {         socket.setSendBufferSize(tcpSendBufferSize).     }     if (tcpReceiveBufferSize > 0) {         socket.setSendBufferSize(tcpReceiveBufferSize).     } }
false;public,static;1;7;;public static SocketChannel accept(ServerSocketChannel serverSocketChannel) throws IOException {     try {         return AccessController.doPrivileged((PrivilegedExceptionAction<SocketChannel>) serverSocketChannel::accept).     } catch (PrivilegedActionException e) {         throw (IOException) e.getCause().     } }
false;private,static;2;7;;private static void connect(SocketChannel socketChannel, InetSocketAddress remoteAddress) throws IOException {     try {         AccessController.doPrivileged((PrivilegedExceptionAction<Boolean>) () -> socketChannel.connect(remoteAddress)).     } catch (PrivilegedActionException e) {         throw (IOException) e.getCause().     } }
