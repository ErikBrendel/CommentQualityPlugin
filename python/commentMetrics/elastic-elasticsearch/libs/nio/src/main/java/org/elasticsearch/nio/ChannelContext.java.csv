commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected void register() throws IOException {     doSelectorRegister(). }
true;;0;3;// Package private for testing ;// Package private for testing void doSelectorRegister() throws IOException {     setSelectionKey(rawChannel.register(getSelector().rawSelector(), 0)). }
false;;0;3;;SelectionKey getSelectionKey() {     return selectionKey. }
true;protected;1;3;// Protected for tests ;// Protected for tests protected void setSelectionKey(SelectionKey selectionKey) {     this.selectionKey = selectionKey. }
true;public;0;11;/**  * This method cleans up any context resources that need to be released when a channel is closed. It  * should only be called by the selector thread.  *  * @throws IOException during channel / context close  */ ;/**  * This method cleans up any context resources that need to be released when a channel is closed. It  * should only be called by the selector thread.  *  * @throws IOException during channel / context close  */ public void closeFromSelector() throws IOException {     if (isOpen()) {         try {             rawChannel.close().             closeContext.complete(null).         } catch (Exception e) {             closeContext.completeExceptionally(e).             throw e.         }     } }
true;public;1;3;/**  * Add a listener that will be called when the channel is closed.  *  * @param listener to be called  */ ;/**  * Add a listener that will be called when the channel is closed.  *  * @param listener to be called  */ public void addCloseListener(BiConsumer<Void, Exception> listener) {     closeContext.addListener(listener). }
false;public;0;3;;public boolean isOpen() {     return closeContext.isDone() == false. }
false;;1;3;;void handleException(Exception e) {     exceptionHandler.accept(e). }
true;public,abstract;0;1;/**  * Schedules a channel to be closed by the selector event loop with which it is registered.  *  * If the channel is open and the state can be transitioned to closed, the close operation will  * be scheduled with the event loop.  *  * Depending on the underlying protocol of the channel, a close operation might simply close the socket  * channel or may involve reading and writing messages.  */ ;/**  * Schedules a channel to be closed by the selector event loop with which it is registered.  *  * If the channel is open and the state can be transitioned to closed, the close operation will  * be scheduled with the event loop.  *  * Depending on the underlying protocol of the channel, a close operation might simply close the socket  * channel or may involve reading and writing messages.  */ public abstract void closeChannel().
false;public,abstract;0;1;;public abstract NioSelector getSelector().
false;public,abstract;0;1;;public abstract NioChannel getChannel().
