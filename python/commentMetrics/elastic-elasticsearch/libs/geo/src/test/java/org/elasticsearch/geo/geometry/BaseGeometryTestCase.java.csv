commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Writeable.Reader<T> instanceReader() {     throw new IllegalStateException("shouldn't be called in this test"). }
false;protected;2;10;;@SuppressWarnings("unchecked") @Override protected T copyInstance(T instance, Version version) throws IOException {     String text = WellKnownText.toWKT(instance).     try {         return (T) WellKnownText.fromWKT(text).     } catch (ParseException e) {         throw new ElasticsearchException(e).     } }
false;public;0;3;;public void testVisitor() {     testVisitor(createTestInstance()). }
false;private;2;6;;private Object verify(Geometry geometry, String expectedClass) {     assertFalse("Visitor should be called only once", called.getAndSet(true)).     assertSame(geom, geometry).     assertEquals(geometry.getClass().getName(), "org.elasticsearch.geo.geometry." + expectedClass).     return "result". }
false;public;1;4;;@Override public Object visit(Circle circle) {     return verify(circle, "Circle"). }
false;public;1;3;;@Override public Object visit(GeometryCollection<?> collection) {     return verify(collection, "GeometryCollection"). }
false;public;1;4;;@Override public Object visit(Line line) {     return verify(line, "Line"). }
false;public;1;4;;@Override public Object visit(LinearRing ring) {     return verify(ring, "LinearRing"). }
false;public;1;4;;@Override public Object visit(MultiLine multiLine) {     return verify(multiLine, "MultiLine"). }
false;public;1;4;;@Override public Object visit(MultiPoint multiPoint) {     return verify(multiPoint, "MultiPoint"). }
false;public;1;4;;@Override public Object visit(MultiPolygon multiPolygon) {     return verify(multiPolygon, "MultiPolygon"). }
false;public;1;4;;@Override public Object visit(Point point) {     return verify(point, "Point"). }
false;public;1;4;;@Override public Object visit(Polygon polygon) {     return verify(polygon, "Polygon"). }
false;public;1;4;;@Override public Object visit(Rectangle rectangle) {     return verify(rectangle, "Rectangle"). }
false;public,static;1;63;;public static void testVisitor(Geometry geom) {     AtomicBoolean called = new AtomicBoolean(false).     Object result = geom.visit(new GeometryVisitor<Object>() {          private Object verify(Geometry geometry, String expectedClass) {             assertFalse("Visitor should be called only once", called.getAndSet(true)).             assertSame(geom, geometry).             assertEquals(geometry.getClass().getName(), "org.elasticsearch.geo.geometry." + expectedClass).             return "result".         }          @Override         public Object visit(Circle circle) {             return verify(circle, "Circle").         }          @Override         public Object visit(GeometryCollection<?> collection) {             return verify(collection, "GeometryCollection").         }          @Override         public Object visit(Line line) {             return verify(line, "Line").         }          @Override         public Object visit(LinearRing ring) {             return verify(ring, "LinearRing").         }          @Override         public Object visit(MultiLine multiLine) {             return verify(multiLine, "MultiLine").         }          @Override         public Object visit(MultiPoint multiPoint) {             return verify(multiPoint, "MultiPoint").         }          @Override         public Object visit(MultiPolygon multiPolygon) {             return verify(multiPolygon, "MultiPolygon").         }          @Override         public Object visit(Point point) {             return verify(point, "Point").         }          @Override         public Object visit(Polygon polygon) {             return verify(polygon, "Polygon").         }          @Override         public Object visit(Rectangle rectangle) {             return verify(rectangle, "Rectangle").         }     }).     assertTrue("visitor wasn't called", called.get()).     assertEquals("result", result). }
false;public,static;0;3;;public static double randomLat() {     return randomDoubleBetween(-90, 90, true). }
false;public,static;0;3;;public static double randomLon() {     return randomDoubleBetween(-180, 180, true). }
false;public,static;0;3;;public static Circle randomCircle() {     return new Circle(randomDoubleBetween(-90, 90, true), randomDoubleBetween(-180, 180, true), randomDoubleBetween(0, 100, false)). }
false;public,static;0;10;;public static Line randomLine() {     int size = randomIntBetween(2, 10).     double[] lats = new double[size].     double[] lons = new double[size].     for (int i = 0. i < size. i++) {         lats[i] = randomLat().         lons[i] = randomLon().     }     return new Line(lats, lons). }
false;public,static;0;3;;public static Point randomPoint() {     return new Point(randomLat(), randomLon()). }
false;public,static;0;12;;public static LinearRing randomLinearRing() {     int size = randomIntBetween(3, 10).     double[] lats = new double[size + 1].     double[] lons = new double[size + 1].     for (int i = 0. i < size. i++) {         lats[i] = randomLat().         lons[i] = randomLon().     }     lats[size] = lats[0].     lons[size] = lons[0].     return new LinearRing(lats, lons). }
false;public,static;0;12;;public static Polygon randomPolygon() {     int size = randomIntBetween(0, 10).     List<LinearRing> holes = new ArrayList<>().     for (int i = 0. i < size. i++) {         holes.add(randomLinearRing()).     }     if (holes.size() > 0) {         return new Polygon(randomLinearRing(), holes).     } else {         return new Polygon(randomLinearRing()).     } }
false;public,static;0;7;;public static Rectangle randomRectangle() {     double lat1 = randomLat().     double lat2 = randomLat().     double minLon = randomLon().     double maxLon = randomLon().     return new Rectangle(Math.min(lat1, lat2), Math.max(lat1, lat2), minLon, maxLon). }
false;public,static;0;3;;public static GeometryCollection<Geometry> randomGeometryCollection() {     return randomGeometryCollection(0). }
false;private,static;1;16;;private static GeometryCollection<Geometry> randomGeometryCollection(int level) {     int size = randomIntBetween(1, 10).     List<Geometry> shapes = new ArrayList<>().     for (int i = 0. i < size. i++) {         @SuppressWarnings("unchecked")         Supplier<Geometry> geometry = randomFrom(BaseGeometryTestCase::randomCircle, BaseGeometryTestCase::randomLine, BaseGeometryTestCase::randomPoint, BaseGeometryTestCase::randomPolygon, BaseGeometryTestCase::randomRectangle, // don't build too deep         level < 3 ? () -> randomGeometryCollection(level + 1) : BaseGeometryTestCase::randomPoint).         shapes.add(geometry.get()).     }     return new GeometryCollection<>(shapes). }
