commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Creates a new security manager with a standard set of test packages being the only packages that can exit or halt the virtual  * machine. The packages that can exit are:  * <ul>  *    <li><code>org.apache.maven.surefire.booter.</code></li>  *    <li><code>com.carrotsearch.ant.tasks.junit4.</code></li>  *    <li><code>org.eclipse.internal.junit.runner.</code></li>  *    <li><code>com.intellij.rt.execution.junit.</code></li>  * </ul>  *  * @return an instance of SecureSM where test packages can halt or exit the virtual machine  */ ;/**  * Creates a new security manager with a standard set of test packages being the only packages that can exit or halt the virtual  * machine. The packages that can exit are:  * <ul>  *    <li><code>org.apache.maven.surefire.booter.</code></li>  *    <li><code>com.carrotsearch.ant.tasks.junit4.</code></li>  *    <li><code>org.eclipse.internal.junit.runner.</code></li>  *    <li><code>com.intellij.rt.execution.junit.</code></li>  * </ul>  *  * @return an instance of SecureSM where test packages can halt or exit the virtual machine  */ public static SecureSM createTestSecureSM() {     return new SecureSM(TEST_RUNNER_PACKAGES). }
false;public;0;10;;@Override public Boolean run() {     try {         String v = System.getProperty("java.security.debug").         // simple check that they are trying to debug         return v != null && v.length() > 0.     } catch (SecurityException e) {         return false.     } }
false;public;1;14;;@Override @SuppressForbidden(reason = "java.security.debug messages go to standard error") public void checkAccess(Thread t) {     try {         checkThreadAccess(t).     } catch (SecurityException e) {         if (DEBUG) {             System.err.println("access: caller thread=" + Thread.currentThread()).             System.err.println("access: target thread=" + t).             debugThreadGroups(Thread.currentThread().getThreadGroup(), t.getThreadGroup()).         }         throw e.     } }
false;public;1;13;;@Override @SuppressForbidden(reason = "java.security.debug messages go to standard error") public void checkAccess(ThreadGroup g) {     try {         checkThreadGroupAccess(g).     } catch (SecurityException e) {         if (DEBUG) {             System.err.println("access: caller thread=" + Thread.currentThread()).             debugThreadGroups(Thread.currentThread().getThreadGroup(), g).         }         throw e.     } }
false;private;2;5;;@SuppressForbidden(reason = "java.security.debug messages go to standard error") private void debugThreadGroups(final ThreadGroup caller, final ThreadGroup target) {     System.err.println("access: caller group=" + caller).     System.err.println("access: target group=" + target). }
false;protected;1;16;;protected void checkThreadAccess(Thread t) {     Objects.requireNonNull(t).     // first, check if we can modify threads at all.     checkPermission(MODIFY_THREAD_PERMISSION).     // check the threadgroup, if its our thread group or an ancestor, its fine.     final ThreadGroup source = Thread.currentThread().getThreadGroup().     final ThreadGroup target = t.getThreadGroup().     if (target == null) {         // its a dead thread, do nothing.         return.     } else if (source.parentOf(target) == false) {         checkPermission(MODIFY_ARBITRARY_THREAD_PERMISSION).     } }
false;protected;1;16;;protected void checkThreadGroupAccess(ThreadGroup g) {     Objects.requireNonNull(g).     // first, check if we can modify thread groups at all.     checkPermission(MODIFY_THREADGROUP_PERMISSION).     // check the threadgroup, if its our thread group or an ancestor, its fine.     final ThreadGroup source = Thread.currentThread().getThreadGroup().     final ThreadGroup target = g.     if (source == null) {         // we are a dead thread, do nothing         return.     } else if (source.parentOf(target) == false) {         checkPermission(MODIFY_ARBITRARY_THREADGROUP_PERMISSION).     } }
true;public;1;4;// exit permission logic ;// exit permission logic @Override public void checkExit(int status) {     innerCheckExit(status). }
false;public;0;34;;@Override public Void run() {     final String systemClassName = System.class.getName(), runtimeClassName = Runtime.class.getName().     String exitMethodHit = null.     for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {         final String className = se.getClassName(), methodName = se.getMethodName().         if (("exit".equals(methodName) || "halt".equals(methodName)) && (systemClassName.equals(className) || runtimeClassName.equals(className))) {             exitMethodHit = className + '#' + methodName + '(' + status + ')'.             continue.         }         if (exitMethodHit != null) {             if (classesThatCanExit == null) {                 break.             }             if (classCanExit(className, classesThatCanExit)) {                 // this exit point is allowed, we return normally from closure:                 return null.             }             // anything else in stack trace is not allowed, break and throw SecurityException below:             break.         }     }     if (exitMethodHit == null) {         // should never happen, only if JVM hides stack trace - replace by generic:         exitMethodHit = "JVM exit method".     }     throw new SecurityException(exitMethodHit + " calls are not allowed"). }
true;protected;1;41;/**  * The "Uwe Schindler" algorithm.  *  * @param status the exit status  */ ;/**  * The "Uwe Schindler" algorithm.  *  * @param status the exit status  */ protected void innerCheckExit(final int status) {     AccessController.doPrivileged(new PrivilegedAction<Void>() {          @Override         public Void run() {             final String systemClassName = System.class.getName(), runtimeClassName = Runtime.class.getName().             String exitMethodHit = null.             for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {                 final String className = se.getClassName(), methodName = se.getMethodName().                 if (("exit".equals(methodName) || "halt".equals(methodName)) && (systemClassName.equals(className) || runtimeClassName.equals(className))) {                     exitMethodHit = className + '#' + methodName + '(' + status + ')'.                     continue.                 }                 if (exitMethodHit != null) {                     if (classesThatCanExit == null) {                         break.                     }                     if (classCanExit(className, classesThatCanExit)) {                         // this exit point is allowed, we return normally from closure:                         return null.                     }                     // anything else in stack trace is not allowed, break and throw SecurityException below:                     break.                 }             }             if (exitMethodHit == null) {                 // should never happen, only if JVM hides stack trace - replace by generic:                 exitMethodHit = "JVM exit method".             }             throw new SecurityException(exitMethodHit + " calls are not allowed").         }     }).     // we passed the stack check, delegate to super, so default policy can still deny permission:     super.checkExit(status). }
false;static;2;8;;static boolean classCanExit(final String className, final String[] classesThatCanExit) {     for (final String classThatCanExit : classesThatCanExit) {         if (className.matches(classThatCanExit)) {             return true.         }     }     return false. }
