commented;modifiers;parameterAmount;loc;comment;code
true;public,final;2;39;/**  * Parses options for this command from args and executes it.  */ ;/**  * Parses options for this command from args and executes it.  */ public final int main(String[] args, Terminal terminal) throws Exception {     if (addShutdownHook()) {         shutdownHookThread = new Thread(() -> {             try {                 this.close().             } catch (final IOException e) {                 try (StringWriter sw = new StringWriter().                     PrintWriter pw = new PrintWriter(sw)) {                     e.printStackTrace(pw).                     terminal.println(sw.toString()).                 } catch (final IOException impossible) {                     // say that an exception here is impossible                     throw new AssertionError(impossible).                 }             }         }).         Runtime.getRuntime().addShutdownHook(shutdownHookThread).     }     beforeMain.run().     try {         mainWithoutErrorHandling(args, terminal).     } catch (OptionException e) {         printHelp(terminal).         terminal.println(Terminal.Verbosity.SILENT, "ERROR: " + e.getMessage()).         return ExitCodes.USAGE.     } catch (UserException e) {         if (e.exitCode == ExitCodes.USAGE) {             printHelp(terminal).         }         terminal.println(Terminal.Verbosity.SILENT, "ERROR: " + e.getMessage()).         return e.exitCode.     }     return ExitCodes.OK. }
true;;2;18;/**  * Executes the command, but all errors are thrown.  */ ;/**  * Executes the command, but all errors are thrown.  */ void mainWithoutErrorHandling(String[] args, Terminal terminal) throws Exception {     final OptionSet options = parser.parse(args).     if (options.has(helpOption)) {         printHelp(terminal).         return.     }     if (options.has(silentOption)) {         terminal.setVerbosity(Terminal.Verbosity.SILENT).     } else if (options.has(verboseOption)) {         terminal.setVerbosity(Terminal.Verbosity.VERBOSE).     } else {         terminal.setVerbosity(Terminal.Verbosity.NORMAL).     }     execute(terminal, options). }
true;private;1;6;/**  * Prints a help message for the command to the terminal.  */ ;/**  * Prints a help message for the command to the terminal.  */ private void printHelp(Terminal terminal) throws IOException {     terminal.println(description).     terminal.println("").     printAdditionalHelp(terminal).     parser.printHelpOn(terminal.getWriter()). }
true;protected;1;1;/**  * Prints additional help information, specific to the command  */ ;/**  * Prints additional help information, specific to the command  */ protected void printAdditionalHelp(Terminal terminal) { }
false;protected,static;1;4;;@SuppressForbidden(reason = "Allowed to exit explicitly from #main()") protected static void exit(int status) {     System.exit(status). }
true;protected,abstract;2;1;/**  * Executes this command.  *  * Any runtime user errors (like an input file that does not exist), should throw a {@link UserException}.  */ ;/**  * Executes this command.  *  * Any runtime user errors (like an input file that does not exist), should throw a {@link UserException}.  */ protected abstract void execute(Terminal terminal, OptionSet options) throws Exception.
true;protected;0;3;/**  * Return whether or not to install the shutdown hook to cleanup resources on exit. This method should only be overridden in test  * classes.  *  * @return whether or not to install the shutdown hook  */ ;/**  * Return whether or not to install the shutdown hook to cleanup resources on exit. This method should only be overridden in test  * classes.  *  * @return whether or not to install the shutdown hook  */ protected boolean addShutdownHook() {     return true. }
true;;0;3;/**  * Gets the shutdown hook thread if it exists *  */ ;/**  * Gets the shutdown hook thread if it exists *  */ Thread getShutdownHookThread() {     return shutdownHookThread. }
false;public;0;4;;@Override public void close() throws IOException { }
