commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Registers the current thread and interrupts the current thread  * if the takes too long for this thread to invoke {@link #unregister()}.  */ ;/**  * Registers the current thread and interrupts the current thread  * if the takes too long for this thread to invoke {@link #unregister()}.  */ void register().
true;;0;1;/**  * @return The maximum allowed time in milliseconds for a thread to invoke {@link #unregister()}  *         after {@link #register()} has been invoked before this ThreadWatchDog starts to interrupting that thread.  */ ;/**  * @return The maximum allowed time in milliseconds for a thread to invoke {@link #unregister()}  *         after {@link #register()} has been invoked before this ThreadWatchDog starts to interrupting that thread.  */ long maxExecutionTimeInMillis().
true;;0;1;/**  * Unregisters the current thread and prevents it from being interrupted.  */ ;/**  * Unregisters the current thread and prevents it from being interrupted.  */ void unregister().
true;static;4;6;/**  * Returns an implementation that checks for each fixed interval if there are threads that have invoked {@link #register()}  * and not {@link #unregister()} and have been in this state for longer than the specified max execution interval and  * then interrupts these threads.  *  * @param interval              The fixed interval to check if there are threads to interrupt  * @param maxExecutionTime      The time a thread has the execute an operation.  * @param relativeTimeSupplier  A supplier that returns relative time  * @param scheduler             A scheduler that is able to execute a command for each fixed interval  */ ;/**  * Returns an implementation that checks for each fixed interval if there are threads that have invoked {@link #register()}  * and not {@link #unregister()} and have been in this state for longer than the specified max execution interval and  * then interrupts these threads.  *  * @param interval              The fixed interval to check if there are threads to interrupt  * @param maxExecutionTime      The time a thread has the execute an operation.  * @param relativeTimeSupplier  A supplier that returns relative time  * @param scheduler             A scheduler that is able to execute a command for each fixed interval  */ static ThreadWatchdog newInstance(long interval, long maxExecutionTime, LongSupplier relativeTimeSupplier, BiConsumer<Long, Runnable> scheduler) {     return new Default(interval, maxExecutionTime, relativeTimeSupplier, scheduler). }
true;static;0;3;/**  * @return A noop implementation that does not interrupt threads and is useful for testing and pre-defined grok expressions.  */ ;/**  * @return A noop implementation that does not interrupt threads and is useful for testing and pre-defined grok expressions.  */ static ThreadWatchdog noop() {     return Noop.INSTANCE. }
false;public;0;3;;@Override public void register() { }
false;public;0;4;;@Override public long maxExecutionTimeInMillis() {     return Long.MAX_VALUE. }
false;public;0;3;;@Override public void unregister() { }
false;public;0;8;;public void register() {     registered.getAndIncrement().     Long previousValue = registry.put(Thread.currentThread(), relativeTimeSupplier.getAsLong()).     if (running.compareAndSet(false, true) == true) {         scheduler.accept(interval, this::interruptLongRunningExecutions).     }     assert previousValue == null. }
false;public;0;4;;@Override public long maxExecutionTimeInMillis() {     return maxExecutionTime. }
false;public;0;5;;public void unregister() {     Long previousValue = registry.remove(Thread.currentThread()).     registered.decrementAndGet().     assert previousValue != null. }
false;private;0;14;;private void interruptLongRunningExecutions() {     final long currentRelativeTime = relativeTimeSupplier.getAsLong().     for (Map.Entry<Thread, Long> entry : registry.entrySet()) {         if ((currentRelativeTime - entry.getValue()) > maxExecutionTime) {             entry.getKey().interrupt().         // not removing the entry here, this happens in the unregister() method.         }     }     if (registered.get() > 0) {         scheduler.accept(interval, this::interruptLongRunningExecutions).     } else {         running.set(false).     } }
