commented;modifiers;parameterAmount;loc;comment;code
false;public;0;38;;public void testInterrupt() throws Exception {     // to avoid a lingering thread when test has completed     AtomicBoolean run = new AtomicBoolean(true).     ThreadWatchdog watchdog = ThreadWatchdog.newInstance(10, 100, System::currentTimeMillis, (delay, command) -> {         try {             Thread.sleep(delay).         } catch (InterruptedException e) {             throw new AssertionError(e).         }         Thread thread = new Thread(() -> {             if (run.get()) {                 command.run().             }         }).         thread.start().     }).     Map<?, ?> registry = ((ThreadWatchdog.Default) watchdog).registry.     assertThat(registry.size(), is(0)).     // need to call #register() method on a different thread, assertBusy() fails if current thread gets interrupted     AtomicBoolean interrupted = new AtomicBoolean(false).     Thread thread = new Thread(() -> {         Thread currentThread = Thread.currentThread().         watchdog.register().         while (currentThread.isInterrupted() == false) {         }         interrupted.set(true).         // wait here so that the size of the registry can be asserted         while (run.get()) {         }         watchdog.unregister().     }).     thread.start().     assertBusy(() -> {         assertThat(interrupted.get(), is(true)).         assertThat(registry.size(), is(1)).     }).     run.set(false).     assertBusy(() -> {         assertThat(registry.size(), is(0)).     }). }
false;public;0;34;;public void testIdleIfNothingRegistered() throws Exception {     long interval = 1L.     ScheduledExecutorService threadPool = mock(ScheduledExecutorService.class).     ThreadWatchdog watchdog = ThreadWatchdog.newInstance(interval, Long.MAX_VALUE, System::currentTimeMillis, (delay, command) -> threadPool.schedule(command, delay, TimeUnit.MILLISECONDS)).     // Periodic action is not scheduled because no thread is registered     verifyZeroInteractions(threadPool).     CompletableFuture<Runnable> commandFuture = new CompletableFuture<>().     // Periodic action is scheduled because a thread is registered     doAnswer(invocationOnMock -> {         commandFuture.complete((Runnable) invocationOnMock.getArguments()[0]).         return null.     }).when(threadPool).schedule(any(Runnable.class), eq(interval), eq(TimeUnit.MILLISECONDS)).     watchdog.register().     // Registering the first thread should have caused the command to get scheduled again     Runnable command = commandFuture.get(1L, TimeUnit.MILLISECONDS).     Mockito.reset(threadPool).     watchdog.unregister().     command.run().     // Periodic action is not scheduled again because no thread is registered     verifyZeroInteractions(threadPool).     watchdog.register().     Thread otherThread = new Thread(watchdog::register).     try {         verify(threadPool).schedule(any(Runnable.class), eq(interval), eq(TimeUnit.MILLISECONDS)).         // Registering a second thread does not cause the command to get scheduled twice         verifyNoMoreInteractions(threadPool).         otherThread.start().     } finally {         otherThread.join().     } }
