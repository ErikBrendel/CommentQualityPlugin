commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;8;/**  * Adapts an array (or varags) setter into a list setter.  */ ;/**  * Adapts an array (or varags) setter into a list setter.  */ public static <Value, ElementValue> BiConsumer<Value, List<ElementValue>> fromList(Class<ElementValue> c, BiConsumer<Value, ElementValue[]> consumer) {     return (Value v, List<ElementValue> l) -> {         @SuppressWarnings("unchecked")         ElementValue[] array = (ElementValue[]) Array.newInstance(c, l.size()).         consumer.accept(v, l.toArray(array)).     }. }
true;public;2;7;/**  * Parses a Value from the given {@link XContentParser}  * @param parser the parser to build a value from  * @param context context needed for parsing  * @return a new value instance drawn from the provided value supplier on {@link #ObjectParser(String, Supplier)}  * @throws IOException if an IOException occurs.  */ ;/**  * Parses a Value from the given {@link XContentParser}  * @param parser the parser to build a value from  * @param context context needed for parsing  * @return a new value instance drawn from the provided value supplier on {@link #ObjectParser(String, Supplier)}  * @throws IOException if an IOException occurs.  */ @Override public Value parse(XContentParser parser, Context context) throws IOException {     if (valueSupplier == null) {         throw new NullPointerException("valueSupplier is not set").     }     return parse(parser, valueSupplier.get(), context). }
true;public;3;33;/**  * Parses a Value from the given {@link XContentParser}  * @param parser the parser to build a value from  * @param value the value to fill from the parser  * @param context a context that is passed along to all declared field parsers  * @return the parsed value  * @throws IOException if an IOException occurs.  */ ;/**  * Parses a Value from the given {@link XContentParser}  * @param parser the parser to build a value from  * @param value the value to fill from the parser  * @param context a context that is passed along to all declared field parsers  * @return the parsed value  * @throws IOException if an IOException occurs.  */ public Value parse(XContentParser parser, Value value, Context context) throws IOException {     XContentParser.Token token.     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         token = parser.currentToken().     } else {         token = parser.nextToken().         if (token != XContentParser.Token.START_OBJECT) {             throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] Expected START_OBJECT but was: " + token).         }     }     FieldParser fieldParser = null.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().             fieldParser = getParser(currentFieldName, parser).         } else {             if (currentFieldName == null) {                 throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] no field found").             }             if (fieldParser == null) {                 assert ignoreUnknownFields : "this should only be possible if configured to ignore known fields".                 // noop if parser points to a value, skips children if parser is start object or start array                 parser.skipChildren().             } else {                 fieldParser.assertSupports(name, parser, currentFieldName).                 parseSub(parser, fieldParser, currentFieldName, value, context).             }             fieldParser = null.         }     }     return value. }
false;public;2;11;;@Override public Value apply(XContentParser parser, Context context) {     if (valueSupplier == null) {         throw new NullPointerException("valueSupplier is not set").     }     try {         return parse(parser, valueSupplier.get(), context).     } catch (IOException e) {         throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] failed to parse object", e).     } }
false;;3;1;;void parse(XContentParser parser, Value value, Context context) throws IOException.
false;public;3;12;;public void declareField(Parser<Value, Context> p, ParseField parseField, ValueType type) {     if (parseField == null) {         throw new IllegalArgumentException("[parseField] is required").     }     if (type == null) {         throw new IllegalArgumentException("[type] is required").     }     FieldParser fieldParser = new FieldParser(p, type.supportedTokens(), parseField, type).     for (String fieldValue : parseField.getAllNamesIncludedDeprecated()) {         fieldParserMap.putIfAbsent(fieldValue, fieldParser).     } }
false;public;4;11;;@Override public <T> void declareField(BiConsumer<Value, T> consumer, ContextParser<Context, T> parser, ParseField parseField, ValueType type) {     if (consumer == null) {         throw new IllegalArgumentException("[consumer] is required").     }     if (parser == null) {         throw new IllegalArgumentException("[parser] is required").     }     declareField((p, v, c) -> consumer.accept(v, parser.parse(p, c)), parseField, type). }
false;public;4;12;;public <T> void declareObjectOrDefault(BiConsumer<Value, T> consumer, BiFunction<XContentParser, Context, T> objectParser, Supplier<T> defaultValue, ParseField field) {     declareField((p, v, c) -> {         if (p.currentToken() == XContentParser.Token.VALUE_BOOLEAN) {             if (p.booleanValue()) {                 consumer.accept(v, defaultValue.get()).             }         } else {             consumer.accept(v, objectParser.apply(p, c)).         }     }, field, ValueType.OBJECT_OR_BOOLEAN). }
false;public;4;49;;@Override public <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser, Consumer<Value> orderedModeCallback, ParseField field) {     // This creates and parses the named object     BiFunction<XContentParser, Context, T> objectParser = (XContentParser p, Context c) -> {         if (p.currentToken() != XContentParser.Token.FIELD_NAME) {             throw new XContentParseException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of " + "fields or an array where each entry is an object with a single field").         }         // This messy exception nesting has the nice side effect of telling the use which field failed to parse         try {             String name = p.currentName().             try {                 return namedObjectParser.parse(p, c, name).             } catch (Exception e) {                 throw new XContentParseException(p.getTokenLocation(), "[" + field + "] failed to parse field [" + name + "]", e).             }         } catch (IOException e) {             throw new XContentParseException(p.getTokenLocation(), "[" + field + "] error while parsing", e).         }     }.     declareField((XContentParser p, Value v, Context c) -> {         List<T> fields = new ArrayList<>().         XContentParser.Token token.         if (p.currentToken() == XContentParser.Token.START_OBJECT) {             // Fields are just named entries in a single object             while ((token = p.nextToken()) != XContentParser.Token.END_OBJECT) {                 fields.add(objectParser.apply(p, c)).             }         } else if (p.currentToken() == XContentParser.Token.START_ARRAY) {             // Fields are objects in an array. Each object contains a named field.             orderedModeCallback.accept(v).             while ((token = p.nextToken()) != XContentParser.Token.END_ARRAY) {                 if (token != XContentParser.Token.START_OBJECT) {                     throw new XContentParseException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of " + "fields or an array where each entry is an object with a single field").                 }                 // Move to the first field in the object                 p.nextToken().                 fields.add(objectParser.apply(p, c)).                 // Move past the object, should be back to into the array                 p.nextToken().                 if (p.currentToken() != XContentParser.Token.END_OBJECT) {                     throw new XContentParseException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of " + "fields or an array where each entry is an object with a single field").                 }             }         }         consumer.accept(v, fields).     }, field, ValueType.OBJECT_ARRAY). }
false;public;3;8;;@Override public <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser, ParseField field) {     Consumer<Value> orderedModeCallback = (v) -> {         throw new IllegalArgumentException("[" + field + "] doesn't support arrays. Use a single object with multiple fields.").     }.     declareNamedObjects(consumer, namedObjectParser, orderedModeCallback, field). }
false;;3;1;;T parse(XContentParser p, Context c, String name) throws IOException.
true;public;0;4;/**  * Get the name of the parser.  */ ;/**  * Get the name of the parser.  */ @Override public String getName() {     return name. }
false;private;5;5;;private void parseArray(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context) throws IOException {     assert parser.currentToken() == XContentParser.Token.START_ARRAY : "Token was: " + parser.currentToken().     parseValue(parser, fieldParser, currentFieldName, value, context). }
false;private;5;9;;private void parseValue(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context) throws IOException {     try {         fieldParser.parser.parse(parser, value, context).     } catch (Exception ex) {         throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] failed to parse field [" + currentFieldName + "]", ex).     } }
false;private;5;44;;private void parseSub(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context) throws IOException {     final XContentParser.Token token = parser.currentToken().     switch(token) {         case START_OBJECT:             parseValue(parser, fieldParser, currentFieldName, value, context).             /*                  * Well behaving parsers should consume the entire object but                  * asserting that they do that is not something we can do                  * efficiently here. Instead we can check that they end on an                  * END_OBJECT. They could end on the *wrong* end object and                  * this test won't catch them, but that is the price that we pay                  * for having a cheap test.                  */             if (parser.currentToken() != XContentParser.Token.END_OBJECT) {                 throw new IllegalStateException("parser for [" + currentFieldName + "] did not end on END_OBJECT").             }             break.         case START_ARRAY:             parseArray(parser, fieldParser, currentFieldName, value, context).             /*                  * Well behaving parsers should consume the entire array but                  * asserting that they do that is not something we can do                  * efficiently here. Instead we can check that they end on an                  * END_ARRAY. They could end on the *wrong* end array and                  * this test won't catch them, but that is the price that we pay                  * for having a cheap test.                  */             if (parser.currentToken() != XContentParser.Token.END_ARRAY) {                 throw new IllegalStateException("parser for [" + currentFieldName + "] did not end on END_ARRAY").             }             break.         case END_OBJECT:         case END_ARRAY:         case FIELD_NAME:             throw new XContentParseException(parser.getTokenLocation(), "[" + name + "]" + token + " is unexpected").         case VALUE_STRING:         case VALUE_NUMBER:         case VALUE_BOOLEAN:         case VALUE_EMBEDDED_OBJECT:         case VALUE_NULL:             parseValue(parser, fieldParser, currentFieldName, value, context).     } }
false;private;2;8;;private FieldParser getParser(String fieldName, XContentParser xContentParser) {     FieldParser parser = fieldParserMap.get(fieldName).     if (parser == null && false == ignoreUnknownFields) {         throw new XContentParseException(xContentParser.getTokenLocation(), "[" + name + "] unknown field [" + fieldName + "], parser not found").     }     return parser. }
false;;3;10;;void assertSupports(String parserName, XContentParser parser, String currentFieldName) {     if (parseField.match(currentFieldName, parser.getDeprecationHandler()) == false) {         throw new XContentParseException(parser.getTokenLocation(), "[" + parserName + "] parsefield doesn't accept: " + currentFieldName).     }     if (supportedTokens.contains(parser.currentToken()) == false) {         throw new XContentParseException(parser.getTokenLocation(), "[" + parserName + "] " + currentFieldName + " doesn't support values of type: " + parser.currentToken()).     } }
false;public;0;16;;@Override public String toString() {     String[] deprecatedNames = parseField.getDeprecatedNames().     String allReplacedWith = parseField.getAllReplacedWith().     String deprecated = "".     if (deprecatedNames != null && deprecatedNames.length > 0) {         deprecated = ", deprecated_names=" + Arrays.toString(deprecatedNames).     }     return "FieldParser{" + "preferred_name=" + parseField.getPreferredName() + ", supportedTokens=" + supportedTokens + deprecated + (allReplacedWith == null ? "" : ", replaced_with=" + allReplacedWith) + ", type=" + type.name() + '}'. }
false;public;0;3;;public EnumSet<XContentParser.Token> supportedTokens() {     return this.tokens. }
false;public;0;7;;@Override public String toString() {     return "ObjectParser{" + "name='" + name + '\'' + ", fields=" + fieldParserMap.values() + '}'. }
