commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;7;;private static void checkCoerceString(boolean coerce, Class<? extends Number> clazz) {     if (!coerce) {         // NumberFieldMapper.parseCreateField relies on this for "malformed" value detection         throw new IllegalArgumentException(clazz.getSimpleName() + " value passed as String").     } }
true;;3;11;// then this method is called to trigger the"malformed" handling logic ;// The 3rd party parsers we rely on are known to silently truncate fractions: see // http://fasterxml.github.io/jackson-core/javadoc/2.3.0/com/fasterxml/jackson/core/JsonParser.html#getShortValue() // If this behaviour is flagged as undesirable and any truncation occurs // then this method is called to trigger the"malformed" handling logic void ensureNumberConversion(boolean coerce, long result, Class<? extends Number> clazz) throws IOException {     if (!coerce) {         double fullVal = doDoubleValue().         if (result != fullVal) {             // for "malformed" value detection             throw new IllegalArgumentException(fullVal + " cannot be converted to " + clazz.getSimpleName() + " without data loss").         }     } }
false;public;0;11;;@Override public boolean isBooleanValue() throws IOException {     switch(currentToken()) {         case VALUE_BOOLEAN:             return true.         case VALUE_STRING:             return Booleans.isBoolean(textCharacters(), textOffset(), textLength()).         default:             return false.     } }
false;public;0;8;;@Override public boolean booleanValue() throws IOException {     Token token = currentToken().     if (token == Token.VALUE_STRING) {         return Booleans.parseBoolean(textCharacters(), textOffset(), textLength(), false).     }     return doBooleanValue(). }
false;protected,abstract;0;1;;protected abstract boolean doBooleanValue() throws IOException.
false;public;0;4;;@Override public short shortValue() throws IOException {     return shortValue(DEFAULT_NUMBER_COERCE_POLICY). }
false;public;1;18;;@Override public short shortValue(boolean coerce) throws IOException {     Token token = currentToken().     if (token == Token.VALUE_STRING) {         checkCoerceString(coerce, Short.class).         double doubleValue = Double.parseDouble(text()).         if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {             throw new IllegalArgumentException("Value [" + text() + "] is out of range for a short").         }         return (short) doubleValue.     }     short result = doShortValue().     ensureNumberConversion(coerce, result, Short.class).     return result. }
false;protected,abstract;0;1;;protected abstract short doShortValue() throws IOException.
false;public;0;4;;@Override public int intValue() throws IOException {     return intValue(DEFAULT_NUMBER_COERCE_POLICY). }
false;public;1;17;;@Override public int intValue(boolean coerce) throws IOException {     Token token = currentToken().     if (token == Token.VALUE_STRING) {         checkCoerceString(coerce, Integer.class).         double doubleValue = Double.parseDouble(text()).         if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {             throw new IllegalArgumentException("Value [" + text() + "] is out of range for an integer").         }         return (int) doubleValue.     }     int result = doIntValue().     ensureNumberConversion(coerce, result, Integer.class).     return result. }
false;protected,abstract;0;1;;protected abstract int doIntValue() throws IOException.
true;private,static;2;24;/**  * Return the long that {@code stringValue} stores or throws an exception if the  *  stored value cannot be converted to a long that stores the exact same  *  value and {@code coerce} is false.  */ ;/**  * Return the long that {@code stringValue} stores or throws an exception if the  *  stored value cannot be converted to a long that stores the exact same  *  value and {@code coerce} is false.  */ private static long toLong(String stringValue, boolean coerce) {     try {         return Long.parseLong(stringValue).     } catch (NumberFormatException e) {     // we will try again with BigDecimal     }     final BigInteger bigIntegerValue.     try {         BigDecimal bigDecimalValue = new BigDecimal(stringValue).         bigIntegerValue = coerce ? bigDecimalValue.toBigInteger() : bigDecimalValue.toBigIntegerExact().     } catch (ArithmeticException e) {         throw new IllegalArgumentException("Value [" + stringValue + "] has a decimal part").     } catch (NumberFormatException e) {         throw new IllegalArgumentException("For input string: \"" + stringValue + "\"").     }     if (bigIntegerValue.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0 || bigIntegerValue.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0) {         throw new IllegalArgumentException("Value [" + stringValue + "] is out of range for a long").     }     return bigIntegerValue.longValue(). }
false;public;0;4;;@Override public long longValue() throws IOException {     return longValue(DEFAULT_NUMBER_COERCE_POLICY). }
false;public;1;11;;@Override public long longValue(boolean coerce) throws IOException {     Token token = currentToken().     if (token == Token.VALUE_STRING) {         checkCoerceString(coerce, Long.class).         return toLong(text(), coerce).     }     long result = doLongValue().     ensureNumberConversion(coerce, result, Long.class).     return result. }
false;protected,abstract;0;1;;protected abstract long doLongValue() throws IOException.
false;public;0;4;;@Override public float floatValue() throws IOException {     return floatValue(DEFAULT_NUMBER_COERCE_POLICY). }
false;public;1;9;;@Override public float floatValue(boolean coerce) throws IOException {     Token token = currentToken().     if (token == Token.VALUE_STRING) {         checkCoerceString(coerce, Float.class).         return Float.parseFloat(text()).     }     return doFloatValue(). }
false;protected,abstract;0;1;;protected abstract float doFloatValue() throws IOException.
false;public;0;4;;@Override public double doubleValue() throws IOException {     return doubleValue(DEFAULT_NUMBER_COERCE_POLICY). }
false;public;1;9;;@Override public double doubleValue(boolean coerce) throws IOException {     Token token = currentToken().     if (token == Token.VALUE_STRING) {         checkCoerceString(coerce, Double.class).         return Double.parseDouble(text()).     }     return doDoubleValue(). }
false;protected,abstract;0;1;;protected abstract double doDoubleValue() throws IOException.
false;public,final;0;7;;@Override public final String textOrNull() throws IOException {     if (currentToken() == Token.VALUE_NULL) {         return null.     }     return text(). }
false;public;0;7;;@Override public CharBuffer charBufferOrNull() throws IOException {     if (currentToken() == Token.VALUE_NULL) {         return null.     }     return charBuffer(). }
false;public;0;4;;@Override public Map<String, Object> map() throws IOException {     return readMap(this). }
false;public;0;4;;@Override public Map<String, Object> mapOrdered() throws IOException {     return readOrderedMap(this). }
false;public;0;4;;@Override public Map<String, String> mapStrings() throws IOException {     return readMapStrings(this). }
false;public;0;4;;@Override public Map<String, String> mapStringsOrdered() throws IOException {     return readOrderedMapStrings(this). }
false;public;0;4;;@Override public List<Object> list() throws IOException {     return readList(this). }
false;public;0;4;;@Override public List<Object> listOrderedMap() throws IOException {     return readListOrderedMap(this). }
false;;0;1;;Map<String, Object> newMap().
false;;0;1;;Map<String, String> newMap().
false;static;1;3;;static Map<String, Object> readMap(XContentParser parser) throws IOException {     return readMap(parser, SIMPLE_MAP_FACTORY). }
false;static;1;3;;static Map<String, Object> readOrderedMap(XContentParser parser) throws IOException {     return readMap(parser, ORDERED_MAP_FACTORY). }
false;static;1;3;;static Map<String, String> readMapStrings(XContentParser parser) throws IOException {     return readMapStrings(parser, SIMPLE_MAP_STRINGS_FACTORY). }
false;static;1;3;;static Map<String, String> readOrderedMapStrings(XContentParser parser) throws IOException {     return readMapStrings(parser, ORDERED_MAP_STRINGS_FACTORY). }
false;static;1;3;;static List<Object> readList(XContentParser parser) throws IOException {     return readList(parser, SIMPLE_MAP_FACTORY). }
false;static;1;3;;static List<Object> readListOrderedMap(XContentParser parser) throws IOException {     return readList(parser, ORDERED_MAP_FACTORY). }
false;static;2;19;;static Map<String, Object> readMap(XContentParser parser, MapFactory mapFactory) throws IOException {     Map<String, Object> map = mapFactory.newMap().     XContentParser.Token token = parser.currentToken().     if (token == null) {         token = parser.nextToken().     }     if (token == XContentParser.Token.START_OBJECT) {         token = parser.nextToken().     }     for (. token == XContentParser.Token.FIELD_NAME. token = parser.nextToken()) {         // Must point to field name         String fieldName = parser.currentName().         // And then the value...         token = parser.nextToken().         Object value = readValue(parser, mapFactory, token).         map.put(fieldName, value).     }     return map. }
false;static;2;19;;static Map<String, String> readMapStrings(XContentParser parser, MapStringsFactory mapStringsFactory) throws IOException {     Map<String, String> map = mapStringsFactory.newMap().     XContentParser.Token token = parser.currentToken().     if (token == null) {         token = parser.nextToken().     }     if (token == XContentParser.Token.START_OBJECT) {         token = parser.nextToken().     }     for (. token == XContentParser.Token.FIELD_NAME. token = parser.nextToken()) {         // Must point to field name         String fieldName = parser.currentName().         // And then the value...         parser.nextToken().         String value = parser.text().         map.put(fieldName, value).     }     return map. }
false;static;2;21;;static List<Object> readList(XContentParser parser, MapFactory mapFactory) throws IOException {     XContentParser.Token token = parser.currentToken().     if (token == null) {         token = parser.nextToken().     }     if (token == XContentParser.Token.FIELD_NAME) {         token = parser.nextToken().     }     if (token == XContentParser.Token.START_ARRAY) {         token = parser.nextToken().     } else {         throw new XContentParseException(parser.getTokenLocation(), "Failed to parse list:  expecting " + XContentParser.Token.START_ARRAY + " but got " + token).     }     ArrayList<Object> list = new ArrayList<>().     for (. token != null && token != XContentParser.Token.END_ARRAY. token = parser.nextToken()) {         list.add(readValue(parser, mapFactory, token)).     }     return list. }
false;static;3;18;;static Object readValue(XContentParser parser, MapFactory mapFactory, XContentParser.Token token) throws IOException {     if (token == XContentParser.Token.VALUE_NULL) {         return null.     } else if (token == XContentParser.Token.VALUE_STRING) {         return parser.text().     } else if (token == XContentParser.Token.VALUE_NUMBER) {         return parser.numberValue().     } else if (token == XContentParser.Token.VALUE_BOOLEAN) {         return parser.booleanValue().     } else if (token == XContentParser.Token.START_OBJECT) {         return readMap(parser, mapFactory).     } else if (token == XContentParser.Token.START_ARRAY) {         return readList(parser, mapFactory).     } else if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {         return parser.binaryValue().     }     return null. }
false;public;3;4;;@Override public <T> T namedObject(Class<T> categoryClass, String name, Object context) throws IOException {     return xContentRegistry.parseNamedObject(categoryClass, name, this, context). }
false;public;0;4;;@Override public NamedXContentRegistry getXContentRegistry() {     return xContentRegistry. }
false;public,abstract;0;2;;@Override public abstract boolean isClosed().
false;public;0;4;;@Override public DeprecationHandler getDeprecationHandler() {     return deprecationHandler. }
