commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public XContentType contentType() {     return parser.contentType(). }
false;public;0;14;;@Override public Token nextToken() throws IOException {     if (level > 0) {         Token token = parser.nextToken().         if (token == Token.START_OBJECT || token == Token.START_ARRAY) {             level++.         } else if (token == Token.END_OBJECT || token == Token.END_ARRAY) {             level--.         }         return token.     } else {         // we have reached the end of the wrapped object         return null.     } }
false;public;0;14;;@Override public void skipChildren() throws IOException {     Token token = parser.currentToken().     if (token != Token.START_OBJECT && token != Token.START_ARRAY) {         // skip if not starting on an object or an array         return.     }     int backToLevel = level - 1.     while (nextToken() != null) {         if (level <= backToLevel) {             return.         }     } }
false;public;0;4;;@Override public Token currentToken() {     return parser.currentToken(). }
false;public;0;4;;@Override public String currentName() throws IOException {     return parser.currentName(). }
false;public;0;4;;@Override public Map<String, Object> map() throws IOException {     return parser.map(). }
false;public;0;4;;@Override public Map<String, Object> mapOrdered() throws IOException {     return parser.mapOrdered(). }
false;public;0;4;;@Override public Map<String, String> mapStrings() throws IOException {     return parser.mapStrings(). }
false;public;0;4;;@Override public Map<String, String> mapStringsOrdered() throws IOException {     return parser.mapStringsOrdered(). }
false;public;0;4;;@Override public List<Object> list() throws IOException {     return parser.list(). }
false;public;0;4;;@Override public List<Object> listOrderedMap() throws IOException {     return parser.listOrderedMap(). }
false;public;0;4;;@Override public String text() throws IOException {     return parser.text(). }
false;public;0;4;;@Override public String textOrNull() throws IOException {     return parser.textOrNull(). }
false;public;0;4;;@Override public CharBuffer charBufferOrNull() throws IOException {     return parser.charBufferOrNull(). }
false;public;0;4;;@Override public CharBuffer charBuffer() throws IOException {     return parser.charBuffer(). }
false;public;0;4;;@Override public Object objectText() throws IOException {     return parser.objectText(). }
false;public;0;4;;@Override public Object objectBytes() throws IOException {     return parser.objectBytes(). }
false;public;0;4;;@Override public boolean hasTextCharacters() {     return parser.hasTextCharacters(). }
false;public;0;4;;@Override public char[] textCharacters() throws IOException {     return parser.textCharacters(). }
false;public;0;4;;@Override public int textLength() throws IOException {     return parser.textLength(). }
false;public;0;4;;@Override public int textOffset() throws IOException {     return parser.textOffset(). }
false;public;0;4;;@Override public Number numberValue() throws IOException {     return parser.numberValue(). }
false;public;0;4;;@Override public NumberType numberType() throws IOException {     return parser.numberType(). }
false;public;1;4;;@Override public short shortValue(boolean coerce) throws IOException {     return parser.shortValue(coerce). }
false;public;1;4;;@Override public int intValue(boolean coerce) throws IOException {     return parser.intValue(coerce). }
false;public;1;4;;@Override public long longValue(boolean coerce) throws IOException {     return parser.longValue(coerce). }
false;public;1;4;;@Override public float floatValue(boolean coerce) throws IOException {     return parser.floatValue(coerce). }
false;public;1;4;;@Override public double doubleValue(boolean coerce) throws IOException {     return parser.doubleValue(). }
false;public;0;4;;@Override public short shortValue() throws IOException {     return parser.shortValue(). }
false;public;0;4;;@Override public int intValue() throws IOException {     return parser.intValue(). }
false;public;0;4;;@Override public long longValue() throws IOException {     return parser.longValue(). }
false;public;0;4;;@Override public float floatValue() throws IOException {     return parser.floatValue(). }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return parser.doubleValue(). }
false;public;0;4;;@Override public boolean isBooleanValue() throws IOException {     return parser.isBooleanValue(). }
false;public;0;4;;@Override public boolean booleanValue() throws IOException {     return parser.booleanValue(). }
false;public;0;4;;@Override public byte[] binaryValue() throws IOException {     return parser.binaryValue(). }
false;public;0;4;;@Override public XContentLocation getTokenLocation() {     return parser.getTokenLocation(). }
false;public;3;4;;@Override public <T> T namedObject(Class<T> categoryClass, String name, Object context) throws IOException {     return parser.namedObject(categoryClass, name, context). }
false;public;0;4;;@Override public NamedXContentRegistry getXContentRegistry() {     return parser.getXContentRegistry(). }
false;public;0;4;;@Override public boolean isClosed() {     return closed. }
false;public;0;4;;@Override public DeprecationHandler getDeprecationHandler() {     return parser.getDeprecationHandler(). }
false;public;0;11;;@Override public void close() throws IOException {     if (closed == false) {         closed = true.         while (true) {             if (nextToken() == null) {                 return.             }         }     } }
