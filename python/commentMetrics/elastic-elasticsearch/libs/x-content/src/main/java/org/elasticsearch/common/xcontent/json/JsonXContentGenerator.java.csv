commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public XContentType contentType() {     return XContentType.JSON. }
false;public,final;0;5;;@Override public final void usePrettyPrint() {     generator.setPrettyPrinter(new DefaultPrettyPrinter().withObjectIndenter(INDENTER).withArrayIndenter(INDENTER)).     prettyPrint = true. }
false;public;0;4;;@Override public boolean isPrettyPrint() {     return this.prettyPrint. }
false;public;0;4;;@Override public void usePrintLineFeedAtEnd() {     writeLineFeedAtEnd = true. }
false;private;0;3;;private boolean isFiltered() {     return filter != null. }
false;private;0;12;;private JsonGenerator getLowLevelGenerator() {     if (isFiltered()) {         JsonGenerator delegate = filter.getDelegate().         if (delegate instanceof JsonGeneratorDelegate) {             // In case of combined inclusion and exclusion filters, we have one and only one another delegating level             delegate = ((JsonGeneratorDelegate) delegate).getDelegate().             assert delegate instanceof JsonGeneratorDelegate == false.         }         return delegate.     }     return generator. }
false;private;0;4;;private boolean inRoot() {     JsonStreamContext context = generator.getOutputContext().     return ((context != null) && (context.inRoot() && context.getCurrentName() == null)). }
false;public;0;10;;@Override public void writeStartObject() throws IOException {     if (inRoot()) {         // Use the low level generator to write the startObject so that the root         // start object is always written even if a filtered generator is used         getLowLevelGenerator().writeStartObject().         return.     }     generator.writeStartObject(). }
false;public;0;10;;@Override public void writeEndObject() throws IOException {     if (inRoot()) {         // Use the low level generator to write the startObject so that the root         // start object is always written even if a filtered generator is used         getLowLevelGenerator().writeEndObject().         return.     }     generator.writeEndObject(). }
false;public;0;4;;@Override public void writeStartArray() throws IOException {     generator.writeStartArray(). }
false;public;0;4;;@Override public void writeEndArray() throws IOException {     generator.writeEndArray(). }
false;public;1;4;;@Override public void writeFieldName(String name) throws IOException {     generator.writeFieldName(name). }
false;public;0;4;;@Override public void writeNull() throws IOException {     generator.writeNull(). }
false;public;1;4;;@Override public void writeNullField(String name) throws IOException {     generator.writeNullField(name). }
false;public;2;4;;@Override public void writeBooleanField(String name, boolean value) throws IOException {     generator.writeBooleanField(name, value). }
false;public;1;4;;@Override public void writeBoolean(boolean value) throws IOException {     generator.writeBoolean(value). }
false;public;2;4;;@Override public void writeNumberField(String name, double value) throws IOException {     generator.writeNumberField(name, value). }
false;public;1;4;;@Override public void writeNumber(double value) throws IOException {     generator.writeNumber(value). }
false;public;2;4;;@Override public void writeNumberField(String name, float value) throws IOException {     generator.writeNumberField(name, value). }
false;public;1;4;;@Override public void writeNumber(float value) throws IOException {     generator.writeNumber(value). }
false;public;2;4;;@Override public void writeNumberField(String name, int value) throws IOException {     generator.writeNumberField(name, value). }
false;public;2;7;;@Override public void writeNumberField(String name, BigInteger value) throws IOException {     // as jackson's JsonGenerator doesn't have this method for BigInteger     // we have to implement it ourselves     generator.writeFieldName(name).     generator.writeNumber(value). }
false;public;2;4;;@Override public void writeNumberField(String name, BigDecimal value) throws IOException {     generator.writeNumberField(name, value). }
false;public;1;4;;@Override public void writeNumber(int value) throws IOException {     generator.writeNumber(value). }
false;public;2;4;;@Override public void writeNumberField(String name, long value) throws IOException {     generator.writeNumberField(name, value). }
false;public;1;4;;@Override public void writeNumber(long value) throws IOException {     generator.writeNumber(value). }
false;public;1;4;;@Override public void writeNumber(short value) throws IOException {     generator.writeNumber(value). }
false;public;1;4;;@Override public void writeNumber(BigInteger value) throws IOException {     generator.writeNumber(value). }
false;public;1;4;;@Override public void writeNumber(BigDecimal value) throws IOException {     generator.writeNumber(value). }
false;public;2;4;;@Override public void writeStringField(String name, String value) throws IOException {     generator.writeStringField(name, value). }
false;public;1;4;;@Override public void writeString(String value) throws IOException {     generator.writeString(value). }
false;public;3;4;;@Override public void writeString(char[] value, int offset, int len) throws IOException {     generator.writeString(value, offset, len). }
false;public;3;4;;@Override public void writeUTF8String(byte[] value, int offset, int length) throws IOException {     generator.writeUTF8String(value, offset, length). }
false;public;2;4;;@Override public void writeBinaryField(String name, byte[] value) throws IOException {     generator.writeBinaryField(name, value). }
false;public;1;4;;@Override public void writeBinary(byte[] value) throws IOException {     generator.writeBinary(value). }
false;public;3;4;;@Override public void writeBinary(byte[] value, int offset, int len) throws IOException {     generator.writeBinary(value, offset, len). }
false;private;1;4;;private void writeStartRaw(String name) throws IOException {     writeFieldName(name).     generator.writeRaw(':'). }
false;public;0;8;;public void writeEndRaw() {     assert base != null : "JsonGenerator should be of instance GeneratorBase but was: " + generator.getClass().     if (base != null) {         JsonStreamContext context = base.getOutputContext().         assert (context instanceof JsonWriteContext) : "Expected an instance of JsonWriteContext but was: " + context.getClass().         ((JsonWriteContext) context).writeValue().     } }
false;public;2;12;;@Override public void writeRawField(String name, InputStream content) throws IOException {     if (content.markSupported() == false) {         // needed for the XContentFactory.xContentType call         content = new BufferedInputStream(content).     }     XContentType contentType = XContentFactory.xContentType(content).     if (contentType == null) {         throw new IllegalArgumentException("Can't write raw bytes whose xcontent-type can't be guessed").     }     writeRawField(name, content, contentType). }
false;public;3;20;;@Override public void writeRawField(String name, InputStream content, XContentType contentType) throws IOException {     if (mayWriteRawData(contentType) == false) {         // EMPTY is safe here because we never call namedObject when writing raw data         try (XContentParser parser = XContentFactory.xContent(contentType).createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, content)) {             parser.nextToken().             writeFieldName(name).             copyCurrentStructure(parser).         }     } else {         writeStartRaw(name).         flush().         copyStream(content, os).         writeEndRaw().     } }
false;public;2;14;;@Override public void writeRawValue(InputStream stream, XContentType xContentType) throws IOException {     if (mayWriteRawData(xContentType) == false) {         copyRawValue(stream, xContentType.xContent()).     } else {         if (generator.getOutputContext().getCurrentName() != null) {             // If we've just started a field we'll need to add the separator             generator.writeRaw(':').         }         flush().         transfer(stream, os).         writeEndRaw().     } }
true;private,static;2;11;// A basic copy of Java 9's InputStream#transferTo ;// A basic copy of Java 9's InputStream#transferTo private static long transfer(InputStream in, OutputStream out) throws IOException {     Objects.requireNonNull(out, "out").     long transferred = 0.     byte[] buffer = new byte[8192].     int read.     while ((read = in.read(buffer, 0, 8192)) >= 0) {         out.write(buffer, 0, read).         transferred += read.     }     return transferred. }
false;private;1;10;;private boolean mayWriteRawData(XContentType contentType) {     // filtered or converted     return supportsRawWrites() && isFiltered() == false && contentType == contentType() && prettyPrint == false. }
true;protected;0;3;/**  * Whether this generator supports writing raw data directly  */ ;/**  * Whether this generator supports writing raw data directly  */ protected boolean supportsRawWrites() {     return true. }
false;protected;2;9;;protected void copyRawValue(InputStream stream, XContent xContent) throws IOException {     // EMPTY is safe here because we never call namedObject     try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, stream)) {         copyCurrentStructure(parser).     } }
false;public;1;12;;@Override public void copyCurrentStructure(XContentParser parser) throws IOException {     // the start of the parser     if (parser.currentToken() == null) {         parser.nextToken().     }     if (parser instanceof JsonXContentParser) {         generator.copyCurrentStructure(((JsonXContentParser) parser).parser).     } else {         copyCurrentStructure(this, parser).     } }
true;private,static;2;29;/**  * Low level implementation detail of {@link XContentGenerator#copyCurrentStructure(XContentParser)}.  */ ;/**  * Low level implementation detail of {@link XContentGenerator#copyCurrentStructure(XContentParser)}.  */ private static void copyCurrentStructure(XContentGenerator destination, XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     // Let's handle field-name separately first     if (token == XContentParser.Token.FIELD_NAME) {         destination.writeFieldName(parser.currentName()).         token = parser.nextToken().     // fall-through to copy the associated value     }     switch(token) {         case START_ARRAY:             destination.writeStartArray().             while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                 copyCurrentStructure(destination, parser).             }             destination.writeEndArray().             break.         case START_OBJECT:             destination.writeStartObject().             while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                 copyCurrentStructure(destination, parser).             }             destination.writeEndObject().             break.         default:             // others are simple:             destination.copyCurrentEvent(parser).     } }
false;public;0;4;;@Override public void flush() throws IOException {     generator.flush(). }
false;public;0;16;;@Override public void close() throws IOException {     if (generator.isClosed()) {         return.     }     JsonStreamContext context = generator.getOutputContext().     if ((context != null) && (context.inRoot() == false)) {         throw new IOException("Unclosed object or array found").     }     if (writeLineFeedAtEnd) {         flush().         // Bypass generator to always write the line feed         getLowLevelGenerator().writeRaw(LF).     }     generator.close(). }
false;public;0;4;;@Override public boolean isClosed() {     return generator.isClosed(). }
true;private,static;2;23;/**  * Copy the contents of the given InputStream to the given OutputStream.  * Closes both streams when done.  *  * @param in  the stream to copy from  * @param out the stream to copy to  * @return the number of bytes copied  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given InputStream to the given OutputStream.  * Closes both streams when done.  *  * @param in  the stream to copy from  * @param out the stream to copy to  * @return the number of bytes copied  * @throws IOException in case of I/O errors  */ private static long copyStream(InputStream in, OutputStream out) throws IOException {     Objects.requireNonNull(in, "No InputStream specified").     Objects.requireNonNull(out, "No OutputStream specified").     final byte[] buffer = new byte[8192].     boolean success = false.     try {         long byteCount = 0.         int bytesRead.         while ((bytesRead = in.read(buffer)) != -1) {             out.write(buffer, 0, bytesRead).             byteCount += bytesRead.         }         out.flush().         success = true.         return byteCount.     } finally {         if (success) {             IOUtils.close(in, out).         } else {             IOUtils.closeWhileHandlingException(in, out).         }     } }
