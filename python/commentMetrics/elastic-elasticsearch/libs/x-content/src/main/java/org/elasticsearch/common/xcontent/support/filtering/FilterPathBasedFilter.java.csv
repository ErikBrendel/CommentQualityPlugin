commented;modifiers;parameterAmount;loc;comment;code
true;private;2;27;/**  * Evaluates if a property name matches one of the given filter paths.  */ ;/**  * Evaluates if a property name matches one of the given filter paths.  */ private TokenFilter evaluate(String name, FilterPath[] filters) {     if (filters != null) {         List<FilterPath> nextFilters = null.         for (FilterPath filter : filters) {             FilterPath next = filter.matchProperty(name).             if (next != null) {                 if (next.matches()) {                     return MATCHING.                 } else {                     if (nextFilters == null) {                         nextFilters = new ArrayList<>().                     }                     if (filter.isDoubleWildcard()) {                         nextFilters.add(filter).                     }                     nextFilters.add(next).                 }             }         }         if ((nextFilters != null) && (nextFilters.isEmpty() == false)) {             return new FilterPathBasedFilter(nextFilters.toArray(new FilterPath[nextFilters.size()]), inclusive).         }     }     return NO_MATCHING. }
false;public;1;11;;@Override public TokenFilter includeProperty(String name) {     TokenFilter filter = evaluate(name, filters).     if (filter == MATCHING) {         return inclusive ? TokenFilter.INCLUDE_ALL : null.     }     if (filter == NO_MATCHING) {         return inclusive ? null : TokenFilter.INCLUDE_ALL.     }     return filter. }
false;protected;0;4;;@Override protected boolean _includeScalar() {     return !inclusive. }
