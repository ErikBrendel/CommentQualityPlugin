commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;4;2;/**  * Declare some field. Usually it is easier to use {@link #declareString(BiConsumer, ParseField)} or  * {@link #declareObject(BiConsumer, ContextParser, ParseField)} rather than call this directly.  */ ;/**  * Declare some field. Usually it is easier to use {@link #declareString(BiConsumer, ParseField)} or  * {@link #declareObject(BiConsumer, ContextParser, ParseField)} rather than call this directly.  */ public abstract <T> void declareField(BiConsumer<Value, T> consumer, ContextParser<Context, T> parser, ParseField parseField, ValueType type).
true;public,abstract;3;2;/**  * Declares named objects in the style of aggregations. These are named  * inside and object like this:  *  * <pre>  * <code>  * {  *   "aggregations": {  *     "name_1": { "aggregation_type": {} },  *     "name_2": { "aggregation_type": {} },  *     "name_3": { "aggregation_type": {} }  *     }  *   }  * }  * </code>  * </pre>  *  * Unlike the other version of this method, "ordered" mode (arrays of  * objects) is not supported.  *  * See NamedObjectHolder in ObjectParserTests for examples of how to invoke  * this.  *  * @param consumer  *            sets the values once they have been parsed  * @param namedObjectParser  *            parses each named object  * @param parseField  *            the field to parse  */ ;/**  * Declares named objects in the style of aggregations. These are named  * inside and object like this:  *  * <pre>  * <code>  * {  *   "aggregations": {  *     "name_1": { "aggregation_type": {} },  *     "name_2": { "aggregation_type": {} },  *     "name_3": { "aggregation_type": {} }  *     }  *   }  * }  * </code>  * </pre>  *  * Unlike the other version of this method, "ordered" mode (arrays of  * objects) is not supported.  *  * See NamedObjectHolder in ObjectParserTests for examples of how to invoke  * this.  *  * @param consumer  *            sets the values once they have been parsed  * @param namedObjectParser  *            parses each named object  * @param parseField  *            the field to parse  */ public abstract <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser, ParseField parseField).
true;public,abstract;4;2;/**  * Declares named objects in the style of highlighting's field element.  * These are usually named inside and object like this:  *  * <pre>  * <code>  * {  *   "highlight": {  *     "fields": {        &lt.------ this one  *       "title": {},  *       "body": {},  *       "category": {}  *     }  *   }  * }  * </code>  * </pre>  *  * but, when order is important, some may be written this way:  *  * <pre>  * <code>  * {  *   "highlight": {  *     "fields": [        &lt.------ this one  *       {"title": {}},  *       {"body": {}},  *       {"category": {}}  *     ]  *   }  * }  * </code>  * </pre>  *  * This is because json doesn't enforce ordering. Elasticsearch reads it in  * the order sent but tools that generate json are free to put object  * members in an unordered Map, jumbling them. Thus, if you care about order  * you can send the object in the second way.  *  * See NamedObjectHolder in ObjectParserTests for examples of how to invoke  * this.  *  * @param consumer  *            sets the values once they have been parsed  * @param namedObjectParser  *            parses each named object  * @param orderedModeCallback  *            called when the named object is parsed using the "ordered"  *            mode (the array of objects)  * @param parseField  *            the field to parse  */ ;/**  * Declares named objects in the style of highlighting's field element.  * These are usually named inside and object like this:  *  * <pre>  * <code>  * {  *   "highlight": {  *     "fields": {        &lt.------ this one  *       "title": {},  *       "body": {},  *       "category": {}  *     }  *   }  * }  * </code>  * </pre>  *  * but, when order is important, some may be written this way:  *  * <pre>  * <code>  * {  *   "highlight": {  *     "fields": [        &lt.------ this one  *       {"title": {}},  *       {"body": {}},  *       {"category": {}}  *     ]  *   }  * }  * </code>  * </pre>  *  * This is because json doesn't enforce ordering. Elasticsearch reads it in  * the order sent but tools that generate json are free to put object  * members in an unordered Map, jumbling them. Thus, if you care about order  * you can send the object in the second way.  *  * See NamedObjectHolder in ObjectParserTests for examples of how to invoke  * this.  *  * @param consumer  *            sets the values once they have been parsed  * @param namedObjectParser  *            parses each named object  * @param orderedModeCallback  *            called when the named object is parsed using the "ordered"  *            mode (the array of objects)  * @param parseField  *            the field to parse  */ public abstract <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser, Consumer<Value> orderedModeCallback, ParseField parseField).
false;public,abstract;0;1;;public abstract String getName().
false;public;4;7;;public <T> void declareField(BiConsumer<Value, T> consumer, CheckedFunction<XContentParser, T, IOException> parser, ParseField parseField, ValueType type) {     if (parser == null) {         throw new IllegalArgumentException("[parser] is required").     }     declareField(consumer, (p, c) -> parser.apply(p), parseField, type). }
false;public;3;3;;public <T> void declareObject(BiConsumer<Value, T> consumer, ContextParser<Context, T> objectParser, ParseField field) {     declareField(consumer, (p, c) -> objectParser.parse(p, c), field, ValueType.OBJECT). }
false;public;2;4;;public void declareFloat(BiConsumer<Value, Float> consumer, ParseField field) {     // Using a method reference here angers some compilers     declareField(consumer, p -> p.floatValue(), field, ValueType.FLOAT). }
false;public;2;4;;public void declareDouble(BiConsumer<Value, Double> consumer, ParseField field) {     // Using a method reference here angers some compilers     declareField(consumer, p -> p.doubleValue(), field, ValueType.DOUBLE). }
false;public;2;4;;public void declareLong(BiConsumer<Value, Long> consumer, ParseField field) {     // Using a method reference here angers some compilers     declareField(consumer, p -> p.longValue(), field, ValueType.LONG). }
false;public;2;4;;public void declareInt(BiConsumer<Value, Integer> consumer, ParseField field) {     // Using a method reference here angers some compilers     declareField(consumer, p -> p.intValue(), field, ValueType.INT). }
false;public;2;3;;public void declareString(BiConsumer<Value, String> consumer, ParseField field) {     declareField(consumer, XContentParser::text, field, ValueType.STRING). }
false;public;2;4;;public void declareStringOrNull(BiConsumer<Value, String> consumer, ParseField field) {     declareField(consumer, (p) -> p.currentToken() == XContentParser.Token.VALUE_NULL ? null : p.text(), field, ValueType.STRING_OR_NULL). }
false;public;2;3;;public void declareBoolean(BiConsumer<Value, Boolean> consumer, ParseField field) {     declareField(consumer, XContentParser::booleanValue, field, ValueType.BOOLEAN). }
false;public;3;4;;public <T> void declareObjectArray(BiConsumer<Value, List<T>> consumer, ContextParser<Context, T> objectParser, ParseField field) {     declareFieldArray(consumer, (p, c) -> objectParser.parse(p, c), field, ValueType.OBJECT_ARRAY). }
false;public;2;3;;public void declareStringArray(BiConsumer<Value, List<String>> consumer, ParseField field) {     declareFieldArray(consumer, (p, c) -> p.text(), field, ValueType.STRING_ARRAY). }
false;public;2;3;;public void declareDoubleArray(BiConsumer<Value, List<Double>> consumer, ParseField field) {     declareFieldArray(consumer, (p, c) -> p.doubleValue(), field, ValueType.DOUBLE_ARRAY). }
false;public;2;3;;public void declareFloatArray(BiConsumer<Value, List<Float>> consumer, ParseField field) {     declareFieldArray(consumer, (p, c) -> p.floatValue(), field, ValueType.FLOAT_ARRAY). }
false;public;2;3;;public void declareLongArray(BiConsumer<Value, List<Long>> consumer, ParseField field) {     declareFieldArray(consumer, (p, c) -> p.longValue(), field, ValueType.LONG_ARRAY). }
false;public;2;3;;public void declareIntArray(BiConsumer<Value, List<Integer>> consumer, ParseField field) {     declareFieldArray(consumer, (p, c) -> p.intValue(), field, ValueType.INT_ARRAY). }
true;public;4;4;/**  * Declares a field that can contain an array of elements listed in the type ValueType enum  */ ;/**  * Declares a field that can contain an array of elements listed in the type ValueType enum  */ public <T> void declareFieldArray(BiConsumer<Value, List<T>> consumer, ContextParser<Context, T> itemParser, ParseField field, ValueType type) {     declareField(consumer, (p, c) -> parseArray(p, () -> itemParser.parse(p, c)), field, type). }
false;;0;1;;T get() throws IOException.
false;private,static;2;19;;private static <T> List<T> parseArray(XContentParser parser, IOSupplier<T> supplier) throws IOException {     List<T> list = new ArrayList<>().     if (parser.currentToken().isValue() || parser.currentToken() == XContentParser.Token.VALUE_NULL || parser.currentToken() == XContentParser.Token.START_OBJECT) {         // single value         list.add(supplier.get()).     } else {         while (parser.nextToken() != XContentParser.Token.END_ARRAY) {             if (parser.currentToken().isValue() || parser.currentToken() == XContentParser.Token.VALUE_NULL || parser.currentToken() == XContentParser.Token.START_OBJECT) {                 list.add(supplier.get()).             } else {                 throw new IllegalStateException("expected value but got [" + parser.currentToken() + "]").             }         }     }     return list. }
