commented;modifiers;parameterAmount;loc;comment;code
true;public;2;8;/**  * Call this to do the actual parsing. This implements {@link BiFunction} for conveniently integrating with ObjectParser.  */ ;/**  * Call this to do the actual parsing. This implements {@link BiFunction} for conveniently integrating with ObjectParser.  */ @Override public Value apply(XContentParser parser, Context context) {     try {         return parse(parser, context).     } catch (IOException e) {         throw new XContentParseException(parser.getTokenLocation(), "[" + objectParser.getName() + "] failed to parse object", e).     } }
false;public;2;4;;@Override public Value parse(XContentParser parser, Context context) throws IOException {     return objectParser.parse(parser, new Target(parser, context), context).finish(). }
true;public,static;0;4;/**  * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's  * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to  * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are  * parsed from the {@linkplain XContentParser} the target object is immediately built.  */ ;/**  * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's  * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to  * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are  * parsed from the {@linkplain XContentParser} the target object is immediately built.  */ // Safe because we never call the method. This is just trickery to make the interface pretty. @SuppressWarnings("unchecked") public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg() {     return (BiConsumer<Value, FieldT>) REQUIRED_CONSTRUCTOR_ARG_MARKER. }
true;public,static;0;4;/**  * Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's  * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to  * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are  * parsed from the {@linkplain XContentParser} the target object is immediately built.  */ ;/**  * Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's  * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to  * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are  * parsed from the {@linkplain XContentParser} the target object is immediately built.  */ // Safe because we never call the method. This is just trickery to make the interface pretty. @SuppressWarnings("unchecked") public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg() {     return (BiConsumer<Value, FieldT>) OPTIONAL_CONSTRUCTOR_ARG_MARKER. }
false;public;4;31;;@Override public <T> void declareField(BiConsumer<Value, T> consumer, ContextParser<Context, T> parser, ParseField parseField, ValueType type) {     if (consumer == null) {         throw new IllegalArgumentException("[consumer] is required").     }     if (parser == null) {         throw new IllegalArgumentException("[parser] is required").     }     if (parseField == null) {         throw new IllegalArgumentException("[parseField] is required").     }     if (type == null) {         throw new IllegalArgumentException("[type] is required").     }     if (consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER || consumer == OPTIONAL_CONSTRUCTOR_ARG_MARKER) {         /*              * Constructor arguments are detected by these "marker" consumers. It keeps the API looking clean even if it is a bit sleezy. We              * then build a new consumer directly against the object parser that triggers the "constructor arg just arrived behavior" of the              * parser. Conveniently, we can close over the position of the constructor in the argument list so we don't need to do any fancy              * or expensive lookups whenever the constructor args come in.              */         int position = constructorArgInfos.size().         boolean required = consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER.         constructorArgInfos.add(new ConstructorArgInfo(parseField, required)).         objectParser.declareField((target, v) -> target.constructorArg(position, v), parser, parseField, type).     } else {         numberOfFields += 1.         objectParser.declareField(queueingConsumer(consumer, parseField), parser, parseField, type).     } }
false;public;3;32;;@Override public <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser, ParseField parseField) {     if (consumer == null) {         throw new IllegalArgumentException("[consumer] is required").     }     if (namedObjectParser == null) {         throw new IllegalArgumentException("[parser] is required").     }     if (parseField == null) {         throw new IllegalArgumentException("[parseField] is required").     }     if (consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER || consumer == OPTIONAL_CONSTRUCTOR_ARG_MARKER) {         /*              * Constructor arguments are detected by this "marker" consumer. It              * keeps the API looking clean even if it is a bit sleezy. We then              * build a new consumer directly against the object parser that              * triggers the "constructor arg just arrived behavior" of the              * parser. Conveniently, we can close over the position of the              * constructor in the argument list so we don't need to do any fancy              * or expensive lookups whenever the constructor args come in.              */         int position = constructorArgInfos.size().         boolean required = consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER.         constructorArgInfos.add(new ConstructorArgInfo(parseField, required)).         objectParser.declareNamedObjects((target, v) -> target.constructorArg(position, v), namedObjectParser, parseField).     } else {         numberOfFields += 1.         objectParser.declareNamedObjects(queueingConsumer(consumer, parseField), namedObjectParser, parseField).     } }
false;public;4;37;;@Override public <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser, Consumer<Value> orderedModeCallback, ParseField parseField) {     if (consumer == null) {         throw new IllegalArgumentException("[consumer] is required").     }     if (namedObjectParser == null) {         throw new IllegalArgumentException("[parser] is required").     }     if (orderedModeCallback == null) {         throw new IllegalArgumentException("[orderedModeCallback] is required").     }     if (parseField == null) {         throw new IllegalArgumentException("[parseField] is required").     }     if (consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER || consumer == OPTIONAL_CONSTRUCTOR_ARG_MARKER) {         /*              * Constructor arguments are detected by this "marker" consumer. It              * keeps the API looking clean even if it is a bit sleezy. We then              * build a new consumer directly against the object parser that              * triggers the "constructor arg just arrived behavior" of the              * parser. Conveniently, we can close over the position of the              * constructor in the argument list so we don't need to do any fancy              * or expensive lookups whenever the constructor args come in.              */         int position = constructorArgInfos.size().         boolean required = consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER.         constructorArgInfos.add(new ConstructorArgInfo(parseField, required)).         objectParser.declareNamedObjects((target, v) -> target.constructorArg(position, v), namedObjectParser, wrapOrderedModeCallBack(orderedModeCallback), parseField).     } else {         numberOfFields += 1.         objectParser.declareNamedObjects(queueingConsumer(consumer, parseField), namedObjectParser, wrapOrderedModeCallBack(orderedModeCallback), parseField).     } }
false;public;0;4;;@Override public String getName() {     return objectParser.getName(). }
false;private;1;13;;private Consumer<Target> wrapOrderedModeCallBack(Consumer<Value> callback) {     return (target) -> {         if (target.targetObject != null) {             // The target has already been built. Call the callback now.             callback.accept(target.targetObject).             return.         }         /*              * The target hasn't been built. Queue the callback.              */         target.queuedOrderedModeCallback = callback.     }. }
true;private;2;24;/**  * Creates the consumer that does the "field just arrived" behavior. If the targetObject hasn't been built then it queues the value.  * Otherwise it just applies the value just like {@linkplain ObjectParser} does.  */ ;/**  * Creates the consumer that does the "field just arrived" behavior. If the targetObject hasn't been built then it queues the value.  * Otherwise it just applies the value just like {@linkplain ObjectParser} does.  */ private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField) {     return (target, v) -> {         if (target.targetObject != null) {             // The target has already been built. Just apply the consumer now.             consumer.accept(target.targetObject, v).             return.         }         /*              * The target hasn't been built. Queue the consumer. The next two lines are the only allocations that ConstructingObjectParser              * does during parsing other than the boxing the ObjectParser might do. The first one is to preserve a snapshot of the current              * location so we can add it to the error message if parsing fails. The second one (the lambda) is the actual operation being              * queued. Note that we don't do any of this if the target object has already been built.              */         XContentLocation location = target.parser.getTokenLocation().         target.queue(targetObject -> {             try {                 consumer.accept(targetObject, v).             } catch (Exception e) {                 throw new XContentParseException(location, "[" + objectParser.getName() + "] failed to parse field [" + parseField.getPreferredName() + "]", e).             }         }).     }. }
true;private;2;7;/**  * Set a constructor argument and build the target object if all constructor arguments have arrived.  */ ;/**  * Set a constructor argument and build the target object if all constructor arguments have arrived.  */ private void constructorArg(int position, Object value) {     constructorArgs[position] = value.     constructorArgsCollected++.     if (constructorArgsCollected == constructorArgInfos.size()) {         buildTarget().     } }
true;private;1;10;/**  * Queue a consumer that we'll call once the targetObject is built. If targetObject has been built this will fail because the caller  * should have just applied the consumer immediately.  */ ;/**  * Queue a consumer that we'll call once the targetObject is built. If targetObject has been built this will fail because the caller  * should have just applied the consumer immediately.  */ private void queue(Consumer<Value> queueMe) {     assert targetObject == null : "Don't queue after the targetObject has been built! Just apply the consumer directly.".     if (queuedFields == null) {         @SuppressWarnings({ "unchecked", "rawtypes" })         Consumer<Value>[] queuedFields = new Consumer[numberOfFields].         this.queuedFields = queuedFields.     }     queuedFields[queuedFieldsCount] = queueMe.     queuedFieldsCount++. }
true;private;0;36;/**  * Finish parsing the object.  */ ;/**  * Finish parsing the object.  */ private Value finish() {     if (targetObject != null) {         return targetObject.     }     /*              * The object hasn't been built which ought to mean we're missing some constructor arguments. But they could be optional! We'll              * check if they are all optional and build the error message at the same time - if we don't start the error message then they              * were all optional!              */     StringBuilder message = null.     for (int i = 0. i < constructorArgs.length. i++) {         if (constructorArgs[i] != null)             continue.         ConstructorArgInfo arg = constructorArgInfos.get(i).         if (false == arg.required)             continue.         if (message == null) {             message = new StringBuilder("Required [").append(arg.field).         } else {             message.append(", ").append(arg.field).         }     }     if (message != null) {         // There were non-optional constructor arguments missing.         throw new IllegalArgumentException(message.append(']').toString()).     }     /*              * If there weren't any constructor arguments declared at all then we won't get an error message but this isn't really a valid              * use of ConstructingObjectParser. You should be using ObjectParser instead. Since this is more of a programmer error and the              * parser ought to still work we just assert this.              */     assert false == constructorArgInfos.isEmpty() : "[" + objectParser.getName() + "] must configure at least one constructor " + "argument. If it doesn't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug " + "in the parser declaration.".     // All missing constructor arguments were optional. Just build the target and return it.     buildTarget().     return targetObject. }
false;private;0;18;;private void buildTarget() {     try {         targetObject = builder.apply(constructorArgs, context).         if (queuedOrderedModeCallback != null) {             queuedOrderedModeCallback.accept(targetObject).         }         while (queuedFieldsCount > 0) {             queuedFieldsCount -= 1.             queuedFields[queuedFieldsCount].accept(targetObject).         }     } catch (XContentParseException e) {         throw new XContentParseException(e.getLocation(), "failed to build [" + objectParser.getName() + "] after last required field arrived", e).     } catch (Exception e) {         throw new XContentParseException(null, "Failed to build [" + objectParser.getName() + "] after last required field arrived", e).     } }
