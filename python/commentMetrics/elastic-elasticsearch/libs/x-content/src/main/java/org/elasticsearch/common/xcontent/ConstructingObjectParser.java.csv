# id;timestamp;commentText;codeText;commentWords;codeWords
ConstructingObjectParser -> @Override     public Value apply(XContentParser parser, Context context);1524684173;Call this to do the actual parsing. This implements {@link BiFunction} for conveniently integrating with ObjectParser.;@Override_    public Value apply(XContentParser parser, Context context) {_        try {_            return parse(parser, context)__        } catch (IOException e) {_            throw new XContentParseException(parser.getTokenLocation(), "[" + objectParser.getName()  + "] failed to parse object", e)__        }_    };call,this,to,do,the,actual,parsing,this,implements,link,bi,function,for,conveniently,integrating,with,object,parser;override,public,value,apply,xcontent,parser,parser,context,context,try,return,parse,parser,context,catch,ioexception,e,throw,new,xcontent,parse,exception,parser,get,token,location,object,parser,get,name,failed,to,parse,object,e
ConstructingObjectParser -> @Override     public Value apply(XContentParser parser, Context context);1531729807;Call this to do the actual parsing. This implements {@link BiFunction} for conveniently integrating with ObjectParser.;@Override_    public Value apply(XContentParser parser, Context context) {_        try {_            return parse(parser, context)__        } catch (IOException e) {_            throw new XContentParseException(parser.getTokenLocation(), "[" + objectParser.getName()  + "] failed to parse object", e)__        }_    };call,this,to,do,the,actual,parsing,this,implements,link,bi,function,for,conveniently,integrating,with,object,parser;override,public,value,apply,xcontent,parser,parser,context,context,try,return,parse,parser,context,catch,ioexception,e,throw,new,xcontent,parse,exception,parser,get,token,location,object,parser,get,name,failed,to,parse,object,e
ConstructingObjectParser -> @Override     public Value apply(XContentParser parser, Context context);1539951844;Call this to do the actual parsing. This implements {@link BiFunction} for conveniently integrating with ObjectParser.;@Override_    public Value apply(XContentParser parser, Context context) {_        try {_            return parse(parser, context)__        } catch (IOException e) {_            throw new XContentParseException(parser.getTokenLocation(), "[" + objectParser.getName()  + "] failed to parse object", e)__        }_    };call,this,to,do,the,actual,parsing,this,implements,link,bi,function,for,conveniently,integrating,with,object,parser;override,public,value,apply,xcontent,parser,parser,context,context,try,return,parse,parser,context,catch,ioexception,e,throw,new,xcontent,parse,exception,parser,get,token,location,object,parser,get,name,failed,to,parse,object,e
ConstructingObjectParser -> Target -> private Value finish();1524684173;Finish parsing the object.;private Value finish() {_            if (targetObject != null) {_                return targetObject__            }_            _            StringBuilder message = null__            for (int i = 0_ i < constructorArgs.length_ i++) {_                if (constructorArgs[i] != null) continue__                ConstructorArgInfo arg = constructorArgInfos.get(i)__                if (false == arg.required) continue__                if (message == null) {_                    message = new StringBuilder("Required [").append(arg.field)__                } else {_                    message.append(", ").append(arg.field)__                }_            }_            if (message != null) {_                _                throw new IllegalArgumentException(message.append(']').toString())__            }_            _            assert false == constructorArgInfos.isEmpty() : "[" + objectParser.getName() + "] must configure at least one constructor "_                        + "argument. If it doesn't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug "_                        + "in the parser declaration."__            _            buildTarget()__            return targetObject__        };finish,parsing,the,object;private,value,finish,if,target,object,null,return,target,object,string,builder,message,null,for,int,i,0,i,constructor,args,length,i,if,constructor,args,i,null,continue,constructor,arg,info,arg,constructor,arg,infos,get,i,if,false,arg,required,continue,if,message,null,message,new,string,builder,required,append,arg,field,else,message,append,append,arg,field,if,message,null,throw,new,illegal,argument,exception,message,append,to,string,assert,false,constructor,arg,infos,is,empty,object,parser,get,name,must,configure,at,least,one,constructor,argument,if,it,doesn,t,have,any,it,should,use,object,parser,instead,of,constructing,object,parser,this,is,a,bug,in,the,parser,declaration,build,target,return,target,object
ConstructingObjectParser -> Target -> private Value finish();1531729807;Finish parsing the object.;private Value finish() {_            if (targetObject != null) {_                return targetObject__            }_            _            StringBuilder message = null__            for (int i = 0_ i < constructorArgs.length_ i++) {_                if (constructorArgs[i] != null) continue__                ConstructorArgInfo arg = constructorArgInfos.get(i)__                if (false == arg.required) continue__                if (message == null) {_                    message = new StringBuilder("Required [").append(arg.field)__                } else {_                    message.append(", ").append(arg.field)__                }_            }_            if (message != null) {_                _                throw new IllegalArgumentException(message.append(']').toString())__            }_            _            assert false == constructorArgInfos.isEmpty() : "[" + objectParser.getName() + "] must configure at least one constructor "_                        + "argument. If it doesn't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug "_                        + "in the parser declaration."__            _            buildTarget()__            return targetObject__        };finish,parsing,the,object;private,value,finish,if,target,object,null,return,target,object,string,builder,message,null,for,int,i,0,i,constructor,args,length,i,if,constructor,args,i,null,continue,constructor,arg,info,arg,constructor,arg,infos,get,i,if,false,arg,required,continue,if,message,null,message,new,string,builder,required,append,arg,field,else,message,append,append,arg,field,if,message,null,throw,new,illegal,argument,exception,message,append,to,string,assert,false,constructor,arg,infos,is,empty,object,parser,get,name,must,configure,at,least,one,constructor,argument,if,it,doesn,t,have,any,it,should,use,object,parser,instead,of,constructing,object,parser,this,is,a,bug,in,the,parser,declaration,build,target,return,target,object
ConstructingObjectParser -> Target -> private Value finish();1539951844;Finish parsing the object.;private Value finish() {_            if (targetObject != null) {_                return targetObject__            }_            _            StringBuilder message = null__            for (int i = 0_ i < constructorArgs.length_ i++) {_                if (constructorArgs[i] != null) continue__                ConstructorArgInfo arg = constructorArgInfos.get(i)__                if (false == arg.required) continue__                if (message == null) {_                    message = new StringBuilder("Required [").append(arg.field)__                } else {_                    message.append(", ").append(arg.field)__                }_            }_            if (message != null) {_                _                throw new IllegalArgumentException(message.append(']').toString())__            }_            _            assert false == constructorArgInfos.isEmpty() : "[" + objectParser.getName() + "] must configure at least one constructor "_                        + "argument. If it doesn't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug "_                        + "in the parser declaration."__            _            buildTarget()__            return targetObject__        };finish,parsing,the,object;private,value,finish,if,target,object,null,return,target,object,string,builder,message,null,for,int,i,0,i,constructor,args,length,i,if,constructor,args,i,null,continue,constructor,arg,info,arg,constructor,arg,infos,get,i,if,false,arg,required,continue,if,message,null,message,new,string,builder,required,append,arg,field,else,message,append,append,arg,field,if,message,null,throw,new,illegal,argument,exception,message,append,to,string,assert,false,constructor,arg,infos,is,empty,object,parser,get,name,must,configure,at,least,one,constructor,argument,if,it,doesn,t,have,any,it,should,use,object,parser,instead,of,constructing,object,parser,this,is,a,bug,in,the,parser,declaration,build,target,return,target,object
ConstructingObjectParser -> public ConstructingObjectParser(String name, boolean ignoreUnknownFields, Function<Object[], Value> builder);1524684173;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing responses_from external systems, never when parsing requests from users._@param builder A function that builds the object from an array of Objects. Declare this inline with the parser, casting the elements_of the array to the arguments so they work with your favorite constructor. The objects in the array will be in the same order_that you declared the {@link #constructorArg()}s and none will be null. If any of the constructor arguments aren't defined in_the XContent then parsing will throw an error. We use an array here rather than a {@code Map<String, Object>} to save on_allocations.;public ConstructingObjectParser(String name, boolean ignoreUnknownFields, Function<Object[], Value> builder) {_        this(name, ignoreUnknownFields, (args, context) -> builder.apply(args))__    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,ignore,unknown,fields,should,this,parser,ignore,unknown,fields,this,should,generally,be,set,to,true,only,when,parsing,responses,from,external,systems,never,when,parsing,requests,from,users,param,builder,a,function,that,builds,the,object,from,an,array,of,objects,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,boolean,ignore,unknown,fields,function,object,value,builder,this,name,ignore,unknown,fields,args,context,builder,apply,args
ConstructingObjectParser -> public ConstructingObjectParser(String name, boolean ignoreUnknownFields, Function<Object[], Value> builder);1531729807;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing responses_from external systems, never when parsing requests from users._@param builder A function that builds the object from an array of Objects. Declare this inline with the parser, casting the elements_of the array to the arguments so they work with your favorite constructor. The objects in the array will be in the same order_that you declared the {@link #constructorArg()}s and none will be null. If any of the constructor arguments aren't defined in_the XContent then parsing will throw an error. We use an array here rather than a {@code Map<String, Object>} to save on_allocations.;public ConstructingObjectParser(String name, boolean ignoreUnknownFields, Function<Object[], Value> builder) {_        this(name, ignoreUnknownFields, (args, context) -> builder.apply(args))__    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,ignore,unknown,fields,should,this,parser,ignore,unknown,fields,this,should,generally,be,set,to,true,only,when,parsing,responses,from,external,systems,never,when,parsing,requests,from,users,param,builder,a,function,that,builds,the,object,from,an,array,of,objects,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,boolean,ignore,unknown,fields,function,object,value,builder,this,name,ignore,unknown,fields,args,context,builder,apply,args
ConstructingObjectParser -> public ConstructingObjectParser(String name, boolean ignoreUnknownFields, Function<Object[], Value> builder);1539951844;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing responses_from external systems, never when parsing requests from users._@param builder A function that builds the object from an array of Objects. Declare this inline with the parser, casting the elements_of the array to the arguments so they work with your favorite constructor. The objects in the array will be in the same order_that you declared the {@link #constructorArg()}s and none will be null. If any of the constructor arguments aren't defined in_the XContent then parsing will throw an error. We use an array here rather than a {@code Map<String, Object>} to save on_allocations.;public ConstructingObjectParser(String name, boolean ignoreUnknownFields, Function<Object[], Value> builder) {_        this(name, ignoreUnknownFields, (args, context) -> builder.apply(args))__    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,ignore,unknown,fields,should,this,parser,ignore,unknown,fields,this,should,generally,be,set,to,true,only,when,parsing,responses,from,external,systems,never,when,parsing,requests,from,users,param,builder,a,function,that,builds,the,object,from,an,array,of,objects,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,boolean,ignore,unknown,fields,function,object,value,builder,this,name,ignore,unknown,fields,args,context,builder,apply,args
ConstructingObjectParser -> @SuppressWarnings("unchecked")      public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg();1524684173;Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's_javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to_{@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are_parsed from the {@linkplain XContentParser} the target object is immediately built.;@SuppressWarnings("unchecked") _    public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg() {_        return (BiConsumer<Value, FieldT>) OPTIONAL_CONSTRUCTOR_ARG_MARKER__    };pass,the,linkplain,bi,consumer,this,returns,the,declare,methods,to,declare,an,optional,constructor,argument,see,this,class,s,javadoc,for,an,example,the,order,in,which,these,are,declared,matters,it,is,the,order,that,they,come,in,the,array,passed,to,link,builder,and,the,order,that,missing,arguments,are,reported,to,the,user,if,any,are,missing,when,all,of,these,parameters,are,parsed,from,the,linkplain,xcontent,parser,the,target,object,is,immediately,built;suppress,warnings,unchecked,public,static,value,field,t,bi,consumer,value,field,t,optional,constructor,arg,return,bi,consumer,value,field,t
ConstructingObjectParser -> @SuppressWarnings("unchecked")      public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg();1531729807;Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's_javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to_{@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are_parsed from the {@linkplain XContentParser} the target object is immediately built.;@SuppressWarnings("unchecked") _    public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg() {_        return (BiConsumer<Value, FieldT>) OPTIONAL_CONSTRUCTOR_ARG_MARKER__    };pass,the,linkplain,bi,consumer,this,returns,the,declare,methods,to,declare,an,optional,constructor,argument,see,this,class,s,javadoc,for,an,example,the,order,in,which,these,are,declared,matters,it,is,the,order,that,they,come,in,the,array,passed,to,link,builder,and,the,order,that,missing,arguments,are,reported,to,the,user,if,any,are,missing,when,all,of,these,parameters,are,parsed,from,the,linkplain,xcontent,parser,the,target,object,is,immediately,built;suppress,warnings,unchecked,public,static,value,field,t,bi,consumer,value,field,t,optional,constructor,arg,return,bi,consumer,value,field,t
ConstructingObjectParser -> @SuppressWarnings("unchecked")      public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg();1539951844;Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's_javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to_{@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are_parsed from the {@linkplain XContentParser} the target object is immediately built.;@SuppressWarnings("unchecked") _    public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg() {_        return (BiConsumer<Value, FieldT>) OPTIONAL_CONSTRUCTOR_ARG_MARKER__    };pass,the,linkplain,bi,consumer,this,returns,the,declare,methods,to,declare,an,optional,constructor,argument,see,this,class,s,javadoc,for,an,example,the,order,in,which,these,are,declared,matters,it,is,the,order,that,they,come,in,the,array,passed,to,link,builder,and,the,order,that,missing,arguments,are,reported,to,the,user,if,any,are,missing,when,all,of,these,parameters,are,parsed,from,the,linkplain,xcontent,parser,the,target,object,is,immediately,built;suppress,warnings,unchecked,public,static,value,field,t,bi,consumer,value,field,t,optional,constructor,arg,return,bi,consumer,value,field,t
ConstructingObjectParser -> public ConstructingObjectParser(String name, boolean ignoreUnknownFields, BiFunction<Object[], Context, Value> builder);1524684173;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing responses_from external systems, never when parsing requests from users._@param builder A binary function that builds the object from an array of Objects and the parser context.  Declare this inline with_the parser, casting the elements of the array to the arguments so they work with your favorite constructor. The objects in_the array will be in the same order that you declared the {@link #constructorArg()}s and none will be null. The second_argument is the value of the context provided to the {@link #parse(XContentParser, Object) parse function}. If any of the_constructor arguments aren't defined in the XContent then parsing will throw an error. We use an array here rather than a_{@code Map<String, Object>} to save on allocations.;public ConstructingObjectParser(String name, boolean ignoreUnknownFields, BiFunction<Object[], Context, Value> builder) {_        objectParser = new ObjectParser<>(name, ignoreUnknownFields, null)__        this.builder = builder___    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,ignore,unknown,fields,should,this,parser,ignore,unknown,fields,this,should,generally,be,set,to,true,only,when,parsing,responses,from,external,systems,never,when,parsing,requests,from,users,param,builder,a,binary,function,that,builds,the,object,from,an,array,of,objects,and,the,parser,context,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,the,second,argument,is,the,value,of,the,context,provided,to,the,link,parse,xcontent,parser,object,parse,function,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,boolean,ignore,unknown,fields,bi,function,object,context,value,builder,object,parser,new,object,parser,name,ignore,unknown,fields,null,this,builder,builder
ConstructingObjectParser -> public ConstructingObjectParser(String name, boolean ignoreUnknownFields, BiFunction<Object[], Context, Value> builder);1531729807;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing responses_from external systems, never when parsing requests from users._@param builder A binary function that builds the object from an array of Objects and the parser context.  Declare this inline with_the parser, casting the elements of the array to the arguments so they work with your favorite constructor. The objects in_the array will be in the same order that you declared the {@link #constructorArg()}s and none will be null. The second_argument is the value of the context provided to the {@link #parse(XContentParser, Object) parse function}. If any of the_constructor arguments aren't defined in the XContent then parsing will throw an error. We use an array here rather than a_{@code Map<String, Object>} to save on allocations.;public ConstructingObjectParser(String name, boolean ignoreUnknownFields, BiFunction<Object[], Context, Value> builder) {_        objectParser = new ObjectParser<>(name, ignoreUnknownFields, null)__        this.builder = builder___    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,ignore,unknown,fields,should,this,parser,ignore,unknown,fields,this,should,generally,be,set,to,true,only,when,parsing,responses,from,external,systems,never,when,parsing,requests,from,users,param,builder,a,binary,function,that,builds,the,object,from,an,array,of,objects,and,the,parser,context,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,the,second,argument,is,the,value,of,the,context,provided,to,the,link,parse,xcontent,parser,object,parse,function,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,boolean,ignore,unknown,fields,bi,function,object,context,value,builder,object,parser,new,object,parser,name,ignore,unknown,fields,null,this,builder,builder
ConstructingObjectParser -> public ConstructingObjectParser(String name, boolean ignoreUnknownFields, BiFunction<Object[], Context, Value> builder);1539951844;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing responses_from external systems, never when parsing requests from users._@param builder A binary function that builds the object from an array of Objects and the parser context.  Declare this inline with_the parser, casting the elements of the array to the arguments so they work with your favorite constructor. The objects in_the array will be in the same order that you declared the {@link #constructorArg()}s and none will be null. The second_argument is the value of the context provided to the {@link #parse(XContentParser, Object) parse function}. If any of the_constructor arguments aren't defined in the XContent then parsing will throw an error. We use an array here rather than a_{@code Map<String, Object>} to save on allocations.;public ConstructingObjectParser(String name, boolean ignoreUnknownFields, BiFunction<Object[], Context, Value> builder) {_        objectParser = new ObjectParser<>(name, ignoreUnknownFields, null)__        this.builder = builder___    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,ignore,unknown,fields,should,this,parser,ignore,unknown,fields,this,should,generally,be,set,to,true,only,when,parsing,responses,from,external,systems,never,when,parsing,requests,from,users,param,builder,a,binary,function,that,builds,the,object,from,an,array,of,objects,and,the,parser,context,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,the,second,argument,is,the,value,of,the,context,provided,to,the,link,parse,xcontent,parser,object,parse,function,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,boolean,ignore,unknown,fields,bi,function,object,context,value,builder,object,parser,new,object,parser,name,ignore,unknown,fields,null,this,builder,builder
ConstructingObjectParser -> Target -> private void constructorArg(int position, ParseField parseField, Object value);1524684173;Set a constructor argument and build the target object if all constructor arguments have arrived.;private void constructorArg(int position, ParseField parseField, Object value) {_            if (constructorArgs[position] != null) {_                throw new IllegalArgumentException("Can't repeat param [" + parseField + "]")__            }_            constructorArgs[position] = value__            constructorArgsCollected++__            if (constructorArgsCollected == constructorArgInfos.size()) {_                buildTarget()__            }_        };set,a,constructor,argument,and,build,the,target,object,if,all,constructor,arguments,have,arrived;private,void,constructor,arg,int,position,parse,field,parse,field,object,value,if,constructor,args,position,null,throw,new,illegal,argument,exception,can,t,repeat,param,parse,field,constructor,args,position,value,constructor,args,collected,if,constructor,args,collected,constructor,arg,infos,size,build,target
ConstructingObjectParser -> Target -> private void constructorArg(int position, ParseField parseField, Object value);1531729807;Set a constructor argument and build the target object if all constructor arguments have arrived.;private void constructorArg(int position, ParseField parseField, Object value) {_            if (constructorArgs[position] != null) {_                throw new IllegalArgumentException("Can't repeat param [" + parseField + "]")__            }_            constructorArgs[position] = value__            constructorArgsCollected++__            if (constructorArgsCollected == constructorArgInfos.size()) {_                buildTarget()__            }_        };set,a,constructor,argument,and,build,the,target,object,if,all,constructor,arguments,have,arrived;private,void,constructor,arg,int,position,parse,field,parse,field,object,value,if,constructor,args,position,null,throw,new,illegal,argument,exception,can,t,repeat,param,parse,field,constructor,args,position,value,constructor,args,collected,if,constructor,args,collected,constructor,arg,infos,size,build,target
ConstructingObjectParser -> private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField);1524684173;Creates the consumer that does the "field just arrived" behavior. If the targetObject hasn't been built then it queues the value._Otherwise it just applies the value just like {@linkplain ObjectParser} does.;private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField) {_        return (target, v) -> {_            if (target.targetObject != null) {_                _                consumer.accept(target.targetObject, v)__                return__            }_            _            XContentLocation location = target.parser.getTokenLocation()__            target.queue(targetObject -> {_                try {_                    consumer.accept(targetObject, v)__                } catch (Exception e) {_                    throw new XContentParseException(location,_                            "[" + objectParser.getName() + "] failed to parse field [" + parseField.getPreferredName() + "]", e)__                }_            })__        }__    };creates,the,consumer,that,does,the,field,just,arrived,behavior,if,the,target,object,hasn,t,been,built,then,it,queues,the,value,otherwise,it,just,applies,the,value,just,like,linkplain,object,parser,does;private,t,bi,consumer,target,t,queueing,consumer,bi,consumer,value,t,consumer,parse,field,parse,field,return,target,v,if,target,target,object,null,consumer,accept,target,target,object,v,return,xcontent,location,location,target,parser,get,token,location,target,queue,target,object,try,consumer,accept,target,object,v,catch,exception,e,throw,new,xcontent,parse,exception,location,object,parser,get,name,failed,to,parse,field,parse,field,get,preferred,name,e
ConstructingObjectParser -> private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField);1531729807;Creates the consumer that does the "field just arrived" behavior. If the targetObject hasn't been built then it queues the value._Otherwise it just applies the value just like {@linkplain ObjectParser} does.;private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField) {_        return (target, v) -> {_            if (target.targetObject != null) {_                _                consumer.accept(target.targetObject, v)__                return__            }_            _            XContentLocation location = target.parser.getTokenLocation()__            target.queue(targetObject -> {_                try {_                    consumer.accept(targetObject, v)__                } catch (Exception e) {_                    throw new XContentParseException(location,_                            "[" + objectParser.getName() + "] failed to parse field [" + parseField.getPreferredName() + "]", e)__                }_            })__        }__    };creates,the,consumer,that,does,the,field,just,arrived,behavior,if,the,target,object,hasn,t,been,built,then,it,queues,the,value,otherwise,it,just,applies,the,value,just,like,linkplain,object,parser,does;private,t,bi,consumer,target,t,queueing,consumer,bi,consumer,value,t,consumer,parse,field,parse,field,return,target,v,if,target,target,object,null,consumer,accept,target,target,object,v,return,xcontent,location,location,target,parser,get,token,location,target,queue,target,object,try,consumer,accept,target,object,v,catch,exception,e,throw,new,xcontent,parse,exception,location,object,parser,get,name,failed,to,parse,field,parse,field,get,preferred,name,e
ConstructingObjectParser -> private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField);1539951844;Creates the consumer that does the "field just arrived" behavior. If the targetObject hasn't been built then it queues the value._Otherwise it just applies the value just like {@linkplain ObjectParser} does.;private <T> BiConsumer<Target, T> queueingConsumer(BiConsumer<Value, T> consumer, ParseField parseField) {_        return (target, v) -> {_            if (target.targetObject != null) {_                _                consumer.accept(target.targetObject, v)__                return__            }_            _            XContentLocation location = target.parser.getTokenLocation()__            target.queue(targetObject -> {_                try {_                    consumer.accept(targetObject, v)__                } catch (Exception e) {_                    throw new XContentParseException(location,_                            "[" + objectParser.getName() + "] failed to parse field [" + parseField.getPreferredName() + "]", e)__                }_            })__        }__    };creates,the,consumer,that,does,the,field,just,arrived,behavior,if,the,target,object,hasn,t,been,built,then,it,queues,the,value,otherwise,it,just,applies,the,value,just,like,linkplain,object,parser,does;private,t,bi,consumer,target,t,queueing,consumer,bi,consumer,value,t,consumer,parse,field,parse,field,return,target,v,if,target,target,object,null,consumer,accept,target,target,object,v,return,xcontent,location,location,target,parser,get,token,location,target,queue,target,object,try,consumer,accept,target,object,v,catch,exception,e,throw,new,xcontent,parse,exception,location,object,parser,get,name,failed,to,parse,field,parse,field,get,preferred,name,e
ConstructingObjectParser -> Target -> private void queue(Consumer<Value> queueMe);1524684173;Queue a consumer that we'll call once the targetObject is built. If targetObject has been built this will fail because the caller_should have just applied the consumer immediately.;private void queue(Consumer<Value> queueMe) {_            assert targetObject == null: "Don't queue after the targetObject has been built! Just apply the consumer directly."__            if (queuedFields == null) {_                @SuppressWarnings({"unchecked", "rawtypes"})_                Consumer<Value>[] queuedFields = new Consumer[numberOfFields]__                this.queuedFields = queuedFields__            }_            queuedFields[queuedFieldsCount] = queueMe__            queuedFieldsCount++__        };queue,a,consumer,that,we,ll,call,once,the,target,object,is,built,if,target,object,has,been,built,this,will,fail,because,the,caller,should,have,just,applied,the,consumer,immediately;private,void,queue,consumer,value,queue,me,assert,target,object,null,don,t,queue,after,the,target,object,has,been,built,just,apply,the,consumer,directly,if,queued,fields,null,suppress,warnings,unchecked,rawtypes,consumer,value,queued,fields,new,consumer,number,of,fields,this,queued,fields,queued,fields,queued,fields,queued,fields,count,queue,me,queued,fields,count
ConstructingObjectParser -> Target -> private void queue(Consumer<Value> queueMe);1531729807;Queue a consumer that we'll call once the targetObject is built. If targetObject has been built this will fail because the caller_should have just applied the consumer immediately.;private void queue(Consumer<Value> queueMe) {_            assert targetObject == null: "Don't queue after the targetObject has been built! Just apply the consumer directly."__            if (queuedFields == null) {_                @SuppressWarnings({"unchecked", "rawtypes"})_                Consumer<Value>[] queuedFields = new Consumer[numberOfFields]__                this.queuedFields = queuedFields__            }_            queuedFields[queuedFieldsCount] = queueMe__            queuedFieldsCount++__        };queue,a,consumer,that,we,ll,call,once,the,target,object,is,built,if,target,object,has,been,built,this,will,fail,because,the,caller,should,have,just,applied,the,consumer,immediately;private,void,queue,consumer,value,queue,me,assert,target,object,null,don,t,queue,after,the,target,object,has,been,built,just,apply,the,consumer,directly,if,queued,fields,null,suppress,warnings,unchecked,rawtypes,consumer,value,queued,fields,new,consumer,number,of,fields,this,queued,fields,queued,fields,queued,fields,queued,fields,count,queue,me,queued,fields,count
ConstructingObjectParser -> Target -> private void queue(Consumer<Value> queueMe);1539951844;Queue a consumer that we'll call once the targetObject is built. If targetObject has been built this will fail because the caller_should have just applied the consumer immediately.;private void queue(Consumer<Value> queueMe) {_            assert targetObject == null: "Don't queue after the targetObject has been built! Just apply the consumer directly."__            if (queuedFields == null) {_                @SuppressWarnings({"unchecked", "rawtypes"})_                Consumer<Value>[] queuedFields = new Consumer[numberOfFields]__                this.queuedFields = queuedFields__            }_            queuedFields[queuedFieldsCount] = queueMe__            queuedFieldsCount++__        };queue,a,consumer,that,we,ll,call,once,the,target,object,is,built,if,target,object,has,been,built,this,will,fail,because,the,caller,should,have,just,applied,the,consumer,immediately;private,void,queue,consumer,value,queue,me,assert,target,object,null,don,t,queue,after,the,target,object,has,been,built,just,apply,the,consumer,directly,if,queued,fields,null,suppress,warnings,unchecked,rawtypes,consumer,value,queued,fields,new,consumer,number,of,fields,this,queued,fields,queued,fields,queued,fields,queued,fields,count,queue,me,queued,fields,count
ConstructingObjectParser -> public ConstructingObjectParser(String name, Function<Object[], Value> builder);1524684173;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param builder A function that builds the object from an array of Objects. Declare this inline with the parser, casting the elements_of the array to the arguments so they work with your favorite constructor. The objects in the array will be in the same order_that you declared the {@link #constructorArg()}s and none will be null. If any of the constructor arguments aren't defined in_the XContent then parsing will throw an error. We use an array here rather than a {@code Map<String, Object>} to save on_allocations.;public ConstructingObjectParser(String name, Function<Object[], Value> builder) {_        this(name, false, builder)__    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,builder,a,function,that,builds,the,object,from,an,array,of,objects,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,function,object,value,builder,this,name,false,builder
ConstructingObjectParser -> public ConstructingObjectParser(String name, Function<Object[], Value> builder);1531729807;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param builder A function that builds the object from an array of Objects. Declare this inline with the parser, casting the elements_of the array to the arguments so they work with your favorite constructor. The objects in the array will be in the same order_that you declared the {@link #constructorArg()}s and none will be null. If any of the constructor arguments aren't defined in_the XContent then parsing will throw an error. We use an array here rather than a {@code Map<String, Object>} to save on_allocations.;public ConstructingObjectParser(String name, Function<Object[], Value> builder) {_        this(name, false, builder)__    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,builder,a,function,that,builds,the,object,from,an,array,of,objects,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,function,object,value,builder,this,name,false,builder
ConstructingObjectParser -> public ConstructingObjectParser(String name, Function<Object[], Value> builder);1539951844;Build the parser.__@param name The name given to the delegate ObjectParser for error identification. Use what you'd use if the object worked with_ObjectParser._@param builder A function that builds the object from an array of Objects. Declare this inline with the parser, casting the elements_of the array to the arguments so they work with your favorite constructor. The objects in the array will be in the same order_that you declared the {@link #constructorArg()}s and none will be null. If any of the constructor arguments aren't defined in_the XContent then parsing will throw an error. We use an array here rather than a {@code Map<String, Object>} to save on_allocations.;public ConstructingObjectParser(String name, Function<Object[], Value> builder) {_        this(name, false, builder)__    };build,the,parser,param,name,the,name,given,to,the,delegate,object,parser,for,error,identification,use,what,you,d,use,if,the,object,worked,with,object,parser,param,builder,a,function,that,builds,the,object,from,an,array,of,objects,declare,this,inline,with,the,parser,casting,the,elements,of,the,array,to,the,arguments,so,they,work,with,your,favorite,constructor,the,objects,in,the,array,will,be,in,the,same,order,that,you,declared,the,link,constructor,arg,s,and,none,will,be,null,if,any,of,the,constructor,arguments,aren,t,defined,in,the,xcontent,then,parsing,will,throw,an,error,we,use,an,array,here,rather,than,a,code,map,string,object,to,save,on,allocations;public,constructing,object,parser,string,name,function,object,value,builder,this,name,false,builder
ConstructingObjectParser -> @SuppressWarnings("unchecked")      public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg();1524684173;Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's_javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to_{@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are_parsed from the {@linkplain XContentParser} the target object is immediately built.;@SuppressWarnings("unchecked") _    public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg() {_        return (BiConsumer<Value, FieldT>) REQUIRED_CONSTRUCTOR_ARG_MARKER__    };pass,the,linkplain,bi,consumer,this,returns,the,declare,methods,to,declare,a,required,constructor,argument,see,this,class,s,javadoc,for,an,example,the,order,in,which,these,are,declared,matters,it,is,the,order,that,they,come,in,the,array,passed,to,link,builder,and,the,order,that,missing,arguments,are,reported,to,the,user,if,any,are,missing,when,all,of,these,parameters,are,parsed,from,the,linkplain,xcontent,parser,the,target,object,is,immediately,built;suppress,warnings,unchecked,public,static,value,field,t,bi,consumer,value,field,t,constructor,arg,return,bi,consumer,value,field,t
ConstructingObjectParser -> @SuppressWarnings("unchecked")      public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg();1531729807;Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's_javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to_{@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are_parsed from the {@linkplain XContentParser} the target object is immediately built.;@SuppressWarnings("unchecked") _    public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg() {_        return (BiConsumer<Value, FieldT>) REQUIRED_CONSTRUCTOR_ARG_MARKER__    };pass,the,linkplain,bi,consumer,this,returns,the,declare,methods,to,declare,a,required,constructor,argument,see,this,class,s,javadoc,for,an,example,the,order,in,which,these,are,declared,matters,it,is,the,order,that,they,come,in,the,array,passed,to,link,builder,and,the,order,that,missing,arguments,are,reported,to,the,user,if,any,are,missing,when,all,of,these,parameters,are,parsed,from,the,linkplain,xcontent,parser,the,target,object,is,immediately,built;suppress,warnings,unchecked,public,static,value,field,t,bi,consumer,value,field,t,constructor,arg,return,bi,consumer,value,field,t
ConstructingObjectParser -> @SuppressWarnings("unchecked")      public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg();1539951844;Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's_javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to_{@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are_parsed from the {@linkplain XContentParser} the target object is immediately built.;@SuppressWarnings("unchecked") _    public static <Value, FieldT> BiConsumer<Value, FieldT> constructorArg() {_        return (BiConsumer<Value, FieldT>) REQUIRED_CONSTRUCTOR_ARG_MARKER__    };pass,the,linkplain,bi,consumer,this,returns,the,declare,methods,to,declare,a,required,constructor,argument,see,this,class,s,javadoc,for,an,example,the,order,in,which,these,are,declared,matters,it,is,the,order,that,they,come,in,the,array,passed,to,link,builder,and,the,order,that,missing,arguments,are,reported,to,the,user,if,any,are,missing,when,all,of,these,parameters,are,parsed,from,the,linkplain,xcontent,parser,the,target,object,is,immediately,built;suppress,warnings,unchecked,public,static,value,field,t,bi,consumer,value,field,t,constructor,arg,return,bi,consumer,value,field,t
