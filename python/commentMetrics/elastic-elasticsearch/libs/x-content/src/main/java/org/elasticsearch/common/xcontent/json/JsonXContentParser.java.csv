commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public XContentType contentType() {     return XContentType.JSON. }
false;public;0;4;;@Override public Token nextToken() throws IOException {     return convertToken(parser.nextToken()). }
false;public;0;4;;@Override public void skipChildren() throws IOException {     parser.skipChildren(). }
false;public;0;4;;@Override public Token currentToken() {     return convertToken(parser.getCurrentToken()). }
false;public;0;4;;@Override public NumberType numberType() throws IOException {     return convertNumberType(parser.getNumberType()). }
false;public;0;4;;@Override public String currentName() throws IOException {     return parser.getCurrentName(). }
false;protected;0;4;;@Override protected boolean doBooleanValue() throws IOException {     return parser.getBooleanValue(). }
false;public;0;7;;@Override public String text() throws IOException {     if (currentToken().isValue()) {         return parser.getText().     }     throw new IllegalStateException("Can't get text on a " + currentToken() + " at " + getTokenLocation()). }
false;public;0;4;;@Override public CharBuffer charBuffer() throws IOException {     return CharBuffer.wrap(parser.getTextCharacters(), parser.getTextOffset(), parser.getTextLength()). }
false;public;0;17;;@Override public Object objectText() throws IOException {     JsonToken currentToken = parser.getCurrentToken().     if (currentToken == JsonToken.VALUE_STRING) {         return text().     } else if (currentToken == JsonToken.VALUE_NUMBER_INT || currentToken == JsonToken.VALUE_NUMBER_FLOAT) {         return parser.getNumberValue().     } else if (currentToken == JsonToken.VALUE_TRUE) {         return Boolean.TRUE.     } else if (currentToken == JsonToken.VALUE_FALSE) {         return Boolean.FALSE.     } else if (currentToken == JsonToken.VALUE_NULL) {         return null.     } else {         return text().     } }
false;public;0;17;;@Override public Object objectBytes() throws IOException {     JsonToken currentToken = parser.getCurrentToken().     if (currentToken == JsonToken.VALUE_STRING) {         return charBuffer().     } else if (currentToken == JsonToken.VALUE_NUMBER_INT || currentToken == JsonToken.VALUE_NUMBER_FLOAT) {         return parser.getNumberValue().     } else if (currentToken == JsonToken.VALUE_TRUE) {         return Boolean.TRUE.     } else if (currentToken == JsonToken.VALUE_FALSE) {         return Boolean.FALSE.     } else if (currentToken == JsonToken.VALUE_NULL) {         return null.     } else {         return charBuffer().     } }
false;public;0;4;;@Override public boolean hasTextCharacters() {     return parser.hasTextCharacters(). }
false;public;0;4;;@Override public char[] textCharacters() throws IOException {     return parser.getTextCharacters(). }
false;public;0;4;;@Override public int textLength() throws IOException {     return parser.getTextLength(). }
false;public;0;4;;@Override public int textOffset() throws IOException {     return parser.getTextOffset(). }
false;public;0;4;;@Override public Number numberValue() throws IOException {     return parser.getNumberValue(). }
false;public;0;4;;@Override public short doShortValue() throws IOException {     return parser.getShortValue(). }
false;public;0;4;;@Override public int doIntValue() throws IOException {     return parser.getIntValue(). }
false;public;0;4;;@Override public long doLongValue() throws IOException {     return parser.getLongValue(). }
false;public;0;4;;@Override public float doFloatValue() throws IOException {     return parser.getFloatValue(). }
false;public;0;4;;@Override public double doDoubleValue() throws IOException {     return parser.getDoubleValue(). }
false;public;0;4;;@Override public byte[] binaryValue() throws IOException {     return parser.getBinaryValue(). }
false;public;0;8;;@Override public XContentLocation getTokenLocation() {     JsonLocation loc = parser.getTokenLocation().     if (loc == null) {         return null.     }     return new XContentLocation(loc.getLineNr(), loc.getColumnNr()). }
false;public;0;4;;@Override public void close() {     IOUtils.closeWhileHandlingException(parser). }
false;private;1;13;;private NumberType convertNumberType(JsonParser.NumberType numberType) {     switch(numberType) {         case INT:             return NumberType.INT.         case LONG:             return NumberType.LONG.         case FLOAT:             return NumberType.FLOAT.         case DOUBLE:             return NumberType.DOUBLE.     }     throw new IllegalStateException("No matching token for number_type [" + numberType + "]"). }
false;private;1;30;;private Token convertToken(JsonToken token) {     if (token == null) {         return null.     }     switch(token) {         case FIELD_NAME:             return Token.FIELD_NAME.         case VALUE_FALSE:         case VALUE_TRUE:             return Token.VALUE_BOOLEAN.         case VALUE_STRING:             return Token.VALUE_STRING.         case VALUE_NUMBER_INT:         case VALUE_NUMBER_FLOAT:             return Token.VALUE_NUMBER.         case VALUE_NULL:             return Token.VALUE_NULL.         case START_OBJECT:             return Token.START_OBJECT.         case END_OBJECT:             return Token.END_OBJECT.         case START_ARRAY:             return Token.START_ARRAY.         case END_ARRAY:             return Token.END_ARRAY.         case VALUE_EMBEDDED_OBJECT:             return Token.VALUE_EMBEDDED_OBJECT.     }     throw new IllegalStateException("No matching token for json_token [" + token + "]"). }
false;public;0;4;;@Override public boolean isClosed() {     return parser.isClosed(). }
