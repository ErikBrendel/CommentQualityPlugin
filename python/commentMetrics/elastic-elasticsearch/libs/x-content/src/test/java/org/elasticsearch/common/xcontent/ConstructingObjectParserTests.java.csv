commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;public void testNullDeclares() {     ConstructingObjectParser<Void, Void> objectParser = new ConstructingObjectParser<>("foo", a -> null).     Exception e = expectThrows(IllegalArgumentException.class, () -> objectParser.declareField(null, (r, c) -> null, new ParseField("test"), ObjectParser.ValueType.STRING)).     assertEquals("[consumer] is required", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> objectParser.declareField((o, v) -> {     }, (ContextParser<Void, Object>) null, new ParseField("test"), ObjectParser.ValueType.STRING)).     assertEquals("[parser] is required", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> objectParser.declareField((o, v) -> {     }, (CheckedFunction<XContentParser, Object, IOException>) null, new ParseField("test"), ObjectParser.ValueType.STRING)).     assertEquals("[parser] is required", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> objectParser.declareField((o, v) -> {     }, (r, c) -> null, null, ObjectParser.ValueType.STRING)).     assertEquals("[parseField] is required", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> objectParser.declareField((o, v) -> {     }, (r, c) -> null, new ParseField("test"), null)).     assertEquals("[type] is required", e.getMessage()). }
true;public;0;25;/**  * Builds the object in random order and parses it.  */ ;/**  * Builds the object in random order and parses it.  */ public void testRandomOrder() throws Exception {     HasCtorArguments expected = new HasCtorArguments(randomAlphaOfLength(5), randomInt()).     expected.setMineral(randomInt()).     expected.setFruit(randomInt()).     expected.setA(randomBoolean() ? null : randomAlphaOfLength(5)).     expected.setB(randomBoolean() ? null : randomAlphaOfLength(5)).     expected.setC(randomBoolean() ? null : randomAlphaOfLength(5)).     expected.setD(randomBoolean()).     XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint().     expected.toXContent(builder, ToXContent.EMPTY_PARAMS).     builder = shuffleXContent(builder).     builder.flush().     byte[] bytes = ((ByteArrayOutputStream) builder.getOutputStream()).toByteArray().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, bytes)) {         HasCtorArguments parsed = randomFrom(HasCtorArguments.ALL_PARSERS).apply(parser, null).         assertEquals(expected.animal, parsed.animal).         assertEquals(expected.vegetable, parsed.vegetable).         assertEquals(expected.mineral, parsed.mineral).         assertEquals(expected.fruit, parsed.fruit).         assertEquals(expected.a, parsed.a).         assertEquals(expected.b, parsed.b).         assertEquals(expected.c, parsed.c).         assertEquals(expected.d, parsed.d).     } }
false;public;0;14;;public void testMissingAllConstructorArgs() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"mineral\": 1\n" + "}").     ConstructingObjectParser<HasCtorArguments, Void> objectParser = randomBoolean() ? HasCtorArguments.PARSER : HasCtorArguments.PARSER_VEGETABLE_OPTIONAL.     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> objectParser.apply(parser, null)).     if (objectParser == HasCtorArguments.PARSER) {         assertEquals("Required [animal, vegetable]", e.getMessage()).     } else {         assertEquals("Required [animal]", e.getMessage()).     } }
false;public;0;8;;public void testMissingAllConstructorArgsButNotRequired() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"mineral\": 1\n" + "}").     HasCtorArguments parsed = HasCtorArguments.PARSER_ALL_OPTIONAL.apply(parser, null).     assertEquals(1, parsed.mineral). }
false;public;0;10;;public void testMissingSecondConstructorArg() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"mineral\": 1,\n" + "  \"animal\": \"cat\"\n" + "}").     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> HasCtorArguments.PARSER.apply(parser, null)).     assertEquals("Required [vegetable]", e.getMessage()). }
false;public;0;12;;public void testMissingSecondConstructorArgButNotRequired() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"mineral\": 1,\n" + "  \"animal\": \"cat\"\n" + "}").     @SuppressWarnings("unchecked")     HasCtorArguments parsed = randomFrom(HasCtorArguments.PARSER_VEGETABLE_OPTIONAL, HasCtorArguments.PARSER_ALL_OPTIONAL).apply(parser, null).     assertEquals(1, parsed.mineral).     assertEquals("cat", parsed.animal). }
false;public;0;11;;public void testMissingFirstConstructorArg() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"mineral\": 1,\n" + "  \"vegetable\": 2\n" + "}").     @SuppressWarnings("unchecked")     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> randomFrom(HasCtorArguments.PARSER, HasCtorArguments.PARSER_VEGETABLE_OPTIONAL).apply(parser, null)).     assertEquals("Required [animal]", e.getMessage()). }
false;public;0;10;;public void testMissingFirstConstructorArgButNotRequired() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"mineral\": 1,\n" + "  \"vegetable\": 2\n" + "}").     HasCtorArguments parsed = HasCtorArguments.PARSER_ALL_OPTIONAL.apply(parser, null).     assertEquals(1, parsed.mineral).     assertEquals((Integer) 2, parsed.vegetable). }
false;public;0;14;;public void testBadParam() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"animal\": \"cat\",\n" + "  \"vegetable\": 2,\n" + "  \"a\": \"supercalifragilisticexpialidocious\"\n" + "}").     XContentParseException e = expectThrows(XContentParseException.class, () -> randomFrom(HasCtorArguments.ALL_PARSERS).apply(parser, null)).     assertThat(e.getMessage(), containsString("[has_required_arguments] failed to parse field [a]")).     assertEquals(4, e.getLineNumber()).     assertEquals("[a] must be less than 10 characters in length but was [supercalifragilisticexpialidocious]", e.getCause().getMessage()). }
false;public;0;20;;public void testBadParamBeforeObjectBuilt() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"a\": \"supercalifragilisticexpialidocious\",\n" + "  \"animal\": \"cat\"\n," + "  \"vegetable\": 2\n" + "}").     XContentParseException e = expectThrows(XContentParseException.class, () -> randomFrom(HasCtorArguments.ALL_PARSERS).apply(parser, null)).     assertThat(e.getMessage(), containsString("[has_required_arguments] failed to parse field [vegetable]")).     assertEquals(4, e.getLineNumber()).     e = (XContentParseException) e.getCause().     assertThat(e.getMessage(), containsString("failed to build [has_required_arguments] after last required field arrived")).     assertEquals(2, e.getLineNumber()).     e = (XContentParseException) e.getCause().     assertThat(e.getMessage(), containsString("[has_required_arguments] failed to parse field [a]")).     assertEquals(2, e.getLineNumber()).     assertEquals("[a] must be less than 10 characters in length but was [supercalifragilisticexpialidocious]", e.getCause().getMessage()). }
false;public;0;13;;public void testConstructorArgsMustBeConfigured() throws IOException {     class NoConstructorArgs {     }     ConstructingObjectParser<NoConstructorArgs, Void> parser = new ConstructingObjectParser<>("constructor_args_required", (a) -> new NoConstructorArgs()).     try {         parser.apply(createParser(JsonXContent.jsonXContent, "{}"), null).         fail("Expected AssertionError").     } catch (AssertionError e) {         assertEquals("[constructor_args_required] must configure at least one constructor argument. If it doesn't have any it should " + "use ObjectParser instead of ConstructingObjectParser. This is a bug in the parser declaration.", e.getMessage()).     } }
false;;1;4;;void setFoo(String foo) {     assertFalse(fooSet).     fooSet = true. }
true;public;0;51;/**  * Tests the non-constructor fields are only set on time.  */ ;/**  * Tests the non-constructor fields are only set on time.  */ public void testCalledOneTime() throws IOException {     boolean ctorArgOptional = randomBoolean().     class CalledOneTime {          CalledOneTime(String yeah) {             Matcher<String> yeahMatcher = equalTo("!").             if (ctorArgOptional) {                 // either(yeahMatcher).or(nullValue) is broken by https://github.com/hamcrest/JavaHamcrest/issues/49                 yeahMatcher = anyOf(yeahMatcher, nullValue()).             }             assertThat(yeah, yeahMatcher).         }          boolean fooSet = false.          void setFoo(String foo) {             assertFalse(fooSet).             fooSet = true.         }     }     ConstructingObjectParser<CalledOneTime, Void> parser = new ConstructingObjectParser<>("one_time_test", (a) -> new CalledOneTime((String) a[0])).     parser.declareString(CalledOneTime::setFoo, new ParseField("foo")).     parser.declareString(ctorArgOptional ? optionalConstructorArg() : constructorArg(), new ParseField("yeah")).     // ctor arg first so we can test for the bug we found one time     XContentParser xcontent = createParser(JsonXContent.jsonXContent, "{\n" + "  \"yeah\": \"!\",\n" + "  \"foo\": \"foo\"\n" + "}").     CalledOneTime result = parser.apply(xcontent, null).     assertTrue(result.fooSet).     // and ctor arg second just in case     xcontent = createParser(JsonXContent.jsonXContent, "{\n" + "  \"foo\": \"foo\",\n" + "  \"yeah\": \"!\"\n" + "}").     result = parser.apply(xcontent, null).     assertTrue(result.fooSet).     if (ctorArgOptional) {         // and without the constructor arg if we've made it optional         xcontent = createParser(JsonXContent.jsonXContent, "{\n" + "  \"foo\": \"foo\"\n" + "}").         result = parser.apply(xcontent, null).     }     assertTrue(result.fooSet). }
false;public;0;18;;public void testIgnoreUnknownFields() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"test\" : \"foo\",\n" + "  \"junk\" : 2\n" + "}").     class TestStruct {          public final String test.          TestStruct(String test) {             this.test = test.         }     }     ConstructingObjectParser<TestStruct, Void> objectParser = new ConstructingObjectParser<>("foo", true, a -> new TestStruct((String) a[0])).     objectParser.declareString(constructorArg(), new ParseField("test")).     TestStruct s = objectParser.apply(parser, null).     assertEquals(s.test, "foo"). }
false;public;0;11;;public void testConstructObjectUsingContext() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\n" + "  \"animal\": \"dropbear\",\n" + "  \"mineral\": -8\n" + "}").     HasCtorArguments parsed = HasCtorArguments.PARSER_INT_CONTEXT.apply(parser, 42).     assertEquals(Integer.valueOf(42), parsed.vegetable).     assertEquals("dropbear", parsed.animal).     assertEquals(-8, parsed.mineral). }
false;public;1;3;;public void setMineral(int mineral) {     this.mineral = mineral. }
false;public;1;3;;public void setFruit(int fruit) {     this.fruit = fruit. }
false;public;1;6;;public void setA(String a) {     if (a != null && a.length() > 9) {         throw new IllegalArgumentException("[a] must be less than 10 characters in length but was [" + a + "]").     }     this.a = a. }
false;public;1;3;;public void setB(String b) {     this.b = b. }
false;public;1;3;;public void setC(String c) {     this.c = c. }
false;public;1;3;;public void setD(boolean d) {     this.d = d. }
false;public;2;26;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("animal", animal).     builder.field("vegetable", vegetable).     if (mineral != 0) {         // We're just using 0 as the default because it is easy for testing         builder.field("mineral", mineral).     }     if (fruit != 0) {         builder.field("fruit", fruit).     }     if (a != null) {         builder.field("a", a).     }     if (b != null) {         builder.field("b", b).     }     if (c != null) {         builder.field("c", c).     }     if (d) {         builder.field("d", d).     }     builder.endObject().     return builder. }
false;private,static;2;9;;private static ConstructingObjectParser<HasCtorArguments, Void> buildParser(boolean animalRequired, boolean vegetableRequired) {     ConstructingObjectParser<HasCtorArguments, Void> parser = new ConstructingObjectParser<>("has_required_arguments", a -> new HasCtorArguments((String) a[0], (Integer) a[1])).     parser.declareString(animalRequired ? constructorArg() : optionalConstructorArg(), new ParseField("animal")).     parser.declareInt(vegetableRequired ? constructorArg() : optionalConstructorArg(), new ParseField("vegetable")).     declareSetters(parser).     return parser. }
false;private,static;0;7;;private static ConstructingObjectParser<HasCtorArguments, Integer> buildContextParser() {     ConstructingObjectParser<HasCtorArguments, Integer> parser = new ConstructingObjectParser<>("has_required_arguments", false, (args, ctx) -> new HasCtorArguments((String) args[0], ctx)).     parser.declareString(constructorArg(), new ParseField("animal")).     declareSetters(parser).     return parser. }
false;private,static;1;8;;private static void declareSetters(ConstructingObjectParser<HasCtorArguments, ?> parser) {     parser.declareInt(HasCtorArguments::setMineral, new ParseField("mineral")).     parser.declareInt(HasCtorArguments::setFruit, new ParseField("fruit")).     parser.declareString(HasCtorArguments::setA, new ParseField("a")).     parser.declareString(HasCtorArguments::setB, new ParseField("b")).     parser.declareString(HasCtorArguments::setC, new ParseField("c")).     parser.declareBoolean(HasCtorArguments::setD, new ParseField("d")). }
false;public;0;14;;public void testParseNamedObject() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": {\n" + "  \"a\": {}" + "},\"named_in_constructor\": {\n" + "  \"b\": {}" + "}}").     NamedObjectHolder h = NamedObjectHolder.PARSER.apply(parser, null).     assertThat(h.named, hasSize(1)).     assertEquals("a", h.named.get(0).name).     assertThat(h.namedInConstructor, hasSize(1)).     assertEquals("b", h.namedInConstructor.get(0).name).     assertFalse(h.namedSuppliedInOrder). }
false;public;0;14;;public void testParseNamedObjectInOrder() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {\"a\": {}}" + "],\"named_in_constructor\": [\n" + "  {\"b\": {}}" + "]}").     NamedObjectHolder h = NamedObjectHolder.PARSER.apply(parser, null).     assertThat(h.named, hasSize(1)).     assertEquals("a", h.named.get(0).name).     assertThat(h.namedInConstructor, hasSize(1)).     assertEquals("b", h.namedInConstructor.get(0).name).     assertTrue(h.namedSuppliedInOrder). }
false;public;0;13;;public void testParseNamedObjectTwoFieldsInArray() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {\"a\": {}, \"b\": {}}" + "],\"named_in_constructor\": [\n" + "  {\"c\": {}}" + "]}").     XContentParseException e = expectThrows(XContentParseException.class, () -> NamedObjectHolder.PARSER.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named]")).     assertThat(e.getCause().getMessage(), containsString("[named] can be a single object with any number of fields " + "or an array where each entry is an object with a single field")). }
false;public;0;13;;public void testParseNamedObjectTwoFieldsInArrayConstructorArg() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {\"a\": {}}" + "],\"named_in_constructor\": [\n" + "  {\"c\": {}, \"d\": {}}" + "]}").     XContentParseException e = expectThrows(XContentParseException.class, () -> NamedObjectHolder.PARSER.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named_in_constructor]")).     assertThat(e.getCause().getMessage(), containsString("[named_in_constructor] can be a single object with any number of fields " + "or an array where each entry is an object with a single field")). }
false;public;0;13;;public void testParseNamedObjectNoFieldsInArray() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {}" + "],\"named_in_constructor\": [\n" + "  {\"a\": {}}" + "]}").     XContentParseException e = expectThrows(XContentParseException.class, () -> NamedObjectHolder.PARSER.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named]")).     assertThat(e.getCause().getMessage(), containsString("[named] can be a single object with any number of fields " + "or an array where each entry is an object with a single field")). }
false;public;0;13;;public void testParseNamedObjectNoFieldsInArrayConstructorArg() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {\"a\": {}}" + "],\"named_in_constructor\": [\n" + "  {}" + "]}").     XContentParseException e = expectThrows(XContentParseException.class, () -> NamedObjectHolder.PARSER.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named_in_constructor]")).     assertThat(e.getCause().getMessage(), containsString("[named_in_constructor] can be a single object with any number of fields " + "or an array where each entry is an object with a single field")). }
false;public;0;13;;public void testParseNamedObjectJunkInArray() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  \"junk\"" + "],\"named_in_constructor\": [\n" + " {\"a\": {}}" + "]}").     XContentParseException e = expectThrows(XContentParseException.class, () -> NamedObjectHolder.PARSER.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named]")).     assertThat(e.getCause().getMessage(), containsString("[named] can be a single object with any number of fields " + "or an array where each entry is an object with a single field")). }
false;public;0;13;;public void testParseNamedObjectJunkInArrayConstructorArg() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {\"a\": {}}" + "],\"named_in_constructor\": [\n" + "  \"junk\"" + "]}").     XContentParseException e = expectThrows(XContentParseException.class, () -> NamedObjectHolder.PARSER.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named_in_constructor]")).     assertThat(e.getCause().getMessage(), containsString("[named_in_constructor] can be a single object with any number of fields " + "or an array where each entry is an object with a single field")). }
false;public;0;20;;public void testParseNamedObjectInOrderNotSupported() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": [\n" + "  {\"a\": {}}" + "],\"named_in_constructor\": {\"b\": {}}" + "}").     // Create our own parser for this test so we can disable support for the "ordered" mode specified by the array above     @SuppressWarnings("unchecked")     ConstructingObjectParser<NamedObjectHolder, Void> objectParser = new ConstructingObjectParser<>("named_object_holder", a -> new NamedObjectHolder(((List<NamedObject>) a[0]))).     objectParser.declareNamedObjects(ConstructingObjectParser.constructorArg(), NamedObject.PARSER, new ParseField("named_in_constructor")).     objectParser.declareNamedObjects(NamedObjectHolder::setNamed, NamedObject.PARSER, new ParseField("named")).     // Now firing the xml through it fails     XContentParseException e = expectThrows(XContentParseException.class, () -> objectParser.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named]")).     assertEquals("[named] doesn't support arrays. Use a single object with multiple fields.", e.getCause().getMessage()). }
false;public;0;21;;public void testParseNamedObjectInOrderNotSupportedConstructorArg() throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"named\": {\"a\": {}}" + ",\"named_in_constructor\": [\n" + "  {\"b\": {}}" + "]}").     // Create our own parser for this test so we can disable support for the "ordered" mode specified by the array above     @SuppressWarnings("unchecked")     ConstructingObjectParser<NamedObjectHolder, Void> objectParser = new ConstructingObjectParser<>("named_object_holder", a -> new NamedObjectHolder(((List<NamedObject>) a[0]))).     objectParser.declareNamedObjects(ConstructingObjectParser.constructorArg(), NamedObject.PARSER, new ParseField("named_in_constructor")).     objectParser.declareNamedObjects(NamedObjectHolder::setNamed, NamedObject.PARSER, new ParseField("named")).     // Now firing the xml through it fails     XContentParseException e = expectThrows(XContentParseException.class, () -> objectParser.apply(parser, null)).     assertThat(e.getMessage(), containsString("[named_object_holder] failed to parse field [named_in_constructor]")).     assertThat(e.getCause().getMessage(), containsString("[named_in_constructor] doesn't support arrays. Use a single object with multiple fields.")). }
false;public;1;3;;public void setNamed(List<NamedObject> named) {     this.named = named. }
false;public;0;3;;public void keepNamedInOrder() {     namedSuppliedInOrder = true. }
