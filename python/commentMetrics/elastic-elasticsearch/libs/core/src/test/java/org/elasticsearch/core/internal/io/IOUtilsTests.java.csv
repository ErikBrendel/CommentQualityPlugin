commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public void testCloseArray() throws IOException {     runTestClose(Function.identity(), IOUtils::close). }
false;public;0;3;;public void testCloseIterable() throws IOException {     runTestClose((Function<Closeable[], List<Closeable>>) Arrays::asList, IOUtils::close). }
false;private;2;12;;private <T> void runTestClose(final Function<Closeable[], T> function, final CheckedConsumer<T, IOException> close) throws IOException {     final int numberOfCloseables = randomIntBetween(0, 7).     final Closeable[] closeables = new Closeable[numberOfCloseables].     for (int i = 0. i < numberOfCloseables. i++) {         closeables[i] = mock(Closeable.class).     }     close.accept(function.apply(closeables)).     for (int i = 0. i < numberOfCloseables. i++) {         verify(closeables[i]).close().         verifyNoMoreInteractions(closeables[i]).     } }
false;public;0;3;;public void testCloseArrayWithIOExceptions() throws IOException {     runTestCloseWithIOExceptions(Function.identity(), IOUtils::close). }
false;public;0;3;;public void testCloseIterableWithIOExceptions() throws IOException {     runTestCloseWithIOExceptions((Function<Closeable[], List<Closeable>>) Arrays::asList, IOUtils::close). }
false;private;2;30;;private <T> void runTestCloseWithIOExceptions(final Function<Closeable[], T> function, final CheckedConsumer<T, IOException> close) throws IOException {     final int numberOfCloseables = randomIntBetween(1, 8).     final Closeable[] closeables = new Closeable[numberOfCloseables].     final List<Integer> indexesThatThrow = new ArrayList<>(numberOfCloseables).     for (int i = 0. i < numberOfCloseables - 1. i++) {         final Closeable closeable = mock(Closeable.class).         if (randomBoolean()) {             indexesThatThrow.add(i).             doThrow(new IOException(Integer.toString(i))).when(closeable).close().         }         closeables[i] = closeable.     }     // ensure that at least one always throws     final Closeable closeable = mock(Closeable.class).     if (indexesThatThrow.isEmpty() || randomBoolean()) {         indexesThatThrow.add(numberOfCloseables - 1).         doThrow(new IOException(Integer.toString(numberOfCloseables - 1))).when(closeable).close().     }     closeables[numberOfCloseables - 1] = closeable.     final IOException e = expectThrows(IOException.class, () -> close.accept(function.apply(closeables))).     assertThat(e.getMessage(), equalTo(Integer.toString(indexesThatThrow.get(0)))).     assertThat(e.getSuppressed(), arrayWithSize(indexesThatThrow.size() - 1)).     for (int i = 1. i < indexesThatThrow.size(). i++) {         assertNotNull(e.getSuppressed()[i - 1]).         assertThat(e.getSuppressed()[i - 1].getMessage(), equalTo(Integer.toString(indexesThatThrow.get(i)))).     } }
false;public;0;3;;public void testDeleteFilesIgnoringExceptionsArray() throws IOException {     runDeleteFilesIgnoringExceptionsTest(Function.identity(), IOUtils::deleteFilesIgnoringExceptions). }
false;public;0;3;;public void testDeleteFilesIgnoringExceptionsIterable() throws IOException {     runDeleteFilesIgnoringExceptionsTest((Function<Path[], List<Path>>) Arrays::asList, IOUtils::deleteFilesIgnoringExceptions). }
false;private;2;18;;private <T> void runDeleteFilesIgnoringExceptionsTest(final Function<Path[], T> function, CheckedConsumer<T, IOException> deleteFilesIgnoringExceptions) throws IOException {     final int numberOfFiles = randomIntBetween(0, 7).     final Path[] files = new Path[numberOfFiles].     for (int i = 0. i < numberOfFiles. i++) {         if (randomBoolean()) {             files[i] = createTempFile().         } else {             final Path temporary = createTempFile().             files[i] = PathUtils.get(temporary.toString(), randomAlphaOfLength(8)).             Files.delete(temporary).         }     }     deleteFilesIgnoringExceptions.accept(function.apply(files)).     for (int i = 0. i < numberOfFiles. i++) {         assertFalse(files[i].toString(), Files.exists(files[i])).     } }
false;public;0;3;;public void testRm() throws IOException {     runTestRm(false). }
false;public;0;3;;public void testRmWithIOExceptions() throws IOException {     runTestRm(true). }
false;public;1;43;;public void runTestRm(final boolean exception) throws IOException {     final int numberOfLocations = randomIntBetween(0, 7).     final Path[] locations = new Path[numberOfLocations].     final List<Path> locationsThrowingException = new ArrayList<>(numberOfLocations).     for (int i = 0. i < numberOfLocations. i++) {         if (exception && randomBoolean()) {             final Path location = createTempDir().             final FileSystem fs = new AccessDeniedWhileDeletingFileSystem(location.getFileSystem()).getFileSystem(URI.create("file:///")).             final Path wrapped = new FilterPath(location, fs).             locations[i] = wrapped.resolve(randomAlphaOfLength(8)).             Files.createDirectory(locations[i]).             locationsThrowingException.add(locations[i]).         } else {             // we create a tree of files that IOUtils#rm should delete             locations[i] = createTempDir().             Path location = locations[i].             while (true) {                 location = Files.createDirectory(location.resolve(randomAlphaOfLength(8))).                 if (rarely() == false) {                     Files.createTempFile(location, randomAlphaOfLength(8), null).                     break.                 }             }         }     }     if (locationsThrowingException.isEmpty()) {         IOUtils.rm(locations).     } else {         final IOException e = expectThrows(IOException.class, () -> IOUtils.rm(locations)).         assertThat(e, hasToString(containsString("could not remove the following files (in the order of attempts):"))).         for (final Path locationThrowingException : locationsThrowingException) {             assertThat(e, hasToString(containsString("access denied while trying to delete file [" + locationThrowingException + "]"))).         }     }     for (int i = 0. i < numberOfLocations. i++) {         if (locationsThrowingException.contains(locations[i]) == false) {             assertFalse(locations[i].toString(), Files.exists(locations[i])).         }     } }
false;public;1;7;;@Override public void delete(final Path path) throws IOException {     if (Files.exists(path)) {         throw new AccessDeniedException("access denied while trying to delete file [" + path + "]").     }     super.delete(path). }
false;public;0;7;;public void testFsyncDirectory() throws Exception {     final Path path = createTempDir().toRealPath().     final Path subPath = path.resolve(randomAlphaOfLength(8)).     Files.createDirectories(subPath).     IOUtils.fsync(subPath, true). // no exception }
false;public;0;11;;public void testFsyncFile() throws IOException {     final Path path = createTempDir().toRealPath().     final Path subPath = path.resolve(randomAlphaOfLength(8)).     Files.createDirectories(subPath).     final Path file = subPath.resolve(randomAlphaOfLength(8)).     try (OutputStream o = Files.newOutputStream(file)) {         o.write("0\n".getBytes(StandardCharsets.US_ASCII)).     }     IOUtils.fsync(file, false). // no exception }
