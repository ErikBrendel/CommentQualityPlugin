commented;modifiers;parameterAmount;loc;comment;code
false;public;0;50;;public void testRefCount() throws IOException {     MyRefCounted counted = new MyRefCounted().     int incs = randomIntBetween(1, 100).     for (int i = 0. i < incs. i++) {         if (randomBoolean()) {             counted.incRef().         } else {             assertTrue(counted.tryIncRef()).         }         counted.ensureOpen().     }     for (int i = 0. i < incs. i++) {         counted.decRef().         counted.ensureOpen().     }     counted.incRef().     counted.decRef().     for (int i = 0. i < incs. i++) {         if (randomBoolean()) {             counted.incRef().         } else {             assertTrue(counted.tryIncRef()).         }         counted.ensureOpen().     }     for (int i = 0. i < incs. i++) {         counted.decRef().         counted.ensureOpen().     }     counted.decRef().     assertFalse(counted.tryIncRef()).     try {         counted.incRef().         fail(" expected exception").     } catch (IllegalStateException ex) {         assertThat(ex.getMessage(), equalTo("test is already closed can't increment refCount current count [0]")).     }     try {         counted.ensureOpen().         fail(" expected exception").     } catch (IllegalStateException ex) {         assertThat(ex.getMessage(), equalTo("closed")).     } }
false;public;0;16;;@Override public void run() {     try {         latch.await().         for (int j = 0. j < 10000. j++) {             counted.incRef().             try {                 counted.ensureOpen().             } finally {                 counted.decRef().             }         }     } catch (Exception e) {         exceptions.add(e).     } }
false;public;0;41;;public void testMultiThreaded() throws InterruptedException {     final MyRefCounted counted = new MyRefCounted().     Thread[] threads = new Thread[randomIntBetween(2, 5)].     final CountDownLatch latch = new CountDownLatch(1).     final CopyOnWriteArrayList<Exception> exceptions = new CopyOnWriteArrayList<>().     for (int i = 0. i < threads.length. i++) {         threads[i] = new Thread() {              @Override             public void run() {                 try {                     latch.await().                     for (int j = 0. j < 10000. j++) {                         counted.incRef().                         try {                             counted.ensureOpen().                         } finally {                             counted.decRef().                         }                     }                 } catch (Exception e) {                     exceptions.add(e).                 }             }         }.         threads[i].start().     }     latch.countDown().     for (int i = 0. i < threads.length. i++) {         threads[i].join().     }     counted.decRef().     try {         counted.ensureOpen().         fail("expected to be closed").     } catch (IllegalStateException ex) {         assertThat(ex.getMessage(), equalTo("closed")).     }     assertThat(counted.refCount(), is(0)).     assertThat(exceptions, Matchers.emptyIterable()). }
false;protected;0;4;;@Override protected void closeInternal() {     this.closed.set(true). }
false;public;0;6;;public void ensureOpen() {     if (closed.get()) {         assert this.refCount() == 0.         throw new IllegalStateException("closed").     } }
