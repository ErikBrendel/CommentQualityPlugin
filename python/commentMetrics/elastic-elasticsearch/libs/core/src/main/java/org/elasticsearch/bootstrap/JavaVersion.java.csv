commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<Integer> getVersion() {     return version. }
false;public,static;1;14;;public static JavaVersion parse(String value) {     Objects.requireNonNull(value).     if (!isValid(value)) {         throw new IllegalArgumentException("value").     }     List<Integer> version = new ArrayList<>().     String[] components = value.split("\\.").     for (String component : components) {         version.add(Integer.valueOf(component)).     }     return new JavaVersion(version). }
false;public,static;1;3;;public static boolean isValid(String value) {     return value.matches("^0*[0-9]+(\\.[0-9]+)*$"). }
false;public,static;0;3;;public static JavaVersion current() {     return CURRENT. }
false;public;1;13;;@Override public int compareTo(JavaVersion o) {     int len = Math.max(version.size(), o.version.size()).     for (int i = 0. i < len. i++) {         int d = (i < version.size() ? version.get(i) : 0).         int s = (i < o.version.size() ? o.version.get(i) : 0).         if (s < d)             return 1.         if (s > d)             return -1.     }     return 0. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (o == null || o.getClass() != getClass()) {         return false.     }     return compareTo((JavaVersion) o) == 0. }
false;public;0;4;;@Override public int hashCode() {     return version.hashCode(). }
false;public;0;4;;@Override public String toString() {     return version.stream().map(v -> Integer.toString(v)).collect(Collectors.joining(".")). }
