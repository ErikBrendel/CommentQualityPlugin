commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Closes all given {@link Closeable}s. Some of the {@linkplain Closeable}s may be null. they are  * ignored. After everything is closed, the method either throws the first exception it hit  * while closing with other exceptions added as suppressed, or completes normally if there were  * no exceptions.  *  * @param objects objects to close  */ ;/**  * Closes all given {@link Closeable}s. Some of the {@linkplain Closeable}s may be null. they are  * ignored. After everything is closed, the method either throws the first exception it hit  * while closing with other exceptions added as suppressed, or completes normally if there were  * no exceptions.  *  * @param objects objects to close  */ public static void close(final Closeable... objects) throws IOException {     close(null, Arrays.asList(objects)). }
true;public,static;2;3;/**  * Closes all given {@link Closeable}s. Some of the {@linkplain Closeable}s may be null. they are  * ignored. After everything is closed, the method adds any exceptions as suppressed to the  * original exception, or throws the first exception it hit if {@code Exception} is null. If  * no exceptions are encountered and the passed in exception is null, it completes normally.  *  * @param objects objects to close  */ ;/**  * Closes all given {@link Closeable}s. Some of the {@linkplain Closeable}s may be null. they are  * ignored. After everything is closed, the method adds any exceptions as suppressed to the  * original exception, or throws the first exception it hit if {@code Exception} is null. If  * no exceptions are encountered and the passed in exception is null, it completes normally.  *  * @param objects objects to close  */ public static void close(final Exception e, final Closeable... objects) throws IOException {     close(e, Arrays.asList(objects)). }
true;public,static;1;3;/**  * Closes all given {@link Closeable}s. Some of the {@linkplain Closeable}s may be null. they are  * ignored. After everything is closed, the method either throws the first exception it hit  * while closing with other exceptions added as suppressed, or completes normally if there were  * no exceptions.  *  * @param objects objects to close  */ ;/**  * Closes all given {@link Closeable}s. Some of the {@linkplain Closeable}s may be null. they are  * ignored. After everything is closed, the method either throws the first exception it hit  * while closing with other exceptions added as suppressed, or completes normally if there were  * no exceptions.  *  * @param objects objects to close  */ public static void close(final Iterable<? extends Closeable> objects) throws IOException {     close(null, objects). }
true;public,static;2;25;/**  * Closes all given {@link Closeable}s. If a non-null exception is passed in, or closing a  * stream causes an exception, throws the exception with other {@link RuntimeException} or  * {@link IOException} exceptions added as suppressed.  *  * @param ex existing Exception to add exceptions occurring during close to  * @param objects objects to close  *  * @see #close(Closeable...)  */ ;/**  * Closes all given {@link Closeable}s. If a non-null exception is passed in, or closing a  * stream causes an exception, throws the exception with other {@link RuntimeException} or  * {@link IOException} exceptions added as suppressed.  *  * @param ex existing Exception to add exceptions occurring during close to  * @param objects objects to close  *  * @see #close(Closeable...)  */ public static void close(final Exception ex, final Iterable<? extends Closeable> objects) throws IOException {     Exception firstException = ex.     for (final Closeable object : objects) {         try {             if (object != null) {                 object.close().             }         } catch (final IOException | RuntimeException e) {             if (firstException == null) {                 firstException = e.             } else {                 firstException.addSuppressed(e).             }         }     }     if (firstException != null) {         if (firstException instanceof IOException) {             throw (IOException) firstException.         } else {             // since we only assigned an IOException or a RuntimeException to ex above, in this case ex must be a RuntimeException             throw (RuntimeException) firstException.         }     } }
true;public,static;1;3;/**  * Closes all given {@link Closeable}s, suppressing all thrown exceptions. Some of the {@link Closeable}s may be null, they are ignored.  *  * @param objects objects to close  */ ;/**  * Closes all given {@link Closeable}s, suppressing all thrown exceptions. Some of the {@link Closeable}s may be null, they are ignored.  *  * @param objects objects to close  */ public static void closeWhileHandlingException(final Closeable... objects) {     closeWhileHandlingException(Arrays.asList(objects)). }
true;public,static;1;12;/**  * Closes all given {@link Closeable}s, suppressing all thrown exceptions.  *  * @param objects objects to close  *  * @see #closeWhileHandlingException(Closeable...)  */ ;/**  * Closes all given {@link Closeable}s, suppressing all thrown exceptions.  *  * @param objects objects to close  *  * @see #closeWhileHandlingException(Closeable...)  */ public static void closeWhileHandlingException(final Iterable<? extends Closeable> objects) {     for (final Closeable object : objects) {         // noinspection EmptyCatchBlock         try {             if (object != null) {                 object.close().             }         } catch (final IOException | RuntimeException e) {         }     } }
true;public,static;1;3;/**  * Deletes all given files, suppressing all thrown {@link IOException}s. Some of the files may be null, if so they are ignored.  *  * @param files the paths of files to delete  */ ;/**  * Deletes all given files, suppressing all thrown {@link IOException}s. Some of the files may be null, if so they are ignored.  *  * @param files the paths of files to delete  */ public static void deleteFilesIgnoringExceptions(final Path... files) {     deleteFilesIgnoringExceptions(Arrays.asList(files)). }
true;public,static;1;12;/**  * Deletes all given files, suppressing all thrown {@link IOException}s. Some of the files may be null, if so they are ignored.  *  * @param files the paths of files to delete  */ ;/**  * Deletes all given files, suppressing all thrown {@link IOException}s. Some of the files may be null, if so they are ignored.  *  * @param files the paths of files to delete  */ public static void deleteFilesIgnoringExceptions(final Collection<? extends Path> files) {     for (final Path name : files) {         if (name != null) {             // noinspection EmptyCatchBlock             try {                 Files.delete(name).             } catch (final IOException ignored) {             }         }     } }
true;public,static;1;14;/**  * Deletes one or more files or directories (and everything underneath it).  *  * @throws IOException if any of the given files (or their sub-hierarchy files in case of directories) cannot be removed.  */ ;/**  * Deletes one or more files or directories (and everything underneath it).  *  * @throws IOException if any of the given files (or their sub-hierarchy files in case of directories) cannot be removed.  */ public static void rm(final Path... locations) throws IOException {     final LinkedHashMap<Path, Throwable> unremoved = rm(new LinkedHashMap<>(), locations).     if (!unremoved.isEmpty()) {         final StringBuilder b = new StringBuilder("could not remove the following files (in the order of attempts):\n").         for (final Map.Entry<Path, Throwable> kv : unremoved.entrySet()) {             b.append("   ").append(kv.getKey().toAbsolutePath()).append(": ").append(kv.getValue()).append("\n").         }         throw new IOException(b.toString()).     } }
false;public;2;4;;@Override public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs) throws IOException {     return FileVisitResult.CONTINUE. }
false;public;2;11;;@Override public FileVisitResult postVisitDirectory(final Path dir, final IOException impossible) throws IOException {     assert impossible == null.     try {         Files.delete(dir).     } catch (final IOException e) {         unremoved.put(dir, e).     }     return FileVisitResult.CONTINUE. }
false;public;2;9;;@Override public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {     try {         Files.delete(file).     } catch (final IOException exc) {         unremoved.put(file, exc).     }     return FileVisitResult.CONTINUE. }
false;public;2;7;;@Override public FileVisitResult visitFileFailed(final Path file, final IOException exc) throws IOException {     if (exc != null) {         unremoved.put(file, exc).     }     return FileVisitResult.CONTINUE. }
false;private,static;2;50;;private static LinkedHashMap<Path, Throwable> rm(final LinkedHashMap<Path, Throwable> unremoved, final Path... locations) {     if (locations != null) {         for (final Path location : locations) {             // TODO: remove this leniency             if (location != null && Files.exists(location)) {                 try {                     Files.walkFileTree(location, new FileVisitor<Path>() {                          @Override                         public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs) throws IOException {                             return FileVisitResult.CONTINUE.                         }                          @Override                         public FileVisitResult postVisitDirectory(final Path dir, final IOException impossible) throws IOException {                             assert impossible == null.                             try {                                 Files.delete(dir).                             } catch (final IOException e) {                                 unremoved.put(dir, e).                             }                             return FileVisitResult.CONTINUE.                         }                          @Override                         public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {                             try {                                 Files.delete(file).                             } catch (final IOException exc) {                                 unremoved.put(file, exc).                             }                             return FileVisitResult.CONTINUE.                         }                          @Override                         public FileVisitResult visitFileFailed(final Path file, final IOException exc) throws IOException {                             if (exc != null) {                                 unremoved.put(file, exc).                             }                             return FileVisitResult.CONTINUE.                         }                     }).                 } catch (final IOException impossible) {                     throw new AssertionError("visitor threw exception", impossible).                 }             }         }     }     return unremoved. }
true;public,static;2;15;/**  * Ensure that any writes to the given file is written to the storage device that contains it. The {@code isDir} parameter specifies  * whether or not the path to sync is a directory. This is needed because we open for read and ignore an {@link IOException} since not  * all filesystems and operating systems support fsyncing on a directory. For regular files we must open for write for the fsync to have  * an effect.  *  * @param fileToSync the file to fsync  * @param isDir      if true, the given file is a directory (we open for read and ignore {@link IOException}s, because not all file  *                   systems and operating systems allow to fsync on a directory)  */ ;/**  * Ensure that any writes to the given file is written to the storage device that contains it. The {@code isDir} parameter specifies  * whether or not the path to sync is a directory. This is needed because we open for read and ignore an {@link IOException} since not  * all filesystems and operating systems support fsyncing on a directory. For regular files we must open for write for the fsync to have  * an effect.  *  * @param fileToSync the file to fsync  * @param isDir      if true, the given file is a directory (we open for read and ignore {@link IOException}s, because not all file  *                   systems and operating systems allow to fsync on a directory)  */ public static void fsync(final Path fileToSync, final boolean isDir) throws IOException {     try (FileChannel file = FileChannel.open(fileToSync, isDir ? StandardOpenOption.READ : StandardOpenOption.WRITE)) {         file.force(true).     } catch (final IOException ioe) {         if (isDir) {             assert (LINUX || MAC_OS_X) == false : "on Linux and MacOSX fsyncing a directory should not throw IOException, " + "we just don't want to rely on that in production (undocumented). got: " + ioe.             // ignore exception if it is a directory             return.         }         // throw original exception         throw ioe.     } }
