commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public void testBuildTrustConfigFromPKCS12() throws Exception {     assumeFalse("Can't use JKS/PKCS12 keystores in a FIPS JVM", inFipsJvm()).     final Path ks = getDataPath("/certs/ca1/ca.p12").     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, P12_PASS, "PKCS12", DEFAULT_ALGORITHM).     assertThat(trustConfig.getDependentFiles(), Matchers.containsInAnyOrder(ks)).     assertCertificateChain(trustConfig, "CN=Test CA 1"). }
false;public;0;7;;public void testBuildTrustConfigFromJKS() throws Exception {     assumeFalse("Can't use JKS/PKCS12 keystores in a FIPS JVM", inFipsJvm()).     final Path ks = getDataPath("/certs/ca-all/ca.jks").     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, JKS_PASS, "jks", DEFAULT_ALGORITHM).     assertThat(trustConfig.getDependentFiles(), Matchers.containsInAnyOrder(ks)).     assertCertificateChain(trustConfig, "CN=Test CA 1", "CN=Test CA 2", "CN=Test CA 3"). }
false;public;0;8;;public void testBadKeyStoreFormatFails() throws Exception {     assumeFalse("Can't use JKS/PKCS12 keystores in a FIPS JVM", inFipsJvm()).     final Path ks = createTempFile("ca", ".p12").     Files.write(ks, randomByteArrayOfLength(128), StandardOpenOption.APPEND).     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, new char[0], randomFrom("PKCS12", "jks"), DEFAULT_ALGORITHM).     assertThat(trustConfig.getDependentFiles(), Matchers.containsInAnyOrder(ks)).     assertInvalidFileFormat(trustConfig, ks). }
false;public;0;7;;public void testMissingKeyStoreFailsWithMeaningfulMessage() throws Exception {     assumeFalse("Can't use JKS/PKCS12 keystores in a FIPS JVM", inFipsJvm()).     final Path ks = getDataPath("/certs/ca-all/ca.p12").getParent().resolve("keystore.dne").     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, new char[0], randomFrom("PKCS12", "jks"), DEFAULT_ALGORITHM).     assertThat(trustConfig.getDependentFiles(), Matchers.containsInAnyOrder(ks)).     assertFileNotFound(trustConfig, ks). }
false;public;0;6;;public void testIncorrectPasswordFailsWithMeaningfulMessage() throws Exception {     final Path ks = getDataPath("/certs/ca1/ca.p12").     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, new char[0], "PKCS12", DEFAULT_ALGORITHM).     assertThat(trustConfig.getDependentFiles(), Matchers.containsInAnyOrder(ks)).     assertPasswordIsIncorrect(trustConfig, ks). }
false;public;0;18;;public void testMissingTrustEntriesFailsWithMeaningfulMessage() throws Exception {     assumeFalse("Can't use JKS/PKCS12 keystores in a FIPS JVM", inFipsJvm()).     final Path ks.     final char[] password.     final String type.     if (randomBoolean()) {         type = "PKCS12".         ks = getDataPath("/certs/cert-all/certs.p12").         password = P12_PASS.     } else {         type = "jks".         ks = getDataPath("/certs/cert-all/certs.jks").         password = JKS_PASS.     }     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, password, type, DEFAULT_ALGORITHM).     assertThat(trustConfig.getDependentFiles(), Matchers.containsInAnyOrder(ks)).     assertNoCertificateEntries(trustConfig, ks). }
false;public;0;21;;public void testTrustConfigReloadsKeysStoreContents() throws Exception {     assumeFalse("Can't use JKS/PKCS12 keystores in a FIPS JVM", inFipsJvm()).     final Path ks1 = getDataPath("/certs/ca1/ca.p12").     final Path ksAll = getDataPath("/certs/ca-all/ca.p12").     final Path ks = createTempFile("ca", "p12").     final StoreTrustConfig trustConfig = new StoreTrustConfig(ks, P12_PASS, "PKCS12", DEFAULT_ALGORITHM).     Files.copy(ks1, ks, StandardCopyOption.REPLACE_EXISTING).     assertCertificateChain(trustConfig, "CN=Test CA 1").     Files.delete(ks).     assertFileNotFound(trustConfig, ks).     Files.write(ks, randomByteArrayOfLength(128), StandardOpenOption.CREATE).     assertInvalidFileFormat(trustConfig, ks).     Files.copy(ksAll, ks, StandardCopyOption.REPLACE_EXISTING).     assertCertificateChain(trustConfig, "CN=Test CA 1", "CN=Test CA 2", "CN=Test CA 3"). }
false;private;2;10;;private void assertCertificateChain(StoreTrustConfig trustConfig, String... caNames) {     final X509ExtendedTrustManager trustManager = trustConfig.createTrustManager().     final X509Certificate[] issuers = trustManager.getAcceptedIssuers().     final Set<String> issuerNames = Stream.of(issuers).map(X509Certificate::getSubjectDN).map(Principal::getName).collect(Collectors.toSet()).     assertThat(issuerNames, Matchers.containsInAnyOrder(caNames)). }
false;private;2;7;;private void assertInvalidFileFormat(StoreTrustConfig trustConfig, Path file) {     final SslConfigException exception = expectThrows(SslConfigException.class, trustConfig::createTrustManager).     assertThat(exception.getMessage(), Matchers.containsString("cannot read")).     assertThat(exception.getMessage(), Matchers.containsString("keystore")).     assertThat(exception.getMessage(), Matchers.containsString(file.toAbsolutePath().toString())).     assertThat(exception.getCause(), Matchers.instanceOf(IOException.class)). }
false;private;2;7;;private void assertFileNotFound(StoreTrustConfig trustConfig, Path file) {     final SslConfigException exception = expectThrows(SslConfigException.class, trustConfig::createTrustManager).     assertThat(exception.getMessage(), Matchers.containsString("file does not exist")).     assertThat(exception.getMessage(), Matchers.containsString("keystore")).     assertThat(exception.getMessage(), Matchers.containsString(file.toAbsolutePath().toString())).     assertThat(exception.getCause(), nullValue()). }
false;private;2;6;;private void assertPasswordIsIncorrect(StoreTrustConfig trustConfig, Path key) {     final SslConfigException exception = expectThrows(SslConfigException.class, trustConfig::createTrustManager).     assertThat(exception.getMessage(), containsString("keystore")).     assertThat(exception.getMessage(), containsString(key.toAbsolutePath().toString())).     assertThat(exception.getMessage(), containsString("password")). }
false;private;2;6;;private void assertNoCertificateEntries(StoreTrustConfig trustConfig, Path file) {     final SslConfigException exception = expectThrows(SslConfigException.class, trustConfig::createTrustManager).     assertThat(exception.getMessage(), Matchers.containsString("does not contain any trusted certificate entries")).     assertThat(exception.getMessage(), Matchers.containsString("truststore")).     assertThat(exception.getMessage(), Matchers.containsString(file.toAbsolutePath().toString())). }
