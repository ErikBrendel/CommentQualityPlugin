commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Collection<Path> getDependentFiles() {     return certificateAuthorities. }
false;public;0;10;;@Override public X509ExtendedTrustManager createTrustManager() {     try {         final List<Certificate> certificates = loadCertificates().         KeyStore store = KeyStoreUtil.buildTrustStore(certificates).         return KeyStoreUtil.createTrustManager(store, TrustManagerFactory.getDefaultAlgorithm()).     } catch (GeneralSecurityException e) {         throw new SslConfigException("cannot create trust using PEM certificates [" + caPathsAsString() + "]", e).     } }
false;private;0;11;;private List<Certificate> loadCertificates() throws CertificateException {     try {         return PemUtils.readCertificates(this.certificateAuthorities).     } catch (FileNotFoundException | NoSuchFileException e) {         throw new SslConfigException("cannot configure trust using PEM certificates [" + caPathsAsString() + "] because one or more files do not exist", e).     } catch (IOException e) {         throw new SslConfigException("cannot configure trust using PEM certificates [" + caPathsAsString() + "] because one or more files cannot be read", e).     } }
false;public;0;4;;@Override public String toString() {     return "PEM-trust{" + caPathsAsString() + "}". }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final PemTrustConfig that = (PemTrustConfig) o.     return Objects.equals(this.certificateAuthorities, that.certificateAuthorities). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(certificateAuthorities). }
false;private;0;6;;private String caPathsAsString() {     return certificateAuthorities.stream().map(Path::toAbsolutePath).map(Object::toString).collect(Collectors.joining(",")). }
