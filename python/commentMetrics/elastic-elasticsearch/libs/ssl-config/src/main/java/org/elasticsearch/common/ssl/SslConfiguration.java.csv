commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public SslTrustConfig getTrustConfig() {     return trustConfig. }
false;public;0;3;;public SslKeyConfig getKeyConfig() {     return keyConfig. }
false;public;0;3;;public SslVerificationMode getVerificationMode() {     return verificationMode. }
false;public;0;3;;public SslClientAuthenticationMode getClientAuth() {     return clientAuth. }
false;public;0;3;;public List<String> getCipherSuites() {     return ciphers. }
false;public;0;3;;public List<String> getSupportedProtocols() {     return supportedProtocols. }
true;public;0;5;/**  * @return A collection of files that are used by this SSL configuration. If the contents of these files change, then any  * subsequent call to {@link #createSslContext()} (or similar methods) may create a context with different behaviour.  * It is recommended that these files be monitored for changes, and a new ssl-context is created whenever any of the files are modified.  */ ;/**  * @return A collection of files that are used by this SSL configuration. If the contents of these files change, then any  * subsequent call to {@link #createSslContext()} (or similar methods) may create a context with different behaviour.  * It is recommended that these files be monitored for changes, and a new ssl-context is created whenever any of the files are modified.  */ public Collection<Path> getDependentFiles() {     Set<Path> paths = new HashSet<>(keyConfig.getDependentFiles()).     paths.addAll(trustConfig.getDependentFiles()).     return paths. }
true;public;0;11;/**  * Dynamically create a new SSL context based on the current state of the configuration.  * Because the {@link #getKeyConfig() key config} and {@link #getTrustConfig() trust config} may change based on the  * contents of their referenced files (see {@link #getDependentFiles()}, consecutive calls to this method may  * return ssl-contexts with different configurations.  */ ;/**  * Dynamically create a new SSL context based on the current state of the configuration.  * Because the {@link #getKeyConfig() key config} and {@link #getTrustConfig() trust config} may change based on the  * contents of their referenced files (see {@link #getDependentFiles()}, consecutive calls to this method may  * return ssl-contexts with different configurations.  */ public SSLContext createSslContext() {     final X509ExtendedKeyManager keyManager = keyConfig.createKeyManager().     final X509ExtendedTrustManager trustManager = trustConfig.createTrustManager().     try {         SSLContext sslContext = SSLContext.getInstance(contextProtocol()).         sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null).         return sslContext.     } catch (GeneralSecurityException e) {         throw new SslConfigException("cannot create ssl context", e).     } }
true;private;0;12;/**  * Picks the best (highest security / most recent standard) SSL/TLS protocol (/version) that is supported by the  * {@link #getSupportedProtocols() configured protocols}.  */ ;/**  * Picks the best (highest security / most recent standard) SSL/TLS protocol (/version) that is supported by the  * {@link #getSupportedProtocols() configured protocols}.  */ private String contextProtocol() {     if (supportedProtocols.isEmpty()) {         throw new SslConfigException("no SSL/TLS protocols have been configured").     }     for (Entry<String, String> entry : ORDERED_PROTOCOL_ALGORITHM_MAP.entrySet()) {         if (supportedProtocols.contains(entry.getKey())) {             return entry.getValue().         }     }     throw new SslConfigException("no supported SSL/TLS protocol was found in the configured supported protocols: " + supportedProtocols). }
false;public;0;11;;@Override public String toString() {     return getClass().getSimpleName() + '{' + "trustConfig=" + trustConfig + ", keyConfig=" + keyConfig + ", verificationMode=" + verificationMode + ", clientAuth=" + clientAuth + ", ciphers=" + ciphers + ", supportedProtocols=" + supportedProtocols + '}'. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     final SslConfiguration that = (SslConfiguration) o.     return Objects.equals(this.trustConfig, that.trustConfig) && Objects.equals(this.keyConfig, that.keyConfig) && this.verificationMode == that.verificationMode && this.clientAuth == that.clientAuth && Objects.equals(this.ciphers, that.ciphers) && Objects.equals(this.supportedProtocols, that.supportedProtocols). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(trustConfig, keyConfig, verificationMode, clientAuth, ciphers, supportedProtocols). }
