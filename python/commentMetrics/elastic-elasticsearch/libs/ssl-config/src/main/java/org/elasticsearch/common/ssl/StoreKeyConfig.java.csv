commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Collection<Path> getDependentFiles() {     return Collections.singleton(path). }
false;public;0;19;;@Override public X509ExtendedKeyManager createKeyManager() {     try {         final KeyStore keyStore = KeyStoreUtil.readKeyStore(path, type, storePassword).         checkKeyStore(keyStore).         return KeyStoreUtil.createKeyManager(keyStore, keyPassword, algorithm).     } catch (UnrecoverableKeyException e) {         String message = "failed to load a KeyManager for keystore [" + path.toAbsolutePath() + "], this is usually caused by an incorrect key-password".         if (keyPassword.length == 0) {             message += " (no key-password was provided)".         } else if (Arrays.equals(storePassword, keyPassword)) {             message += " (we tried to access the key using the same password as the keystore)".         }         throw new SslConfigException(message, e).     } catch (GeneralSecurityException e) {         throw new SslConfigException("failed to load a KeyManager for keystore [" + path + "] of type [" + type + "]", e).     } }
true;private;1;16;/**  * Verifies that the keystore contains at least 1 private key entry.  */ ;/**  * Verifies that the keystore contains at least 1 private key entry.  */ private void checkKeyStore(KeyStore keyStore) throws KeyStoreException {     Enumeration<String> aliases = keyStore.aliases().     while (aliases.hasMoreElements()) {         String alias = aliases.nextElement().         if (keyStore.isKeyEntry(alias)) {             return.         }     }     final String message.     if (path != null) {         message = "the keystore [" + path + "] does not contain a private key entry".     } else {         message = "the configured PKCS#11 token does not contain a private key entry".     }     throw new SslConfigException(message). }
