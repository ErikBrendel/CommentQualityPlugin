commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Change the default trust config.  * The initial trust config is {@link DefaultJdkTrustConfig}, which trusts the JDK's default CA certs  */ ;/**  * Change the default trust config.  * The initial trust config is {@link DefaultJdkTrustConfig}, which trusts the JDK's default CA certs  */ public void setDefaultTrustConfig(SslTrustConfig defaultTrustConfig) {     this.defaultTrustConfig = defaultTrustConfig. }
true;public;1;3;/**  * Change the default key config.  * The initial key config is {@link EmptyKeyConfig}, which does not provide any keys  */ ;/**  * Change the default key config.  * The initial key config is {@link EmptyKeyConfig}, which does not provide any keys  */ public void setDefaultKeyConfig(SslKeyConfig defaultKeyConfig) {     this.defaultKeyConfig = defaultKeyConfig. }
true;public;1;3;/**  * Change the default verification mode.  * The initial verification mode is {@link SslVerificationMode#FULL}.  */ ;/**  * Change the default verification mode.  * The initial verification mode is {@link SslVerificationMode#FULL}.  */ public void setDefaultVerificationMode(SslVerificationMode defaultVerificationMode) {     this.defaultVerificationMode = defaultVerificationMode. }
true;public;1;3;/**  * Change the default client authentication mode.  * The initial client auth mode is {@link SslClientAuthenticationMode#OPTIONAL}.  */ ;/**  * Change the default client authentication mode.  * The initial client auth mode is {@link SslClientAuthenticationMode#OPTIONAL}.  */ public void setDefaultClientAuth(SslClientAuthenticationMode defaultClientAuth) {     this.defaultClientAuth = defaultClientAuth. }
true;public;1;3;/**  * Change the default supported ciphers.  * The initial cipher list depends on the availability of {@link #has256BitAES() 256 bit AES}.  *  * @see #loadDefaultCiphers()  */ ;/**  * Change the default supported ciphers.  * The initial cipher list depends on the availability of {@link #has256BitAES() 256 bit AES}.  *  * @see #loadDefaultCiphers()  */ public void setDefaultCiphers(List<String> defaultCiphers) {     this.defaultCiphers = defaultCiphers. }
true;public;1;3;/**  * Change the default SSL/TLS protocol list.  * The initial protocol list is defined by {@link #DEFAULT_PROTOCOLS}  */ ;/**  * Change the default SSL/TLS protocol list.  * The initial protocol list is defined by {@link #DEFAULT_PROTOCOLS}  */ public void setDefaultProtocols(List<String> defaultProtocols) {     this.defaultProtocols = defaultProtocols. }
true;protected,abstract;1;1;/**  * Clients of this class should implement this method to load a fully-qualified key from the preferred settings source.  * This method will be called for basic string settings (see {@link SslConfigurationKeys#getStringKeys()}).  * <p>  * The setting should be returned as a string, and this class will convert it to the relevant type.  *  * @throws Exception If a {@link RuntimeException} is thrown, it will be rethrown unwrapped. All checked exceptions are wrapped in  *                   {@link SslConfigException} before being rethrown.  */ ;/**  * Clients of this class should implement this method to load a fully-qualified key from the preferred settings source.  * This method will be called for basic string settings (see {@link SslConfigurationKeys#getStringKeys()}).  * <p>  * The setting should be returned as a string, and this class will convert it to the relevant type.  *  * @throws Exception If a {@link RuntimeException} is thrown, it will be rethrown unwrapped. All checked exceptions are wrapped in  *                   {@link SslConfigException} before being rethrown.  */ protected abstract String getSettingAsString(String key) throws Exception.
true;protected,abstract;1;1;/**  * Clients of this class should implement this method to load a fully-qualified key from the preferred secure settings source.  * This method will be called for any setting keys that are marked as being  * {@link SslConfigurationKeys#getSecureStringKeys() secure} settings.  *  * @throws Exception If a {@link RuntimeException} is thrown, it will be rethrown unwrapped. All checked exceptions are wrapped in  *                   {@link SslConfigException} before being rethrown.  */ ;/**  * Clients of this class should implement this method to load a fully-qualified key from the preferred secure settings source.  * This method will be called for any setting keys that are marked as being  * {@link SslConfigurationKeys#getSecureStringKeys() secure} settings.  *  * @throws Exception If a {@link RuntimeException} is thrown, it will be rethrown unwrapped. All checked exceptions are wrapped in  *                   {@link SslConfigException} before being rethrown.  */ protected abstract char[] getSecureSetting(String key) throws Exception.
true;protected,abstract;1;1;/**  * Clients of this class should implement this method to load a fully-qualified key from the preferred settings source.  * This method will be called for list settings (see {@link SslConfigurationKeys#getListKeys()}).  * <p>  * The setting should be returned as a list of strings, and this class will convert the values to the relevant type.  *  * @throws Exception If a {@link RuntimeException} is thrown, it will be rethrown unwrapped. All checked exceptions are wrapped in  *                   {@link SslConfigException} before being rethrown.  */ ;/**  * Clients of this class should implement this method to load a fully-qualified key from the preferred settings source.  * This method will be called for list settings (see {@link SslConfigurationKeys#getListKeys()}).  * <p>  * The setting should be returned as a list of strings, and this class will convert the values to the relevant type.  *  * @throws Exception If a {@link RuntimeException} is thrown, it will be rethrown unwrapped. All checked exceptions are wrapped in  *                   {@link SslConfigException} before being rethrown.  */ protected abstract List<String> getSettingAsList(String key) throws Exception.
true;public;1;18;/**  * Resolve all necessary configuration settings, and load a {@link SslConfiguration}.  *  * @param basePath The base path to use for any settings that represent file paths. Typically points to the Elasticsearch  *                 configuration directory.  * @throws SslConfigException For any problems with the configuration, or with loading the required SSL classes.  */ ;/**  * Resolve all necessary configuration settings, and load a {@link SslConfiguration}.  *  * @param basePath The base path to use for any settings that represent file paths. Typically points to the Elasticsearch  *                 configuration directory.  * @throws SslConfigException For any problems with the configuration, or with loading the required SSL classes.  */ public SslConfiguration load(Path basePath) {     Objects.requireNonNull(basePath, "Base Path cannot be null").     final List<String> protocols = resolveListSetting(PROTOCOLS, Function.identity(), defaultProtocols).     final List<String> ciphers = resolveListSetting(CIPHERS, Function.identity(), defaultCiphers).     final SslVerificationMode verificationMode = resolveSetting(VERIFICATION_MODE, SslVerificationMode::parse, defaultVerificationMode).     final SslClientAuthenticationMode clientAuth = resolveSetting(CLIENT_AUTH, SslClientAuthenticationMode::parse, defaultClientAuth).     final SslTrustConfig trustConfig = buildTrustConfig(basePath, verificationMode).     final SslKeyConfig keyConfig = buildKeyConfig(basePath).     if (protocols == null || protocols.isEmpty()) {         throw new SslConfigException("no protocols configured in [" + settingPrefix + PROTOCOLS + "]").     }     if (ciphers == null || ciphers.isEmpty()) {         throw new SslConfigException("no cipher suites configured in [" + settingPrefix + CIPHERS + "]").     }     return new SslConfiguration(trustConfig, keyConfig, verificationMode, clientAuth, ciphers, protocols). }
false;private;2;22;;private SslTrustConfig buildTrustConfig(Path basePath, SslVerificationMode verificationMode) {     final List<Path> certificateAuthorities = resolveListSetting(CERTIFICATE_AUTHORITIES, basePath::resolve, null).     final Path trustStorePath = resolveSetting(TRUSTSTORE_PATH, basePath::resolve, null).     if (certificateAuthorities != null && trustStorePath != null) {         throw new SslConfigException("cannot specify both [" + settingPrefix + CERTIFICATE_AUTHORITIES + "] and [" + settingPrefix + TRUSTSTORE_PATH + "]").     }     if (verificationMode.isCertificateVerificationEnabled() == false) {         return TrustEverythingConfig.TRUST_EVERYTHING.     }     if (certificateAuthorities != null) {         return new PemTrustConfig(certificateAuthorities).     }     if (trustStorePath != null) {         final char[] password = resolvePasswordSetting(TRUSTSTORE_SECURE_PASSWORD, TRUSTSTORE_LEGACY_PASSWORD).         final String storeType = resolveSetting(TRUSTSTORE_TYPE, Function.identity(), inferKeyStoreType(trustStorePath)).         final String algorithm = resolveSetting(TRUSTSTORE_ALGORITHM, Function.identity(), TrustManagerFactory.getDefaultAlgorithm()).         return new StoreTrustConfig(trustStorePath, password, storeType, algorithm).     }     return defaultTrustConfig. }
false;private;1;36;;private SslKeyConfig buildKeyConfig(Path basePath) {     final Path certificatePath = resolveSetting(CERTIFICATE, basePath::resolve, null).     final Path keyPath = resolveSetting(KEY, basePath::resolve, null).     final Path keyStorePath = resolveSetting(KEYSTORE_PATH, basePath::resolve, null).     if (certificatePath != null && keyStorePath != null) {         throw new SslConfigException("cannot specify both [" + settingPrefix + CERTIFICATE + "] and [" + settingPrefix + KEYSTORE_PATH + "]").     }     if (certificatePath != null || keyPath != null) {         if (keyPath == null) {             throw new SslConfigException("cannot specify [" + settingPrefix + CERTIFICATE + "] without also setting [" + settingPrefix + KEY + "]").         }         if (certificatePath == null) {             throw new SslConfigException("cannot specify [" + settingPrefix + KEYSTORE_PATH + "] without also setting [" + settingPrefix + CERTIFICATE + "]").         }         final char[] password = resolvePasswordSetting(KEY_SECURE_PASSPHRASE, KEY_LEGACY_PASSPHRASE).         return new PemKeyConfig(certificatePath, keyPath, password).     }     if (keyStorePath != null) {         final char[] storePassword = resolvePasswordSetting(KEYSTORE_SECURE_PASSWORD, KEYSTORE_LEGACY_PASSWORD).         char[] keyPassword = resolvePasswordSetting(KEYSTORE_SECURE_KEY_PASSWORD, KEYSTORE_LEGACY_KEY_PASSWORD).         if (keyPassword.length == 0) {             keyPassword = storePassword.         }         final String storeType = resolveSetting(KEYSTORE_TYPE, Function.identity(), inferKeyStoreType(keyStorePath)).         final String algorithm = resolveSetting(KEYSTORE_ALGORITHM, Function.identity(), KeyManagerFactory.getDefaultAlgorithm()).         return new StoreKeyConfig(keyStorePath, storePassword, storeType, keyPassword, algorithm).     }     return defaultKeyConfig. }
false;private;2;18;;private char[] resolvePasswordSetting(String secureSettingKey, String legacySettingKey) {     final char[] securePassword = resolveSecureSetting(secureSettingKey, null).     final String legacyPassword = resolveSetting(legacySettingKey, Function.identity(), null).     if (securePassword == null) {         if (legacyPassword == null) {             return EMPTY_PASSWORD.         } else {             return legacyPassword.toCharArray().         }     } else {         if (legacyPassword != null) {             throw new SslConfigException("cannot specify both [" + settingPrefix + secureSettingKey + "] and [" + settingPrefix + legacySettingKey + "]").         } else {             return securePassword.         }     } }
false;private;3;13;;private <V> V resolveSetting(String key, Function<String, V> parser, V defaultValue) {     try {         String setting = getSettingAsString(settingPrefix + key).         if (setting == null || setting.isEmpty()) {             return defaultValue.         }         return parser.apply(setting).     } catch (RuntimeException e) {         throw e.     } catch (Exception e) {         throw new SslConfigException("cannot retrieve setting [" + settingPrefix + key + "]", e).     } }
false;private;2;14;;private char[] resolveSecureSetting(String key, char[] defaultValue) {     try {         char[] setting = getSecureSetting(settingPrefix + key).         if (setting == null || setting.length == 0) {             return defaultValue.         }         return setting.     } catch (RuntimeException e) {         throw e.     } catch (Exception e) {         throw new SslConfigException("cannot retrieve secure setting [" + settingPrefix + key + "]", e).     } }
false;private;3;13;;private <V> List<V> resolveListSetting(String key, Function<String, V> parser, List<V> defaultValue) {     try {         final List<String> list = getSettingAsList(settingPrefix + key).         if (list == null || list.isEmpty()) {             return defaultValue.         }         return list.stream().map(parser).collect(Collectors.toList()).     } catch (RuntimeException e) {         throw e.     } catch (Exception e) {         throw new SslConfigException("cannot retrieve setting [" + settingPrefix + key + "]", e).     } }
false;private,static;0;26;;private static List<String> loadDefaultCiphers() {     final List<String> ciphers128 = Arrays.asList("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_128_CBC_SHA256", "TLS_RSA_WITH_AES_128_CBC_SHA").     final List<String> ciphers256 = Arrays.asList("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA256", "TLS_RSA_WITH_AES_256_CBC_SHA").     if (has256BitAES()) {         List<String> ciphers = new ArrayList<>(ciphers256.size() + ciphers128.size()).         ciphers.addAll(ciphers256).         ciphers.addAll(ciphers128).         return ciphers.     } else {         return ciphers128.     } }
false;private,static;0;8;;private static boolean has256BitAES() {     try {         return Cipher.getMaxAllowedKeyLength("AES") > 128.     } catch (NoSuchAlgorithmException e) {         // No AES? Things are going to be very weird, but technically that means we don't have 256 bit AES, so ...         return false.     } }
