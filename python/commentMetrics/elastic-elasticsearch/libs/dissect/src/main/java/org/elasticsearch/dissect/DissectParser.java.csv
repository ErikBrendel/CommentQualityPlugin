commented;modifiers;parameterAmount;loc;comment;code
true;public;1;108;/**  * <p>Entry point to dissect a string into it's parts.</p>  *  * @param inputString The string to dissect  * @return the key/value Map of the results  * @throws DissectException if unable to dissect a pair into it's parts.  */ ;/**  * <p>Entry point to dissect a string into it's parts.</p>  *  * @param inputString The string to dissect  * @return the key/value Map of the results  * @throws DissectException if unable to dissect a pair into it's parts.  */ public Map<String, String> parse(String inputString) {     /**      * This implements a naive string matching algorithm. The string is walked left to right, comparing each byte against      * another string's bytes looking for matches. If the bytes match, then a second cursor looks ahead to see if all the bytes      * of the other string matches. If they all match, record it and advances the primary cursor to the match point. If it can not match      * all of the bytes then progress the main cursor. Repeat till the end of the input string. Since the string being searching for      * (the delimiter) is generally small and rare the naive approach is efficient.      *      * In this case the the string that is walked is the input string, and the string being searched for is the current delimiter.      * For example for a dissect pattern of {@code %{a},%{b}:%{c}} the delimiters (comma then colon) are searched for in the      * input string. At class construction the list of keys+delimiters are found (dissectPairs), which allows the use of that ordered      * list to know which delimiter to use for the search. The delimiters is progressed once the current delimiter is matched.      *      * There are two special cases that requires additional parsing beyond the standard naive algorithm. Consecutive delimiters should      * results in a empty matches unless the {@code ->} is provided. For example given the dissect pattern of      * {@code %{a},%{b},%{c},%{d}} and input string of {@code foo,,,} the match should be successful with empty values for b,c and d.      * However, if the key modifier {@code ->}, is present it will simply skip over any delimiters just to the right of the key      * without assigning any values. For example {@code %{a->},{%b}} will match the input string of {@code foo,,,,,,bar} with a=foo and      * b=bar.      */     DissectMatch dissectMatch = new DissectMatch(appendSeparator, maxMatches, maxResults, appendCount, referenceCount).     Iterator<DissectPair> it = matchPairs.iterator().     // ensure leading delimiter matches     if (inputString != null && inputString.length() > leadingDelimiter.length() && leadingDelimiter.equals(inputString.substring(0, leadingDelimiter.length()))) {         byte[] input = inputString.getBytes(StandardCharsets.UTF_8).         // grab the first key/delimiter pair         DissectPair dissectPair = it.next().         DissectKey key = dissectPair.getKey().         byte[] delimiter = dissectPair.getDelimiter().getBytes(StandardCharsets.UTF_8).         // start dissection after the first delimiter         int i = leadingDelimiter.length().         int valueStart = i.         int lookAheadMatches.         // if a match is found jump forward to the end of the match         for (. i < input.length. i++) {             lookAheadMatches = 0.             // potential match between delimiter and input string             if (delimiter.length > 0 && input[i] == delimiter[0]) {                 // look ahead to see if the entire delimiter matches the input string                 for (int j = 0. j < delimiter.length. j++) {                     if (i + j < input.length && input[i + j] == delimiter[j]) {                         lookAheadMatches++.                     }                 }                 // found a full delimiter match                 if (lookAheadMatches == delimiter.length) {                     // record the key/value tuple                     byte[] value = Arrays.copyOfRange(input, valueStart, i).                     dissectMatch.add(key, new String(value, StandardCharsets.UTF_8)).                     // jump to the end of the match                     i += lookAheadMatches.                     // look for consecutive delimiters (e.g. a,,,,d,e)                     while (i < input.length) {                         lookAheadMatches = 0.                         for (int j = 0. j < delimiter.length. j++) {                             if (i + j < input.length && input[i + j] == delimiter[j]) {                                 lookAheadMatches++.                             }                         }                         // found consecutive delimiters                         if (lookAheadMatches == delimiter.length) {                             // jump to the end of the match                             i += lookAheadMatches.                             if (!key.skipRightPadding()) {                                 // progress the keys/delimiter if possible                                 if (!it.hasNext()) {                                     // the while loop                                     break.                                 }                                 dissectPair = it.next().                                 key = dissectPair.getKey().                                 // add the key with an empty value for the empty delimiter                                 dissectMatch.add(key, "").                             }                         } else {                             // the while loop                             break.                         }                     }                     // progress the keys/delimiter if possible                     if (!it.hasNext()) {                         // the for loop                         break.                     }                     dissectPair = it.next().                     key = dissectPair.getKey().                     delimiter = dissectPair.getDelimiter().getBytes(StandardCharsets.UTF_8).                     // i is always one byte after the last found delimiter, aka the start of the next value                     valueStart = i.                 }             }         }         // and there is no trailing delimiter         if (!dissectMatch.fullyMatched() && delimiter.length == 0) {             byte[] value = Arrays.copyOfRange(input, valueStart, input.length).             String valueString = new String(value, StandardCharsets.UTF_8).             dissectMatch.add(key, valueString).         }     }     Map<String, String> results = dissectMatch.getResults().     if (!dissectMatch.isValid(results)) {         throw new DissectException.FindMatch(pattern, inputString).     }     return results. }
false;private;0;3;;private DissectKey getKey() {     return key. }
false;private;0;3;;private String getDelimiter() {     return delimiter. }
