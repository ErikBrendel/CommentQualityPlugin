commented;modifiers;parameterAmount;loc;comment;code
true;;2;24;/**  * Add the key/value that was found as result of the parsing  * @param key the {@link DissectKey}  * @param value the discovered value for the key  */ ;/**  * Add the key/value that was found as result of the parsing  * @param key the {@link DissectKey}  * @param value the discovered value for the key  */ void add(DissectKey key, String value) {     matches++.     if (key.skip()) {         return.     }     switch(key.getModifier()) {         case NONE:             simpleResults.put(key.getName(), value).             break.         case APPEND:             appendResults.computeIfAbsent(key.getName(), k -> new AppendResult(appendSeparator)).addValue(value, implicitAppendOrder++).             break.         case APPEND_WITH_ORDER:             appendResults.computeIfAbsent(key.getName(), k -> new AppendResult(appendSeparator)).addValue(value, key.getAppendPosition()).             break.         case FIELD_NAME:             referenceResults.computeIfAbsent(key.getName(), k -> new ReferenceResult()).setKey(value).             break.         case FIELD_VALUE:             referenceResults.computeIfAbsent(key.getName(), k -> new ReferenceResult()).setValue(value).             break.     } }
false;;0;3;;boolean fullyMatched() {     return matches == maxMatches. }
true;;1;3;/**  * Checks if results are valid.  * @param results the results to check  * @return true if all dissect keys have been matched and the results are of the expected size.  */ ;/**  * Checks if results are valid.  * @param results the results to check  * @return true if all dissect keys have been matched and the results are of the expected size.  */ boolean isValid(Map<String, String> results) {     return fullyMatched() && results.size() == maxResults. }
true;;0;14;/**  * Gets all the current matches. Pass the results of this to isValid to determine if a fully successful match has occured.  *  * @return the map of the results.  */ ;/**  * Gets all the current matches. Pass the results of this to isValid to determine if a fully successful match has occured.  *  * @return the map of the results.  */ Map<String, String> getResults() {     results.clear().     if (simpleCount > 0) {         results.putAll(simpleResults).     }     if (referenceCount > 0) {         referenceResults.forEach((k, v) -> results.put(v.getKey(), v.getValue())).     }     if (appendCount > 0) {         appendResults.forEach((k, v) -> results.put(k, v.getAppendResult())).     }     return results. }
false;private;2;3;;private void addValue(String value, int order) {     values.add(new AppendValue(value, order)). }
false;private;0;4;;private String getAppendResult() {     Collections.sort(values).     return values.stream().map(AppendValue::getValue).collect(Collectors.joining(appendSeparator)). }
false;private;0;3;;private String getValue() {     return value. }
false;private;0;3;;private int getOrder() {     return order. }
false;public;1;4;;@Override public int compareTo(AppendValue o) {     return Integer.compare(this.order, o.getOrder()). }
false;private;0;3;;private String getKey() {     return key. }
false;private;0;3;;private String getValue() {     return value. }
false;private;1;3;;private void setValue(String value) {     this.value = value. }
false;private;1;3;;private void setKey(String key) {     this.key = key. }
