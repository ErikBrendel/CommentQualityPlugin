commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;9;;public static String dumpLicense(License license) throws Exception {     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     builder.startObject().     builder.startObject("license").     license.toInnerXContent(builder, ToXContent.EMPTY_PARAMS).     builder.endObject().     builder.endObject().     return Strings.toString(builder). }
false;public,static;2;3;;public static String dateMathString(String time, final long now) {     return dateFormatter.format(dateMathParser.parse(time, () -> now).atZone(ZoneOffset.UTC)). }
false;public,static;2;3;;public static long dateMath(String time, final long now) {     return dateMathParser.parse(time, () -> now).toEpochMilli(). }
false;public,static;1;48;;public static LicenseSpec generateRandomLicenseSpec(int version) {     boolean datesInMillis = randomBoolean().     long now = System.currentTimeMillis().     String uid = UUID.randomUUID().toString().     String issuer = "issuer__" + randomInt().     String issuedTo = "issuedTo__" + randomInt().     String type = version < License.VERSION_NO_FEATURE_TYPE ? randomFrom("subscription", "internal", "development") : randomFrom("basic", "silver", "dev", "gold", "platinum").     final String subscriptionType.     final String feature.     if (version < License.VERSION_NO_FEATURE_TYPE) {         subscriptionType = randomFrom("gold", "silver", "platinum").         feature = "feature__" + randomInt().     } else {         subscriptionType = null.         feature = null.     }     int maxNodes = randomIntBetween(5, 100).     if (datesInMillis) {         long issueDateInMillis = dateMath("now", now).         long expiryDateInMillis = dateMath("now+10d/d", now).         return new LicenseSpec(version, uid, feature, issueDateInMillis, expiryDateInMillis, type, subscriptionType, issuedTo, issuer, maxNodes).     } else {         String issueDate = dateMathString("now", now).         String expiryDate = dateMathString("now+10d/d", now).         return new LicenseSpec(version, uid, feature, issueDate, expiryDate, type, subscriptionType, issuedTo, issuer, maxNodes).     } }
false;public,static;1;27;;public static String generateLicenseSpecString(LicenseSpec licenseSpec) throws IOException {     XContentBuilder licenses = jsonBuilder().     licenses.startObject().     licenses.startObject("license").field("uid", licenseSpec.uid).field("type", licenseSpec.type).field("subscription_type", licenseSpec.subscriptionType).field("issued_to", licenseSpec.issuedTo).field("issuer", licenseSpec.issuer).field("feature", licenseSpec.feature).field("max_nodes", licenseSpec.maxNodes).     if (licenseSpec.issueDate != null) {         licenses.field("issue_date", licenseSpec.issueDate).     } else {         licenses.field("issue_date_in_millis", licenseSpec.issueDateInMillis).     }     if (licenseSpec.expiryDate != null) {         licenses.field("expiry_date", licenseSpec.expiryDate).     } else {         licenses.field("expiry_date_in_millis", licenseSpec.expiryDateInMillis).     }     licenses.field("version", licenseSpec.version).     licenses.endObject().     licenses.endObject().     return Strings.toString(licenses). }
false;public,static;2;21;;public static void assertLicenseSpec(LicenseSpec spec, License license) {     MatcherAssert.assertThat(license.uid(), equalTo(spec.uid)).     MatcherAssert.assertThat(license.issuedTo(), equalTo(spec.issuedTo)).     MatcherAssert.assertThat(license.issuer(), equalTo(spec.issuer)).     MatcherAssert.assertThat(license.type(), equalTo(spec.type)).     MatcherAssert.assertThat(license.maxNodes(), equalTo(spec.maxNodes)).     if (spec.issueDate != null) {         MatcherAssert.assertThat(license.issueDate(), equalTo(DateUtils.beginningOfTheDay(spec.issueDate))).     } else {         MatcherAssert.assertThat(license.issueDate(), equalTo(spec.issueDateInMillis)).     }     if (spec.expiryDate != null) {         MatcherAssert.assertThat(license.expiryDate(), equalTo(DateUtils.endOfTheDay(spec.expiryDate))).     } else {         MatcherAssert.assertThat(license.expiryDate(), equalTo(spec.expiryDateInMillis)).     } }
false;public,static;3;23;;public static License generateSignedLicense(TimeValue expiryDuration, Path pubKeyPath, Path priKeyPath) throws Exception {     long issue = System.currentTimeMillis().     int version = ESTestCase.randomIntBetween(License.VERSION_START, License.VERSION_CURRENT).     String type = version < License.VERSION_NO_FEATURE_TYPE ? randomFrom("subscription", "internal", "development") : randomFrom("trial", "basic", "silver", "dev", "gold", "platinum").     final License.Builder builder = License.builder().uid(UUID.randomUUID().toString()).expiryDate(issue + expiryDuration.getMillis()).issueDate(issue).version(version).type(type).issuedTo("customer").issuer("elasticsearch").maxNodes(5).     if (version == License.VERSION_START) {         builder.subscriptionType(randomFrom("dev", "gold", "platinum", "silver")).         builder.feature(ESTestCase.randomAlphaOfLength(10)).     }     LicenseSigner signer = new LicenseSigner(priKeyPath, pubKeyPath).     return signer.sign(builder.build()). }
