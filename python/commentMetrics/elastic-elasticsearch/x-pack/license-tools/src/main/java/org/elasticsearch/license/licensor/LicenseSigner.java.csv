commented;modifiers;parameterAmount;loc;comment;code
true;public;1;44;/**  * Generates a signature for the {@code licenseSpec}. Signature structure:  * <code>  * | VERSION | MAGIC | PUB_KEY_DIGEST | SIGNED_LICENSE_CONTENT |  * </code>  *  * @return a signed License  */ ;/**  * Generates a signature for the {@code licenseSpec}. Signature structure:  * <code>  * | VERSION | MAGIC | PUB_KEY_DIGEST | SIGNED_LICENSE_CONTENT |  * </code>  *  * @return a signed License  */ public License sign(License licenseSpec) throws IOException {     XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON).     final Map<String, String> licenseSpecViewMode = Collections.singletonMap(License.LICENSE_SPEC_VIEW_MODE, "true").     licenseSpec.toXContent(contentBuilder, new ToXContent.MapParams(licenseSpecViewMode)).     final byte[] signedContent.     final boolean preV4 = licenseSpec.version() < License.VERSION_CRYPTO_ALGORITHMS.     try {         final Signature rsa = Signature.getInstance("SHA512withRSA").         PrivateKey decryptedPrivateKey = CryptUtils.readEncryptedPrivateKey(Files.readAllBytes(privateKeyPath)).         rsa.initSign(decryptedPrivateKey).         final BytesRefIterator iterator = BytesReference.bytes(contentBuilder).iterator().         BytesRef ref.         while ((ref = iterator.next()) != null) {             rsa.update(ref.bytes, ref.offset, ref.length).         }         signedContent = rsa.sign().     } catch (InvalidKeyException | IOException | NoSuchAlgorithmException | SignatureException e) {         throw new IllegalStateException(e).     }     final byte[] magic = new byte[MAGIC_LENGTH].     SecureRandom random = new SecureRandom().     random.nextBytes(magic).     final byte[] publicKeyBytes = Files.readAllBytes(publicKeyPath).     PublicKey publicKey = CryptUtils.readPublicKey(publicKeyBytes).     final byte[] pubKeyFingerprint = preV4 ? Base64.getEncoder().encode(CryptUtils.writeEncryptedPublicKey(publicKey)) : getPublicKeyFingerprint(publicKeyBytes).     byte[] bytes = new byte[4 + 4 + MAGIC_LENGTH + 4 + pubKeyFingerprint.length + 4 + signedContent.length].     ByteBuffer byteBuffer = ByteBuffer.wrap(bytes).     byteBuffer.putInt(licenseSpec.version()).putInt(magic.length).put(magic).putInt(pubKeyFingerprint.length).put(pubKeyFingerprint).putInt(signedContent.length).put(signedContent).     return License.builder().fromLicenseSpec(licenseSpec, Base64.getEncoder().encodeToString(bytes)).build(). }
false;private;1;5;;private byte[] getPublicKeyFingerprint(byte[] keyBytes) {     MessageDigest sha256 = MessageDigests.sha256().     sha256.update(keyBytes).     return sha256.digest(). }
