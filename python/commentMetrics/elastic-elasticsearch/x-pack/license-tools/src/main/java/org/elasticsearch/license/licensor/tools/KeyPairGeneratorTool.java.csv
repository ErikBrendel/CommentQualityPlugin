commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static void main(String[] args) throws Exception {     exit(new KeyPairGeneratorTool().main(args, Terminal.DEFAULT)). }
false;protected;1;7;;@Override protected void printAdditionalHelp(Terminal terminal) {     terminal.println("This tool generates and saves a key pair to the provided publicKeyPath").     terminal.println("and privateKeyPath. The tool checks the existence of the provided key").     terminal.println("paths and will not override if any existing keys are found.").     terminal.println(""). }
false;protected;2;25;;@Override protected void execute(Terminal terminal, OptionSet options) throws Exception {     Path publicKeyPath = parsePath(publicKeyPathOption.value(options)).     Path privateKeyPath = parsePath(privateKeyPathOption.value(options)).     if (Files.exists(privateKeyPath)) {         throw new UserException(ExitCodes.USAGE, privateKeyPath + " already exists").     } else if (Files.exists(publicKeyPath)) {         throw new UserException(ExitCodes.USAGE, publicKeyPath + " already exists").     }     SecureRandom random = new SecureRandom().     KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA").     keyGen.initialize(2048, random).     KeyPair keyPair = keyGen.generateKeyPair().     Files.write(privateKeyPath, writeEncryptedPrivateKey(keyPair.getPrivate())).     Files.write(publicKeyPath, keyPair.getPublic().getEncoded()).     terminal.println(Terminal.Verbosity.VERBOSE, "generating key pair [public key: " + publicKeyPath + ", private key: " + privateKeyPath + "]"). }
false;private,static;1;4;;@SuppressForbidden(reason = "Parsing command line path") private static Path parsePath(String path) {     return PathUtils.get(path). }
