commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static void main(String[] args) throws Exception {     exit(new LicenseVerificationTool().main(args, Terminal.DEFAULT)). }
false;protected;2;39;;@Override protected void execute(Terminal terminal, OptionSet options) throws Exception {     Path publicKeyPath = parsePath(publicKeyPathOption.value(options)).     if (Files.exists(publicKeyPath) == false) {         throw new UserException(ExitCodes.USAGE, publicKeyPath + " does not exist").     }     final License licenseSpec.     if (options.has(licenseOption)) {         final BytesArray bytes = new BytesArray(licenseOption.value(options).getBytes(StandardCharsets.UTF_8)).         licenseSpec = License.fromSource(bytes, XContentType.JSON).     } else if (options.has(licenseFileOption)) {         Path licenseSpecPath = parsePath(licenseFileOption.value(options)).         if (Files.exists(licenseSpecPath) == false) {             throw new UserException(ExitCodes.USAGE, licenseSpecPath + " does not exist").         }         final BytesArray bytes = new BytesArray(Files.readAllBytes(licenseSpecPath)).         licenseSpec = License.fromSource(bytes, XContentType.JSON).     } else {         throw new UserException(ExitCodes.USAGE, "Must specify either --license or --licenseFile").     }     // verify     if (!LicenseVerifier.verifyLicense(licenseSpec, Files.readAllBytes(publicKeyPath))) {         throw new UserException(ExitCodes.DATA_ERROR, "Invalid License!").     }     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     builder.startObject().     builder.startObject("license").     licenseSpec.toInnerXContent(builder, ToXContent.EMPTY_PARAMS).     builder.endObject().     builder.endObject().     builder.flush().     terminal.println(Strings.toString(builder)). }
false;private,static;1;4;;@SuppressForbidden(reason = "Parsing command line path") private static Path parsePath(String path) {     return PathUtils.get(path). }
