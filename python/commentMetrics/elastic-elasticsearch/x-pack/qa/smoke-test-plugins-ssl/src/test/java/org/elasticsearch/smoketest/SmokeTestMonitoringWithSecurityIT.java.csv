commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;19;;@Override protected void after() {     try {         GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } catch (IllegalStateException e) {         if (e.getMessage().equals("thread was not started") == false) {             throw e.         }     // ignore since the thread was never started     }     try {         ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return Collections.singletonList(XPackPlugin.class). }
false;protected;0;6;;@Override protected Settings externalClusterClientSettings() {     return Settings.builder().put(SecurityField.USER_SETTING.getKey(), USER + ":" + PASS).put(NetworkModule.TRANSPORT_TYPE_KEY, SecurityField.NAME4).build(). }
false;public;0;9;;@Before public void enableExporter() throws Exception {     Settings exporterSettings = Settings.builder().put("xpack.monitoring.collection.enabled", true).put("xpack.monitoring.exporters._http.enabled", true).put("xpack.monitoring.exporters._http.host", "https://" + randomNodeHttpAddress()).build().     assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(exporterSettings)). }
false;public;0;9;;@After public void disableExporter() {     Settings exporterSettings = Settings.builder().putNull("xpack.monitoring.collection.enabled").putNull("xpack.monitoring.exporters._http.enabled").putNull("xpack.monitoring.exporters._http.host").build().     assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(exporterSettings)). }
false;private;0;13;;private boolean getMonitoringUsageExportersDefined() throws Exception {     final XPackUsageResponse usageResponse = new XPackUsageRequestBuilder(client()).execute().get().     final Optional<MonitoringFeatureSetUsage> monitoringUsage = usageResponse.getUsages().stream().filter(usage -> usage instanceof MonitoringFeatureSetUsage).map(usage -> (MonitoringFeatureSetUsage) usage).findFirst().     assertThat("Monitoring feature set does not exist", monitoringUsage.isPresent(), is(true)).     return monitoringUsage.get().getExporters().isEmpty() == false. }
false;public;0;31;;public void testHTTPExporterWithSSL() throws Exception {     // Ensures that the exporter is actually on     assertBusy(() -> assertThat("[_http] exporter is not defined", getMonitoringUsageExportersDefined(), is(true))).     // Checks that the monitoring index templates have been installed     assertBusy(() -> {         GetIndexTemplatesResponse response = client().admin().indices().prepareGetTemplates(MONITORING_PATTERN).get().         assertThat(response.getIndexTemplates().size(), greaterThanOrEqualTo(2)).     }).     // Waits for monitoring indices to be created     assertBusy(() -> {         try {             assertThat(client().admin().indices().prepareExists(MONITORING_PATTERN).get().isExists(), equalTo(true)).         } catch (Exception e) {             fail("exception when checking for monitoring documents: " + e.getMessage()).         }     }).     // Waits for indices to be ready     ensureYellowAndNoInitializingShards(MONITORING_PATTERN).     // Checks that the HTTP exporter has successfully exported some data     assertBusy(() -> {         try {             assertThat(client().prepareSearch(MONITORING_PATTERN).setSize(0).get().getHits().getTotalHits().value, greaterThan(0L)).         } catch (Exception e) {             fail("exception when checking for monitoring documents: " + e.getMessage()).         }     }). }
false;private;0;10;;private String randomNodeHttpAddress() {     List<NodeInfo> nodes = client().admin().cluster().prepareNodesInfo().clear().setHttp(true).get().getNodes().     assertThat(nodes.size(), greaterThan(0)).     InetSocketAddress[] httpAddresses = new InetSocketAddress[nodes.size()].     for (int i = 0. i < nodes.size(). i++) {         httpAddresses[i] = nodes.get(i).getHttp().address().publishAddress().address().     }     return NetworkAddress.format(randomFrom(httpAddresses)). }
