commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;8;;@BeforeClass public static void setupRealm() {     realmConfig = randomFrom(RealmConfig.values()).     roleMappings = realmConfig.selectRoleMappings(ESTestCase::randomBoolean).     LogManager.getLogger(AbstractAdLdapRealmTestCase.class).info("running test with realm configuration [{}], with direct group to role mapping [{}]. Settings [{}]", realmConfig, realmConfig.mapGroupsAsRoles, realmConfig.settings). }
false;public,static;0;4;;@AfterClass public static void cleanupRealm() {     realmConfig = null. }
false;protected;1;42;;@Override protected Settings nodeSettings(int nodeOrdinal) {     final RealmConfig realm = AbstractAdLdapRealmTestCase.realmConfig.     final Path nodeCert = getDataPath(TESTNODE_CERT).     final Path nodeKey = getDataPath(TESTNODE_KEY).     Settings.Builder builder = Settings.builder().     // don't use filter since it returns a prefixed secure setting instead of mock!     Settings settingsToAdd = super.nodeSettings(nodeOrdinal).     builder.put(settingsToAdd.filter(k -> k.startsWith("xpack.transport.security.ssl.") == false), false).     MockSecureSettings mockSecureSettings = (MockSecureSettings) Settings.builder().put(settingsToAdd).getSecureSettings().     if (mockSecureSettings != null) {         MockSecureSettings filteredSecureSettings = new MockSecureSettings().         builder.setSecureSettings(filteredSecureSettings).         for (String secureSetting : mockSecureSettings.getSettingNames()) {             if (secureSetting.startsWith("xpack.transport.security.ssl.") == false) {                 SecureString secureString = mockSecureSettings.getString(secureSetting).                 if (secureString == null) {                     final byte[] fileBytes.                     try (InputStream in = mockSecureSettings.getFile(secureSetting).                         ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {                         int numRead.                         byte[] bytes = new byte[1024].                         while ((numRead = in.read(bytes)) != -1) {                             byteArrayOutputStream.write(bytes, 0, numRead).                         }                         byteArrayOutputStream.flush().                         fileBytes = byteArrayOutputStream.toByteArray().                     } catch (IOException e) {                         throw new UncheckedIOException(e).                     }                     filteredSecureSettings.setFile(secureSetting, fileBytes).                 } else {                     filteredSecureSettings.setString(secureSetting, new String(secureString.getChars())).                 }             }         }     }     addSslSettingsForKeyPair(builder, nodeKey, "testnode", nodeCert, getNodeTrustedCertificates()).     builder.put(buildRealmSettings(realm, roleMappings, getNodeTrustedCertificates())).     return builder.build(). }
false;protected;3;7;;protected Settings buildRealmSettings(RealmConfig realm, List<RoleMappingEntry> roleMappingEntries, List<String> certificateAuthorities) {     Settings.Builder builder = Settings.builder().     builder.put(realm.buildSettings(certificateAuthorities)).     configureFileRoleMappings(builder, roleMappingEntries).     return builder.build(). }
false;public;0;21;;@Before public void setupRoleMappings() throws Exception {     assertSecurityIndexActive().     List<String> content = getRoleMappingContent(RoleMappingEntry::getNativeContent).     if (content.isEmpty()) {         return.     }     SecurityClient securityClient = securityClient().     Map<String, ActionFuture<PutRoleMappingResponse>> futures = new LinkedHashMap<>(content.size()).     for (int i = 0. i < content.size(). i++) {         final String name = "external_" + i.         final PutRoleMappingRequestBuilder builder = securityClient.preparePutRoleMapping(name, new BytesArray(content.get(i)), XContentType.JSON).         futures.put(name, builder.execute()).     }     for (String mappingName : futures.keySet()) {         final PutRoleMappingResponse response = futures.get(mappingName).get().         logger.info("Created native role-mapping {} : {}", mappingName, response.isCreated()).     } }
false;public;0;4;;@After public void cleanupSecurityIndex() throws Exception {     super.deleteSecurityIndex(). }
false;public;0;6;;@Override public Set<String> excludeTemplates() {     Set<String> templates = Sets.newHashSet(super.excludeTemplates()).     // don't remove the security index template     templates.add(SecurityIndexManager.SECURITY_TEMPLATE_NAME).     return templates. }
false;private;1;3;;private List<String> getRoleMappingContent(Function<RoleMappingEntry, String> contentFunction) {     return getRoleMappingContent(contentFunction, AbstractAdLdapRealmTestCase.roleMappings). }
false;private;2;6;;private List<String> getRoleMappingContent(Function<RoleMappingEntry, String> contentFunction, List<RoleMappingEntry> mappings) {     return mappings.stream().map(contentFunction).filter(Objects::nonNull).collect(Collectors.toList()). }
false;protected,final;2;6;;protected final void configureFileRoleMappings(Settings.Builder builder, List<RoleMappingEntry> mappings) {     String content = getRoleMappingContent(RoleMappingEntry::getFileContent, mappings).stream().collect(Collectors.joining("\n")).     Path nodeFiles = createTempDir().     String file = writeFile(nodeFiles, "role_mapping.yml", content).     builder.put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".files.role_mapping", file). }
false;protected;0;25;;@Override protected String configRoles() {     return super.configRoles() + "\n" + "Avengers:\n" + "  cluster: [ NONE ]\n" + "  indices:\n" + "    - names: 'avengers'\n" + "      privileges: [ all ]\n" + "SHIELD:\n" + "  cluster: [ NONE ]\n" + "  indices:\n" + "    - names: '" + SECURITY_INDEX + "'\n" + "      privileges: [ all ]\n" + "Gods:\n" + "  cluster: [ NONE ]\n" + "  indices:\n" + "    - names: '" + ASGARDIAN_INDEX + "'\n" + "      privileges: [ all ]\n" + "Philanthropists:\n" + "  cluster: [ NONE ]\n" + "  indices:\n" + "    - names: '" + PHILANTHROPISTS_INDEX + "'\n" + "      privileges: [ all ]\n". }
false;protected;2;19;;protected void assertAccessAllowed(String user, String index) throws IOException {     Client client = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, userHeader(user, PASSWORD))).     IndexResponse indexResponse = client.prepareIndex(index, "type").setSource(jsonBuilder().startObject().field("name", "value").endObject()).execute().actionGet().     assertEquals("user " + user + " should have write access to index " + index, DocWriteResponse.Result.CREATED, indexResponse.getResult()).     refresh().     GetResponse getResponse = client.prepareGet(index, "type", indexResponse.getId()).get().     assertThat("user " + user + " should have read access to index " + index, getResponse.getId(), equalTo(indexResponse.getId())). }
false;protected;2;15;;protected void assertAccessDenied(String user, String index) throws IOException {     try {         client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, userHeader(user, PASSWORD))).prepareIndex(index, "type").setSource(jsonBuilder().startObject().field("name", "value").endObject()).execute().actionGet().         fail("Write access to index " + index + " should not be allowed for user " + user).     } catch (ElasticsearchSecurityException e) {     // expected     }     refresh(). }
false;protected,static;2;3;;protected static String userHeader(String username, String password) {     return UsernamePasswordToken.basicAuthHeaderValue(username, new SecureString(password.toCharArray())). }
false;private;5;8;;private void addSslSettingsForKeyPair(Settings.Builder builder, Path key, String keyPassphrase, Path cert, List<String> certificateAuthorities) {     builder.put("xpack.transport.security.ssl.key", key).put("xpack.transport.security.ssl.key_passphrase", keyPassphrase).put("xpack.transport.security.ssl.verification_mode", "certificate").put("xpack.transport.security.ssl.certificate", cert).putList("xpack.transport.security.ssl.certificate_authorities", certificateAuthorities). }
true;;0;16;/**  * Collects all the certificates that are normally trusted by the node ( contained in testnode.jks )  */ ;/**  * Collects all the certificates that are normally trusted by the node ( contained in testnode.jks )  */ List<String> getNodeTrustedCertificates() {     Path testnodeCert = getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt").     Path testnodeClientProfileCert = getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode-client-profile.crt").     Path activedirCert = getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/active-directory-ca.crt").     Path testclientCert = getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt").     Path openldapCert = getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/openldap.crt").     Path samba4Cert = getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/samba4.crt").     return Arrays.asList(testnodeCert.toString(), testnodeClientProfileCert.toString(), activedirCert.toString(), testclientCert.toString(), openldapCert.toString(), samba4Cert.toString()). }
false;;0;3;;String getFileContent() {     return fileContent. }
false;;0;3;;String getNativeContent() {     return nativeContent. }
false;;1;13;;RoleMappingEntry pickEntry(Supplier<Boolean> shouldPickFileContent) {     if (nativeContent == null) {         return new RoleMappingEntry(fileContent, null).     }     if (fileContent == null) {         return new RoleMappingEntry(null, nativeContent).     }     if (shouldPickFileContent.get()) {         return new RoleMappingEntry(fileContent, null).     } else {         return new RoleMappingEntry(null, nativeContent).     } }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final RoleMappingEntry that = (RoleMappingEntry) o.     return Objects.equals(this.fileContent, that.fileContent) && Objects.equals(this.nativeContent, that.nativeContent). }
false;public;0;6;;@Override public int hashCode() {     int result = Objects.hashCode(fileContent).     result = 31 * result + Objects.hashCode(nativeContent).     return result. }
false;public;1;3;;public Settings buildSettings(List<String> certificateAuthorities) {     return buildSettings(certificateAuthorities, 1). }
false;protected;2;9;;protected Settings buildSettings(List<String> certificateAuthorities, int order) {     Settings.Builder builder = Settings.builder().put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".order", order).put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".hostname_verification", false).put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".unmapped_groups_as_roles", mapGroupsAsRoles).put(this.settings).putList(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".ssl.certificate_authorities", certificateAuthorities).     return builder.build(). }
false;public;1;10;;public List<RoleMappingEntry> selectRoleMappings(Supplier<Boolean> shouldPickFileContent) {     // if mapGroupsAsRoles is turned on we use empty role mapping     if (mapGroupsAsRoles) {         return Collections.emptyList().     } else {         return Arrays.stream(this.roleMappings).map(e -> e.pickEntry(shouldPickFileContent)).collect(Collectors.toList()).     } }
