commented;modifiers;parameterAmount;loc;comment;code
false;public;2;8;;@Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {     String fileName = file.getFileName().toString().     if (fileName.endsWith(".crt")) {         certificatePaths.add(getDataPath("../ldap/support/" + fileName).toString()).     }     return FileVisitResult.CONTINUE. }
false;public;0;32;;@Before public void initializeSslSocketFactory() throws Exception {     // We use certificates in PEM format and `ssl.certificate_authorities` instead of ssl.trustore     // so that these tests can also run in a FIPS JVM where JKS keystores can't be used.     certificatePaths = new ArrayList<>().     Files.walkFileTree(getDataPath("../ldap/support"), new SimpleFileVisitor<Path>() {          @Override         public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {             String fileName = file.getFileName().toString().             if (fileName.endsWith(".crt")) {                 certificatePaths.add(getDataPath("../ldap/support/" + fileName).toString()).             }             return FileVisitResult.CONTINUE.         }     }).     /*          * Prior to each test we reinitialize the socket factory with a new SSLService so that we get a new SSLContext.          * If we re-use a SSLContext, previously connected sessions can get re-established which breaks hostname          * verification tests since a re-established connection does not perform hostname verification.          */     Settings.Builder builder = Settings.builder().put("path.home", createTempDir()).     // fake realms so ssl will get loaded     builder.putList("xpack.security.authc.realms.foo.ssl.certificate_authorities", certificatePaths).     builder.put("xpack.security.authc.realms.foo.ssl.verification_mode", VerificationMode.FULL).     builder.putList("xpack.security.authc.realms.bar.ssl.certificate_authorities", certificatePaths).     builder.put("xpack.security.authc.realms.bar.ssl.verification_mode", VerificationMode.CERTIFICATE).     globalSettings = builder.build().     Environment environment = TestEnvironment.newEnvironment(globalSettings).     sslService = new SSLService(globalSettings, environment). }
false;;6;22;;Settings buildAdSettings(RealmConfig.RealmIdentifier realmId, String ldapUrl, String adDomainName, String userSearchDN, LdapSearchScope scope, boolean hostnameVerification) {     final String realmName = realmId.getName().     Settings.Builder builder = Settings.builder().putList(getFullSettingKey(realmId, SessionFactorySettings.URLS_SETTING), ldapUrl).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_DOMAIN_NAME_SETTING), adDomainName).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_USER_SEARCH_BASEDN_SETTING), userSearchDN).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_USER_SEARCH_SCOPE_SETTING), scope).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_LDAP_PORT_SETTING), AD_LDAP_PORT).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_LDAPS_PORT_SETTING), AD_LDAPS_PORT).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_GC_LDAP_PORT_SETTING), AD_GC_LDAP_PORT).put(getFullSettingKey(realmName, ActiveDirectorySessionFactorySettings.AD_GC_LDAPS_PORT_SETTING), AD_GC_LDAPS_PORT).put(getFullSettingKey(realmId, SessionFactorySettings.FOLLOW_REFERRALS_SETTING), FOLLOW_REFERRALS).putList(getFullSettingKey(realmId, SSLConfigurationSettings.CAPATH_SETTING_REALM), certificatePaths).     if (randomBoolean()) {         builder.put(getFullSettingKey(realmId, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM), hostnameVerification ? VerificationMode.FULL : VerificationMode.CERTIFICATE).     } else {         builder.put(getFullSettingKey(realmId, SessionFactorySettings.HOSTNAME_VERIFICATION_SETTING), hostnameVerification).     }     return builder.build(). }
false;public;0;16;;@Override public Void run() {     try {         if (conn instanceof LDAPConnection) {             ((LDAPConnection) conn).reconnect().         } else if (conn instanceof LDAPConnectionPool) {             try (LDAPConnection c = ((LDAPConnectionPool) conn).getConnection()) {                 c.reconnect().             }         }     } catch (LDAPException e) {         fail("Connection is not valid. It will not work on follow referral flow." + System.lineSeparator() + ExceptionsHelper.stackTrace(e)).     }     return null. }
false;protected,static;1;20;;protected static void assertConnectionCanReconnect(LDAPInterface conn) {     AccessController.doPrivileged(new PrivilegedAction<Void>() {          @Override         public Void run() {             try {                 if (conn instanceof LDAPConnection) {                     ((LDAPConnection) conn).reconnect().                 } else if (conn instanceof LDAPConnectionPool) {                     try (LDAPConnection c = ((LDAPConnectionPool) conn).getConnection()) {                         c.reconnect().                     }                 }             } catch (LDAPException e) {                 fail("Connection is not valid. It will not work on follow referral flow." + System.lineSeparator() + ExceptionsHelper.stackTrace(e)).             }             return null.         }     }). }
false;private,static;2;4;;private static String getFromEnv(String envVar, String defaultValue) {     final String value = System.getenv(envVar).     return value == null ? defaultValue : value. }
false;private,static;1;6;;private static String getFromProperty(String port) {     String key = "test.fixtures.smb-fixture.tcp." + port.     final String value = System.getProperty(key).     assertNotNull("Expected the actual value for port " + port + " to be in system property " + key, value).     return value. }
