commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;9;;private static Oid getSpnegoOid() {     Oid oid = null.     try {         oid = new Oid("1.3.6.1.5.5.2").     } catch (GSSException gsse) {         throw ExceptionsHelper.convertToRuntime(gsse).     }     return oid. }
false;public;1;5;;@Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {     setupSpnegoAuthSchemeSupport(httpClientBuilder).     return httpClientBuilder. }
false;private;1;26;;private void setupSpnegoAuthSchemeSupport(HttpAsyncClientBuilder httpClientBuilder) {     final Lookup<AuthSchemeProvider> authSchemeRegistry = RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory()).build().     final GSSManager gssManager = GSSManager.getInstance().     try {         final GSSName gssUserPrincipalName = gssManager.createName(userPrincipalName, GSSName.NT_USER_NAME).         login().         final AccessControlContext acc = AccessController.getContext().         final GSSCredential credential = doAsPrivilegedWrapper(loginContext.getSubject(), (PrivilegedExceptionAction<GSSCredential>) () -> gssManager.createCredential(gssUserPrincipalName, GSSCredential.DEFAULT_LIFETIME, SPNEGO_OID, GSSCredential.INITIATE_ONLY), acc).         final KerberosCredentialsProvider credentialsProvider = new KerberosCredentialsProvider().         credentialsProvider.setCredentials(new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM, AuthSchemes.SPNEGO), new KerberosCredentials(credential)).         httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider).     } catch (GSSException e) {         throw new RuntimeException(e).     } catch (PrivilegedActionException e) {         throw new RuntimeException(e.getCause()).     }     httpClientBuilder.setDefaultAuthSchemeRegistry(authSchemeRegistry). }
true;public,synchronized;0;21;/**  * If logged in {@link LoginContext} is not available, it attempts login and  * returns {@link LoginContext}  *  * @return {@link LoginContext}  * @throws PrivilegedActionException  */ ;/**  * If logged in {@link LoginContext} is not available, it attempts login and  * returns {@link LoginContext}  *  * @return {@link LoginContext}  * @throws PrivilegedActionException  */ public synchronized LoginContext login() throws PrivilegedActionException {     if (this.loginContext == null) {         AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {             final Subject subject = new Subject(false, Collections.singleton(new KerberosPrincipal(userPrincipalName)), Collections.emptySet(), Collections.emptySet()).             Configuration conf = null.             final CallbackHandler callback.             if (password != null) {                 conf = new PasswordJaasConf(userPrincipalName, enableDebugLogs).                 callback = new KrbCallbackHandler(userPrincipalName, password).             } else {                 conf = new KeytabJaasConf(userPrincipalName, keytabPath, enableDebugLogs).                 callback = null.             }             loginContext = new LoginContext(CRED_CONF_NAME, subject, callback, conf).             loginContext.login().             return null.         }).     }     return loginContext. }
true;static;3;11;/**  * Privileged Wrapper that invokes action with Subject.doAs to perform work as  * given subject.  *  * @param subject {@link Subject} to be used for this work  * @param action {@link PrivilegedExceptionAction} action for performing inside  *            Subject.doAs  * @param acc the {@link AccessControlContext} to be tied to the specified  *            subject and action see  *            {@link Subject#doAsPrivileged(Subject, PrivilegedExceptionAction, AccessControlContext)  * @return the value returned by the PrivilegedExceptionAction's run method  * @throws PrivilegedActionException  */ ;/**  * Privileged Wrapper that invokes action with Subject.doAs to perform work as  * given subject.  *  * @param subject {@link Subject} to be used for this work  * @param action {@link PrivilegedExceptionAction} action for performing inside  *            Subject.doAs  * @param acc the {@link AccessControlContext} to be tied to the specified  *            subject and action see  *            {@link Subject#doAsPrivileged(Subject, PrivilegedExceptionAction, AccessControlContext)  * @return the value returned by the PrivilegedExceptionAction's run method  * @throws PrivilegedActionException  */ static <T> T doAsPrivilegedWrapper(final Subject subject, final PrivilegedExceptionAction<T> action, final AccessControlContext acc) throws PrivilegedActionException {     try {         return AccessController.doPrivileged((PrivilegedExceptionAction<T>) () -> Subject.doAsPrivileged(subject, action, acc)).     } catch (PrivilegedActionException pae) {         if (pae.getCause() instanceof PrivilegedActionException) {             throw (PrivilegedActionException) pae.getCause().         }         throw pae.     } }
false;public;2;8;;@Override public void setCredentials(AuthScope authscope, Credentials credentials) {     if (authscope.getScheme().regionMatches(true, 0, AuthSchemes.SPNEGO, 0, AuthSchemes.SPNEGO.length()) == false) {         throw new IllegalArgumentException("Only " + AuthSchemes.SPNEGO + " auth scheme is supported in AuthScope").     }     this.authScope = authscope.     this.credentials = credentials. }
false;public;1;5;;@Override public Credentials getCredentials(AuthScope authscope) {     assert this.authScope != null && authscope != null.     return authscope.match(this.authScope) > -1 ? this.credentials : null. }
false;public;0;5;;@Override public void clear() {     this.authScope = null.     this.credentials = null. }
false;public;1;11;;public void handle(final Callback[] callbacks) throws IOException, UnsupportedCallbackException {     for (Callback callback : callbacks) {         if (callback instanceof PasswordCallback) {             PasswordCallback pc = (PasswordCallback) callback.             if (pc.getPrompt().contains(principal)) {                 pc.setPassword(password.getChars()).                 break.             }         }     } }
false;public;1;4;;public void addOptions(final Map<String, String> options) {     options.put("useTicketCache", Boolean.FALSE.toString()).     options.put("useKeyTab", Boolean.FALSE.toString()). }
false;public;1;5;;public void addOptions(final Map<String, String> options) {     options.put("useKeyTab", Boolean.TRUE.toString()).     options.put("keyTab", keytabFilePath).     options.put("doNotPrompt", Boolean.TRUE.toString()). }
false;public;1;11;;@Override public AppConfigurationEntry[] getAppConfigurationEntry(final String name) {     final Map<String, String> options = new HashMap<>().     options.put("principal", userPrincipalName).     options.put("isInitiator", Boolean.TRUE.toString()).     options.put("storeKey", Boolean.TRUE.toString()).     options.put("debug", Boolean.toString(enableDebugLogs)).     addOptions(options).     return new AppConfigurationEntry[] { new AppConfigurationEntry(SUN_KRB5_LOGIN_MODULE, AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, Collections.unmodifiableMap(options)) }. }
false;abstract;1;1;;abstract void addOptions(Map<String, String> options).
