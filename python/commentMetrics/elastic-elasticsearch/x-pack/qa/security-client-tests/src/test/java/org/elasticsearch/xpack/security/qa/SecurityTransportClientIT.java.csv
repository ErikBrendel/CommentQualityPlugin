commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected Settings externalClusterClientSettings() {     return Settings.builder().put(SecurityField.USER_SETTING.getKey(), ADMIN_USER_PW).put(NetworkModule.TRANSPORT_TYPE_KEY, "security4").build(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return Collections.singletonList(XPackClientPlugin.class). }
false;public;0;9;;public void testThatTransportClientWithoutAuthenticationDoesNotWork() throws Exception {     try (TransportClient client = transportClient(Settings.EMPTY)) {         boolean connected = awaitBusy(() -> {             return client.connectedNodes().size() > 0.         }, 5L, TimeUnit.SECONDS).         assertThat(connected, is(false)).     } }
false;public;0;20;;public void testThatTransportClientAuthenticationWithTransportClientRole() throws Exception {     Settings settings = Settings.builder().put(SecurityField.USER_SETTING.getKey(), TRANSPORT_USER_PW).build().     try (TransportClient client = transportClient(settings)) {         boolean connected = awaitBusy(() -> {             return client.connectedNodes().size() > 0.         }, 5L, TimeUnit.SECONDS).         assertThat(connected, is(true)).         // this checks that the transport client is really running in a limited state         try {             client.admin().cluster().prepareHealth().get().             fail("the transport user should not be be able to get health!").         } catch (ElasticsearchSecurityException e) {             assertThat(e.toString(), containsString("unauthorized")).         }     } }
false;public;0;25;;public void testTransportClientWithAdminUser() throws Exception {     final boolean useTransportUser = randomBoolean().     Settings settings = Settings.builder().put(SecurityField.USER_SETTING.getKey(), useTransportUser ? TRANSPORT_USER_PW : ADMIN_USER_PW).build().     try (TransportClient client = transportClient(settings)) {         boolean connected = awaitBusy(() -> {             return client.connectedNodes().size() > 0.         }, 5L, TimeUnit.SECONDS).         assertThat(connected, is(true)).         // this checks that the transport client is really running in a limited state         ClusterHealthResponse response.         if (useTransportUser) {             response = client.filterWithHeader(Collections.singletonMap("Authorization", basicAuthHeaderValue("test_user", new SecureString("x-pack-test-password".toCharArray())))).admin().cluster().prepareHealth().get().         } else {             response = client.admin().cluster().prepareHealth().get().         }         assertThat(response.isTimedOut(), is(false)).     } }
false;;1;16;;TransportClient transportClient(Settings extraSettings) {     NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().get().     List<NodeInfo> nodes = nodeInfos.getNodes().     assertTrue(nodes.isEmpty() == false).     TransportAddress publishAddress = randomFrom(nodes).getTransport().address().publishAddress().     String clusterName = nodeInfos.getClusterName().value().     Settings settings = Settings.builder().put(extraSettings).put("cluster.name", clusterName).build().     TransportClient client = new PreBuiltXPackTransportClient(settings).     client.addTransportAddress(publishAddress).     return client. }
