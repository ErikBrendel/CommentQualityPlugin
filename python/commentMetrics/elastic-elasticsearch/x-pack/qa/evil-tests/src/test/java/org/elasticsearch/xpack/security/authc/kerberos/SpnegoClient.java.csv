commented;modifiers;parameterAmount;loc;comment;code
true;;0;5;/**  * GSSContext initiator side handling, initiates context establishment and returns the  * base64 encoded token to be sent to server.  *  * @return Base64 encoded token  * @throws PrivilegedActionException when privileged action threw exception  */ ;/**  * GSSContext initiator side handling, initiates context establishment and returns the  * base64 encoded token to be sent to server.  *  * @return Base64 encoded token  * @throws PrivilegedActionException when privileged action threw exception  */ String getBase64EncodedTokenForSpnegoHeader() throws PrivilegedActionException {     final byte[] outToken = KerberosTestCase.doAsWrapper(loginContext.getSubject(), (PrivilegedExceptionAction<byte[]>) () -> gssContext.initSecContext(new byte[0], 0, 0)).     return Base64.getEncoder().encodeToString(outToken). }
true;;1;12;/**  * Handles server response and returns new token if any to be sent to server.  *  * @param base64Token inToken received from server passed to initSecContext for  *            gss negotiation  * @return Base64 encoded token to be sent to server. May return {@code null} if  *         nothing to be sent.  * @throws PrivilegedActionException when privileged action threw exception  */ ;/**  * Handles server response and returns new token if any to be sent to server.  *  * @param base64Token inToken received from server passed to initSecContext for  *            gss negotiation  * @return Base64 encoded token to be sent to server. May return {@code null} if  *         nothing to be sent.  * @throws PrivilegedActionException when privileged action threw exception  */ String handleResponse(final String base64Token) throws PrivilegedActionException {     if (gssContext.isEstablished()) {         throw new IllegalStateException("GSS Context has already been established").     }     final byte[] token = Base64.getDecoder().decode(base64Token).     final byte[] outToken = KerberosTestCase.doAsWrapper(loginContext.getSubject(), (PrivilegedExceptionAction<byte[]>) () -> gssContext.initSecContext(token, 0, token.length)).     if (outToken == null || outToken.length == 0) {         return null.     }     return Base64.getEncoder().encodeToString(outToken). }
true;public;0;14;/**  * Spnego Client after usage needs to be closed in order to logout from  * {@link LoginContext} and dispose {@link GSSContext}  */ ;/**  * Spnego Client after usage needs to be closed in order to logout from  * {@link LoginContext} and dispose {@link GSSContext}  */ public void close() throws LoginException, GSSException, PrivilegedActionException {     if (loginContext != null) {         AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {             loginContext.logout().             return null.         }).     }     if (gssContext != null) {         AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {             gssContext.dispose().             return null.         }).     } }
true;;0;3;/**  * @return {@code true} If the gss security context was established  */ ;/**  * @return {@code true} If the gss security context was established  */ boolean isEstablished() {     return gssContext.isEstablished(). }
true;private,static;2;11;/**  * Performs authentication using provided principal name and password for client  *  * @param principal Principal name  * @param password {@link SecureString}  * @return authenticated {@link LoginContext} instance. Note: This needs to be  *         closed {@link LoginContext#logout()} after usage.  * @throws LoginException thrown if problem with login configuration or when login fails  */ ;/**  * Performs authentication using provided principal name and password for client  *  * @param principal Principal name  * @param password {@link SecureString}  * @return authenticated {@link LoginContext} instance. Note: This needs to be  *         closed {@link LoginContext#logout()} after usage.  * @throws LoginException thrown if problem with login configuration or when login fails  */ private static LoginContext loginUsingPassword(final String principal, final SecureString password) throws LoginException {     final Set<Principal> principals = Collections.singleton(new KerberosPrincipal(principal)).     final Subject subject = new Subject(false, principals, Collections.emptySet(), Collections.emptySet()).     final Configuration conf = new PasswordJaasConf(principal).     final CallbackHandler callback = new KrbCallbackHandler(principal, password).     final LoginContext loginContext = new LoginContext(CRED_CONF_NAME, subject, callback, conf).     loginContext.login().     return loginContext. }
false;public;1;13;;@Override public AppConfigurationEntry[] getAppConfigurationEntry(final String name) {     final Map<String, String> options = new HashMap<>().     options.put("principal", principal).     options.put("storeKey", Boolean.TRUE.toString()).     options.put("isInitiator", Boolean.TRUE.toString()).     options.put("debug", Boolean.TRUE.toString()).     // Refresh Krb5 config during tests as the port keeps changing for kdc server     options.put("refreshKrb5Config", Boolean.TRUE.toString()).     return new AppConfigurationEntry[] { new AppConfigurationEntry(SUN_KRB5_LOGIN_MODULE, AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, Collections.unmodifiableMap(options)) }. }
false;public;1;11;;public void handle(final Callback[] callbacks) throws IOException, UnsupportedCallbackException {     for (Callback callback : callbacks) {         if (callback instanceof PasswordCallback) {             PasswordCallback pc = (PasswordCallback) callback.             if (pc.getPrompt().contains(principal)) {                 pc.setPassword(password.getChars()).                 break.             }         }     } }
false;public;0;10;;@Override @SuppressForbidden(reason = "For tests where we provide credentials, need to set and reset javax.security.auth.useSubjectCredsOnly") public String run() throws Exception {     String oldValue = System.getProperty("javax.security.auth.useSubjectCredsOnly").     if (value != null) {         System.setProperty("javax.security.auth.useSubjectCredsOnly", value).     }     return oldValue. }
false;private,static;1;22;;private static String getAndSetUseSubjectCredsOnlySystemProperty(final String value) {     String retVal = null.     try {         retVal = AccessController.doPrivileged(new PrivilegedExceptionAction<String>() {              @Override             @SuppressForbidden(reason = "For tests where we provide credentials, need to set and reset javax.security.auth.useSubjectCredsOnly")             public String run() throws Exception {                 String oldValue = System.getProperty("javax.security.auth.useSubjectCredsOnly").                 if (value != null) {                     System.setProperty("javax.security.auth.useSubjectCredsOnly", value).                 }                 return oldValue.             }         }).     } catch (PrivilegedActionException e) {         throw ExceptionsHelper.convertToRuntime(e).     }     return retVal. }
