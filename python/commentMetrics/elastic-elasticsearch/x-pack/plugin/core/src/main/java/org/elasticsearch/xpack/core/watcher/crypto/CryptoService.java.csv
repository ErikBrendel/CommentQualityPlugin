commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;10;;private static SecretKey readSystemKey(InputStream in) throws IOException {     final int keySizeBytes = KEY_SIZE / 8.     final byte[] keyBytes = new byte[keySizeBytes].     final int read = Streams.readFully(in, keyBytes).     if (read != keySizeBytes) {         throw new IllegalArgumentException("key size did not match expected value. was the key generated with elasticsearch-syskeygen?").     }     return new SecretKeySpec(keyBytes, KEY_ALGO). }
true;public;1;5;/**  * Encrypts the provided char array and returns the encrypted values in a char array  * @param chars the characters to encrypt  * @return character array representing the encrypted data  */ ;/**  * Encrypts the provided char array and returns the encrypted values in a char array  * @param chars the characters to encrypt  * @return character array representing the encrypted data  */ public char[] encrypt(char[] chars) {     byte[] charBytes = CharArrays.toUtf8Bytes(chars).     String base64 = Base64.getEncoder().encodeToString(encryptInternal(charBytes, encryptionKey)).     return ENCRYPTED_TEXT_PREFIX.concat(base64).toCharArray(). }
true;public;1;17;/**  * Decrypts the provided char array and returns the plain-text chars  * @param chars the data to decrypt  * @return plaintext chars  */ ;/**  * Decrypts the provided char array and returns the plain-text chars  * @param chars the data to decrypt  * @return plaintext chars  */ public char[] decrypt(char[] chars) {     if (!isEncrypted(chars)) {         // Not encrypted         return chars.     }     String encrypted = new String(chars, ENCRYPTED_TEXT_PREFIX.length(), chars.length - ENCRYPTED_TEXT_PREFIX.length()).     byte[] bytes.     try {         bytes = Base64.getDecoder().decode(encrypted).     } catch (IllegalArgumentException e) {         throw new ElasticsearchException("unable to decode encrypted data", e).     }     byte[] decrypted = decryptInternal(bytes, encryptionKey).     return CharArrays.utf8BytesToChars(decrypted). }
true;protected;1;3;/**  * Checks whether the given chars are encrypted  * @param chars the chars to check if they are encrypted  * @return true is data is encrypted  */ ;/**  * Checks whether the given chars are encrypted  * @param chars the chars to check if they are encrypted  * @return true is data is encrypted  */ protected boolean isEncrypted(char[] chars) {     return CharArrays.charsBeginsWith(ENCRYPTED_TEXT_PREFIX, chars). }
false;private;2;14;;private byte[] encryptInternal(byte[] bytes, SecretKey key) {     byte[] iv = new byte[ivLength].     secureRandom.nextBytes(iv).     Cipher cipher = cipher(Cipher.ENCRYPT_MODE, encryptionAlgorithm, key, iv).     try {         byte[] encrypted = cipher.doFinal(bytes).         byte[] output = new byte[iv.length + encrypted.length].         System.arraycopy(iv, 0, output, 0, iv.length).         System.arraycopy(encrypted, 0, output, iv.length, encrypted.length).         return output.     } catch (BadPaddingException | IllegalBlockSizeException e) {         throw new ElasticsearchException("error encrypting data", e).     } }
false;private;2;18;;private byte[] decryptInternal(byte[] bytes, SecretKey key) {     if (bytes.length < ivLength) {         logger.error("received data for decryption with size [{}] that is less than IV length [{}]", bytes.length, ivLength).         throw new IllegalArgumentException("invalid data to decrypt").     }     byte[] iv = new byte[ivLength].     System.arraycopy(bytes, 0, iv, 0, ivLength).     byte[] data = new byte[bytes.length - ivLength].     System.arraycopy(bytes, ivLength, data, 0, bytes.length - ivLength).     Cipher cipher = cipher(Cipher.DECRYPT_MODE, encryptionAlgorithm, key, iv).     try {         return cipher.doFinal(data).     } catch (BadPaddingException | IllegalBlockSizeException e) {         throw new IllegalStateException("error decrypting data", e).     } }
false;private,static;4;9;;private static Cipher cipher(int mode, String encryptionAlgorithm, SecretKey key, byte[] initializationVector) {     try {         Cipher cipher = Cipher.getInstance(encryptionAlgorithm).         cipher.init(mode, key, new IvParameterSpec(initializationVector)).         return cipher.     } catch (Exception e) {         throw new ElasticsearchException("error creating cipher", e).     } }
false;private,static;3;17;;private static SecretKey encryptionKey(SecretKey systemKey, int keyLength, String algorithm) throws NoSuchAlgorithmException {     byte[] bytes = systemKey.getEncoded().     if ((bytes.length * 8) < keyLength) {         throw new IllegalArgumentException("at least " + keyLength + " bits should be provided as key data").     }     MessageDigest messageDigest = MessageDigest.getInstance("SHA-256").     byte[] digest = messageDigest.digest(bytes).     assert digest.length == (256 / 8).     if ((digest.length * 8) < keyLength) {         throw new IllegalArgumentException("requested key length is too large").     }     byte[] truncatedDigest = Arrays.copyOfRange(digest, 0, (keyLength / 8)).     return new SecretKeySpec(truncatedDigest, algorithm). }
false;public,static;1;5;;public static void addSettings(List<Setting<?>> settings) {     settings.add(ENCRYPTION_KEY_LENGTH_SETTING).     settings.add(ENCRYPTION_KEY_ALGO_SETTING).     settings.add(ENCRYPTION_ALGO_SETTING). }
