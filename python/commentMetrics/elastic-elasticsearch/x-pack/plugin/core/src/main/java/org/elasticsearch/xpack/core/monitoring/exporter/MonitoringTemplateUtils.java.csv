commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Get a template name for any template ID.  *  * @param id The template identifier.  * @return Never {@code null} {@link String} prefixed by ".monitoring-".  * @see #TEMPLATE_IDS  */ ;/**  * Get a template name for any template ID.  *  * @param id The template identifier.  * @return Never {@code null} {@link String} prefixed by ".monitoring-".  * @see #TEMPLATE_IDS  */ public static String templateName(final String id) {     return ".monitoring-" + id. }
true;public,static;1;3;/**  * Get a template name for any template ID for old templates in the previous version.  *  * @param id The template identifier.  * @return Never {@code null} {@link String} prefixed by ".monitoring-" and ended by the {@code OLD_TEMPLATE_VERSION}.  * @see #OLD_TEMPLATE_IDS  */ ;/**  * Get a template name for any template ID for old templates in the previous version.  *  * @param id The template identifier.  * @return Never {@code null} {@link String} prefixed by ".monitoring-" and ended by the {@code OLD_TEMPLATE_VERSION}.  * @see #OLD_TEMPLATE_IDS  */ public static String oldTemplateName(final String id) {     return ".monitoring-" + id + "-" + OLD_TEMPLATE_VERSION. }
false;public,static;1;4;;public static String loadTemplate(final String id) {     String resource = String.format(Locale.ROOT, TEMPLATE_FILE, id).     return TemplateUtils.loadTemplate(resource, TEMPLATE_VERSION, TEMPLATE_VERSION_PROPERTY). }
true;public,static;1;4;/**  * Create a template that does nothing but exist and provide a newer {@code version} so that we know that <em>we</em> created it.  *  * @param id The template identifier.  * @return Never {@code null}.  * @see #OLD_TEMPLATE_IDS  * @see #OLD_TEMPLATE_VERSION  */ ;/**  * Create a template that does nothing but exist and provide a newer {@code version} so that we know that <em>we</em> created it.  *  * @param id The template identifier.  * @return Never {@code null}.  * @see #OLD_TEMPLATE_IDS  * @see #OLD_TEMPLATE_VERSION  */ public static String createEmptyTemplate(final String id) {     // e.g., { "index_patterns": [ ".monitoring-data-2*" ], "version": 6000002 }     return "{\"index_patterns\":[\".monitoring-" + id + "-" + OLD_TEMPLATE_VERSION + "*\"],\"version\":" + LAST_UPDATED_VERSION + "}". }
true;public,static;1;3;/**  * Get a pipeline name for any template ID.  *  * @param id The template identifier.  * @return Never {@code null} {@link String} prefixed by "xpack_monitoring_" and the {@code id}.  * @see #TEMPLATE_IDS  */ ;/**  * Get a pipeline name for any template ID.  *  * @param id The template identifier.  * @return Never {@code null} {@link String} prefixed by "xpack_monitoring_" and the {@code id}.  * @see #TEMPLATE_IDS  */ public static String pipelineName(String id) {     return "xpack_monitoring_" + id. }
true;public,static;2;10;/**  * Create a pipeline that allows documents for different template versions to be upgraded.  * <p>  * The expectation is that you will call either {@link Strings#toString(XContentBuilder)} or  * {@link BytesReference#bytes(XContentBuilder)}}.  *  * @param id The API version (e.g., "2") to use  * @param type The type of data you want to format for the request  * @return Never {@code null}. Always an ended-object.  * @throws IllegalArgumentException if {@code apiVersion} is unrecognized  * @see #PIPELINE_IDS  */ ;/**  * Create a pipeline that allows documents for different template versions to be upgraded.  * <p>  * The expectation is that you will call either {@link Strings#toString(XContentBuilder)} or  * {@link BytesReference#bytes(XContentBuilder)}}.  *  * @param id The API version (e.g., "2") to use  * @param type The type of data you want to format for the request  * @return Never {@code null}. Always an ended-object.  * @throws IllegalArgumentException if {@code apiVersion} is unrecognized  * @see #PIPELINE_IDS  */ public static XContentBuilder loadPipeline(final String id, final XContentType type) {     switch(id) {         case TEMPLATE_VERSION:             return emptyPipeline(type).         case OLD_TEMPLATE_VERSION:             return pipelineForApiVersion2(type).     }     throw new IllegalArgumentException("unrecognized pipeline API version [" + id + "]"). }
true;static;1;65;/**  * Create a pipeline to upgrade documents from {@link MonitoringTemplateUtils#OLD_TEMPLATE_VERSION}  * <pre><code>  * {  *   "description" : "This pipeline upgrades documents ...",  *   "version": 6000001,  *   "processors": [ ]  * }  * </code></pre>  * The expectation is that you will call either {@link Strings#toString(XContentBuilder)} or  * {@link BytesReference#bytes(XContentBuilder)}}.  *  * @param type The type of data you want to format for the request  * @return Never {@code null}. Always an ended-object.  * @see #LAST_UPDATED_VERSION  */ ;/**  * Create a pipeline to upgrade documents from {@link MonitoringTemplateUtils#OLD_TEMPLATE_VERSION}  * <pre><code>  * {  *   "description" : "This pipeline upgrades documents ...",  *   "version": 6000001,  *   "processors": [ ]  * }  * </code></pre>  * The expectation is that you will call either {@link Strings#toString(XContentBuilder)} or  * {@link BytesReference#bytes(XContentBuilder)}}.  *  * @param type The type of data you want to format for the request  * @return Never {@code null}. Always an ended-object.  * @see #LAST_UPDATED_VERSION  */ static XContentBuilder pipelineForApiVersion2(final XContentType type) {     try {         // to pipelines, then it would better serve this use case         return XContentBuilder.builder(type.xContent()).startObject().field("description", "This pipeline upgrades documents from the older version of the Monitoring API to " + "the newer version (" + TEMPLATE_VERSION + ") by fixing breaking " + "changes in those older documents before they are indexed from the older version (" + OLD_TEMPLATE_VERSION + ").").field("version", LAST_UPDATED_VERSION).startArray("processors").startObject().startObject("script").field("source", "boolean legacyIndex = ctx._index == '.monitoring-data-2'." + "if (legacyIndex || ctx._index.startsWith('.monitoring-es-2')) {" + "if (ctx._type == 'cluster_info') {" + "ctx._type = 'cluster_stats'." + "ctx._id = null." + "} else if (legacyIndex || ctx._type == 'cluster_stats' || ctx._type == 'node') {" + "String index = ctx._index." + "Object clusterUuid = ctx.cluster_uuid." + "Object timestamp = ctx.timestamp." + "ctx.clear()." + "ctx._id = 'xpack_monitoring_2_drop_bucket'." + "ctx._index = index." + "ctx._type = 'legacy_data'." + "ctx.timestamp = timestamp." + "ctx.cluster_uuid = clusterUuid." + "}" + "if (legacyIndex) {" + "ctx._index = '<.monitoring-es-" + TEMPLATE_VERSION + "-{now}>'." + "}" + "}").endObject().endObject().startObject().startObject("rename").field("field", "_type").field("target_field", "type").endObject().endObject().startObject().startObject("set").field("field", "_type").field("value", "doc").endObject().endObject().startObject().startObject("gsub").field("field", "_index").field("pattern", "(.monitoring-\\w+-)2(-.+)").field("replacement", "$1" + TEMPLATE_VERSION + "$2").endObject().endObject().endArray().endObject().     } catch (final IOException e) {         throw new RuntimeException("Failed to create pipeline to upgrade from older version [" + OLD_TEMPLATE_VERSION + "] to the newer version [" + TEMPLATE_VERSION + "].", e).     } }
true;public,static;1;14;/**  * Create an empty pipeline.  * <pre><code>  * {  *   "description" : "This is a placeholder pipeline ...",  *   "version": 6000001,  *   "processors": [ ]  * }  * </code></pre>  * The expectation is that you will call either {@link Strings#toString(XContentBuilder)} or  * {@link BytesReference#bytes(XContentBuilder)}}.  *  * @param type The type of data you want to format for the request  * @return Never {@code null}. Always an ended-object.  * @see #LAST_UPDATED_VERSION  */ ;/**  * Create an empty pipeline.  * <pre><code>  * {  *   "description" : "This is a placeholder pipeline ...",  *   "version": 6000001,  *   "processors": [ ]  * }  * </code></pre>  * The expectation is that you will call either {@link Strings#toString(XContentBuilder)} or  * {@link BytesReference#bytes(XContentBuilder)}}.  *  * @param type The type of data you want to format for the request  * @return Never {@code null}. Always an ended-object.  * @see #LAST_UPDATED_VERSION  */ public static XContentBuilder emptyPipeline(final XContentType type) {     try {         // to pipelines, then it would better serve this use case         return XContentBuilder.builder(type.xContent()).startObject().field("description", "This is a placeholder pipeline for Monitoring API version " + TEMPLATE_VERSION + " so that future versions may fix breaking changes.").field("version", LAST_UPDATED_VERSION).startArray("processors").endArray().endObject().     } catch (final IOException e) {         throw new RuntimeException("Failed to create empty pipeline", e).     } }
true;public,static;3;3;/**  * Get the index name given a specific date format, a monitored system and a timestamp.  *  * @param formatter the {@link DateFormatter} to use to compute the timestamped index name  * @param system the {@link MonitoredSystem} for which the index name is computed  * @param timestamp the timestamp value to use to compute the timestamped index name  * @return the index name as a @{link String}  */ ;/**  * Get the index name given a specific date format, a monitored system and a timestamp.  *  * @param formatter the {@link DateFormatter} to use to compute the timestamped index name  * @param system the {@link MonitoredSystem} for which the index name is computed  * @param timestamp the timestamp value to use to compute the timestamped index name  * @return the index name as a @{link String}  */ public static String indexName(final DateFormatter formatter, final MonitoredSystem system, final long timestamp) {     return ".monitoring-" + system.getSystem() + "-" + TEMPLATE_VERSION + "-" + formatter.format(Instant.ofEpochMilli(timestamp)). }
