commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, Job> getJobs() {     return jobs. }
false;public;2;3;;public Set<String> expandJobIds(String expression, boolean allowNoJobs) {     return groupOrJobLookup.expandJobIds(expression, allowNoJobs). }
false;public;0;3;;public SortedMap<String, DatafeedConfig> getDatafeeds() {     return datafeeds. }
false;public;1;3;;public DatafeedConfig getDatafeed(String datafeedId) {     return datafeeds.get(datafeedId). }
false;public;1;3;;public Optional<DatafeedConfig> getDatafeedByJobId(String jobId) {     return datafeeds.values().stream().filter(s -> s.getJobId().equals(jobId)).findFirst(). }
false;public;2;4;;public Set<String> expandDatafeedIds(String expression, boolean allowNoDatafeeds) {     return NameResolver.newUnaliased(datafeeds.keySet(), ExceptionsHelper::missingDatafeedException).expand(expression, allowNoDatafeeds). }
false;public;0;3;;public boolean isUpgradeMode() {     return upgradeMode. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.V_6_0_0_alpha1. }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return MetaData.ALL_CONTEXTS. }
false;public;1;4;;@Override public Diff<MetaData.Custom> diff(MetaData.Custom previousState) {     return new MlMetadataDiff((MlMetadata) previousState, this). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     writeMap(jobs, out).     writeMap(datafeeds, out).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeBoolean(upgradeMode).     } }
false;private,static;2;7;;private static <T extends Writeable> void writeMap(Map<String, T> map, StreamOutput out) throws IOException {     out.writeVInt(map.size()).     for (Map.Entry<String, T> entry : map.entrySet()) {         out.writeString(entry.getKey()).         entry.getValue().writeTo(out).     } }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     DelegatingMapParams extendedParams = new DelegatingMapParams(Collections.singletonMap(ToXContentParams.FOR_INTERNAL_STORAGE, "true"), params).     mapValuesToXContent(JOBS_FIELD, jobs, builder, extendedParams).     mapValuesToXContent(DATAFEEDS_FIELD, datafeeds, builder, extendedParams).     builder.field(UPGRADE_MODE.getPreferredName(), upgradeMode).     return builder. }
false;private,static;4;12;;private static <T extends ToXContent> void mapValuesToXContent(ParseField field, Map<String, T> map, XContentBuilder builder, Params params) throws IOException {     if (map.isEmpty()) {         return.     }     builder.startArray(field.getPreferredName()).     for (Map.Entry<String, T> entry : map.entrySet()) {         entry.getValue().toXContent(builder, params).     }     builder.endArray(). }
true;public;1;6;/**  * Merge the diff with the ML metadata.  * @param part The current ML metadata.  * @return The new ML metadata.  */ ;/**  * Merge the diff with the ML metadata.  * @param part The current ML metadata.  * @return The new ML metadata.  */ @Override public MetaData.Custom apply(MetaData.Custom part) {     TreeMap<String, Job> newJobs = new TreeMap<>(jobs.apply(((MlMetadata) part).jobs)).     TreeMap<String, DatafeedConfig> newDatafeeds = new TreeMap<>(datafeeds.apply(((MlMetadata) part).datafeeds)).     return new MlMetadata(newJobs, newDatafeeds, upgradeMode). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     jobs.writeTo(out).     datafeeds.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeBoolean(upgradeMode).     } }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;static;1;3;;static Diff<Job> readJobDiffFrom(StreamInput in) throws IOException {     return AbstractDiffable.readDiffFrom(Job::new, in). }
false;static;1;3;;static Diff<DatafeedConfig> readDatafeedDiffFrom(StreamInput in) throws IOException {     return AbstractDiffable.readDiffFrom(DatafeedConfig::new, in). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     MlMetadata that = (MlMetadata) o.     return Objects.equals(jobs, that.jobs) && Objects.equals(datafeeds, that.datafeeds) && Objects.equals(upgradeMode, that.upgradeMode). }
false;public,final;0;4;;@Override public final String toString() {     return Strings.toString(this). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(jobs, datafeeds, upgradeMode). }
false;public;2;7;;public Builder putJob(Job job, boolean overwrite) {     if (jobs.containsKey(job.getId()) && overwrite == false) {         throw ExceptionsHelper.jobAlreadyExists(job.getId()).     }     this.jobs.put(job.getId(), job).     return this. }
false;public;1;6;;public Builder putJobs(Collection<Job> jobs) {     for (Job job : jobs) {         putJob(job, true).     }     return this. }
false;public;2;23;;public Builder putDatafeed(DatafeedConfig datafeedConfig, Map<String, String> headers) {     if (datafeeds.containsKey(datafeedConfig.getId())) {         throw ExceptionsHelper.datafeedAlreadyExists(datafeedConfig.getId()).     }     String jobId = datafeedConfig.getJobId().     checkJobIsAvailableForDatafeed(jobId).     Job job = jobs.get(jobId).     DatafeedJobValidator.validate(datafeedConfig, job).     if (headers.isEmpty() == false) {         // Adjust the request, adding security headers from the current thread context         DatafeedConfig.Builder builder = new DatafeedConfig.Builder(datafeedConfig).         Map<String, String> securityHeaders = headers.entrySet().stream().filter(e -> ClientHelper.SECURITY_HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).         builder.setHeaders(securityHeaders).         datafeedConfig = builder.build().     }     datafeeds.put(datafeedConfig.getId(), datafeedConfig).     return this. }
false;private;1;11;;private void checkJobIsAvailableForDatafeed(String jobId) {     Job job = jobs.get(jobId).     if (job == null || job.isDeleting()) {         throw ExceptionsHelper.missingJobException(jobId).     }     Optional<DatafeedConfig> existingDatafeed = getDatafeedByJobId(jobId).     if (existingDatafeed.isPresent()) {         throw ExceptionsHelper.conflictStatusException("A datafeed [" + existingDatafeed.get().getId() + "] already exists for job [" + jobId + "]").     } }
false;private;1;3;;private Optional<DatafeedConfig> getDatafeedByJobId(String jobId) {     return datafeeds.values().stream().filter(s -> s.getJobId().equals(jobId)).findFirst(). }
false;public;1;6;;public Builder putDatafeeds(Collection<DatafeedConfig> datafeeds) {     for (DatafeedConfig datafeed : datafeeds) {         this.datafeeds.put(datafeed.getId(), datafeed).     }     return this. }
false;public;1;4;;public Builder isUpgradeMode(boolean upgradeMode) {     this.upgradeMode = upgradeMode.     return this. }
false;public;0;3;;public MlMetadata build() {     return new MlMetadata(jobs, datafeeds, upgradeMode). }
false;public,static;1;7;;public static MlMetadata getMlMetadata(ClusterState state) {     MlMetadata mlMetadata = (state == null) ? null : state.getMetaData().custom(TYPE).     if (mlMetadata == null) {         return EMPTY_METADATA.     }     return mlMetadata. }
