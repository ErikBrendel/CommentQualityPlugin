commented;modifiers;parameterAmount;loc;comment;code
false;public;0;21;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (name == null) {         validationException = addValidationError("role-mapping name is missing", validationException).     }     if (roles.isEmpty()) {         validationException = addValidationError("role-mapping roles are missing", validationException).     }     if (rules == null) {         validationException = addValidationError("role-mapping rules are missing", validationException).     }     if (MetadataUtils.containsReservedMetadata(metadata)) {         validationException = addValidationError("metadata keys may not start with [" + MetadataUtils.RESERVED_PREFIX + "]", validationException).     }     return validationException. }
false;public;0;3;;public String getName() {     return name. }
false;public;1;3;;public void setName(String name) {     this.name = name. }
false;public;0;3;;public boolean isEnabled() {     return enabled. }
false;public;1;3;;public void setEnabled(boolean enabled) {     this.enabled = enabled. }
false;public;0;3;;public List<String> getRoles() {     return Collections.unmodifiableList(roles). }
false;public;1;3;;public void setRoles(List<String> roles) {     this.roles = new ArrayList<>(roles). }
false;public;0;3;;public RoleMapperExpression getRules() {     return rules. }
false;public;1;3;;public void setRules(RoleMapperExpression expression) {     this.rules = expression. }
false;public;1;5;;@Override public PutRoleMappingRequest setRefreshPolicy(RefreshPolicy refreshPolicy) {     this.refreshPolicy = refreshPolicy.     return this. }
true;public;0;4;/**  * Should this request trigger a refresh ({@linkplain RefreshPolicy#IMMEDIATE}, the default),  * wait for a refresh ({@linkplain RefreshPolicy#WAIT_UNTIL}), or proceed ignore refreshes  * entirely ({@linkplain RefreshPolicy#NONE}).  */ ;/**  * Should this request trigger a refresh ({@linkplain RefreshPolicy#IMMEDIATE}, the default),  * wait for a refresh ({@linkplain RefreshPolicy#WAIT_UNTIL}), or proceed ignore refreshes  * entirely ({@linkplain RefreshPolicy#NONE}).  */ @Override public RefreshPolicy getRefreshPolicy() {     return refreshPolicy. }
false;public;1;3;;public void setMetadata(Map<String, Object> metadata) {     this.metadata = Objects.requireNonNull(metadata). }
false;public;0;3;;public Map<String, Object> getMetadata() {     return metadata. }
false;public;1;10;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     this.name = in.readString().     this.enabled = in.readBoolean().     this.roles = in.readStringList().     this.rules = ExpressionParser.readExpression(in).     this.metadata = in.readMap().     this.refreshPolicy = RefreshPolicy.readFrom(in). }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(name).     out.writeBoolean(enabled).     out.writeStringCollection(roles).     ExpressionParser.writeExpression(rules, out).     out.writeMap(metadata).     refreshPolicy.writeTo(out). }
false;public;0;9;;public ExpressionRoleMapping getMapping() {     return new ExpressionRoleMapping(name, rules, roles, metadata, enabled). }
