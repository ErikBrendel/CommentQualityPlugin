commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public TimeValue getTook() {     return new TimeValue(tookInMillis). }
false;public;0;3;;public long getTookInMillis() {     return tookInMillis. }
true;public;0;3;/**  * @return true if the time stated in {@link GraphExploreRequest#timeout(TimeValue)} was exceeded  * (not all hops may have been completed in this case)  */ ;/**  * @return true if the time stated in {@link GraphExploreRequest#timeout(TimeValue)} was exceeded  * (not all hops may have been completed in this case)  */ public boolean isTimedOut() {     return this.timedOut. }
false;public;0;3;;public ShardOperationFailedException[] getShardFailures() {     return shardFailures. }
false;public;1;34;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     tookInMillis = in.readVLong().     timedOut = in.readBoolean().     int size = in.readVInt().     if (size == 0) {         shardFailures = ShardSearchFailure.EMPTY_ARRAY.     } else {         shardFailures = new ShardSearchFailure[size].         for (int i = 0. i < shardFailures.length. i++) {             shardFailures[i] = readShardSearchFailure(in).         }     }     // read vertices     size = in.readVInt().     vertices = new HashMap<>().     for (int i = 0. i < size. i++) {         Vertex n = Vertex.readFrom(in).         vertices.put(n.getId(), n).     }     size = in.readVInt().     connections = new HashMap<>().     for (int i = 0. i < size. i++) {         Connection e = new Connection(in, vertices).         connections.put(e.getId(), e).     }     returnDetailedInfo = in.readBoolean(). }
false;public;0;3;;public Collection<Connection> getConnections() {     return connections.values(). }
false;public;0;3;;public Collection<Vertex> getVertices() {     return vertices.values(). }
false;public;1;3;;public Vertex getVertex(VertexId id) {     return vertices.get(id). }
false;public;1;24;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVLong(tookInMillis).     out.writeBoolean(timedOut).     out.writeVInt(shardFailures.length).     for (ShardOperationFailedException shardSearchFailure : shardFailures) {         shardSearchFailure.writeTo(out).     }     out.writeVInt(vertices.size()).     for (Vertex vertex : vertices.values()) {         vertex.writeTo(out).     }     out.writeVInt(connections.size()).     for (Connection connection : connections.values()) {         connection.writeTo(out).     }     out.writeBoolean(returnDetailedInfo). }
false;public;2;41;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(TOOK.getPreferredName(), tookInMillis).     builder.field(TIMED_OUT.getPreferredName(), timedOut).     builder.startArray(FAILURES.getPreferredName()).     if (shardFailures != null) {         for (ShardOperationFailedException shardFailure : shardFailures) {             builder.startObject().             shardFailure.toXContent(builder, params).             builder.endObject().         }     }     builder.endArray().     ObjectIntHashMap<Vertex> vertexNumbers = new ObjectIntHashMap<>(vertices.size()).     Map<String, String> extraParams = new HashMap<>().     extraParams.put(RETURN_DETAILED_INFO_PARAM, Boolean.toString(returnDetailedInfo)).     Params extendedParams = new DelegatingMapParams(extraParams, params).     builder.startArray(VERTICES.getPreferredName()).     for (Vertex vertex : vertices.values()) {         builder.startObject().         vertexNumbers.put(vertex, vertexNumbers.size()).         vertex.toXContent(builder, extendedParams).         builder.endObject().     }     builder.endArray().     builder.startArray(CONNECTIONS.getPreferredName()).     for (Connection connection : connections.values()) {         builder.startObject().         connection.toXContent(builder, extendedParams, vertexNumbers).         builder.endObject().     }     builder.endArray().     builder.endObject().     return builder. }
false;public,static;1;3;;public static GraphExploreResponse fromXContent(XContentParser parser) throws IOException {     return PARSER.apply(parser, null). }
