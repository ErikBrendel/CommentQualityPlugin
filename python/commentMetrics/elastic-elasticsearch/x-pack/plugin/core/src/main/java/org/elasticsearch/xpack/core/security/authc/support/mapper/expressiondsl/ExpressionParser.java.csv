commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static RoleMapperExpression readExpression(StreamInput in) throws IOException {     return in.readNamedWriteable(RoleMapperExpression.class). }
false;public,static;2;3;;public static void writeExpression(RoleMapperExpression expression, StreamOutput out) throws IOException {     out.writeNamedWriteable(expression). }
false;static;1;3;;static List<RoleMapperExpression> readExpressionList(StreamInput in) throws IOException {     return in.readNamedWriteableList(RoleMapperExpression.class). }
false;static;2;3;;static void writeExpressionList(List<RoleMapperExpression> list, StreamOutput out) throws IOException {     out.writeNamedWriteableList(list). }
true;public,static;2;3;/**  * This function exists to be compatible with  * {@link org.elasticsearch.common.xcontent.ContextParser#parse(XContentParser, Object)}  */ ;/**  * This function exists to be compatible with  * {@link org.elasticsearch.common.xcontent.ContextParser#parse(XContentParser, Object)}  */ public static RoleMapperExpression parseObject(XContentParser parser, String id) throws IOException {     return new ExpressionParser().parse(id, parser). }
true;public;2;5;/**  * @param name    The name of the expression tree within its containing object. Used to provide  *                descriptive error messages.  * @param content The XContent (typically JSON) DSL representation of the expression  */ ;/**  * @param name    The name of the expression tree within its containing object. Used to provide  *                descriptive error messages.  * @param content The XContent (typically JSON) DSL representation of the expression  */ public RoleMapperExpression parse(String name, XContentSource content) throws IOException {     try (InputStream stream = content.getBytes().streamInput()) {         return parse(name, content.parser(NamedXContentRegistry.EMPTY, stream)).     } }
true;public;2;3;/**  * @param name   The name of the expression tree within its containing object. Used to provide  *               descriptive error messages.  * @param parser A parser over the XContent (typically JSON) DSL representation of the  *               expression  */ ;/**  * @param name   The name of the expression tree within its containing object. Used to provide  *               descriptive error messages.  * @param parser A parser over the XContent (typically JSON) DSL representation of the  *               expression  */ public RoleMapperExpression parse(String name, XContentParser parser) throws IOException {     return parseRulesObject(name, parser, false). }
false;private;3;21;;private RoleMapperExpression parseRulesObject(String objectName, XContentParser parser, boolean allowExcept) throws IOException {     // find the start of the DSL object     XContentParser.Token token.     if (parser.currentToken() == null) {         token = parser.nextToken().     } else {         token = parser.currentToken().     }     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("failed to parse rules expression. expected [{}] to be an object but found [{}] instead", objectName, token).     }     final String fieldName = readFieldName(objectName, parser).     final RoleMapperExpression expr = parseExpression(parser, fieldName, allowExcept, objectName).     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ElasticsearchParseException("failed to parse rules expression. object [{}] contains multiple fields", objectName).     }     return expr. }
false;private;4;21;;private RoleMapperExpression parseExpression(XContentParser parser, String field, boolean allowExcept, String objectName) throws IOException {     if (Fields.ANY.match(field, parser.getDeprecationHandler())) {         return new AnyExpression(parseExpressionArray(Fields.ANY, parser, false)).     } else if (Fields.ALL.match(field, parser.getDeprecationHandler())) {         return new AllExpression(parseExpressionArray(Fields.ALL, parser, true)).     } else if (Fields.FIELD.match(field, parser.getDeprecationHandler())) {         return parseFieldExpression(parser).     } else if (Fields.EXCEPT.match(field, parser.getDeprecationHandler())) {         if (allowExcept) {             return parseExceptExpression(parser).         } else {             throw new ElasticsearchParseException("failed to parse rules expression. field [{}] is not allowed within [{}]", field, objectName).         }     } else {         throw new ElasticsearchParseException("failed to parse rules expression. field [{}] is not recognised in object [{}]", field, objectName).     } }
false;private;1;15;;private RoleMapperExpression parseFieldExpression(XContentParser parser) throws IOException {     checkStartObject(parser).     final String fieldName = readFieldName(Fields.FIELD.getPreferredName(), parser).     final List<FieldExpression.FieldValue> values.     if (parser.nextToken() == XContentParser.Token.START_ARRAY) {         values = parseArray(Fields.FIELD, parser, this::parseFieldValue).     } else {         values = Collections.singletonList(parseFieldValue(parser)).     }     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ElasticsearchParseException("failed to parse rules expression. object [{}] contains multiple fields", Fields.FIELD.getPreferredName()).     }     return new FieldExpression(fieldName, values). }
false;private;1;4;;private RoleMapperExpression parseExceptExpression(XContentParser parser) throws IOException {     checkStartObject(parser).     return new ExceptExpression(parseRulesObject(Fields.EXCEPT.getPreferredName(), parser, false)). }
false;private;1;6;;private void checkStartObject(XContentParser parser) throws IOException {     final XContentParser.Token token = parser.nextToken().     if (token != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("failed to parse rules expression. expected an object but found [{}] instead", token).     } }
false;private;2;6;;private String readFieldName(String objectName, XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.FIELD_NAME) {         throw new ElasticsearchParseException("failed to parse rules expression. object [{}] does not contain any fields", objectName).     }     return parser.currentName(). }
false;private;3;5;;private List<RoleMapperExpression> parseExpressionArray(ParseField field, XContentParser parser, boolean allowExcept) throws IOException {     // parseArray requires that the parser is positioned at the START_ARRAY token     parser.nextToken().     return parseArray(field, parser, p -> parseRulesObject(field.getPreferredName(), p, allowExcept)). }
false;private;3;13;;private <T> List<T> parseArray(ParseField field, XContentParser parser, CheckedFunction<XContentParser, T, IOException> elementParser) throws IOException {     final XContentParser.Token token = parser.currentToken().     if (token == XContentParser.Token.START_ARRAY) {         List<T> list = new ArrayList<>().         while (parser.nextToken() != XContentParser.Token.END_ARRAY) {             list.add(elementParser.apply(parser)).         }         return list.     } else {         throw new ElasticsearchParseException("failed to parse rules expression. field [{}] requires an array", field).     } }
false;private;1;19;;private FieldExpression.FieldValue parseFieldValue(XContentParser parser) throws IOException {     switch(parser.currentToken()) {         case VALUE_STRING:             return new FieldExpression.FieldValue(parser.text()).         case VALUE_BOOLEAN:             return new FieldExpression.FieldValue(parser.booleanValue()).         case VALUE_NUMBER:             return new FieldExpression.FieldValue(parser.longValue()).         case VALUE_NULL:             return new FieldExpression.FieldValue(null).         default:             throw new ElasticsearchParseException("failed to parse rules expression. expected a field value but found [{}] instead", parser.currentToken()).     } }
