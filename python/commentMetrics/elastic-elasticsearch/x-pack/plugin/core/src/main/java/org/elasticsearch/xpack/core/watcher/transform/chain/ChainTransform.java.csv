commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String type() {     return TYPE. }
false;public;0;3;;public List<Transform> getTransforms() {     return transforms. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ChainTransform that = (ChainTransform) o.     return transforms.equals(that.transforms). }
false;public;0;4;;@Override public int hashCode() {     return transforms.hashCode(). }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startArray().     for (Transform transform : transforms) {         builder.startObject().field(transform.type(), transform, params).endObject().     }     return builder.endArray(). }
false;static;3;25;;static ChainTransform parse(String watchId, XContentParser parser, TransformRegistry transformRegistry) throws IOException {     XContentParser.Token token = parser.currentToken().     if (token != XContentParser.Token.START_ARRAY) {         throw new ElasticsearchParseException("could not parse [{}] transform for watch [{}]. expected an array of transform objects," + " but found [{}] instead", TYPE, watchId, token).     }     List<Transform> transforms = new ArrayList<>().     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {         if (token != XContentParser.Token.START_OBJECT) {             throw new ElasticsearchParseException("could not parse [{}] transform for watch [{}]. expected a transform object, but " + "found [{}] instead", TYPE, watchId, token).         }         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else {                 transforms.add(transformRegistry.parseTransform(watchId, currentFieldName, parser)).             }         }     }     return new ChainTransform(transforms). }
false;public,static;1;3;;public static Builder builder(Transform... transforms) {     return new Builder(transforms). }
false;public;0;3;;public List<Transform.Result> results() {     return results. }
false;protected;2;13;;@Override protected XContentBuilder typeXContent(XContentBuilder builder, Params params) throws IOException {     if (!results.isEmpty()) {         builder.startObject(type).         builder.startArray(Field.RESULTS.getPreferredName()).         for (Transform.Result result : results) {             result.toXContent(builder, params).         }         builder.endArray().         builder.endObject().     }     return builder. }
false;public;1;4;;public Builder add(Transform... transforms) {     Collections.addAll(this.transforms, transforms).     return this. }
false;public;1;6;;public Builder add(Transform.Builder... transforms) {     for (Transform.Builder transform : transforms) {         this.transforms.add(transform.build()).     }     return this. }
false;public;0;4;;@Override public ChainTransform build() {     return new ChainTransform(transforms). }
