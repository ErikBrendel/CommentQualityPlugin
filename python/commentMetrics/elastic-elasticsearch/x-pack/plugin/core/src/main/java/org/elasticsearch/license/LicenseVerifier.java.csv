# id;timestamp;commentText;codeText;commentWords;codeWords
LicenseVerifier -> public static boolean verifyLicense(final License license, byte[] publicKeyData);1525334055;verifies the license content with the signature using the packaged_public key_@param license to verify_@return true if valid, false otherwise;public static boolean verifyLicense(final License license, byte[] publicKeyData) {_        byte[] signedContent = null__        byte[] publicKeyFingerprint = null__        try {_            byte[] signatureBytes = Base64.getDecoder().decode(license.signature())__            ByteBuffer byteBuffer = ByteBuffer.wrap(signatureBytes)__            int version = byteBuffer.getInt()__            int magicLen = byteBuffer.getInt()__            byte[] magic = new byte[magicLen]__            byteBuffer.get(magic)__            int hashLen = byteBuffer.getInt()__            publicKeyFingerprint = new byte[hashLen]__            byteBuffer.get(publicKeyFingerprint)__            int signedContentLen = byteBuffer.getInt()__            signedContent = new byte[signedContentLen]__            byteBuffer.get(signedContent)__            XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON)__            license.toXContent(contentBuilder, new ToXContent.MapParams(Collections.singletonMap(License.LICENSE_SPEC_VIEW_MODE, "true")))__            Signature rsa = Signature.getInstance("SHA512withRSA")__            rsa.initVerify(CryptUtils.readPublicKey(publicKeyData))__            BytesRefIterator iterator = BytesReference.bytes(contentBuilder).iterator()__            BytesRef ref__            while((ref = iterator.next()) != null) {_                rsa.update(ref.bytes, ref.offset, ref.length)__            }_            return rsa.verify(signedContent)__        } catch (IOException | NoSuchAlgorithmException | SignatureException | InvalidKeyException e) {_            throw new IllegalStateException(e)__        } finally {_            if (signedContent != null) {_                Arrays.fill(signedContent, (byte) 0)__            }_        }_    };verifies,the,license,content,with,the,signature,using,the,packaged,public,key,param,license,to,verify,return,true,if,valid,false,otherwise;public,static,boolean,verify,license,final,license,license,byte,public,key,data,byte,signed,content,null,byte,public,key,fingerprint,null,try,byte,signature,bytes,base64,get,decoder,decode,license,signature,byte,buffer,byte,buffer,byte,buffer,wrap,signature,bytes,int,version,byte,buffer,get,int,int,magic,len,byte,buffer,get,int,byte,magic,new,byte,magic,len,byte,buffer,get,magic,int,hash,len,byte,buffer,get,int,public,key,fingerprint,new,byte,hash,len,byte,buffer,get,public,key,fingerprint,int,signed,content,len,byte,buffer,get,int,signed,content,new,byte,signed,content,len,byte,buffer,get,signed,content,xcontent,builder,content,builder,xcontent,factory,content,builder,xcontent,type,json,license,to,xcontent,content,builder,new,to,xcontent,map,params,collections,singleton,map,license,true,signature,rsa,signature,get,instance,sha512with,rsa,rsa,init,verify,crypt,utils,read,public,key,public,key,data,bytes,ref,iterator,iterator,bytes,reference,bytes,content,builder,iterator,bytes,ref,ref,while,ref,iterator,next,null,rsa,update,ref,bytes,ref,offset,ref,length,return,rsa,verify,signed,content,catch,ioexception,no,such,algorithm,exception,signature,exception,invalid,key,exception,e,throw,new,illegal,state,exception,e,finally,if,signed,content,null,arrays,fill,signed,content,byte,0
LicenseVerifier -> public static boolean verifyLicense(final License license, byte[] publicKeyData);1538067637;verifies the license content with the signature using the packaged_public key_@param license to verify_@return true if valid, false otherwise;public static boolean verifyLicense(final License license, byte[] publicKeyData) {_        byte[] signedContent = null__        byte[] publicKeyFingerprint = null__        try {_            byte[] signatureBytes = Base64.getDecoder().decode(license.signature())__            ByteBuffer byteBuffer = ByteBuffer.wrap(signatureBytes)__            @SuppressWarnings("unused")_            int version = byteBuffer.getInt()__            int magicLen = byteBuffer.getInt()__            byte[] magic = new byte[magicLen]__            byteBuffer.get(magic)__            int hashLen = byteBuffer.getInt()__            publicKeyFingerprint = new byte[hashLen]__            byteBuffer.get(publicKeyFingerprint)__            int signedContentLen = byteBuffer.getInt()__            signedContent = new byte[signedContentLen]__            byteBuffer.get(signedContent)__            XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON)__            license.toXContent(contentBuilder, new ToXContent.MapParams(Collections.singletonMap(License.LICENSE_SPEC_VIEW_MODE, "true")))__            Signature rsa = Signature.getInstance("SHA512withRSA")__            rsa.initVerify(CryptUtils.readPublicKey(publicKeyData))__            BytesRefIterator iterator = BytesReference.bytes(contentBuilder).iterator()__            BytesRef ref__            while((ref = iterator.next()) != null) {_                rsa.update(ref.bytes, ref.offset, ref.length)__            }_            return rsa.verify(signedContent)__        } catch (IOException | NoSuchAlgorithmException | SignatureException | InvalidKeyException e) {_            throw new IllegalStateException(e)__        } finally {_            if (signedContent != null) {_                Arrays.fill(signedContent, (byte) 0)__            }_        }_    };verifies,the,license,content,with,the,signature,using,the,packaged,public,key,param,license,to,verify,return,true,if,valid,false,otherwise;public,static,boolean,verify,license,final,license,license,byte,public,key,data,byte,signed,content,null,byte,public,key,fingerprint,null,try,byte,signature,bytes,base64,get,decoder,decode,license,signature,byte,buffer,byte,buffer,byte,buffer,wrap,signature,bytes,suppress,warnings,unused,int,version,byte,buffer,get,int,int,magic,len,byte,buffer,get,int,byte,magic,new,byte,magic,len,byte,buffer,get,magic,int,hash,len,byte,buffer,get,int,public,key,fingerprint,new,byte,hash,len,byte,buffer,get,public,key,fingerprint,int,signed,content,len,byte,buffer,get,int,signed,content,new,byte,signed,content,len,byte,buffer,get,signed,content,xcontent,builder,content,builder,xcontent,factory,content,builder,xcontent,type,json,license,to,xcontent,content,builder,new,to,xcontent,map,params,collections,singleton,map,license,true,signature,rsa,signature,get,instance,sha512with,rsa,rsa,init,verify,crypt,utils,read,public,key,public,key,data,bytes,ref,iterator,iterator,bytes,reference,bytes,content,builder,iterator,bytes,ref,ref,while,ref,iterator,next,null,rsa,update,ref,bytes,ref,offset,ref,length,return,rsa,verify,signed,content,catch,ioexception,no,such,algorithm,exception,signature,exception,invalid,key,exception,e,throw,new,illegal,state,exception,e,finally,if,signed,content,null,arrays,fill,signed,content,byte,0
