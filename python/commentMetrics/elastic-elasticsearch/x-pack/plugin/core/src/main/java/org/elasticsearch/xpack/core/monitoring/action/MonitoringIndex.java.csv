commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean matchesIndexName(String indexName) {     return false. }
false;public;1;4;;@Override public boolean matchesIndexName(String indexName) {     return Strings.isEmpty(indexName). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeByte((byte) ordinal()). }
false;public,static;1;3;;public static MonitoringIndex readFrom(StreamInput in) throws IOException {     return values()[in.readByte()]. }
true;public,abstract;1;1;/**  * Determine if the {@code indexName} matches {@code this} monitoring index.  *  * @param indexName The name of the index.  * @return {@code true} if {@code this} matches the {@code indexName}  */ ;/**  * Determine if the {@code indexName} matches {@code this} monitoring index.  *  * @param indexName The name of the index.  * @return {@code true} if {@code this} matches the {@code indexName}  */ public abstract boolean matchesIndexName(String indexName).
true;public,static;1;10;/**  * Find the {@link MonitoringIndex} to use for the request.  *  * @param indexName The name of the index.  * @return Never {@code null}.  * @throws IllegalArgumentException if {@code indexName} is unrecognized  */ ;/**  * Find the {@link MonitoringIndex} to use for the request.  *  * @param indexName The name of the index.  * @return Never {@code null}.  * @throws IllegalArgumentException if {@code indexName} is unrecognized  */ public static MonitoringIndex from(String indexName) {     if (TIMESTAMPED.matchesIndexName(indexName)) {         return TIMESTAMPED.     } else if ("_data".equals(indexName)) {         // we explicitly ignore this where it's used to maintain binary BWC         return IGNORED_DATA.     }     throw new IllegalArgumentException("unrecognized index name [" + indexName + "]"). }
