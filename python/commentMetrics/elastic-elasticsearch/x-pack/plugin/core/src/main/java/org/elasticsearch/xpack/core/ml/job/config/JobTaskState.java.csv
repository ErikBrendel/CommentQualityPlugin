commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;7;;public static JobTaskState fromXContent(XContentParser parser) {     try {         return PARSER.parse(parser, null).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public;0;3;;public JobState getState() {     return state. }
false;public;0;4;;@Nullable public String getReason() {     return reason. }
true;public;1;3;/**  * The job state stores the allocation ID at the time it was last set.  * This method compares the allocation ID in the state with the allocation  * ID in the task.  If the two are different then the task has been relocated  * to a different node after the last time the state was set.  This in turn  * means that the state is not necessarily correct.  For example, a job that  * has a state of OPENED but is stale must be considered to be OPENING, because  * it won't yet have a corresponding autodetect process.  * @param task The job task to check.  * @return Has the task been relocated to another node and not had its status set since then?  */ ;/**  * The job state stores the allocation ID at the time it was last set.  * This method compares the allocation ID in the state with the allocation  * ID in the task.  If the two are different then the task has been relocated  * to a different node after the last time the state was set.  This in turn  * means that the state is not necessarily correct.  For example, a job that  * has a state of OPENED but is stale must be considered to be OPENING, because  * it won't yet have a corresponding autodetect process.  * @param task The job task to check.  * @return Has the task been relocated to another node and not had its status set since then?  */ public boolean isStatusStale(PersistentTask<?> task) {     return allocationId != task.getAllocationId(). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     state.writeTo(out).     out.writeLong(allocationId).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeOptionalString(reason).     } }
false;public;0;4;;@Override public boolean isFragment() {     return false. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(STATE.getPreferredName(), state.value()).     builder.field(ALLOCATION_ID.getPreferredName(), allocationId).     if (reason != null) {         builder.field(REASON.getPreferredName(), reason).     }     builder.endObject().     return builder. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     JobTaskState that = (JobTaskState) o.     return state == that.state && Objects.equals(allocationId, that.allocationId) && Objects.equals(reason, that.reason). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(state, allocationId, reason). }
