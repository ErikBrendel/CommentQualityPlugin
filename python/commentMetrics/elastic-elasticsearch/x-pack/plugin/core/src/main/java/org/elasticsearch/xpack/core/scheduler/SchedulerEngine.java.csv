commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getId() {     return id. }
false;public;0;3;;public Schedule getSchedule() {     return schedule. }
false;public;0;3;;public String getJobName() {     return jobName. }
false;public;0;3;;public long getTriggeredTime() {     return triggeredTime. }
false;public;0;3;;public long getScheduledTime() {     return scheduledTime. }
false;;1;1;;void triggered(Event event).
true;;2;1;/**  * Returns the next scheduled time after the given time, according to this schedule. If the given schedule  * cannot resolve the next scheduled time, then {@code -1} is returned. It really depends on the type of  * schedule to determine when {@code -1} is returned. Some schedules (e.g. IntervalSchedule) will never return  * {@code -1} as they can always compute the next scheduled time. {@code Cron} based schedules are good example  * of schedules that may return {@code -1}, for example, when the schedule only points to times that are all  * before the given time (in which case, there is no next scheduled time for the given time).  *  * Example:  *  *      cron    0 0 0 * 1 ? 2013        (only points to days in January 2013)  *  *      time    2015-01-01 12:00:00     (this time is in 2015)  */ ;/**  * Returns the next scheduled time after the given time, according to this schedule. If the given schedule  * cannot resolve the next scheduled time, then {@code -1} is returned. It really depends on the type of  * schedule to determine when {@code -1} is returned. Some schedules (e.g. IntervalSchedule) will never return  * {@code -1} as they can always compute the next scheduled time. {@code Cron} based schedules are good example  * of schedules that may return {@code -1}, for example, when the schedule only points to times that are all  * before the given time (in which case, there is no next scheduled time for the given time).  *  * Example:  *  *      cron    0 0 0 * 1 ? 2013        (only points to days in January 2013)  *  *      time    2015-01-01 12:00:00     (this time is in 2015)  */ long nextScheduledTimeAfter(long startTime, long now).
false;public;1;3;;public void register(Listener listener) {     listeners.add(listener). }
false;public;1;3;;public void unregister(Listener listener) {     listeners.remove(listener). }
false;public;1;3;;public void start(Collection<Job> jobs) {     jobs.forEach(this::add). }
false;public;0;12;;public void stop() {     scheduler.shutdownNow().     try {         final boolean terminated = scheduler.awaitTermination(5L, TimeUnit.SECONDS).         if (terminated == false) {             logger.warn("scheduler engine was not terminated after waiting 5s").         }     } catch (InterruptedException e) {         logger.warn("interrupted while waiting for scheduler engine termination").         Thread.currentThread().interrupt().     } }
false;public;1;9;;public void add(Job job) {     ActiveSchedule schedule = new ActiveSchedule(job.getId(), job.getSchedule(), clock.millis()).     schedules.compute(schedule.name, (name, previousSchedule) -> {         if (previousSchedule != null) {             previousSchedule.cancel().         }         return schedule.     }). }
false;public;1;7;;public boolean remove(String jobId) {     ActiveSchedule removedSchedule = schedules.remove(jobId).     if (removedSchedule != null) {         removedSchedule.cancel().     }     return removedSchedule != null. }
true;public;0;3;/**  * @return The number of currently active/triggered jobs  */ ;/**  * @return The number of currently active/triggered jobs  */ public int jobCount() {     return schedules.size(). }
false;protected;3;11;;protected void notifyListeners(final String name, final long triggeredTime, final long scheduledTime) {     final Event event = new Event(name, triggeredTime, scheduledTime).     for (final Listener listener : listeners) {         try {             listener.triggered(event).         } catch (final Exception e) {             // do not allow exceptions to escape this method. we should continue to notify listeners and schedule the next run             logger.warn(new ParameterizedMessage("listener failed while handling triggered event [{}]", name), e).         }     } }
false;public;0;18;;@Override public void run() {     final long triggeredTime = clock.millis().     try {         notifyListeners(name, triggeredTime, scheduledTime).     } catch (final Throwable t) {         /*                  * Allowing the throwable to escape here will lead to be it being caught in FutureTask#run and set as the outcome of this                  * task. however, we never inspect the the outcomes of these scheduled tasks and so allowing the throwable to escape                  * unhandled here could lead to us losing fatal errors. Instead, we rely on ExceptionsHelper#maybeDieOnAnotherThread to                  * appropriately dispatch any error to the uncaught exception handler. We should never see an exception here as these do                  * not escape from SchedulerEngine#notifyListeners.                  */         ExceptionsHelper.maybeDieOnAnotherThread(t).         throw t.     }     scheduleNextRun(triggeredTime). }
false;private;1;7;;private void scheduleNextRun(long currentTime) {     this.scheduledTime = schedule.nextScheduledTimeAfter(startTime, currentTime).     if (scheduledTime != -1) {         long delay = Math.max(0, scheduledTime - currentTime).         future = scheduler.schedule(this, delay, TimeUnit.MILLISECONDS).     } }
false;public;0;3;;public void cancel() {     FutureUtils.cancel(future). }
