commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected void doStart() {     super.doStart(). }
false;public,final;1;12;;@Override public final ChannelHandler getServerChannelInitializer(String name) {     if (sslEnabled) {         SSLConfiguration configuration = profileConfiguration.get(name).         if (configuration == null) {             throw new IllegalStateException("unknown profile: " + name).         }         return getSslChannelInitializer(name, configuration).     } else {         return getNoSslChannelInitializer(name).     } }
false;protected;1;3;;protected ChannelHandler getNoSslChannelInitializer(final String name) {     return super.getServerChannelInitializer(name). }
false;protected;1;4;;@Override protected ChannelHandler getClientChannelInitializer(DiscoveryNode node) {     return new SecurityClientChannelInitializer(node). }
false;public;2;31;;@Override public void onException(TcpChannel channel, Exception e) {     if (!lifecycle.started()) {         // just close and ignore - we are already stopped and just need to make sure we release all resources         CloseableChannel.closeChannel(channel).     } else if (SSLExceptionHelper.isNotSslRecordException(e)) {         if (logger.isTraceEnabled()) {             logger.trace(new ParameterizedMessage("received plaintext traffic on an encrypted channel, closing connection {}", channel), e).         } else {             logger.warn("received plaintext traffic on an encrypted channel, closing connection {}", channel).         }         CloseableChannel.closeChannel(channel).     } else if (SSLExceptionHelper.isCloseDuringHandshakeException(e)) {         if (logger.isTraceEnabled()) {             logger.trace(new ParameterizedMessage("connection {} closed during ssl handshake", channel), e).         } else {             logger.warn("connection {} closed during handshake", channel).         }         CloseableChannel.closeChannel(channel).     } else if (SSLExceptionHelper.isReceivedCertificateUnknownException(e)) {         if (logger.isTraceEnabled()) {             logger.trace(new ParameterizedMessage("client did not trust server's certificate, closing connection {}", channel), e).         } else {             logger.warn("client did not trust this server's certificate, closing connection {}", channel).         }         CloseableChannel.closeChannel(channel).     } else {         super.onException(channel, e).     } }
false;protected;1;9;;@Override protected void initChannel(Channel ch) throws Exception {     SSLEngine serverEngine = sslService.createSSLEngine(configuration, null, -1).     serverEngine.setUseClientMode(false).     final SslHandler sslHandler = new SslHandler(serverEngine).     ch.pipeline().addFirst("sslhandler", sslHandler).     super.initChannel(ch).     assert ch.pipeline().first() == sslHandler : "SSL handler must be first handler in pipeline". }
false;protected;2;3;;protected ServerChannelInitializer getSslChannelInitializer(final String name, final SSLConfiguration configuration) {     return new SslChannelInitializer(name, sslConfiguration). }
false;protected;1;8;;@Override protected void initChannel(Channel ch) throws Exception {     super.initChannel(ch).     if (sslEnabled) {         ch.pipeline().addFirst(new ClientSslHandlerInitializer(sslConfiguration, sslService, hostnameVerificationEnabled, serverName)).     } }
false;public;4;22;;@Override public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {     final SSLEngine sslEngine.     if (hostnameVerificationEnabled) {         InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress.         // we create the socket based on the name given. don't reverse DNS         sslEngine = sslService.createSSLEngine(sslConfiguration, inetSocketAddress.getHostString(), inetSocketAddress.getPort()).     } else {         sslEngine = sslService.createSSLEngine(sslConfiguration, null, -1).     }     sslEngine.setUseClientMode(true).     if (serverName != null) {         SSLParameters sslParameters = sslEngine.getSSLParameters().         sslParameters.setServerNames(Collections.singletonList(serverName)).         sslEngine.setSSLParameters(sslParameters).     }     ctx.pipeline().replace(this, "ssl", new SslHandler(sslEngine)).     super.connect(ctx, remoteAddress, localAddress, promise). }
