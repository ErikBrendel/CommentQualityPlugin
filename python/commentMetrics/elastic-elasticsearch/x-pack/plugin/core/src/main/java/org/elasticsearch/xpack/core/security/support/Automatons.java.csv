commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Builds and returns an automaton that will represent the union of all the given patterns.  */ ;/**  * Builds and returns an automaton that will represent the union of all the given patterns.  */ public static Automaton patterns(String... patterns) {     return patterns(Arrays.asList(patterns)). }
true;public,static;1;14;/**  * Builds and returns an automaton that will represent the union of all the given patterns.  */ ;/**  * Builds and returns an automaton that will represent the union of all the given patterns.  */ public static Automaton patterns(Collection<String> patterns) {     if (patterns.isEmpty()) {         return EMPTY.     }     if (cache == null) {         return buildAutomaton(patterns).     } else {         try {             return cache.computeIfAbsent(Sets.newHashSet(patterns), ignore -> buildAutomaton(patterns)).         } catch (ExecutionException e) {             throw unwrapCacheException(e).         }     } }
false;private,static;1;8;;private static Automaton buildAutomaton(Collection<String> patterns) {     List<Automaton> automata = new ArrayList<>(patterns.size()).     for (String pattern : patterns) {         final Automaton patternAutomaton = pattern(pattern).         automata.add(patternAutomaton).     }     return unionAndMinimize(automata). }
true;static;1;11;/**  * Builds and returns an automaton that represents the given pattern.  */ ;/**  * Builds and returns an automaton that represents the given pattern.  */ static Automaton pattern(String pattern) {     if (cache == null) {         return buildAutomaton(pattern).     } else {         try {             return cache.computeIfAbsent(pattern, ignore -> buildAutomaton(pattern)).         } catch (ExecutionException e) {             throw unwrapCacheException(e).         }     } }
false;private,static;1;15;;private static Automaton buildAutomaton(String pattern) {     if (pattern.startsWith("/")) {         // it's a lucene regexp         if (pattern.length() == 1 || !pattern.endsWith("/")) {             throw new IllegalArgumentException("invalid pattern [" + pattern + "]. patterns starting with '/' " + "indicate regular expression pattern and therefore must also end with '/'." + " other patterns (those that do not start with '/') will be treated as simple wildcard patterns").         }         String regex = pattern.substring(1, pattern.length() - 1).         return new RegExp(regex).toAutomaton().     } else if (pattern.equals("*")) {         return MATCH_ALL.     } else {         return wildcard(pattern).     } }
false;private,static;1;8;;private static RuntimeException unwrapCacheException(ExecutionException e) {     final Throwable cause = e.getCause().     if (cause instanceof RuntimeException) {         return (RuntimeException) cause.     } else {         return new RuntimeException(cause).     } }
true;static;1;28;/**  * Builds and returns an automaton that represents the given pattern.  */ ;/**  * Builds and returns an automaton that represents the given pattern.  */ // explicit fallthrough at end of switch @SuppressWarnings("fallthrough") static Automaton wildcard(String text) {     List<Automaton> automata = new ArrayList<>().     for (int i = 0. i < text.length(). ) {         final char c = text.charAt(i).         int length = 1.         switch(c) {             case WILDCARD_STRING:                 automata.add(Automata.makeAnyString()).                 break.             case WILDCARD_CHAR:                 automata.add(Automata.makeAnyChar()).                 break.             case WILDCARD_ESCAPE:                 // add the next codepoint instead, if it exists                 if (i + length < text.length()) {                     final char nextChar = text.charAt(i + length).                     length += 1.                     automata.add(Automata.makeChar(nextChar)).                     break.                 }             // else fallthru, lenient parsing with a trailing \             default:                 automata.add(Automata.makeChar(c)).         }         i += length.     }     return concatenate(automata). }
false;public,static;1;4;;public static Automaton unionAndMinimize(Collection<Automaton> automata) {     Automaton res = union(automata).     return minimize(res, maxDeterminizedStates). }
false;public,static;2;4;;public static Automaton minusAndMinimize(Automaton a1, Automaton a2) {     Automaton res = minus(a1, a2, maxDeterminizedStates).     return minimize(res, maxDeterminizedStates). }
false;public,static;2;4;;public static Automaton intersectAndMinimize(Automaton a1, Automaton a2) {     Automaton res = intersection(a1, a2).     return minimize(res, maxDeterminizedStates). }
false;public,static;1;3;;public static Predicate<String> predicate(String... patterns) {     return predicate(Arrays.asList(patterns)). }
false;public,static;1;3;;public static Predicate<String> predicate(Collection<String> patterns) {     return predicate(patterns(patterns), collectionToDelimitedString(patterns, "|")). }
false;public,static;1;3;;public static Predicate<String> predicate(Automaton automaton) {     return predicate(automaton, "Predicate for " + automaton). }
false;public,static;1;4;;public static void updateConfiguration(Settings settings) {     maxDeterminizedStates = MAX_DETERMINIZED_STATES_SETTING.get(settings).     cache = buildCache(settings). }
false;private,static;1;9;;private static Cache<Object, Automaton> buildCache(Settings settings) {     if (CACHE_ENABLED.get(settings) == false) {         return null.     }     return CacheBuilder.<Object, Automaton>builder().setExpireAfterAccess(CACHE_TTL.get(settings)).setMaximumWeight(CACHE_SIZE.get(settings)).build(). }
true;static;0;3;// accessor for testing ;// accessor for testing static int getMaxDeterminizedStates() {     return maxDeterminizedStates. }
false;public;1;4;;@Override public boolean test(String s) {     return runAutomaton.run(s). }
false;public;0;4;;@Override public String toString() {     return toString. }
false;private,static;2;14;;private static Predicate<String> predicate(Automaton automaton, final String toString) {     CharacterRunAutomaton runAutomaton = new CharacterRunAutomaton(automaton, maxDeterminizedStates).     return new Predicate<String>() {          @Override         public boolean test(String s) {             return runAutomaton.run(s).         }          @Override         public String toString() {             return toString.         }     }. }
false;public,static;1;6;;public static void addSettings(List<Setting<?>> settingsList) {     settingsList.add(MAX_DETERMINIZED_STATES_SETTING).     settingsList.add(CACHE_ENABLED).     settingsList.add(CACHE_SIZE).     settingsList.add(CACHE_TTL). }
