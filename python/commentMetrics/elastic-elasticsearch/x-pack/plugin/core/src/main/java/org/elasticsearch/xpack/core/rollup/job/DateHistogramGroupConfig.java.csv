commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void writeTo(final StreamOutput out) throws IOException {     interval.writeTo(out).     out.writeString(field).     out.writeOptionalWriteable(delay).     out.writeString(timeZone). }
false;public;2;13;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     builder.startObject().     {         builder.field(INTERVAL, interval.toString()).         builder.field(FIELD, field).         if (delay != null) {             builder.field(DELAY, delay.toString()).         }         builder.field(TIME_ZONE, timeZone).     }     return builder.endObject(). }
true;public;0;3;/**  * Get the date field  */ ;/**  * Get the date field  */ public String getField() {     return field. }
true;public;0;3;/**  * Get the date interval  */ ;/**  * Get the date interval  */ public DateHistogramInterval getInterval() {     return interval. }
true;public;0;3;/**  * Get the time delay for this histogram  */ ;/**  * Get the time delay for this histogram  */ public DateHistogramInterval getDelay() {     return delay. }
true;public;0;3;/**  * Get the timezone to apply  */ ;/**  * Get the timezone to apply  */ public String getTimeZone() {     return timeZone. }
true;public;0;3;/**  * Create the rounding for this date histogram  */ ;/**  * Create the rounding for this date histogram  */ public Rounding createRounding() {     return createRounding(interval.toString(), timeZone). }
false;public;2;21;;public void validateMappings(Map<String, Map<String, FieldCapabilities>> fieldCapsResponse, ActionRequestValidationException validationException) {     Map<String, FieldCapabilities> fieldCaps = fieldCapsResponse.get(field).     if (fieldCaps != null && fieldCaps.isEmpty() == false) {         if (fieldCaps.containsKey("date") && fieldCaps.size() == 1) {             if (fieldCaps.get("date").isAggregatable()) {                 return.             } else {                 validationException.addValidationError("The field [" + field + "] must be aggregatable across all indices, " + "but is not.").             }         } else {             validationException.addValidationError("The field referenced by a date_histo group must be a [date] type across all " + "indices in the index pattern.  Found: " + fieldCaps.keySet().toString() + " for field [" + field + "]").         }     }     validationException.addValidationError("Could not find a [date] field with name [" + field + "] in any of the indices matching " + "the index pattern."). }
false;public;1;14;;@Override public boolean equals(final Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     final DateHistogramGroupConfig that = (DateHistogramGroupConfig) other.     return Objects.equals(interval, that.interval) && Objects.equals(field, that.field) && Objects.equals(delay, that.delay) && Objects.equals(timeZone, that.timeZone). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(interval, field, delay, timeZone). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
false;public,static;1;3;;public static DateHistogramGroupConfig fromXContent(final XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;private,static;2;11;;private static Rounding createRounding(final String expr, final String timeZone) {     Rounding.DateTimeUnit timeUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(expr).     final Rounding.Builder rounding.     if (timeUnit != null) {         rounding = new Rounding.Builder(timeUnit).     } else {         rounding = new Rounding.Builder(TimeValue.parseTimeValue(expr, "createRounding")).     }     rounding.timeZone(ZoneId.of(timeZone)).     return rounding.build(). }
