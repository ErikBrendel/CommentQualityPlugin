commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Response newResponse() {     return new Response(). }
false;public;0;3;;public FileStructure getFileStructure() {     return fileStructure. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     fileStructure = new FileStructure(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     fileStructure.writeTo(out). }
false;public;0;4;;@Override public RestStatus status() {     return RestStatus.OK. }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     fileStructure.toXContent(builder, params).     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(fileStructure). }
false;public;1;14;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     FindFileStructureAction.Response that = (FindFileStructureAction.Response) other.     return Objects.equals(fileStructure, that.fileStructure). }
false;public;0;3;;public Integer getLinesToSample() {     return linesToSample. }
false;public;1;3;;public void setLinesToSample(Integer linesToSample) {     this.linesToSample = linesToSample. }
false;public;0;3;;public TimeValue getTimeout() {     return timeout. }
false;public;1;3;;public void setTimeout(TimeValue timeout) {     this.timeout = timeout. }
false;public;0;3;;public String getCharset() {     return charset. }
false;public;1;3;;public void setCharset(String charset) {     this.charset = (charset == null || charset.isEmpty()) ? null : charset. }
false;public;0;3;;public FileStructure.Format getFormat() {     return format. }
false;public;1;3;;public void setFormat(FileStructure.Format format) {     this.format = format. }
false;public;1;3;;public void setFormat(String format) {     this.format = (format == null || format.isEmpty()) ? null : FileStructure.Format.fromString(format). }
false;public;0;3;;public List<String> getColumnNames() {     return columnNames. }
false;public;1;3;;public void setColumnNames(List<String> columnNames) {     this.columnNames = (columnNames == null || columnNames.isEmpty()) ? null : columnNames. }
false;public;1;3;;public void setColumnNames(String[] columnNames) {     this.columnNames = (columnNames == null || columnNames.length == 0) ? null : Arrays.asList(columnNames). }
false;public;0;3;;public Boolean getHasHeaderRow() {     return hasHeaderRow. }
false;public;1;3;;public void setHasHeaderRow(Boolean hasHeaderRow) {     this.hasHeaderRow = hasHeaderRow. }
false;public;0;3;;public Character getDelimiter() {     return delimiter. }
false;public;1;3;;public void setDelimiter(Character delimiter) {     this.delimiter = delimiter. }
false;public;1;9;;public void setDelimiter(String delimiter) {     if (delimiter == null || delimiter.isEmpty()) {         this.delimiter = null.     } else if (delimiter.length() == 1) {         this.delimiter = delimiter.charAt(0).     } else {         throw new IllegalArgumentException(DELIMITER.getPreferredName() + " must be a single character").     } }
false;public;0;3;;public Character getQuote() {     return quote. }
false;public;1;3;;public void setQuote(Character quote) {     this.quote = quote. }
false;public;1;9;;public void setQuote(String quote) {     if (quote == null || quote.isEmpty()) {         this.quote = null.     } else if (quote.length() == 1) {         this.quote = quote.charAt(0).     } else {         throw new IllegalArgumentException(QUOTE.getPreferredName() + " must be a single character").     } }
false;public;0;3;;public Boolean getShouldTrimFields() {     return shouldTrimFields. }
false;public;1;3;;public void setShouldTrimFields(Boolean shouldTrimFields) {     this.shouldTrimFields = shouldTrimFields. }
false;public;0;3;;public String getGrokPattern() {     return grokPattern. }
false;public;1;3;;public void setGrokPattern(String grokPattern) {     this.grokPattern = (grokPattern == null || grokPattern.isEmpty()) ? null : grokPattern. }
false;public;0;3;;public String getTimestampFormat() {     return timestampFormat. }
false;public;1;3;;public void setTimestampFormat(String timestampFormat) {     this.timestampFormat = (timestampFormat == null || timestampFormat.isEmpty()) ? null : timestampFormat. }
false;public;0;3;;public String getTimestampField() {     return timestampField. }
false;public;1;3;;public void setTimestampField(String timestampField) {     this.timestampField = (timestampField == null || timestampField.isEmpty()) ? null : timestampField. }
false;public;0;3;;public BytesReference getSample() {     return sample. }
false;public;1;3;;public void setSample(BytesReference sample) {     this.sample = sample. }
false;private,static;3;5;;private static ActionRequestValidationException addIncompatibleArgError(ParseField arg, FileStructure.Format format, ActionRequestValidationException validationException) {     return addValidationError(String.format(Locale.ROOT, ARG_INCOMPATIBLE_WITH_FORMAT_TEMPLATE, arg.getPreferredName(), format), validationException). }
false;public;0;35;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (linesToSample != null && linesToSample <= 0) {         validationException = addValidationError("[" + LINES_TO_SAMPLE.getPreferredName() + "] must be positive if specified", validationException).     }     if (format != FileStructure.Format.DELIMITED) {         if (columnNames != null) {             validationException = addIncompatibleArgError(COLUMN_NAMES, FileStructure.Format.DELIMITED, validationException).         }         if (hasHeaderRow != null) {             validationException = addIncompatibleArgError(HAS_HEADER_ROW, FileStructure.Format.DELIMITED, validationException).         }         if (delimiter != null) {             validationException = addIncompatibleArgError(DELIMITER, FileStructure.Format.DELIMITED, validationException).         }         if (quote != null) {             validationException = addIncompatibleArgError(QUOTE, FileStructure.Format.DELIMITED, validationException).         }         if (shouldTrimFields != null) {             validationException = addIncompatibleArgError(SHOULD_TRIM_FIELDS, FileStructure.Format.DELIMITED, validationException).         }     }     if (format != FileStructure.Format.SEMI_STRUCTURED_TEXT) {         if (grokPattern != null) {             validationException = addIncompatibleArgError(GROK_PATTERN, FileStructure.Format.SEMI_STRUCTURED_TEXT, validationException).         }     }     if (sample == null || sample.length() == 0) {         validationException = addValidationError("sample must be specified", validationException).     }     return validationException. }
false;public;1;17;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     linesToSample = in.readOptionalVInt().     timeout = in.readOptionalTimeValue().     charset = in.readOptionalString().     format = in.readBoolean() ? in.readEnum(FileStructure.Format.class) : null.     columnNames = in.readBoolean() ? in.readStringList() : null.     hasHeaderRow = in.readOptionalBoolean().     delimiter = in.readBoolean() ? (char) in.readVInt() : null.     quote = in.readBoolean() ? (char) in.readVInt() : null.     shouldTrimFields = in.readOptionalBoolean().     grokPattern = in.readOptionalString().     timestampFormat = in.readOptionalString().     timestampField = in.readOptionalString().     sample = in.readBytesReference(). }
false;public;1;37;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalVInt(linesToSample).     out.writeOptionalTimeValue(timeout).     out.writeOptionalString(charset).     if (format == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeEnum(format).     }     if (columnNames == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeCollection(columnNames, StreamOutput::writeString).     }     out.writeOptionalBoolean(hasHeaderRow).     if (delimiter == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeVInt(delimiter).     }     if (quote == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeVInt(quote).     }     out.writeOptionalBoolean(shouldTrimFields).     out.writeOptionalString(grokPattern).     out.writeOptionalString(timestampFormat).     out.writeOptionalString(timestampField).     out.writeBytesReference(sample). }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(linesToSample, timeout, charset, format, columnNames, hasHeaderRow, delimiter, grokPattern, timestampFormat, timestampField, sample). }
false;public;1;24;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     Request that = (Request) other.     return Objects.equals(this.linesToSample, that.linesToSample) && Objects.equals(this.timeout, that.timeout) && Objects.equals(this.charset, that.charset) && Objects.equals(this.format, that.format) && Objects.equals(this.columnNames, that.columnNames) && Objects.equals(this.hasHeaderRow, that.hasHeaderRow) && Objects.equals(this.delimiter, that.delimiter) && Objects.equals(this.grokPattern, that.grokPattern) && Objects.equals(this.timestampFormat, that.timestampFormat) && Objects.equals(this.timestampField, that.timestampField) && Objects.equals(this.sample, that.sample). }
