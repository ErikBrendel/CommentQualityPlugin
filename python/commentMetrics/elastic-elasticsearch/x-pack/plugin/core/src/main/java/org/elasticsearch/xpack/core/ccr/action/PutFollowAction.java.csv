commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Response newResponse() {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;0;4;;@Override public Writeable.Reader<Response> getResponseReader() {     return Response::new. }
false;public,static;3;12;;public static Request fromXContent(final XContentParser parser, final String followerIndex, ActiveShardCount waitForActiveShards) throws IOException {     PutFollowParameters parameters = PARSER.parse(parser, null).     Request request = new Request().     request.waitForActiveShards(waitForActiveShards).     request.setFollowerIndex(followerIndex).     request.setRemoteCluster(parameters.remoteCluster).     request.setLeaderIndex(parameters.leaderIndex).     request.setParameters(parameters).     return request. }
false;public;0;3;;public String getFollowerIndex() {     return followerIndex. }
false;public;1;3;;public void setFollowerIndex(String followerIndex) {     this.followerIndex = followerIndex. }
false;public;0;3;;public String getRemoteCluster() {     return remoteCluster. }
false;public;1;3;;public void setRemoteCluster(String remoteCluster) {     this.remoteCluster = remoteCluster. }
false;public;0;3;;public String getLeaderIndex() {     return leaderIndex. }
false;public;1;3;;public void setLeaderIndex(String leaderIndex) {     this.leaderIndex = leaderIndex. }
false;public;0;3;;public FollowParameters getParameters() {     return parameters. }
false;public;1;3;;public void setParameters(FollowParameters parameters) {     this.parameters = parameters. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return waitForActiveShards. }
true;public;1;7;/**  * Sets the number of shard copies that should be active for follower index creation to  * return. Defaults to {@link ActiveShardCount#NONE}, which will not wait for any shards  * to be active. Set this value to {@link ActiveShardCount#DEFAULT} to wait for the primary  * shard to be active. Set this value to {@link ActiveShardCount#ALL} to  wait for all shards  * (primary and all replicas) to be active before returning.  *  * @param waitForActiveShards number of active shard copies to wait on  */ ;/**  * Sets the number of shard copies that should be active for follower index creation to  * return. Defaults to {@link ActiveShardCount#NONE}, which will not wait for any shards  * to be active. Set this value to {@link ActiveShardCount#DEFAULT} to wait for the primary  * shard to be active. Set this value to {@link ActiveShardCount#ALL} to  wait for all shards  * (primary and all replicas) to be active before returning.  *  * @param waitForActiveShards number of active shard copies to wait on  */ public void waitForActiveShards(ActiveShardCount waitForActiveShards) {     if (waitForActiveShards.equals(ActiveShardCount.DEFAULT)) {         this.waitForActiveShards = ActiveShardCount.NONE.     } else {         this.waitForActiveShards = waitForActiveShards.     } }
false;public;0;14;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException e = parameters.validate().     if (remoteCluster == null) {         e = addValidationError(REMOTE_CLUSTER_FIELD.getPreferredName() + " is missing", e).     }     if (leaderIndex == null) {         e = addValidationError(LEADER_INDEX_FIELD.getPreferredName() + " is missing", e).     }     if (followerIndex == null) {         e = addValidationError("follower_index is missing", e).     }     return e. }
false;public;0;4;;@Override public String[] indices() {     return new String[] { followerIndex }. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.strictSingleIndexNoExpandForbidClosed(). }
false;public;1;11;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(remoteCluster).     out.writeString(leaderIndex).     out.writeString(followerIndex).     parameters.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         waitForActiveShards.writeTo(out).     } }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.field(REMOTE_CLUSTER_FIELD.getPreferredName(), remoteCluster).         builder.field(LEADER_INDEX_FIELD.getPreferredName(), leaderIndex).         parameters.toXContentFragment(builder).     }     builder.endObject().     return builder. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Request request = (Request) o.     return Objects.equals(remoteCluster, request.remoteCluster) && Objects.equals(leaderIndex, request.leaderIndex) && Objects.equals(followerIndex, request.followerIndex) && Objects.equals(parameters, request.parameters) && Objects.equals(waitForActiveShards, request.waitForActiveShards). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(remoteCluster, leaderIndex, followerIndex, parameters, waitForActiveShards). }
false;public;0;3;;public boolean isFollowIndexCreated() {     return followIndexCreated. }
false;public;0;3;;public boolean isFollowIndexShardsAcked() {     return followIndexShardsAcked. }
false;public;0;3;;public boolean isIndexFollowingStarted() {     return indexFollowingStarted. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeBoolean(followIndexCreated).     out.writeBoolean(followIndexShardsAcked).     out.writeBoolean(indexFollowingStarted). }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.field("follow_index_created", followIndexCreated).         builder.field("follow_index_shards_acked", followIndexShardsAcked).         builder.field("index_following_started", indexFollowingStarted).     }     builder.endObject().     return builder. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Response response = (Response) o.     return followIndexCreated == response.followIndexCreated && followIndexShardsAcked == response.followIndexShardsAcked && indexFollowingStarted == response.indexFollowingStarted. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(followIndexCreated, followIndexShardsAcked, indexFollowingStarted). }
false;public;0;8;;@Override public String toString() {     return "PutFollowAction.Response{" + "followIndexCreated=" + followIndexCreated + ", followIndexShardsAcked=" + followIndexShardsAcked + ", indexFollowingStarted=" + indexFollowingStarted + '}'. }
