commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return The content type of the source  */ ;/**  * @return The content type of the source  */ public XContentType getContentType() {     return contentType. }
true;public;0;3;/**  * @return The bytes reference of the source  */ ;/**  * @return The bytes reference of the source  */ public BytesReference getBytes() {     return bytes. }
true;public;0;3;/**  * @return true if the top level value of the source is a map  */ ;/**  * @return true if the top level value of the source is a map  */ public boolean isMap() {     return data() instanceof Map. }
true;public;0;3;/**  * @return The source as a map  */ ;/**  * @return The source as a map  */ public Map<String, Object> getAsMap() {     return (Map<String, Object>) data(). }
true;public;0;3;/**  * @return true if the top level value of the source is a list  */ ;/**  * @return true if the top level value of the source is a list  */ public boolean isList() {     return data() instanceof List. }
true;public;0;3;/**  * @return The source as a list  */ ;/**  * @return The source as a list  */ public List<Object> getAsList() {     return (List<Object>) data(). }
true;public;1;3;/**  * Extracts a value identified by the given path in the source.  *  * @param path a dot notation path to the requested value  * @return The extracted value or {@code null} if no value is associated with the given path  */ ;/**  * Extracts a value identified by the given path in the source.  *  * @param path a dot notation path to the requested value  * @return The extracted value or {@code null} if no value is associated with the given path  */ public <T> T getValue(String path) {     return (T) ObjectPath.eval(path, data()). }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     // EMPTY is safe here because we never use namedObject     try (InputStream stream = bytes.streamInput().         XContentParser parser = parser(NamedXContentRegistry.EMPTY, stream)) {         parser.nextToken().         builder.generator().copyCurrentStructure(parser).         return builder.     } }
false;public;2;3;;public XContentParser parser(NamedXContentRegistry xContentRegistry, InputStream stream) throws IOException {     return contentType.xContent().createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream). }
false;public,static;1;3;;public static XContentSource readFrom(StreamInput in) throws IOException {     return new XContentSource(in.readBytesReference(), in.readEnum(XContentType.class)). }
false;public,static;2;4;;public static void writeTo(XContentSource source, StreamOutput out) throws IOException {     out.writeBytesReference(source.bytes).     out.writeEnum(source.contentType). }
false;private;0;12;;private Object data() {     if (data == null) {         // EMPTY is safe here because we never use namedObject         try (InputStream stream = bytes.streamInput().             XContentParser parser = parser(NamedXContentRegistry.EMPTY, stream)) {             data = XContentUtils.readValue(parser, parser.nextToken()).         } catch (IOException ex) {             throw new ElasticsearchException("failed to read value", ex).         }     }     return data. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     XContentSource that = (XContentSource) o.     return Objects.equals(data(), that.data()). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(data()). }
false;public;0;4;;@Override public String toString() {     return bytes.utf8ToString(). }
