commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;1;/**  * @return true if the watch associated with this context is known to watcher (i.e. it's stored  *              in watcher. This plays a key role in how we handle execution. For example, if  *              the watch is known, but then the watch is not there (perhaps deleted in between)  *              we abort execution. It also plays a part (along with {@link #recordExecution()}  *              in the decision of whether the watch record should be stored and if the watch  *              status should be updated.  */ ;/**  * @return true if the watch associated with this context is known to watcher (i.e. it's stored  *              in watcher. This plays a key role in how we handle execution. For example, if  *              the watch is known, but then the watch is not there (perhaps deleted in between)  *              we abort execution. It also plays a part (along with {@link #recordExecution()}  *              in the decision of whether the watch record should be stored and if the watch  *              status should be updated.  */ public abstract boolean knownWatch().
true;public,abstract;1;1;/**  * @return true if this action should be simulated  */ ;/**  * @return true if this action should be simulated  */ public abstract boolean simulateAction(String actionId).
false;public,abstract;1;1;;public abstract boolean skipThrottling(String actionId).
true;public,abstract;0;1;/**  * @return true if execution is allowed (this depends on the type of the watch context)  */ ;/**  * @return true if execution is allowed (this depends on the type of the watch context)  */ public abstract boolean shouldBeExecuted().
true;public,abstract;0;1;/**  * @return true if this execution should be recorded in the .watcher-history index  */ ;/**  * @return true if this execution should be recorded in the .watcher-history index  */ public abstract boolean recordExecution().
false;public;0;3;;public Watch watch() {     return watch. }
false;public,final;1;6;;public final void ensureWatchExists(CheckedSupplier<Watch, Exception> supplier) throws Exception {     if (watch == null) {         watch = supplier.get().         user = WatchExecutionContext.getUsernameFromWatch(watch).     } }
false;public;0;3;;public Wid id() {     return id. }
false;public;0;3;;public ZonedDateTime executionTime() {     return executionTime. }
true;public;0;3;/**  * @return The default throttle period in the system.  */ ;/**  * @return The default throttle period in the system.  */ public TimeValue defaultThrottlePeriod() {     return defaultThrottlePeriod. }
false;public;0;3;;public boolean overrideRecordOnConflict() {     return false. }
false;public;0;3;;public TriggerEvent triggerEvent() {     return triggerEvent. }
false;public;0;3;;public Payload payload() {     return payload. }
false;public;0;3;;public Map<String, Object> vars() {     return vars. }
false;public;0;3;;public ExecutionPhase executionPhase() {     return phase. }
true;public;1;3;/**  * @param nodeId The node id this watch execution context runs on  */ ;/**  * @param nodeId The node id this watch execution context runs on  */ public void setNodeId(String nodeId) {     this.nodeId = nodeId. }
true;public;0;3;/**  * @return The node this watch execution context runs on, which will be stored in the watch history  */ ;/**  * @return The node this watch execution context runs on, which will be stored in the watch history  */ public String getNodeId() {     return nodeId. }
true;public;0;1;/**  * @return The user that executes the watch, which will be stored in the watch history  */ ;/**  * @return The user that executes the watch, which will be stored in the watch history  */ public String getUser() {     return user. }
false;public;0;5;;public void start() {     assert phase == ExecutionPhase.AWAITS_EXECUTION.     relativeStartTime = System.nanoTime().     phase = ExecutionPhase.STARTED. }
false;public;0;4;;public void beforeInput() {     assert phase == ExecutionPhase.STARTED.     phase = ExecutionPhase.INPUT. }
false;public;1;7;;public void onInputResult(Input.Result inputResult) {     assert !phase.sealed().     this.inputResult = inputResult.     if (inputResult.status() == Input.Result.Status.SUCCESS) {         this.payload = inputResult.payload().     } }
false;public;0;3;;public Input.Result inputResult() {     return inputResult. }
false;public;0;4;;public void beforeCondition() {     assert phase == ExecutionPhase.INPUT.     phase = ExecutionPhase.CONDITION. }
false;public;1;5;;public void onConditionResult(Condition.Result conditionResult) {     assert !phase.sealed().     this.conditionResult = conditionResult.     watch().status().onCheck(conditionResult.met(), executionTime). }
false;public;0;3;;public Condition.Result conditionResult() {     return conditionResult. }
false;public;0;4;;public void beforeWatchTransform() {     assert phase == ExecutionPhase.CONDITION.     this.phase = ExecutionPhase.WATCH_TRANSFORM. }
false;public;1;7;;public void onWatchTransformResult(Transform.Result result) {     assert !phase.sealed().     this.transformResult = result.     if (result.status() == Transform.Result.Status.SUCCESS) {         this.payload = result.payload().     } }
false;public;0;3;;public Transform.Result transformResult() {     return transformResult. }
false;public;0;4;;public void beforeActions() {     assert phase == ExecutionPhase.CONDITION || phase == ExecutionPhase.WATCH_TRANSFORM.     phase = ExecutionPhase.ACTIONS. }
false;public;1;5;;public void onActionResult(ActionWrapperResult result) {     assert !phase.sealed().     actionsResults.put(result.id(), result).     watch().status().onActionResult(result.id(), executionTime, result.action()). }
false;public;0;3;;public Map<String, ActionWrapperResult> actionsResults() {     return Collections.unmodifiableMap(actionsResults). }
false;public;2;5;;public WatchRecord abortBeforeExecution(ExecutionState state, String message) {     assert !phase.sealed().     phase = ExecutionPhase.ABORTED.     return new WatchRecord.MessageWatchRecord(id, triggerEvent, state, message, getNodeId()). }
false;public;1;8;;public WatchRecord abortFailedExecution(String message) {     assert !phase.sealed().     phase = ExecutionPhase.ABORTED.     long executionTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - relativeStartTime).     WatchExecutionResult result = new WatchExecutionResult(this, executionTime).     watch().status().setExecutionState(WatchRecord.getState(result)).     return new WatchRecord.MessageWatchRecord(this, result, message). }
false;public;1;8;;public WatchRecord abortFailedExecution(Exception e) {     assert !phase.sealed().     phase = ExecutionPhase.ABORTED.     long executionTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - relativeStartTime).     WatchExecutionResult result = new WatchExecutionResult(this, executionTime).     watch().status().setExecutionState(WatchRecord.getState(result)).     return new WatchRecord.ExceptionWatchRecord(this, result, e). }
false;public;0;8;;public WatchRecord finish() {     assert !phase.sealed().     phase = ExecutionPhase.FINISHED.     long executionTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - relativeStartTime).     WatchExecutionResult result = new WatchExecutionResult(this, executionTime).     watch().status().setExecutionState(WatchRecord.getState(result)).     return new WatchRecord.MessageWatchRecord(this, result). }
false;public;1;3;;public WatchExecutionSnapshot createSnapshot(Thread executionThread) {     return new WatchExecutionSnapshot(this, executionThread.getStackTrace()). }
true;public,static;1;10;/**  * Given a watch, this extracts and decodes the relevant auth header and returns the principal of the user that is  * executing the watch.  */ ;/**  * Given a watch, this extracts and decodes the relevant auth header and returns the principal of the user that is  * executing the watch.  */ public static String getUsernameFromWatch(Watch watch) throws IOException {     if (watch != null && watch.status() != null && watch.status().getHeaders() != null) {         String header = watch.status().getHeaders().get(AuthenticationField.AUTHENTICATION_KEY).         if (header != null) {             Authentication auth = Authentication.decode(header).             return auth.getUser().principal().         }     }     return null. }
