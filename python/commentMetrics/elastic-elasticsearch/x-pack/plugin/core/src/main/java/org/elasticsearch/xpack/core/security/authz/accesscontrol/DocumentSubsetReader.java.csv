commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;4;;public static DocumentSubsetDirectoryReader wrap(DirectoryReader in, BitsetFilterCache bitsetFilterCache, Query roleQuery) throws IOException {     return new DocumentSubsetDirectoryReader(in, bitsetFilterCache, roleQuery). }
true;private,static;3;23;/**  * Compute the number of live documents. This method is SLOW.  */ ;/**  * Compute the number of live documents. This method is SLOW.  */ private static int computeNumDocs(LeafReader reader, Query roleQuery, BitSet roleQueryBits) {     final Bits liveDocs = reader.getLiveDocs().     if (roleQueryBits == null) {         return 0.     } else if (liveDocs == null) {         // slow         return roleQueryBits.cardinality().     } else {         // very slow, but necessary in order to be correct         int numDocs = 0.         // we don't use the cost         DocIdSetIterator it = new BitSetIterator(roleQueryBits, 0L).         try {             for (int doc = it.nextDoc(). doc != DocIdSetIterator.NO_MORE_DOCS. doc = it.nextDoc()) {                 if (liveDocs.get(doc)) {                     numDocs++.                 }             }             return numDocs.         } catch (IOException e) {             throw new UncheckedIOException(e).         }     } }
true;private,static;3;27;/**  * Like {@link #computeNumDocs} but caches results.  */ ;/**  * Like {@link #computeNumDocs} but caches results.  */ private static int getNumDocs(LeafReader reader, Query roleQuery, BitSet roleQueryBits) throws IOException, ExecutionException {     // this one takes deletes into account     IndexReader.CacheHelper cacheHelper = reader.getReaderCacheHelper().     if (cacheHelper == null) {         throw new IllegalStateException("Reader " + reader + " does not support caching").     }     final boolean[] added = new boolean[] { false }.     Cache<Query, Integer> perReaderCache = NUM_DOCS_CACHE.computeIfAbsent(cacheHelper.getKey(), key -> {         added[0] = true.         return CacheBuilder.<Query, Integer>builder().setMaximumWeight(1000).weigher(// just count         (k, v) -> 1).build().     }).     if (added[0]) {         IndexReader.ClosedListener closedListener = NUM_DOCS_CACHE::remove.         try {             cacheHelper.addClosedListener(closedListener).         } catch (AlreadyClosedException e) {             closedListener.onClose(cacheHelper.getKey()).             throw e.         }     }     return perReaderCache.computeIfAbsent(roleQuery, q -> computeNumDocs(reader, roleQuery, roleQueryBits)). }
false;public;1;8;;@Override public LeafReader wrap(LeafReader reader) {     try {         return new DocumentSubsetReader(reader, bitsetFilterCache, roleQuery).     } catch (Exception e) {         throw ExceptionsHelper.convertToElastic(e).     } }
false;protected;1;4;;@Override protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) throws IOException {     return new DocumentSubsetDirectoryReader(in, bitsetFilterCache, roleQuery). }
false;private,static;1;11;;private static void verifyNoOtherDocumentSubsetDirectoryReaderIsWrapped(DirectoryReader reader) {     if (reader instanceof FilterDirectoryReader) {         FilterDirectoryReader filterDirectoryReader = (FilterDirectoryReader) reader.         if (filterDirectoryReader instanceof DocumentSubsetDirectoryReader) {             throw new IllegalArgumentException(LoggerMessageFormat.format("Can't wrap [{}] twice", DocumentSubsetDirectoryReader.class)).         } else {             verifyNoOtherDocumentSubsetDirectoryReaderIsWrapped(filterDirectoryReader.getDelegate()).         }     } }
false;public;0;4;;@Override public CacheHelper getReaderCacheHelper() {     return in.getReaderCacheHelper(). }
false;public;1;4;;@Override public boolean get(int index) {     return roleQueryBits.get(index) && actualLiveDocs.get(index). }
false;public;0;4;;@Override public int length() {     return roleQueryBits.length(). }
false;public;0;25;;@Override public Bits getLiveDocs() {     final Bits actualLiveDocs = in.getLiveDocs().     if (roleQueryBits == null) {         // but that isn't the case. No docs match with the role query and therefor all docs are marked as deleted         return new Bits.MatchNoBits(in.maxDoc()).     } else if (actualLiveDocs == null) {         return roleQueryBits.     } else {         // apply deletes when needed:         return new Bits() {              @Override             public boolean get(int index) {                 return roleQueryBits.get(index) && actualLiveDocs.get(index).             }              @Override             public int length() {                 return roleQueryBits.length().             }         }.     } }
false;public;0;4;;@Override public int numDocs() {     return numDocs. }
false;public;0;5;;@Override public boolean hasDeletions() {     // we always return liveDocs and hide docs:     return true. }
false;public;0;4;;@Override public CacheHelper getCoreCacheHelper() {     return in.getCoreCacheHelper(). }
false;public;0;5;;@Override public CacheHelper getReaderCacheHelper() {     // Not delegated since we change the live docs     return null. }
false;;0;3;;BitSet getRoleQueryBits() {     return roleQueryBits. }
false;;0;3;;Bits getWrappedLiveDocs() {     return in.getLiveDocs(). }
