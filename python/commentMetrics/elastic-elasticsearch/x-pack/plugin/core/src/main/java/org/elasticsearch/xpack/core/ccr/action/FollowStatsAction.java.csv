commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public StatsResponses newResponse() {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;0;4;;@Override public Writeable.Reader<StatsResponses> getResponseReader() {     return StatsResponses::new. }
false;public;0;3;;public List<StatsResponse> getStatsResponses() {     return statsResponse. }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeList(statsResponse). }
false;public;2;33;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     // sort by index name, then shard ID     final Map<String, Map<Integer, StatsResponse>> taskResponsesByIndex = new TreeMap<>().     for (final StatsResponse statsResponse : statsResponse) {         taskResponsesByIndex.computeIfAbsent(statsResponse.status().followerIndex(), k -> new TreeMap<>()).put(statsResponse.status().getShardId(), statsResponse).     }     builder.startObject().     {         builder.startArray("indices").         {             for (final Map.Entry<String, Map<Integer, StatsResponse>> index : taskResponsesByIndex.entrySet()) {                 builder.startObject().                 {                     builder.field("index", index.getKey()).                     builder.startArray("shards").                     {                         for (final Map.Entry<Integer, StatsResponse> shard : index.getValue().entrySet()) {                             shard.getValue().status().toXContent(builder, params).                         }                     }                     builder.endArray().                 }                 builder.endObject().             }         }         builder.endArray().     }     builder.endObject().     return builder. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     StatsResponses that = (StatsResponses) o.     return Objects.equals(statsResponse, that.statsResponse). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(statsResponse). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalStringArray(indices). }
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;1;3;;public void setIndices(final String[] indices) {     this.indices = indices. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.strictExpand(). }
false;public;1;12;;@Override public boolean match(final Task task) {     /*              * This is a limitation of the current tasks API. When the transport action is executed, the tasks API invokes this match method              * to find the tasks on which to execute the task-level operation (see TransportTasksAction#nodeOperation and              * TransportTasksAction#processTasks). If we do the matching here, then we can not match index patterns. Therefore, we override              * TransportTasksAction#processTasks (see TransportFollowStatsAction#processTasks) and do the matching there. We should never              * see this method invoked and since we can not support matching a task on the basis of the request here, we throw that this              * operation is unsupported.              */     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     StatsRequest that = (StatsRequest) o.     return Arrays.equals(indices, that.indices). }
false;public;0;4;;@Override public int hashCode() {     return Arrays.hashCode(indices). }
false;public;0;3;;public ShardFollowNodeTaskStatus status() {     return status. }
false;public;1;4;;@Override public void writeTo(final StreamOutput out) throws IOException {     status.writeTo(out). }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     StatsResponse that = (StatsResponse) o.     return Objects.equals(status, that.status). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(status). }
