commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeMap(transformCountByState, StreamOutput::writeString, StreamOutput::writeLong).     accumulatedStats.writeTo(out). }
false;protected;2;17;;@Override protected void innerXContent(XContentBuilder builder, Params params) throws IOException {     super.innerXContent(builder, params).     if (transformCountByState.isEmpty() == false) {         builder.startObject(DataFrameField.TRANSFORMS.getPreferredName()).         long all = 0L.         for (Entry<String, Long> entry : transformCountByState.entrySet()) {             builder.field(entry.getKey(), entry.getValue()).             all += entry.getValue().         }         builder.field(MetaData.ALL, all).         builder.endObject().         // if there are no transforms, do not show any stats         builder.field(DataFrameField.STATS_FIELD.getPreferredName(), accumulatedStats).     } }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(enabled, available, transformCountByState, accumulatedStats). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     DataFrameFeatureSetUsage other = (DataFrameFeatureSetUsage) obj.     return Objects.equals(name, other.name) && available == other.available && enabled == other.enabled && Objects.equals(transformCountByState, other.transformCountByState) && Objects.equals(accumulatedStats, other.accumulatedStats). }
