commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getApplication() {     return application. }
true;;0;3;// Package level for testing ;// Package level for testing String[] getPatterns() {     return patterns. }
true;public,static;1;3;/**  * Validate that the provided application name is valid, and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ ;/**  * Validate that the provided application name is valid, and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ public static void validateApplicationName(String application) {     validateApplicationName(application, false). }
true;public,static;1;3;/**  * Validate that the provided name is a valid application, or a wildcard pattern for an application and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ ;/**  * Validate that the provided name is a valid application, or a wildcard pattern for an application and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ public static void validateApplicationNameOrWildcard(String application) {     validateApplicationName(application, true). }
true;private,static;2;43;/**  * Validates that an application name matches the following rules:  * - consist of a "prefix", optionally followed by either "-" or "_" and a suffix  * - the prefix must begin with a lowercase ASCII letter  * - the prefix only contain ASCII letter or digits  * - the prefix must be at least 3 characters long  * - the suffix must only contain {@link Strings#validFileName valid filename} characters  * - no part of the name may contain whitespace  * If {@code allowWildcard} is true, then the names that end with a '*', and would match a valid  * application name are also accepted.  */ ;/**  * Validates that an application name matches the following rules:  * - consist of a "prefix", optionally followed by either "-" or "_" and a suffix  * - the prefix must begin with a lowercase ASCII letter  * - the prefix only contain ASCII letter or digits  * - the prefix must be at least 3 characters long  * - the suffix must only contain {@link Strings#validFileName valid filename} characters  * - no part of the name may contain whitespace  * If {@code allowWildcard} is true, then the names that end with a '*', and would match a valid  * application name are also accepted.  */ private static void validateApplicationName(String application, boolean allowWildcard) {     if (Strings.isEmpty(application)) {         throw new IllegalArgumentException("Application names cannot be blank").     }     final int asterisk = application.indexOf('*').     if (asterisk != -1) {         if (allowWildcard == false) {             throw new IllegalArgumentException("Application names may not contain '*' (found '" + application + "')").         }         if (application.equals("*")) {             // this is allowed and short-circuiting here makes the later validation simpler             return.         }         if (asterisk != application.length() - 1) {             throw new IllegalArgumentException("Application name patterns only support trailing wildcards (found '" + application + "')").         }     }     if (WHITESPACE.matcher(application).find()) {         throw new IllegalArgumentException("Application names may not contain whitespace (found '" + application + "')").     }     final String[] parts = application.split("[_-]", 2).     String prefix = parts[0].     if (prefix.endsWith("*")) {         prefix = prefix.substring(0, prefix.length() - 1).     }     if (VALID_APPLICATION_PREFIX.matcher(prefix).matches() == false) {         throw new IllegalArgumentException("An application name prefix must match the pattern " + VALID_APPLICATION_PREFIX.pattern() + " (found '" + prefix + "')").     }     if (prefix.length() < 3 && asterisk == -1) {         throw new IllegalArgumentException("An application name prefix must be at least 3 characters long (found '" + prefix + "')").     }     if (parts.length > 1) {         final String suffix = parts[1].         if (Strings.validFileName(suffix) == false) {             throw new IllegalArgumentException("An application name suffix may not contain any of the characters '" + Strings.collectionToDelimitedString(Strings.INVALID_FILENAME_CHARS, "") + "' (found '" + suffix + "')").         }     } }
true;public,static;1;6;/**  * Validate that the provided privilege name is valid, and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ ;/**  * Validate that the provided privilege name is valid, and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ public static void validatePrivilegeName(String name) {     if (isValidPrivilegeName(name) == false) {         throw new IllegalArgumentException("Application privilege names must match the pattern " + VALID_NAME.pattern() + " (found '" + name + "')").     } }
false;private,static;1;3;;private static boolean isValidPrivilegeName(String name) {     return VALID_NAME.matcher(name).matches(). }
true;public,static;1;6;/**  * Validate that the provided name is a valid privilege name or action name, and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ ;/**  * Validate that the provided name is a valid privilege name or action name, and throws an exception otherwise  *  * @throws IllegalArgumentException if the name is not valid  */ public static void validatePrivilegeOrActionName(String name) {     if (VALID_NAME_OR_ACTION.matcher(name).matches() == false) {         throw new IllegalArgumentException("Application privilege names and actions must match the pattern " + VALID_NAME_OR_ACTION.pattern() + " (found '" + name + "')").     } }
true;public,static;3;10;/**  * Finds or creates an application privileges with the provided names.  * Each element in {@code name} may be the name of a stored privilege (to be resolved from {@code stored}, or a bespoke action pattern.  */ ;/**  * Finds or creates an application privileges with the provided names.  * Each element in {@code name} may be the name of a stored privilege (to be resolved from {@code stored}, or a bespoke action pattern.  */ public static ApplicationPrivilege get(String application, Set<String> name, Collection<ApplicationPrivilegeDescriptor> stored) {     if (name.isEmpty()) {         return NONE.apply(application).     } else {         Map<String, ApplicationPrivilegeDescriptor> lookup = stored.stream().filter(apd -> apd.getApplication().equals(application)).collect(Collectors.toMap(ApplicationPrivilegeDescriptor::getName, Function.identity())).         return resolve(application, name, lookup).     } }
false;private,static;3;22;;private static ApplicationPrivilege resolve(String application, Set<String> names, Map<String, ApplicationPrivilegeDescriptor> lookup) {     final int size = names.size().     if (size == 0) {         throw new IllegalArgumentException("empty set should not be used").     }     Set<String> actions = new HashSet<>().     Set<String> patterns = new HashSet<>().     for (String name : names) {         if (isValidPrivilegeName(name)) {             ApplicationPrivilegeDescriptor descriptor = lookup.get(name).             if (descriptor != null) {                 patterns.addAll(descriptor.getActions()).             }         } else {             actions.add(name).         }     }     patterns.addAll(actions).     return new ApplicationPrivilege(application, names, patterns.toArray(new String[patterns.size()])). }
false;public;0;4;;@Override public String toString() {     return application + ":" + super.toString() + "(" + Strings.arrayToCommaDelimitedString(patterns) + ")". }
false;public;0;7;;@Override public int hashCode() {     int result = super.hashCode().     result = 31 * result + Objects.hashCode(application).     result = 31 * result + Arrays.hashCode(patterns).     return result. }
false;public;1;6;;@Override public boolean equals(Object o) {     return super.equals(o) && Objects.equals(this.application, ((ApplicationPrivilege) o).application) && Arrays.equals(this.patterns, ((ApplicationPrivilege) o).patterns). }
