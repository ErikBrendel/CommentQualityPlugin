commented;modifiers;parameterAmount;loc;comment;code
false;public;1;26;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalString(id).     out.writeBoolean(ignoreCondition).     out.writeBoolean(recordExecution).     out.writeBoolean(alternativeInput != null).     if (alternativeInput != null) {         out.writeMap(alternativeInput).     }     out.writeBoolean(triggerData != null).     if (triggerData != null) {         out.writeMap(triggerData).     }     out.writeLong(actionModes.size()).     for (Map.Entry<String, ActionExecutionMode> entry : actionModes.entrySet()) {         out.writeString(entry.getKey()).         out.writeByte(entry.getValue().id()).     }     out.writeBoolean(watchSource != null).     if (watchSource != null) {         out.writeBytesReference(watchSource).         out.writeEnum(xContentType).     }     out.writeBoolean(debug). }
true;public;0;3;/**  * @return The id of the watch to be executed  */ ;/**  * @return The id of the watch to be executed  */ public String getId() {     return id. }
true;public;1;3;/**  * Sets the id of the watch to be executed  */ ;/**  * Sets the id of the watch to be executed  */ public void setId(String id) {     this.id = id. }
true;public;0;3;/**  * @return Should the condition for this execution be ignored  */ ;/**  * @return Should the condition for this execution be ignored  */ public boolean isIgnoreCondition() {     return ignoreCondition. }
true;public;1;3;/**  * @param ignoreCondition set if the condition for this execution be ignored  */ ;/**  * @param ignoreCondition set if the condition for this execution be ignored  */ public void setIgnoreCondition(boolean ignoreCondition) {     this.ignoreCondition = ignoreCondition. }
true;public;0;3;/**  * @return Should this execution be recorded in the history index  */ ;/**  * @return Should this execution be recorded in the history index  */ public boolean isRecordExecution() {     return recordExecution. }
true;public;1;3;/**  * @param recordExecution Sets if this execution be recorded in the history index  */ ;/**  * @param recordExecution Sets if this execution be recorded in the history index  */ public void setRecordExecution(boolean recordExecution) {     this.recordExecution = recordExecution. }
true;public;0;3;/**  * @return The alertnative input to use (may be null)  */ ;/**  * @return The alertnative input to use (may be null)  */ public Map<String, Object> getAlternativeInput() {     return alternativeInput. }
true;public;1;3;/**  * @param alternativeInput Set's the alernative input  */ ;/**  * @param alternativeInput Set's the alernative input  */ public void setAlternativeInput(Map<String, Object> alternativeInput) {     this.alternativeInput = alternativeInput. }
true;public;1;3;/**  * @param data The data that should be associated with the trigger event.  */ ;/**  * @param data The data that should be associated with the trigger event.  */ public void setTriggerData(Map<String, Object> data) throws IOException {     this.triggerData = data. }
true;public;1;3;/**  * @param event the trigger event to use  */ ;/**  * @param event the trigger event to use  */ public void setTriggerEvent(TriggerEvent event) throws IOException {     setTriggerData(event.data()). }
true;public;0;3;/**  * @return the trigger to use  */ ;/**  * @return the trigger to use  */ public Map<String, Object> getTriggerData() {     return triggerData. }
true;public;0;3;/**  * @return the source of the watch to execute  */ ;/**  * @return the source of the watch to execute  */ public BytesReference getWatchSource() {     return watchSource. }
false;public;0;3;;public XContentType getXContentType() {     return xContentType. }
true;public;2;4;/**  * @param watchSource instead of using an existing watch use this non persisted watch  */ ;/**  * @param watchSource instead of using an existing watch use this non persisted watch  */ public void setWatchSource(BytesReference watchSource, XContentType xContentType) {     this.watchSource = watchSource.     this.xContentType = xContentType. }
true;public;1;4;/**  * @param watchSource instead of using an existing watch use this non persisted watch  */ ;/**  * @param watchSource instead of using an existing watch use this non persisted watch  */ public void setWatchSource(WatchSourceBuilder watchSource) {     this.watchSource = watchSource.buildAsBytes(XContentType.JSON).     this.xContentType = XContentType.JSON. }
true;public;0;3;/**  * @return  the execution modes for the actions. These modes determine the nature of the execution  *          of the watch actions while the watch is executing.  */ ;/**  * @return  the execution modes for the actions. These modes determine the nature of the execution  *          of the watch actions while the watch is executing.  */ public Map<String, ActionExecutionMode> getActionModes() {     return actionModes. }
true;public;2;3;/**  * Sets the action execution mode for the give action (identified by its id).  *  * @param actionId      the action id.  * @param actionMode    the execution mode of the action.  */ ;/**  * Sets the action execution mode for the give action (identified by its id).  *  * @param actionId      the action id.  * @param actionMode    the execution mode of the action.  */ public void setActionMode(String actionId, ActionExecutionMode actionMode) {     actionModes.put(actionId, actionMode). }
true;public;0;3;/**  * @return whether the watch should execute in debug mode. In debug mode the execution {@code vars}  *         will be returned as part of the watch record.  */ ;/**  * @return whether the watch should execute in debug mode. In debug mode the execution {@code vars}  *         will be returned as part of the watch record.  */ public boolean isDebug() {     return debug. }
true;public;1;3;/**  * @param debug indicates whether the watch should execute in debug mode. In debug mode the  *              returned watch record will hold the execution {@code vars}  */ ;/**  * @param debug indicates whether the watch should execute in debug mode. In debug mode the  *              returned watch record will hold the execution {@code vars}  */ public void setDebug(boolean debug) {     this.debug = debug. }
false;public;0;29;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (id == null && watchSource == null) {         validationException = ValidateActions.addValidationError("a watch execution request must either have a watch id or an inline " + "watch source, but both are missing", validationException).     }     if (id != null && WatcherUtils.isValidId(id) == false) {         validationException = ValidateActions.addValidationError("watch id contains whitespace", validationException).     }     for (String actionId : actionModes.keySet()) {         if (actionId == null) {             validationException = ValidateActions.addValidationError(String.format(Locale.ROOT, "action id may not be null"), validationException).         } else if (WatcherUtils.isValidId(actionId) == false) {             validationException = ValidateActions.addValidationError(String.format(Locale.ROOT, "action id [%s] contains whitespace", actionId), validationException).         }     }     if (watchSource != null && id != null) {         validationException = ValidateActions.addValidationError("a watch execution request must either have a watch id or an inline " + "watch source but not both", validationException).     }     if (watchSource != null && recordExecution) {         validationException = ValidateActions.addValidationError("the execution of an inline watch cannot be recorded", validationException).     }     return validationException. }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;0;4;;@Override public String toString() {     return "execute[" + id + "]". }
