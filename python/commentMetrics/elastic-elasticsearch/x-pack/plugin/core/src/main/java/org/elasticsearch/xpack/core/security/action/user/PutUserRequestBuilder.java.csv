commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public PutUserRequestBuilder username(String username) {     request.username(username).     return this. }
false;public;1;4;;public PutUserRequestBuilder roles(String... roles) {     request.roles(roles).     return this. }
false;public;2;15;;public PutUserRequestBuilder password(char[] password, Hasher hasher) {     if (password != null) {         Validation.Error error = Validation.Users.validatePassword(password).         if (error != null) {             throw validationException(error.toString()).         }         if (request.passwordHash() != null) {             throw validationException("password_hash has already been set").         }         request.passwordHash(hasher.hash(new SecureString(password))).     } else {         request.passwordHash(null).     }     return this. }
false;public;1;4;;public PutUserRequestBuilder metadata(Map<String, Object> metadata) {     request.metadata(metadata).     return this. }
false;public;1;4;;public PutUserRequestBuilder fullName(String fullName) {     request.fullName(fullName).     return this. }
false;public;1;4;;public PutUserRequestBuilder email(String email) {     request.email(email).     return this. }
false;public;2;12;;public PutUserRequestBuilder passwordHash(char[] passwordHash, Hasher configuredHasher) {     final Hasher resolvedHasher = Hasher.resolveFromHash(passwordHash).     if (resolvedHasher.equals(configuredHasher) == false) {         throw new IllegalArgumentException("Provided password hash uses [" + resolvedHasher + "] but the configured hashing algorithm is [" + configuredHasher + "]").     }     if (request.passwordHash() != null) {         throw validationException("password_hash has already been set").     }     request.passwordHash(passwordHash).     return this. }
false;public;1;4;;public PutUserRequestBuilder enabled(boolean enabled) {     request.enabled(enabled).     return this. }
true;public;4;83;/**  * Populate the put user request using the given source and username  */ ;/**  * Populate the put user request using the given source and username  */ public PutUserRequestBuilder source(String username, BytesReference source, XContentType xContentType, Hasher hasher) throws IOException {     Objects.requireNonNull(xContentType).     username(username).     // EMPTY is ok here because we never call namedObject     try (InputStream stream = source.streamInput().         XContentParser parser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {         XContentUtils.verifyObject(parser).         XContentParser.Token token.         String currentFieldName = null.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (User.Fields.PASSWORD.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     String password = parser.text().                     char[] passwordChars = password.toCharArray().                     password(passwordChars, hasher).                     Arrays.fill(passwordChars, (char) 0).                 } else {                     throw new ElasticsearchParseException("expected field [{}] to be of type string, but found [{}] instead", currentFieldName, token).                 }             } else if (User.Fields.PASSWORD_HASH.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     char[] passwordChars = parser.text().toCharArray().                     passwordHash(passwordChars, hasher).                 } else {                     throw new ElasticsearchParseException("expected field [{}] to be of type string, but found [{}] instead", currentFieldName, token).                 }             } else if (User.Fields.ROLES.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     roles(Strings.commaDelimitedListToStringArray(parser.text())).                 } else {                     roles(XContentUtils.readStringArray(parser, false)).                 }             } else if (User.Fields.FULL_NAME.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     fullName(parser.text()).                 } else if (token != XContentParser.Token.VALUE_NULL) {                     throw new ElasticsearchParseException("expected field [{}] to be of type string, but found [{}] instead", currentFieldName, token).                 }             } else if (User.Fields.EMAIL.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     email(parser.text()).                 } else if (token != XContentParser.Token.VALUE_NULL) {                     throw new ElasticsearchParseException("expected field [{}] to be of type string, but found [{}] instead", currentFieldName, token).                 }             } else if (User.Fields.METADATA.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.START_OBJECT) {                     metadata(parser.map()).                 } else {                     throw new ElasticsearchParseException("expected field [{}] to be of type object, but found [{}] instead", currentFieldName, token).                 }             } else if (User.Fields.ENABLED.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_BOOLEAN) {                     enabled(parser.booleanValue()).                 } else {                     throw new ElasticsearchParseException("expected field [{}] to be of type boolean, but found [{}] instead", currentFieldName, token).                 }             } else if (User.Fields.USERNAME.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == Token.VALUE_STRING) {                     if (username.equals(parser.text()) == false) {                         throw new IllegalArgumentException("[username] in source does not match the username provided [" + username + "]").                     }                 } else {                     throw new ElasticsearchParseException("expected field [{}] to be of type string, but found [{}] instead", currentFieldName, token).                 }             } else {                 throw new ElasticsearchParseException("failed to parse add user request. unexpected field [{}]", currentFieldName).             }         }         return this.     } }
false;private;1;5;;private ValidationException validationException(String abc) {     ValidationException validationException = new ValidationException().     validationException.addValidationError(abc).     return validationException. }
