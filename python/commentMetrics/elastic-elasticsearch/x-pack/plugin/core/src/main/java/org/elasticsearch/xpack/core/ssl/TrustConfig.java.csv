commented;modifiers;parameterAmount;loc;comment;code
true;abstract;1;1;/**  * Creates a {@link X509ExtendedTrustManager} based on the provided configuration  * @param environment the environment to resolve files against or null in the case of running in a transport client  */ ;/**  * Creates a {@link X509ExtendedTrustManager} based on the provided configuration  * @param environment the environment to resolve files against or null in the case of running in a transport client  */ abstract X509ExtendedTrustManager createTrustManager(@Nullable Environment environment).
false;abstract;1;1;;abstract Collection<CertificateInfo> certificates(@Nullable Environment environment) throws GeneralSecurityException, IOException.
true;abstract;1;1;/**  * Returns a list of files that should be monitored for changes  * @param environment the environment to resolve files against or null in the case of running in a transport client  */ ;/**  * Returns a list of files that should be monitored for changes  * @param environment the environment to resolve files against or null in the case of running in a transport client  */ abstract List<Path> filesToMonitor(@Nullable Environment environment).
true;public,abstract;0;1;/**  * {@inheritDoc}. Declared as abstract to force implementors to provide a custom implementation  */ ;/**  * {@inheritDoc}. Declared as abstract to force implementors to provide a custom implementation  */ public abstract String toString().
true;public,abstract;1;1;/**  * {@inheritDoc}. Declared as abstract to force implementors to provide a custom implementation  */ ;/**  * {@inheritDoc}. Declared as abstract to force implementors to provide a custom implementation  */ public abstract boolean equals(Object o).
true;public,abstract;0;1;/**  * {@inheritDoc}. Declared as abstract to force implementors to provide a custom implementation  */ ;/**  * {@inheritDoc}. Declared as abstract to force implementors to provide a custom implementation  */ public abstract int hashCode().
true;;4;15;/**  * Loads and returns the appropriate {@link KeyStore} for the given configuration. The KeyStore can be backed by a file  * in any format that the Security Provider might support, or a cryptographic software or hardware token in the case  * of a PKCS#11 Provider.  *  * @param environment   the environment to resolve files against or null in the case of running in a transport client  * @param storePath     the path to the {@link KeyStore} to load, or null if a PKCS11 token is configured as the keystore/truststore  *                      of the JVM  * @param storeType     the type of the {@link KeyStore}  * @param storePassword the password to be used for decrypting the {@link KeyStore}  * @return the loaded KeyStore to be used as a keystore or a truststore  * @throws KeyStoreException        if an instance of the specified type cannot be loaded  * @throws CertificateException     if any of the certificates in the keystore could not be loaded  * @throws NoSuchAlgorithmException if the algorithm used to check the integrity of the keystore cannot be found  * @throws IOException              if there is an I/O issue with the KeyStore data or the password is incorrect  */ ;/**  * Loads and returns the appropriate {@link KeyStore} for the given configuration. The KeyStore can be backed by a file  * in any format that the Security Provider might support, or a cryptographic software or hardware token in the case  * of a PKCS#11 Provider.  *  * @param environment   the environment to resolve files against or null in the case of running in a transport client  * @param storePath     the path to the {@link KeyStore} to load, or null if a PKCS11 token is configured as the keystore/truststore  *                      of the JVM  * @param storeType     the type of the {@link KeyStore}  * @param storePassword the password to be used for decrypting the {@link KeyStore}  * @return the loaded KeyStore to be used as a keystore or a truststore  * @throws KeyStoreException        if an instance of the specified type cannot be loaded  * @throws CertificateException     if any of the certificates in the keystore could not be loaded  * @throws NoSuchAlgorithmException if the algorithm used to check the integrity of the keystore cannot be found  * @throws IOException              if there is an I/O issue with the KeyStore data or the password is incorrect  */ KeyStore getStore(@Nullable Environment environment, @Nullable String storePath, String storeType, SecureString storePassword) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {     if (null != storePath) {         try (InputStream in = Files.newInputStream(CertParsingUtils.resolvePath(storePath, environment))) {             KeyStore ks = KeyStore.getInstance(storeType).             ks.load(in, storePassword.getChars()).             return ks.         }     } else if (storeType.equalsIgnoreCase("pkcs11")) {         KeyStore ks = KeyStore.getInstance(storeType).         ks.load(null, storePassword.getChars()).         return ks.     }     throw new IllegalArgumentException("keystore.path or truststore.path can only be empty when using a PKCS#11 token"). }
false;;1;16;;@Override X509ExtendedTrustManager createTrustManager(@Nullable Environment environment) {     Optional<TrustConfig> matchAll = trustConfigs.stream().filter(TrustAllConfig.INSTANCE::equals).findAny().     if (matchAll.isPresent()) {         return matchAll.get().createTrustManager(environment).     }     try {         return CertParsingUtils.trustManager(trustConfigs.stream().flatMap((tc) -> Arrays.stream(tc.createTrustManager(environment).getAcceptedIssuers())).collect(Collectors.toList()).toArray(new X509Certificate[0])).     } catch (Exception e) {         throw new ElasticsearchException("failed to create trust manager", e).     } }
false;;1;8;;@Override Collection<CertificateInfo> certificates(Environment environment) throws GeneralSecurityException, IOException {     List<CertificateInfo> certificates = new ArrayList<>().     for (TrustConfig tc : trustConfigs) {         certificates.addAll(tc.certificates(environment)).     }     return certificates. }
false;;1;4;;@Override List<Path> filesToMonitor(@Nullable Environment environment) {     return trustConfigs.stream().flatMap((tc) -> tc.filesToMonitor(environment).stream()).collect(Collectors.toList()). }
false;public;0;4;;@Override public String toString() {     return "Combining Trust Config{" + trustConfigs.stream().map(TrustConfig::toString).collect(Collectors.joining(", ")) + "}". }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (!(o instanceof CombiningTrustConfig)) {         return false.     }     CombiningTrustConfig that = (CombiningTrustConfig) o.     return trustConfigs.equals(that.trustConfigs). }
false;public;0;4;;@Override public int hashCode() {     return trustConfigs.hashCode(). }
