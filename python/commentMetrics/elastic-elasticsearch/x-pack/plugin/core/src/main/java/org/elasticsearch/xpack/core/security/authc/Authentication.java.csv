commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public User getUser() {     return user. }
false;public;0;3;;public RealmRef getAuthenticatedBy() {     return authenticatedBy. }
false;public;0;3;;public RealmRef getLookedUpBy() {     return lookedUpBy. }
false;public;0;3;;public Version getVersion() {     return version. }
false;public;0;3;;public AuthenticationType getAuthenticationType() {     return type. }
false;public;0;3;;public Map<String, Object> getMetadata() {     return metadata. }
false;public,static;1;13;;public static Authentication readFromContext(ThreadContext ctx) throws IOException, IllegalArgumentException {     Authentication authentication = ctx.getTransient(AuthenticationField.AUTHENTICATION_KEY).     if (authentication != null) {         assert ctx.getHeader(AuthenticationField.AUTHENTICATION_KEY) != null.         return authentication.     }     String authenticationHeader = ctx.getHeader(AuthenticationField.AUTHENTICATION_KEY).     if (authenticationHeader == null) {         return null.     }     return deserializeHeaderAndPutInContext(authenticationHeader, ctx). }
false;public,static;1;3;;public static Authentication getAuthentication(ThreadContext context) {     return context.getTransient(AuthenticationField.AUTHENTICATION_KEY). }
false;static;2;8;;static Authentication deserializeHeaderAndPutInContext(String header, ThreadContext ctx) throws IOException, IllegalArgumentException {     assert ctx.getTransient(AuthenticationField.AUTHENTICATION_KEY) == null.     Authentication authentication = decode(header).     ctx.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication).     return authentication. }
false;public,static;1;7;;public static Authentication decode(String header) throws IOException {     byte[] bytes = Base64.getDecoder().decode(header).     StreamInput input = StreamInput.wrap(bytes).     Version version = Version.readVersion(input).     input.setVersion(version).     return new Authentication(input). }
true;public;1;6;/**  * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an  * {@link IllegalStateException} will be thrown  */ ;/**  * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an  * {@link IllegalStateException} will be thrown  */ public void writeToContext(ThreadContext ctx) throws IOException, IllegalArgumentException {     ensureContextDoesNotContainAuthentication(ctx).     String header = encode().     ctx.putTransient(AuthenticationField.AUTHENTICATION_KEY, this).     ctx.putHeader(AuthenticationField.AUTHENTICATION_KEY, header). }
false;;1;8;;void ensureContextDoesNotContainAuthentication(ThreadContext ctx) {     if (ctx.getTransient(AuthenticationField.AUTHENTICATION_KEY) != null) {         if (ctx.getHeader(AuthenticationField.AUTHENTICATION_KEY) == null) {             throw new IllegalStateException("authentication present as a transient but not a header").         }         throw new IllegalStateException("authentication is already present in the context").     } }
false;public;0;7;;public String encode() throws IOException {     BytesStreamOutput output = new BytesStreamOutput().     output.setVersion(version).     Version.writeVersion(version, output).     writeTo(output).     return Base64.getEncoder().encodeToString(BytesReference.toBytes(output.bytes())). }
false;public;1;14;;public void writeTo(StreamOutput out) throws IOException {     InternalUserSerializationHelper.writeTo(user, out).     authenticatedBy.writeTo(out).     if (lookedUpBy != null) {         out.writeBoolean(true).         lookedUpBy.writeTo(out).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeVInt(type.ordinal()).         out.writeMap(metadata).     } }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Authentication that = (Authentication) o.     return user.equals(that.user) && authenticatedBy.equals(that.authenticatedBy) && Objects.equals(lookedUpBy, that.lookedUpBy) && version.equals(that.version) && type == that.type && metadata.equals(that.metadata). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(user, authenticatedBy, lookedUpBy, version, type, metadata). }
false;public;2;24;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(User.Fields.USERNAME.getPreferredName(), user.principal()).     builder.array(User.Fields.ROLES.getPreferredName(), user.roles()).     builder.field(User.Fields.FULL_NAME.getPreferredName(), user.fullName()).     builder.field(User.Fields.EMAIL.getPreferredName(), user.email()).     builder.field(User.Fields.METADATA.getPreferredName(), user.metadata()).     builder.field(User.Fields.ENABLED.getPreferredName(), user.enabled()).     builder.startObject(User.Fields.AUTHENTICATION_REALM.getPreferredName()).     builder.field(User.Fields.REALM_NAME.getPreferredName(), getAuthenticatedBy().getName()).     builder.field(User.Fields.REALM_TYPE.getPreferredName(), getAuthenticatedBy().getType()).     builder.endObject().     builder.startObject(User.Fields.LOOKUP_REALM.getPreferredName()).     if (getLookedUpBy() != null) {         builder.field(User.Fields.REALM_NAME.getPreferredName(), getLookedUpBy().getName()).         builder.field(User.Fields.REALM_TYPE.getPreferredName(), getLookedUpBy().getType()).     } else {         builder.field(User.Fields.REALM_NAME.getPreferredName(), getAuthenticatedBy().getName()).         builder.field(User.Fields.REALM_TYPE.getPreferredName(), getAuthenticatedBy().getType()).     }     builder.endObject().     return builder.endObject(). }
false;;1;5;;void writeTo(StreamOutput out) throws IOException {     out.writeString(nodeName).     out.writeString(name).     out.writeString(type). }
false;public;0;3;;public String getNodeName() {     return nodeName. }
false;public;0;3;;public String getName() {     return name. }
false;public;0;3;;public String getType() {     return type. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     RealmRef realmRef = (RealmRef) o.     if (!nodeName.equals(realmRef.nodeName))         return false.     if (!name.equals(realmRef.name))         return false.     return type.equals(realmRef.type). }
false;public;0;7;;@Override public int hashCode() {     int result = nodeName.hashCode().     result = 31 * result + name.hashCode().     result = 31 * result + type.hashCode().     return result. }
