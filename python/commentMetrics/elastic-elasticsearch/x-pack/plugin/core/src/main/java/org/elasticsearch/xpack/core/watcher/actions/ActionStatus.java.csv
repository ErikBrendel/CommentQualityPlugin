commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public AckStatus ackStatus() {     return ackStatus. }
false;public;0;3;;public Execution lastExecution() {     return lastExecution. }
false;public;0;3;;public Execution lastSuccessfulExecution() {     return lastSuccessfulExecution. }
false;public;0;3;;public Throttle lastThrottle() {     return lastThrottle. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ActionStatus that = (ActionStatus) o.     return Objects.equals(ackStatus, that.ackStatus) && Objects.equals(lastExecution, that.lastExecution) && Objects.equals(lastSuccessfulExecution, that.lastSuccessfulExecution) && Objects.equals(lastThrottle, that.lastThrottle). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(ackStatus, lastExecution, lastSuccessfulExecution, lastThrottle). }
false;public;2;22;;public void update(ZonedDateTime timestamp, Action.Result result) {     switch(result.status()) {         case FAILURE:             String reason = result instanceof Action.Result.Failure ? ((Action.Result.Failure) result).reason() : "".             lastExecution = Execution.failure(timestamp, reason).             return.         case THROTTLED:             reason = result instanceof Action.Result.Throttled ? ((Action.Result.Throttled) result).reason() : "".             lastThrottle = new Throttle(timestamp, reason).             return.         case SUCCESS:         case SIMULATED:             lastExecution = Execution.successful(timestamp).             lastSuccessfulExecution = lastExecution.             if (ackStatus.state == AckStatus.State.AWAITS_SUCCESSFUL_EXECUTION) {                 ackStatus = new AckStatus(timestamp, AckStatus.State.ACKABLE).             }     } }
false;public;1;7;;public boolean onAck(ZonedDateTime timestamp) {     if (ackStatus.state == AckStatus.State.ACKABLE) {         ackStatus = new AckStatus(timestamp, AckStatus.State.ACKED).         return true.     }     return false. }
false;public;1;7;;public boolean resetAckStatus(ZonedDateTime timestamp) {     if (ackStatus.state != AckStatus.State.AWAITS_SUCCESSFUL_EXECUTION) {         ackStatus = new AckStatus(timestamp, AckStatus.State.AWAITS_SUCCESSFUL_EXECUTION).         return true.     }     return false. }
false;public,static;2;15;;public static void writeTo(ActionStatus status, StreamOutput out) throws IOException {     AckStatus.writeTo(status.ackStatus, out).     out.writeBoolean(status.lastExecution != null).     if (status.lastExecution != null) {         Execution.writeTo(status.lastExecution, out).     }     out.writeBoolean(status.lastSuccessfulExecution != null).     if (status.lastSuccessfulExecution != null) {         Execution.writeTo(status.lastSuccessfulExecution, out).     }     out.writeBoolean(status.lastThrottle != null).     if (status.lastThrottle != null) {         Throttle.writeTo(status.lastThrottle, out).     } }
false;public,static;1;7;;public static ActionStatus readFrom(StreamInput in) throws IOException {     AckStatus ackStatus = AckStatus.readFrom(in).     Execution lastExecution = in.readBoolean() ? Execution.readFrom(in) : null.     Execution lastSuccessfulExecution = in.readBoolean() ? Execution.readFrom(in) : null.     Throttle lastThrottle = in.readBoolean() ? Throttle.readFrom(in) : null.     return new ActionStatus(ackStatus, lastExecution, lastSuccessfulExecution, lastThrottle). }
false;public;2;15;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Field.ACK_STATUS.getPreferredName(), ackStatus, params).     if (lastExecution != null) {         builder.field(Field.LAST_EXECUTION.getPreferredName(), lastExecution, params).     }     if (lastSuccessfulExecution != null) {         builder.field(Field.LAST_SUCCESSFUL_EXECUTION.getPreferredName(), lastSuccessfulExecution, params).     }     if (lastThrottle != null) {         builder.field(Field.LAST_THROTTLE.getPreferredName(), lastThrottle, params).     }     return builder.endObject(). }
false;public,static;3;30;;public static ActionStatus parse(String watchId, String actionId, XContentParser parser) throws IOException {     AckStatus ackStatus = null.     Execution lastExecution = null.     Execution lastSuccessfulExecution = null.     Throttle lastThrottle = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.ACK_STATUS.match(currentFieldName, parser.getDeprecationHandler())) {             ackStatus = AckStatus.parse(watchId, actionId, parser).         } else if (Field.LAST_EXECUTION.match(currentFieldName, parser.getDeprecationHandler())) {             lastExecution = Execution.parse(watchId, actionId, parser).         } else if (Field.LAST_SUCCESSFUL_EXECUTION.match(currentFieldName, parser.getDeprecationHandler())) {             lastSuccessfulExecution = Execution.parse(watchId, actionId, parser).         } else if (Field.LAST_THROTTLE.match(currentFieldName, parser.getDeprecationHandler())) {             lastThrottle = Throttle.parse(watchId, actionId, parser).         } else {             throw new ElasticsearchParseException("could not parse action status for [{}/{}]. unexpected field [{}]", watchId, actionId, currentFieldName).         }     }     if (ackStatus == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}]", watchId, actionId, Field.ACK_STATUS.getPreferredName()).     }     return new ActionStatus(ackStatus, lastExecution, lastSuccessfulExecution, lastThrottle). }
false;static;1;9;;static State resolve(byte value) {     switch(value) {         case 1:             return AWAITS_SUCCESSFUL_EXECUTION.         case 2:             return ACKABLE.         case 3:             return ACKED.         default:             throw illegalArgument("unknown action ack status state value [{}]", value).     } }
false;public;0;3;;public ZonedDateTime timestamp() {     return timestamp. }
false;public;0;3;;public State state() {     return state. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     AckStatus ackStatus = (AckStatus) o.     return Objects.equals(timestamp, ackStatus.timestamp) && Objects.equals(state, ackStatus.state). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(timestamp, state). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().field(Field.TIMESTAMP.getPreferredName()).value(dateTimeFormatter.format(timestamp)).field(Field.ACK_STATUS_STATE.getPreferredName(), state.name().toLowerCase(Locale.ROOT)).endObject(). }
false;public,static;3;28;;public static AckStatus parse(String watchId, String actionId, XContentParser parser) throws IOException {     ZonedDateTime timestamp = null.     State state = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.TIMESTAMP.match(currentFieldName, parser.getDeprecationHandler())) {             timestamp = DateFormatters.from(dateTimeFormatter.parse(parser.text())).         } else if (Field.ACK_STATUS_STATE.match(currentFieldName, parser.getDeprecationHandler())) {             state = State.valueOf(parser.text().toUpperCase(Locale.ROOT)).         } else {             throw new ElasticsearchParseException("could not parse action status for [{}/{}]. unexpected field [{}.{}]", watchId, actionId, Field.ACK_STATUS.getPreferredName(), currentFieldName).         }     }     if (timestamp == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}.{}]", watchId, actionId, Field.ACK_STATUS.getPreferredName(), Field.TIMESTAMP.getPreferredName()).     }     if (state == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}.{}]", watchId, actionId, Field.ACK_STATUS.getPreferredName(), Field.ACK_STATUS_STATE.getPreferredName()).     }     return new AckStatus(timestamp, state). }
false;static;2;4;;static void writeTo(AckStatus status, StreamOutput out) throws IOException {     out.writeLong(status.timestamp.toInstant().toEpochMilli()).     out.writeByte(status.state.value). }
false;static;1;5;;static AckStatus readFrom(StreamInput in) throws IOException {     ZonedDateTime timestamp = Instant.ofEpochMilli(in.readLong()).atZone(ZoneOffset.UTC).     State state = State.resolve(in.readByte()).     return new AckStatus(timestamp, state). }
false;public,static;1;3;;public static Execution successful(ZonedDateTime timestamp) {     return new Execution(timestamp, true, null). }
false;public,static;2;3;;public static Execution failure(ZonedDateTime timestamp, String reason) {     return new Execution(timestamp, false, reason). }
false;public;0;3;;public ZonedDateTime timestamp() {     return timestamp. }
false;public;0;3;;public boolean successful() {     return successful. }
false;public;0;3;;public String reason() {     return reason. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Execution execution = (Execution) o.     return Objects.equals(successful, execution.successful) && Objects.equals(timestamp, execution.timestamp) && Objects.equals(reason, execution.reason). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(timestamp, successful, reason). }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Field.TIMESTAMP.getPreferredName()).value(dateTimeFormatter.format(timestamp)).     builder.field(Field.EXECUTION_SUCCESSFUL.getPreferredName(), successful).     if (reason != null) {         builder.field(Field.REASON.getPreferredName(), reason).     }     return builder.endObject(). }
false;public,static;3;38;;public static Execution parse(String watchId, String actionId, XContentParser parser) throws IOException {     ZonedDateTime timestamp = null.     Boolean successful = null.     String reason = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.TIMESTAMP.match(currentFieldName, parser.getDeprecationHandler())) {             timestamp = DateFormatters.from(dateTimeFormatter.parse(parser.text())).         } else if (Field.EXECUTION_SUCCESSFUL.match(currentFieldName, parser.getDeprecationHandler())) {             successful = parser.booleanValue().         } else if (Field.REASON.match(currentFieldName, parser.getDeprecationHandler())) {             reason = parser.text().         } else {             throw new ElasticsearchParseException("could not parse action status for [{}/{}]. unexpected field [{}.{}]", watchId, actionId, Field.LAST_EXECUTION.getPreferredName(), currentFieldName).         }     }     if (timestamp == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}.{}]", watchId, actionId, Field.LAST_EXECUTION.getPreferredName(), Field.TIMESTAMP.getPreferredName()).     }     if (successful == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}.{}]", watchId, actionId, Field.LAST_EXECUTION.getPreferredName(), Field.EXECUTION_SUCCESSFUL.getPreferredName()).     }     if (successful) {         return successful(timestamp).     }     if (reason == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field for unsuccessful" + " execution [{}.{}]", watchId, actionId, Field.LAST_EXECUTION.getPreferredName(), Field.REASON.getPreferredName()).     }     return failure(timestamp, reason). }
false;public,static;2;7;;public static void writeTo(Execution execution, StreamOutput out) throws IOException {     out.writeLong(execution.timestamp.toInstant().toEpochMilli()).     out.writeBoolean(execution.successful).     if (!execution.successful) {         out.writeString(execution.reason).     } }
false;public,static;1;8;;public static Execution readFrom(StreamInput in) throws IOException {     ZonedDateTime timestamp = Instant.ofEpochMilli(in.readLong()).atZone(ZoneOffset.UTC).     boolean successful = in.readBoolean().     if (successful) {         return successful(timestamp).     }     return failure(timestamp, in.readString()). }
false;public;0;3;;public ZonedDateTime timestamp() {     return timestamp. }
false;public;0;3;;public String reason() {     return reason. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Throttle throttle = (Throttle) o.     return Objects.equals(timestamp, throttle.timestamp) && Objects.equals(reason, throttle.reason). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(timestamp, reason). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().field(Field.TIMESTAMP.getPreferredName()).value(dateTimeFormatter.format(timestamp)).field(Field.REASON.getPreferredName(), reason).endObject(). }
false;public,static;3;28;;public static Throttle parse(String watchId, String actionId, XContentParser parser) throws IOException {     ZonedDateTime timestamp = null.     String reason = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.TIMESTAMP.match(currentFieldName, parser.getDeprecationHandler())) {             timestamp = DateFormatters.from(dateTimeFormatter.parse(parser.text())).         } else if (Field.REASON.match(currentFieldName, parser.getDeprecationHandler())) {             reason = parser.text().         } else {             throw new ElasticsearchParseException("could not parse action status for [{}/{}]. unexpected field [{}.{}]", watchId, actionId, Field.LAST_THROTTLE.getPreferredName(), currentFieldName).         }     }     if (timestamp == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}.{}]", watchId, actionId, Field.LAST_THROTTLE.getPreferredName(), Field.TIMESTAMP.getPreferredName()).     }     if (reason == null) {         throw new ElasticsearchParseException("could not parse action status for [{}/{}]. missing required field [{}.{}]", watchId, actionId, Field.LAST_THROTTLE.getPreferredName(), Field.REASON.getPreferredName()).     }     return new Throttle(timestamp, reason). }
false;static;2;4;;static void writeTo(Throttle throttle, StreamOutput out) throws IOException {     out.writeLong(throttle.timestamp.toInstant().toEpochMilli()).     out.writeString(throttle.reason). }
false;static;1;4;;static Throttle readFrom(StreamInput in) throws IOException {     ZonedDateTime timestamp = ZonedDateTime.ofInstant(Instant.ofEpochMilli(in.readLong()), ZoneOffset.UTC).     return new Throttle(timestamp, in.readString()). }
