commented;modifiers;parameterAmount;loc;comment;code
false;public;2;74;;@Override public void evaluateCondition(IndexMetaData indexMetaData, Listener listener) {     String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetaData.getSettings()).     if (Strings.isNullOrEmpty(rolloverAlias)) {         listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT, "setting [%s] for index [%s] is empty or not defined", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, indexMetaData.getIndex().getName()))).         return.     }     // The order of the following checks is important in ways which may not be obvious.     // First, figure out if 1) The configured alias points to this index, and if so,     // whether this index is the write alias for this index     boolean aliasPointsToThisIndex = indexMetaData.getAliases().containsKey(rolloverAlias).     Boolean isWriteIndex = null.     if (aliasPointsToThisIndex) {         // The writeIndex() call returns a tri-state boolean:         // true  -> this index is the write index for this alias         // false -> this index is not the write index for this alias         // null  -> this alias is a "classic-style" alias and does not have a write index configured, but only points to one index         // and is thus the write index by default         isWriteIndex = indexMetaData.getAliases().get(rolloverAlias).writeIndex().     }     boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetaData.getSettings()).     if (indexingComplete) {         logger.trace(indexMetaData.getIndex() + " has lifecycle complete set, skipping " + WaitForRolloverReadyStep.NAME).         // "classic-style" alias and has already rolled over, and we want to continue with the policy.         if (aliasPointsToThisIndex && Boolean.TRUE.equals(isWriteIndex)) {             listener.onFailure(new IllegalStateException(String.format(Locale.ROOT, "index [%s] has [%s] set to [true], but is still the write index for alias [%s]", indexMetaData.getIndex().getName(), LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE, rolloverAlias))).             return.         }         listener.onResponse(true, new WaitForRolloverReadyStep.EmptyInfo()).         return.     }     // If indexing_complete is *not* set, and the alias does not point to this index, we can't roll over this index, so error out.     if (aliasPointsToThisIndex == false) {         listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT, "%s [%s] does not point to index [%s]", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, rolloverAlias, indexMetaData.getIndex().getName()))).         return.     }     // Similarly, if isWriteIndex is false (see note above on false vs. null), we can't roll over this index, so error out.     if (Boolean.FALSE.equals(isWriteIndex)) {         listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT, "index [%s] is not the write index for alias [%s]", rolloverAlias, indexMetaData.getIndex().getName()))).     }     RolloverRequest rolloverRequest = new RolloverRequest(rolloverAlias, null).     rolloverRequest.dryRun(true).     if (maxAge != null) {         rolloverRequest.addMaxIndexAgeCondition(maxAge).     }     if (maxSize != null) {         rolloverRequest.addMaxIndexSizeCondition(maxSize).     }     if (maxDocs != null) {         rolloverRequest.addMaxIndexDocsCondition(maxDocs).     }     getClient().admin().indices().rolloverIndex(rolloverRequest, ActionListener.wrap(response -> listener.onResponse(response.getConditionStatus().values().stream().anyMatch(i -> i), new WaitForRolloverReadyStep.EmptyInfo()), listener::onFailure)). }
false;;0;3;;ByteSizeValue getMaxSize() {     return maxSize. }
false;;0;3;;TimeValue getMaxAge() {     return maxAge. }
false;;0;3;;Long getMaxDocs() {     return maxDocs. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), maxSize, maxAge, maxDocs). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     WaitForRolloverReadyStep other = (WaitForRolloverReadyStep) obj.     return super.equals(obj) && Objects.equals(maxSize, other.maxSize) && Objects.equals(maxAge, other.maxAge) && Objects.equals(maxDocs, other.maxDocs). }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
