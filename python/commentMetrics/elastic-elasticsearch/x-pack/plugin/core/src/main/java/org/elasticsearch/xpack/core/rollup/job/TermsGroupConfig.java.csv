commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return the names of the fields. Never {@code null}.  */ ;/**  * @return the names of the fields. Never {@code null}.  */ public String[] getFields() {     return fields. }
false;public;2;33;;public void validateMappings(Map<String, Map<String, FieldCapabilities>> fieldCapsResponse, ActionRequestValidationException validationException) {     Arrays.stream(fields).forEach(field -> {         Map<String, FieldCapabilities> fieldCaps = fieldCapsResponse.get(field).         if (fieldCaps != null && fieldCaps.isEmpty() == false) {             fieldCaps.forEach((key, value) -> {                 if (key.equals(KeywordFieldMapper.CONTENT_TYPE) || key.equals(TextFieldMapper.CONTENT_TYPE)) {                     if (value.isAggregatable() == false) {                         validationException.addValidationError("The field [" + field + "] must be aggregatable across all indices, " + "but is not.").                     }                 } else if (FLOAT_TYPES.contains(key)) {                     if (value.isAggregatable() == false) {                         validationException.addValidationError("The field [" + field + "] must be aggregatable across all indices, " + "but is not.").                     }                 } else if (NATURAL_TYPES.contains(key)) {                     if (value.isAggregatable() == false) {                         validationException.addValidationError("The field [" + field + "] must be aggregatable across all indices, " + "but is not.").                     }                 } else {                     validationException.addValidationError("The field referenced by a terms group must be a [numeric] or " + "[keyword/text] type, but found " + fieldCaps.keySet().toString() + " for field [" + field + "]").                 }             }).         } else {             validationException.addValidationError("Could not find a [numeric] or [keyword/text] field with name [" + field + "] in any of the indices matching the index pattern.").         }     }). }
false;public;2;8;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.field(FIELDS, fields).     }     return builder.endObject(). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeStringArray(fields). }
false;public;1;11;;@Override public boolean equals(final Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     final TermsGroupConfig that = (TermsGroupConfig) other.     return Arrays.equals(fields, that.fields). }
false;public;0;4;;@Override public int hashCode() {     return Arrays.hashCode(fields). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
false;public,static;1;3;;public static TermsGroupConfig fromXContent(final XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
