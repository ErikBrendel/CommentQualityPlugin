commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the current user information, or null if the current request has no authentication info.  */ ;/**  * Returns the current user information, or null if the current request has no authentication info.  */ public User getUser() {     Authentication authentication = getAuthentication().     return authentication == null ? null : authentication.getUser(). }
true;public;0;10;/**  * Returns the authentication information, or null if the current request has no authentication info.  */ ;/**  * Returns the authentication information, or null if the current request has no authentication info.  */ public Authentication getAuthentication() {     try {         return Authentication.readFromContext(threadContext).     } catch (IOException e) {         // TODO: this seems bogus, the only way to get an ioexception here is from a corrupt or tampered         // auth header, which should be be audited?         logger.error("failed to read authentication", e).         return null.     } }
true;public;2;12;/**  * Sets the user forcefully to the provided user. There must not be an existing user in the ThreadContext otherwise an exception  * will be thrown. This method is package private for testing.  */ ;/**  * Sets the user forcefully to the provided user. There must not be an existing user in the ThreadContext otherwise an exception  * will be thrown. This method is package private for testing.  */ public void setUser(User user, Version version) {     Objects.requireNonNull(user).     final Authentication.RealmRef authenticatedBy = new Authentication.RealmRef("__attach", "__attach", nodeName).     final Authentication.RealmRef lookedUpBy.     if (user.isRunAs()) {         lookedUpBy = authenticatedBy.     } else {         lookedUpBy = null.     }     setAuthentication(new Authentication(user, authenticatedBy, lookedUpBy, version, AuthenticationType.INTERNAL, Collections.emptyMap())). }
true;private;1;7;/**  * Writes the authentication to the thread context  */ ;/**  * Writes the authentication to the thread context  */ private void setAuthentication(Authentication authentication) {     try {         authentication.writeToContext(threadContext).     } catch (IOException e) {         throw new AssertionError("how can we have a IOException with a user we set", e).     } }
true;public;3;7;/**  * Runs the consumer in a new context as the provided user. The original context is provided to the consumer. When this method  * returns, the original context is restored.  */ ;/**  * Runs the consumer in a new context as the provided user. The original context is provided to the consumer. When this method  * returns, the original context is restored.  */ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version version) {     final StoredContext original = threadContext.newStoredContext(true).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         setUser(user, version).         consumer.accept(original).     } }
true;public;2;9;/**  * Runs the consumer in a new context after setting a new version of the authentication that is compatible with the version provided.  * The original context is provided to the consumer. When this method returns, the original context is restored.  */ ;/**  * Runs the consumer in a new context after setting a new version of the authentication that is compatible with the version provided.  * The original context is provided to the consumer. When this method returns, the original context is restored.  */ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer, Version version) {     final StoredContext original = threadContext.newStoredContext(true).     final Authentication authentication = Objects.requireNonNull(userSettings.getAuthentication()).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata())).         consumer.accept(original).     } }
