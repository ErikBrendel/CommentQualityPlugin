commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected DirectoryReader doOpenIfChanged() {     return null. }
false;protected;1;4;;@Override protected DirectoryReader doOpenIfChanged(IndexCommit commit) {     return null. }
false;protected;2;4;;@Override protected DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes) {     return null. }
false;public;0;4;;@Override public long getVersion() {     return 0. }
false;public;0;4;;@Override public boolean isCurrent() {     // always current     return true. }
false;public;0;4;;@Override public IndexCommit getIndexCommit() {     // TODO maybe we can return an empty commit?     return indexCommit. }
false;protected;0;3;;@Override protected void doClose() { }
false;public;0;4;;@Override public CacheHelper getReaderCacheHelper() {     return null. }
false;protected;1;46;;@Override protected DirectoryReader open(IndexCommit indexCommit) throws IOException {     // a no-op now     return new DirectoryReader(indexCommit.getDirectory(), new LeafReader[0]) {          @Override         protected DirectoryReader doOpenIfChanged() {             return null.         }          @Override         protected DirectoryReader doOpenIfChanged(IndexCommit commit) {             return null.         }          @Override         protected DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes) {             return null.         }          @Override         public long getVersion() {             return 0.         }          @Override         public boolean isCurrent() {             // always current             return true.         }          @Override         public IndexCommit getIndexCommit() {             // TODO maybe we can return an empty commit?             return indexCommit.         }          @Override         protected void doClose() {         }          @Override         public CacheHelper getReaderCacheHelper() {             return null.         }     }. }
false;private,synchronized;1;13;;@SuppressForbidden(reason = "we manage references explicitly here") private synchronized void onReaderClosed(IndexReader.CacheKey key) {     // lastOpenedReader member to ensure resources can be GCed     if (lastOpenedReader != null && key == lastOpenedReader.getReaderCacheHelper().getKey()) {         assert lastOpenedReader.getRefCount() == 0.         lastOpenedReader = null.     } }
false;private,synchronized;0;25;;private synchronized DirectoryReader getOrOpenReader() throws IOException {     DirectoryReader reader = null.     boolean success = false.     try {         reader = getReader().         if (reader == null) {             for (ReferenceManager.RefreshListener listeners : config().getInternalRefreshListener()) {                 listeners.beforeRefresh().             }             reader = DirectoryReader.open(engineConfig.getStore().directory()).             processReaders(reader, null).             reader = lastOpenedReader = wrapReader(reader, Function.identity()).             reader.getReaderCacheHelper().addClosedListener(this::onReaderClosed).             for (ReferenceManager.RefreshListener listeners : config().getInternalRefreshListener()) {                 listeners.afterRefresh(true).             }         }         success = true.         return reader.     } finally {         if (success == false) {             IOUtils.close(reader).         }     } }
false;private,synchronized;0;16;;@SuppressForbidden(reason = "we manage references explicitly here") private synchronized DirectoryReader getReader() throws IOException {     DirectoryReader reader = null.     boolean success = false.     try {         if (lastOpenedReader != null && lastOpenedReader.tryIncRef()) {             reader = lastOpenedReader.         }         success = true.         return reader.     } finally {         if (success == false) {             IOUtils.close(reader).         }     } }
false;public;2;58;;@Override @SuppressWarnings("fallthrough") @SuppressForbidden(reason = "we manage references explicitly here") public Searcher acquireSearcher(String source, SearcherScope scope) throws EngineException {     store.incRef().     boolean releaseRefeference = true.     try {         final boolean maybeOpenReader.         switch(source) {             case "load_seq_no":             case "load_version":                 assert false : "this is a read-only engine".             case "doc_stats":                 assert false : "doc_stats are overwritten".             case "refresh_needed":                 assert false : "refresh_needed is always false".             case "segments":             case "segments_stats":             case "completion_stats":             case // special case for can_match phase - we use the cached point values reader             "can_match":                 maybeOpenReader = false.                 break.             default:                 maybeOpenReader = true.         }         // special case we only want to report segment stats if we have a reader open. in that case we only get a reader if we still         // have one open at the time and can inc it's reference.         DirectoryReader reader = maybeOpenReader ? getOrOpenReader() : getReader().         if (reader == null) {             // the category that doesn't trigger a reopen             if ("can_match".equals(source)) {                 canMatchReader.incRef().                 return new Searcher(source, new IndexSearcher(canMatchReader), canMatchReader::decRef).             }             return super.acquireSearcher(source, scope).         } else {             try {                 LazyDirectoryReader lazyDirectoryReader = new LazyDirectoryReader(reader, this).                 Searcher newSearcher = new Searcher(source, new IndexSearcher(lazyDirectoryReader), () -> IOUtils.close(lazyDirectoryReader, store::decRef)).                 releaseRefeference = false.                 return newSearcher.             } finally {                 if (releaseRefeference) {                     // don't call close here we manage reference ourselves                     reader.decRef().                 }             }         }     } catch (IOException e) {         throw new UncheckedIOException(e).     } finally {         if (releaseRefeference) {             store.decRef().         }     } }
false;static;1;9;;static LazyDirectoryReader unwrapLazyReader(DirectoryReader reader) {     while (reader instanceof FilterDirectoryReader) {         if (reader instanceof LazyDirectoryReader) {             return (LazyDirectoryReader) reader.         }         reader = ((FilterDirectoryReader) reader).getDelegate().     }     return null. }
false;public;2;14;;@Override public void validateSearchContext(SearchContext context, TransportRequest transportRequest) {     Searcher engineSearcher = context.searcher().getEngineSearcher().     LazyDirectoryReader lazyDirectoryReader = unwrapLazyReader(engineSearcher.getDirectoryReader()).     if (lazyDirectoryReader != null) {         try {             lazyDirectoryReader.reset().         } catch (IOException e) {             throw new UncheckedIOException(e).         }         // also register a release resource in this case if we have multiple roundtrips like in DFS         registerRelease(context, lazyDirectoryReader).     } }
false;private;2;9;;private void registerRelease(SearchContext context, LazyDirectoryReader lazyDirectoryReader) {     context.addReleasable(() -> {         try {             lazyDirectoryReader.release().         } catch (IOException e) {             throw new UncheckedIOException(e).         }     }, SearchContext.Lifetime.PHASE). }
false;public;1;8;;@Override public void onNewContext(SearchContext context) {     Searcher engineSearcher = context.searcher().getEngineSearcher().     LazyDirectoryReader lazyDirectoryReader = unwrapLazyReader(engineSearcher.getDirectoryReader()).     if (lazyDirectoryReader != null) {         registerRelease(context, lazyDirectoryReader).     } }
false;public;1;4;;@Override public LeafReader wrap(LeafReader reader) {     return new LazyLeafReader(reader). }
false;synchronized;0;21;;@SuppressForbidden(reason = "we manage references explicitly here") synchronized void release() throws IOException {     if (delegate != null) {         // we are lenient here it's ok to double close         delegate.decRef().         delegate = null.         if (tryIncRef()) {             // readers to be GCed we need to null our the references.             try {                 for (LeafReaderContext leaf : leaves()) {                     LazyLeafReader reader = (LazyLeafReader) leaf.reader().                     reader.in = null.                 }             } finally {                 decRef().             }         }     } }
false;;0;12;;void reset() throws IOException {     boolean success = false.     DirectoryReader reader = engine.getOrOpenReader().     try {         reset(reader).         success = true.     } finally {         if (success == false) {             IOUtils.close(reader).         }     } }
false;private,synchronized;1;16;;private synchronized void reset(DirectoryReader delegate) {     if (this.delegate != null) {         throw new AssertionError("lazy reader is not released").     }     assert (delegate instanceof LazyDirectoryReader) == false : "must not be a LazyDirectoryReader".     List<LeafReaderContext> leaves = delegate.leaves().     int ord = 0.     for (LeafReaderContext leaf : leaves()) {         LazyLeafReader reader = (LazyLeafReader) leaf.reader().         LeafReader newReader = leaves.get(ord++).reader().         assert reader.in == null.         reader.in = newReader.         assert reader.info.info.equals(Lucene.segmentReader(newReader).getSegmentInfo().info).     }     this.delegate = delegate. }
false;protected;1;4;;@Override protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {     throw new UnsupportedOperationException(). }
false;;0;7;;void ensureOpenOrReset() {     // ensure we fail early and with good exceptions     ensureOpen().     if (delegate == null) {         throw new AlreadyClosedException("delegate is released").     } }
false;public;0;5;;@Override public long getVersion() {     ensureOpenOrReset().     return delegate.getVersion(). }
false;public;0;5;;@Override public boolean isCurrent() throws IOException {     ensureOpenOrReset().     return delegate.isCurrent(). }
false;public;0;5;;@Override public IndexCommit getIndexCommit() throws IOException {     ensureOpenOrReset().     return delegate.getIndexCommit(). }
false;protected;0;4;;@Override protected void doClose() throws IOException {     release(). }
false;public;0;5;;@Override public CacheHelper getReaderCacheHelper() {     ensureOpenOrReset().     return delegate.getReaderCacheHelper(). }
false;public;0;5;;@Override public DirectoryReader getDelegate() {     ensureOpenOrReset().     return delegate. }
false;private;0;6;;private void ensureOpenOrReleased() {     ensureOpen().     if (in == null) {         throw new AlreadyClosedException("leaf is already released").     } }
false;public;0;5;;@Override public Bits getLiveDocs() {     ensureOpenOrReleased().     return in.getLiveDocs(). }
false;public;0;5;;@Override public FieldInfos getFieldInfos() {     ensureOpenOrReleased().     return in.getFieldInfos(). }
false;public;1;5;;@Override public PointValues getPointValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getPointValues(field). }
false;public;1;6;;@Override public Fields getTermVectors(int docID) throws IOException {     ensureOpenOrReleased().     return in.getTermVectors(docID). }
false;public;0;4;;@Override public int numDocs() {     return numDocs. }
false;public;0;4;;@Override public int maxDoc() {     return maxDocs. }
false;public;2;5;;@Override public void document(int docID, StoredFieldVisitor visitor) throws IOException {     ensureOpenOrReleased().     in.document(docID, visitor). }
false;protected;0;4;;@Override protected void doClose() throws IOException {     in.close(). }
false;public;0;5;;@Override public CacheHelper getReaderCacheHelper() {     ensureOpenOrReleased().     return in.getReaderCacheHelper(). }
false;public;0;5;;@Override public CacheHelper getCoreCacheHelper() {     ensureOpenOrReleased().     return in.getCoreCacheHelper(). }
false;public;1;5;;@Override public Terms terms(String field) throws IOException {     ensureOpenOrReleased().     return in.terms(field). }
false;public;0;7;;@Override public String toString() {     final StringBuilder buffer = new StringBuilder("LazyLeafReader(").     buffer.append(in).     buffer.append(')').     return buffer.toString(). }
false;public;1;5;;@Override public NumericDocValues getNumericDocValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getNumericDocValues(field). }
false;public;1;5;;@Override public BinaryDocValues getBinaryDocValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getBinaryDocValues(field). }
false;public;1;5;;@Override public SortedDocValues getSortedDocValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getSortedDocValues(field). }
false;public;1;5;;@Override public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getSortedNumericDocValues(field). }
false;public;1;5;;@Override public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getSortedSetDocValues(field). }
false;public;1;5;;@Override public NumericDocValues getNormValues(String field) throws IOException {     ensureOpenOrReleased().     return in.getNormValues(field). }
false;public;0;5;;@Override public LeafMetaData getMetaData() {     ensureOpenOrReleased().     return in.getMetaData(). }
false;public;0;5;;@Override public void checkIntegrity() throws IOException {     ensureOpenOrReleased().     in.checkIntegrity(). }
false;public;0;4;;@Override public LeafReader getDelegate() {     return in. }
false;synchronized;0;3;;synchronized boolean isReaderOpen() {     return lastOpenedReader != null. }
