commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Case-insensitive from string method.  * Works with either JSON, json, etc.  *  * @param value String representation  * @return The data format  */ ;/**  * Case-insensitive from string method.  * Works with either JSON, json, etc.  *  * @param value String representation  * @return The data format  */ public static ExcludeFrequent forString(String value) {     return valueOf(value.toUpperCase(Locale.ROOT)). }
false;public,static;1;3;;public static ExcludeFrequent readFromStream(StreamInput in) throws IOException {     return in.readEnum(ExcludeFrequent.class). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
false;private,static;1;23;;private static ObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {     ObjectParser<Builder, Void> parser = new ObjectParser<>("detector", ignoreUnknownFields, Builder::new).     parser.declareString(Builder::setDetectorDescription, DETECTOR_DESCRIPTION_FIELD).     parser.declareString(Builder::setFunction, FUNCTION_FIELD).     parser.declareString(Builder::setFieldName, FIELD_NAME_FIELD).     parser.declareString(Builder::setByFieldName, BY_FIELD_NAME_FIELD).     parser.declareString(Builder::setOverFieldName, OVER_FIELD_NAME_FIELD).     parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME_FIELD).     parser.declareBoolean(Builder::setUseNull, USE_NULL_FIELD).     parser.declareField(Builder::setExcludeFrequent, p -> {         if (p.currentToken() == XContentParser.Token.VALUE_STRING) {             return ExcludeFrequent.forString(p.text()).         }         throw new IllegalArgumentException("Unsupported token [" + p.currentToken() + "]").     }, EXCLUDE_FREQUENT_FIELD, ObjectParser.ValueType.STRING).     parser.declareObjectArray(Builder::setRules, (p, c) -> (ignoreUnknownFields ? DetectionRule.LENIENT_PARSER : DetectionRule.STRICT_PARSER).apply(p, c).build(), CUSTOM_RULES_FIELD).     parser.declareInt(Builder::setDetectorIndex, DETECTOR_INDEX).     return parser. }
false;public;1;22;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(detectorDescription).     out.writeString(function.getFullName()).     out.writeOptionalString(fieldName).     out.writeOptionalString(byFieldName).     out.writeOptionalString(overFieldName).     out.writeOptionalString(partitionFieldName).     out.writeBoolean(useNull).     if (excludeFrequent != null) {         out.writeBoolean(true).         excludeFrequent.writeTo(out).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(DetectionRule.VERSION_INTRODUCED)) {         out.writeList(rules).     } else {         out.writeList(Collections.emptyList()).     }     out.writeInt(detectorIndex). }
false;public;2;35;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(DETECTOR_DESCRIPTION_FIELD.getPreferredName(), detectorDescription).     builder.field(FUNCTION_FIELD.getPreferredName(), function).     if (fieldName != null) {         builder.field(FIELD_NAME_FIELD.getPreferredName(), fieldName).     }     if (byFieldName != null) {         builder.field(BY_FIELD_NAME_FIELD.getPreferredName(), byFieldName).     }     if (overFieldName != null) {         builder.field(OVER_FIELD_NAME_FIELD.getPreferredName(), overFieldName).     }     if (partitionFieldName != null) {         builder.field(PARTITION_FIELD_NAME_FIELD.getPreferredName(), partitionFieldName).     }     if (useNull) {         builder.field(USE_NULL_FIELD.getPreferredName(), useNull).     }     if (excludeFrequent != null) {         builder.field(EXCLUDE_FREQUENT_FIELD.getPreferredName(), excludeFrequent).     }     if (rules.isEmpty() == false) {         builder.field(CUSTOM_RULES_FIELD.getPreferredName(), rules).     }     // negative means "unknown", which should only happen for a 5.4 job     if (detectorIndex >= 0 && // no point writing this to cluster state, as the indexes will get reassigned on reload anyway     params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false) == false) {         builder.field(DETECTOR_INDEX.getPreferredName(), detectorIndex).     }     builder.endObject().     return builder. }
false;public;0;3;;public String getDetectorDescription() {     return detectorDescription. }
true;public;0;3;/**  * The analysis function used e.g. count, rare, min etc.  *  * @return The function or <code>null</code> if not set  */ ;/**  * The analysis function used e.g. count, rare, min etc.  *  * @return The function or <code>null</code> if not set  */ public DetectorFunction getFunction() {     return function. }
true;public;0;3;/**  * The Analysis field  *  * @return The field to analyse  */ ;/**  * The Analysis field  *  * @return The field to analyse  */ public String getFieldName() {     return fieldName. }
true;public;0;3;/**  * The 'by' field or <code>null</code> if not set.  *  * @return The 'by' field  */ ;/**  * The 'by' field or <code>null</code> if not set.  *  * @return The 'by' field  */ public String getByFieldName() {     return byFieldName. }
true;public;0;3;/**  * The 'over' field or <code>null</code> if not set.  *  * @return The 'over' field  */ ;/**  * The 'over' field or <code>null</code> if not set.  *  * @return The 'over' field  */ public String getOverFieldName() {     return overFieldName. }
true;public;0;3;/**  * Segments the analysis along another field to have completely  * independent baselines for each instance of partitionfield  *  * @return The Partition Field  */ ;/**  * Segments the analysis along another field to have completely  * independent baselines for each instance of partitionfield  *  * @return The Partition Field  */ public String getPartitionFieldName() {     return partitionFieldName. }
true;public;0;3;/**  * Where there isn't a value for the 'by' or 'over' field should a new  * series be used as the 'null' series.  *  * @return true if the 'null' series should be created  */ ;/**  * Where there isn't a value for the 'by' or 'over' field should a new  * series be used as the 'null' series.  *  * @return true if the 'null' series should be created  */ public boolean isUseNull() {     return useNull. }
true;public;0;3;/**  * Excludes frequently-occurring metrics from the analysis.  * can apply to 'by' field, 'over' field, or both  *  * @return the value that the user set  */ ;/**  * Excludes frequently-occurring metrics from the analysis.  * can apply to 'by' field, 'over' field, or both  *  * @return the value that the user set  */ public ExcludeFrequent getExcludeFrequent() {     return excludeFrequent. }
false;public;0;3;;public List<DetectionRule> getRules() {     return rules. }
true;public;0;3;/**  * @return the detector index or a negative number if unknown  */ ;/**  * @return the detector index or a negative number if unknown  */ public int getDetectorIndex() {     return detectorIndex. }
true;public;0;5;/**  * Returns a list with the byFieldName, overFieldName and partitionFieldName that are not null  *  * @return a list with the byFieldName, overFieldName and partitionFieldName that are not null  */ ;/**  * Returns a list with the byFieldName, overFieldName and partitionFieldName that are not null  *  * @return a list with the byFieldName, overFieldName and partitionFieldName that are not null  */ public List<String> extractAnalysisFields() {     List<String> analysisFields = Arrays.asList(getByFieldName(), getOverFieldName(), getPartitionFieldName()).     return analysisFields.stream().filter(item -> item != null).collect(Collectors.toList()). }
false;public;0;5;;public Set<String> extractReferencedFilters() {     return rules == null ? Collections.emptySet() : rules.stream().map(DetectionRule::extractReferencedFilters).flatMap(Set::stream).collect(Collectors.toSet()). }
true;public;0;13;/**  * Returns the set of by/over/partition terms  */ ;/**  * Returns the set of by/over/partition terms  */ public Set<String> getByOverPartitionTerms() {     Set<String> terms = new HashSet<>().     if (byFieldName != null) {         terms.add(byFieldName).     }     if (overFieldName != null) {         terms.add(overFieldName).     }     if (partitionFieldName != null) {         terms.add(partitionFieldName).     }     return terms. }
false;public;1;23;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other instanceof Detector == false) {         return false.     }     Detector that = (Detector) other.     return Objects.equals(this.detectorDescription, that.detectorDescription) && Objects.equals(this.function, that.function) && Objects.equals(this.fieldName, that.fieldName) && Objects.equals(this.byFieldName, that.byFieldName) && Objects.equals(this.overFieldName, that.overFieldName) && Objects.equals(this.partitionFieldName, that.partitionFieldName) && Objects.equals(this.useNull, that.useNull) && Objects.equals(this.excludeFrequent, that.excludeFrequent) && Objects.equals(this.rules, that.rules) && this.detectorIndex == that.detectorIndex. }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(detectorDescription, function, fieldName, byFieldName, overFieldName, partitionFieldName, useNull, excludeFrequent, rules, detectorIndex). }
false;public;1;3;;public void setDetectorDescription(String detectorDescription) {     this.detectorDescription = detectorDescription. }
false;public;1;3;;public void setFunction(String function) {     this.function = DetectorFunction.fromString(function). }
false;public;1;3;;public void setFieldName(String fieldName) {     this.fieldName = fieldName. }
false;public;1;3;;public void setByFieldName(String byFieldName) {     this.byFieldName = byFieldName. }
false;public;1;3;;public void setOverFieldName(String overFieldName) {     this.overFieldName = overFieldName. }
false;public;1;3;;public void setPartitionFieldName(String partitionFieldName) {     this.partitionFieldName = partitionFieldName. }
false;public;1;3;;public void setUseNull(boolean useNull) {     this.useNull = useNull. }
false;public;1;3;;public void setExcludeFrequent(ExcludeFrequent excludeFrequent) {     this.excludeFrequent = excludeFrequent. }
false;public;1;3;;public void setRules(List<DetectionRule> rules) {     this.rules = rules. }
false;public;1;3;;public void setDetectorIndex(int detectorIndex) {     this.detectorIndex = detectorIndex. }
false;public;0;99;;public Detector build() {     boolean emptyField = Strings.isEmpty(fieldName).     boolean emptyByField = Strings.isEmpty(byFieldName).     boolean emptyOverField = Strings.isEmpty(overFieldName).     boolean emptyPartitionField = Strings.isEmpty(partitionFieldName).     if (emptyField && emptyByField && emptyOverField) {         if (!Detector.COUNT_WITHOUT_FIELD_FUNCTIONS.contains(function)) {             throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_ANALYSIS_FIELD_MUST_BE_SET)).         }     }     if (emptyField && Detector.FIELD_NAME_FUNCTIONS.contains(function)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_FUNCTION_REQUIRES_FIELDNAME, function)).     }     if (!emptyField && (Detector.FIELD_NAME_FUNCTIONS.contains(function) == false)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_FIELDNAME_INCOMPATIBLE_FUNCTION, function)).     }     if (emptyByField && Detector.BY_FIELD_NAME_FUNCTIONS.contains(function)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_FUNCTION_REQUIRES_BYFIELD, function)).     }     if (emptyOverField && Detector.OVER_FIELD_NAME_FUNCTIONS.contains(function)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_FUNCTION_REQUIRES_OVERFIELD, function)).     }     if (!emptyOverField && Detector.NO_OVER_FIELD_NAME_FUNCTIONS.contains(function)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_OVERFIELD_INCOMPATIBLE_FUNCTION, function)).     }     // field names cannot contain certain characters     String[] fields = { fieldName, byFieldName, overFieldName, partitionFieldName }.     for (String field : fields) {         verifyFieldName(field).     }     DetectorFunction function = this.function == null ? DetectorFunction.METRIC : this.function.     for (DetectionRule rule : rules) {         validateRule(rule, function).     }     // partition, by and over field names cannot be duplicates     if (!emptyPartitionField) {         if (partitionFieldName.equals(byFieldName)) {             throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_DUPLICATE_FIELD_NAME, PARTITION_FIELD_NAME_FIELD.getPreferredName(), BY_FIELD_NAME_FIELD.getPreferredName(), partitionFieldName)).         }         if (partitionFieldName.equals(overFieldName)) {             throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_DUPLICATE_FIELD_NAME, PARTITION_FIELD_NAME_FIELD.getPreferredName(), OVER_FIELD_NAME_FIELD.getPreferredName(), partitionFieldName)).         }     }     if (!emptyByField && byFieldName.equals(overFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_DUPLICATE_FIELD_NAME, BY_FIELD_NAME_FIELD.getPreferredName(), OVER_FIELD_NAME_FIELD.getPreferredName(), byFieldName)).     }     // FIRST - see https://github.com/elastic/x-pack-elasticsearch/issues/858     if (DetectorFunction.COUNT.getFullName().equals(byFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_COUNT_DISALLOWED, BY_FIELD_NAME_FIELD.getPreferredName())).     }     if (DetectorFunction.COUNT.getFullName().equals(overFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_COUNT_DISALLOWED, OVER_FIELD_NAME_FIELD.getPreferredName())).     }     if (BY.equals(byFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_BY_DISALLOWED, BY_FIELD_NAME_FIELD.getPreferredName())).     }     if (BY.equals(overFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_BY_DISALLOWED, OVER_FIELD_NAME_FIELD.getPreferredName())).     }     if (OVER.equals(byFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_OVER_DISALLOWED, BY_FIELD_NAME_FIELD.getPreferredName())).     }     if (OVER.equals(overFieldName)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_DETECTOR_OVER_DISALLOWED, OVER_FIELD_NAME_FIELD.getPreferredName())).     }     return new Detector(detectorDescription, function, fieldName, byFieldName, overFieldName, partitionFieldName, useNull, excludeFrequent, rules, detectorIndex). }
false;public;0;4;;public List<String> extractAnalysisFields() {     List<String> analysisFields = Arrays.asList(byFieldName, overFieldName, partitionFieldName).     return analysisFields.stream().filter(item -> item != null).collect(Collectors.toList()). }
true;public,static;1;10;/**  * Check that the characters used in a field name will not cause problems.  *  * @param field The field name to be validated  */ ;/**  * Check that the characters used in a field name will not cause problems.  *  * @param field The field name to be validated  */ public static void verifyFieldName(String field) throws ElasticsearchParseException {     if (field != null && containsInvalidChar(field)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_INVALID_FIELDNAME_CHARS, field, Detector.PROHIBITED)).     }     if (RecordWriter.CONTROL_FIELD_NAME.equals(field)) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_INVALID_FIELDNAME, field, RecordWriter.CONTROL_FIELD_NAME)).     } }
false;private,static;1;8;;private static boolean containsInvalidChar(String field) {     for (Character ch : Detector.PROHIBITED_FIELDNAME_CHARACTERS) {         if (field.indexOf(ch) >= 0) {             return true.         }     }     return field.chars().anyMatch(Character::isISOControl). }
false;private;2;4;;private void validateRule(DetectionRule rule, DetectorFunction function) {     checkFunctionHasRuleSupport(rule, function).     checkScoping(rule). }
false;private;2;6;;private void checkFunctionHasRuleSupport(DetectionRule rule, DetectorFunction function) {     if (ruleHasConditionOnResultValue(rule) && FUNCTIONS_WITHOUT_RULE_CONDITION_SUPPORT.contains(function)) {         String msg = Messages.getMessage(Messages.JOB_CONFIG_DETECTION_RULE_NOT_SUPPORTED_BY_FUNCTION, function).         throw ExceptionsHelper.badRequestException(msg).     } }
false;private,static;1;15;;private static boolean ruleHasConditionOnResultValue(DetectionRule rule) {     for (RuleCondition condition : rule.getConditions()) {         switch(condition.getAppliesTo()) {             case ACTUAL:             case TYPICAL:             case DIFF_FROM_TYPICAL:                 return true.             case TIME:                 return false.             default:                 throw new IllegalStateException("Unknown applies_to value [" + condition.getAppliesTo() + "]").         }     }     return false. }
false;private;1;4;;private void checkScoping(DetectionRule rule) {     Set<String> analysisFields = new TreeSet<>(extractAnalysisFields()).     rule.getScope().validate(analysisFields). }
