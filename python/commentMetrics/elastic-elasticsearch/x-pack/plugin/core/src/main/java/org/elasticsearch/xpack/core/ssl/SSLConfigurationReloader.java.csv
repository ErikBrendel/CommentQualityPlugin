commented;modifiers;parameterAmount;loc;comment;code
true;private;1;24;/**  * Collects all of the directories that need to be monitored for the provided {@link SSLConfiguration} instances and ensures that  * they are being watched for changes  */ ;/**  * Collects all of the directories that need to be monitored for the provided {@link SSLConfiguration} instances and ensures that  * they are being watched for changes  */ private void startWatching(Collection<SSLConfiguration> sslConfigurations) {     for (SSLConfiguration sslConfiguration : sslConfigurations) {         for (Path directory : directoriesToMonitor(sslConfiguration.filesToMonitor(environment))) {             pathToChangeListenerMap.compute(directory, (path, listener) -> {                 if (listener != null) {                     listener.addSSLConfiguration(sslConfiguration).                     return listener.                 }                 ChangeListener changeListener = new ChangeListener().                 changeListener.addSSLConfiguration(sslConfiguration).                 FileWatcher fileWatcher = new FileWatcher(path).                 fileWatcher.addListener(changeListener).                 try {                     resourceWatcherService.add(fileWatcher, Frequency.HIGH).                     return changeListener.                 } catch (IOException e) {                     logger.error("failed to start watching directory [{}] for ssl configuration [{}]", path, sslConfiguration).                 }                 return null.             }).         }     } }
true;;1;4;/**  * Reloads the ssl context associated with this configuration. It is visible so that tests can override as needed  */ ;/**  * Reloads the ssl context associated with this configuration. It is visible so that tests can override as needed  */ void reloadSSLContext(SSLConfiguration configuration) {     logger.debug("reloading ssl configuration [{}]", configuration).     sslService.sslContextHolder(configuration).reload(). }
true;private,static;1;7;/**  * Returns a unique set of directories that need to be monitored based on the provided file paths  */ ;/**  * Returns a unique set of directories that need to be monitored based on the provided file paths  */ private static Set<Path> directoriesToMonitor(List<Path> filePaths) {     Set<Path> paths = new HashSet<>().     for (Path path : filePaths) {         paths.add(path.getParent()).     }     return paths. }
true;private;1;3;/**  * Adds the given ssl configuration to those that have files within the directory watched by this change listener  */ ;/**  * Adds the given ssl configuration to those that have files within the directory watched by this change listener  */ private void addSSLConfiguration(SSLConfiguration sslConfiguration) {     sslConfigurations.add(sslConfiguration). }
false;public;1;4;;@Override public void onFileCreated(Path file) {     onFileChanged(file). }
false;public;1;4;;@Override public void onFileDeleted(Path file) {     onFileChanged(file). }
false;public;1;14;;@Override public void onFileChanged(Path file) {     boolean reloaded = false.     for (SSLConfiguration sslConfiguration : sslConfigurations) {         if (sslConfiguration.filesToMonitor(environment).contains(file)) {             reloadSSLContext(sslConfiguration).             reloaded = true.         }     }     if (reloaded) {         logger.info("reloaded [{}] and updated ssl contexts using this file", file).     } }
