commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;35;;@Override protected DirectoryReader wrap(final DirectoryReader reader) {     if (licenseState.isDocumentAndFieldLevelSecurityAllowed() == false) {         return reader.     }     try {         final IndicesAccessControl indicesAccessControl = getIndicesAccessControl().         ShardId shardId = ShardUtils.extractShardId(reader).         if (shardId == null) {             throw new IllegalStateException(LoggerMessageFormat.format("couldn't extract shardId from reader [{}]", reader)).         }         final IndicesAccessControl.IndexAccessControl permissions = indicesAccessControl.getIndexPermissions(shardId.getIndexName()).         // No permissions have been defined for an index, so don't intercept the index reader for access control         if (permissions == null) {             return reader.         }         DirectoryReader wrappedReader = reader.         DocumentPermissions documentPermissions = permissions.getDocumentPermissions().         if (documentPermissions != null && documentPermissions.hasDocumentLevelPermissions()) {             BooleanQuery filterQuery = documentPermissions.filter(getUser(), scriptService, shardId, queryShardContextProvider).             if (filterQuery != null) {                 wrappedReader = DocumentSubsetReader.wrap(wrappedReader, bitsetFilterCache, new ConstantScoreQuery(filterQuery)).             }         }         return permissions.getFieldPermissions().filter(wrappedReader).     } catch (IOException e) {         logger.error("Unable to apply field level security").         throw ExceptionsHelper.convertToElastic(e).     } }
false;protected;1;19;;@Override protected IndexSearcher wrap(IndexSearcher searcher) throws EngineException {     if (licenseState.isDocumentAndFieldLevelSecurityAllowed() == false) {         return searcher.     }     final DirectoryReader directoryReader = (DirectoryReader) searcher.getIndexReader().     if (directoryReader instanceof DocumentSubsetDirectoryReader) {         // The reasons why we return a custom searcher:         // 1) in the case the role query is sparse then large part of the main query can be skipped         // 2) If the role query doesn't match with any docs in a segment, that a segment can be skipped         IndexSearcher indexSearcher = new IndexSearcherWrapper((DocumentSubsetDirectoryReader) directoryReader).         indexSearcher.setQueryCache(indexSearcher.getQueryCache()).         indexSearcher.setQueryCachingPolicy(indexSearcher.getQueryCachingPolicy()).         indexSearcher.setSimilarity(indexSearcher.getSimilarity()).         return indexSearcher.     }     return searcher. }
false;protected;3;47;;@Override protected void search(List<LeafReaderContext> leaves, Weight weight, Collector collector) throws IOException {     for (LeafReaderContext ctx : leaves) {         // search each subreader         final LeafCollector leafCollector.         try {             leafCollector = collector.getLeafCollector(ctx).         } catch (CollectionTerminatedException e) {             // continue with the following leaf             continue.         }         // The reader is always of type DocumentSubsetReader when we get here:         DocumentSubsetReader reader = (DocumentSubsetReader) ctx.reader().         BitSet roleQueryBits = reader.getRoleQueryBits().         if (roleQueryBits == null) {             // nothing matches with the role query, so skip this segment:             continue.         }         // if the role query result set is sparse then we should use the SparseFixedBitSet for advancing:         if (roleQueryBits instanceof SparseFixedBitSet) {             Scorer scorer = weight.scorer(ctx).             if (scorer != null) {                 SparseFixedBitSet sparseFixedBitSet = (SparseFixedBitSet) roleQueryBits.                 Bits realLiveDocs = reader.getWrappedLiveDocs().                 try {                     intersectScorerAndRoleBits(scorer, sparseFixedBitSet, leafCollector, realLiveDocs).                 } catch (CollectionTerminatedException e) {                 // collection was terminated prematurely                 // continue with the following leaf                 }             }         } else {             BulkScorer bulkScorer = weight.bulkScorer(ctx).             if (bulkScorer != null) {                 Bits liveDocs = reader.getLiveDocs().                 try {                     bulkScorer.score(leafCollector, liveDocs).                 } catch (CollectionTerminatedException e) {                 // collection was terminated prematurely                 // continue with the following leaf                 }             }         }     } }
false;static;4;12;;static void intersectScorerAndRoleBits(Scorer scorer, SparseFixedBitSet roleBits, LeafCollector collector, Bits acceptDocs) throws IOException {     // ConjunctionDISI uses the DocIdSetIterator#cost() to order the iterators, so if roleBits has the lowest cardinality it should     // be used first:     DocIdSetIterator iterator = ConjunctionDISI.intersectIterators(Arrays.asList(new BitSetIterator(roleBits, roleBits.approximateCardinality()), scorer.iterator())).     for (int docId = iterator.nextDoc(). docId < DocIdSetIterator.NO_MORE_DOCS. docId = iterator.nextDoc()) {         if (acceptDocs == null || acceptDocs.get(docId)) {             collector.collect(docId).         }     } }
false;protected;0;7;;protected IndicesAccessControl getIndicesAccessControl() {     IndicesAccessControl indicesAccessControl = threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY).     if (indicesAccessControl == null) {         throw Exceptions.authorizationError("no indices permissions found").     }     return indicesAccessControl. }
false;protected;0;4;;protected User getUser() {     Authentication authentication = Authentication.getAuthentication(threadContext).     return authentication.getUser(). }
