# id;timestamp;commentText;codeText;commentWords;codeWords
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1524684173;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1525334055;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1527096592;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1528211342;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1531179852;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1532069817;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1532456624;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (newLicense.isProductionLicense()_                    && XPackSettings.SECURITY_ENABLED.get(settings)_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                _                throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                _                _            } else {_                clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                        AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                            @Override_                            protected PutLicenseResponse newResponse(boolean acknowledged) {_                                return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                            }__                            @Override_                            public ClusterState execute(ClusterState currentState) throws Exception {_                                XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                                MetaData currentMetadata = currentState.metaData()__                                LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                                Version trialVersion = null__                                if (licensesMetaData != null) {_                                    trialVersion = licensesMetaData.getMostRecentTrialVersion()__                                }_                                MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                                mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                                return ClusterState.builder(currentState).metaData(mdBuilder).build()__                            }_                        })__            }_        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,new,license,is,production,license,xpack,settings,get,settings,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1533063033;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1534248446;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1534848846;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1541008027;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1542646292;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1544232221;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1544458001;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1544600864;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1544732811;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener);1547625930;Registers new license in the cluster_Master only operation. Installs a new license on the master provided it is VALID;public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {_        final License newLicense = request.license()__        final long now = clock.millis()__        if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID))__        } else if (newLicense.type().equals("basic")) {_            listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed."))__        } else if (newLicense.expiryDate() < now) {_            listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED))__        } else {_            if (!request.acknowledged()) {_                _                final License currentLicense = getLicense()__                if (currentLicense != null) {_                    Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense)__                    if (acknowledgeMessages.isEmpty() == false) {_                        _                        listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER,_                                acknowledgeMessages))__                        return__                    }_                }_            }__            if (XPackSettings.SECURITY_ENABLED.get(settings)) {_                _                _                if (newLicense.isProductionLicense()_                    && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false_                    && isProductionMode(settings, clusterService.localNode())) {_                    _                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless TLS is configured or security is disabled")__                } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings)_                    && newLicense.operationMode() != License.OperationMode.PLATINUM_                    && newLicense.operationMode() != License.OperationMode.TRIAL) {_                    throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() +_                        "] license unless FIPS mode is disabled")__                }_            }__            clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new_                    AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {_                        @Override_                        protected PutLicenseResponse newResponse(boolean acknowledged) {_                            return new PutLicenseResponse(acknowledged, LicensesStatus.VALID)__                        }__                        @Override_                        public ClusterState execute(ClusterState currentState) throws Exception {_                            XPackPlugin.checkReadyForXPackCustomMetadata(currentState)__                            MetaData currentMetadata = currentState.metaData()__                            LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE)__                            Version trialVersion = null__                            if (licensesMetaData != null) {_                                trialVersion = licensesMetaData.getMostRecentTrialVersion()__                            }_                            MetaData.Builder mdBuilder = MetaData.builder(currentMetadata)__                            mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion))__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        }_                    })__        }_    };registers,new,license,in,the,cluster,master,only,operation,installs,a,new,license,on,the,master,provided,it,is,valid;public,void,register,license,final,put,license,request,request,final,action,listener,put,license,response,listener,final,license,new,license,request,license,final,long,now,clock,millis,if,license,verifier,verify,license,new,license,new,license,issue,date,now,new,license,start,date,now,listener,on,response,new,put,license,response,true,licenses,status,invalid,else,if,new,license,type,equals,basic,listener,on,failure,new,illegal,argument,exception,registering,basic,licenses,is,not,allowed,else,if,new,license,expiry,date,now,listener,on,response,new,put,license,response,true,licenses,status,expired,else,if,request,acknowledged,final,license,current,license,get,license,if,current,license,null,map,string,string,acknowledge,messages,get,ack,messages,new,license,current,license,if,acknowledge,messages,is,empty,false,listener,on,response,new,put,license,response,false,licenses,status,valid,acknowledge,messages,return,if,xpack,settings,get,settings,if,new,license,is,production,license,xpack,settings,get,settings,false,is,production,mode,settings,cluster,service,local,node,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,tls,is,configured,or,security,is,disabled,else,if,xpack,settings,get,settings,new,license,operation,mode,license,operation,mode,platinum,new,license,operation,mode,license,operation,mode,trial,throw,new,illegal,state,exception,cannot,install,a,new,license,operation,mode,license,unless,fips,mode,is,disabled,cluster,service,submit,state,update,task,register,license,new,license,uid,new,acked,cluster,state,update,task,put,license,response,request,listener,override,protected,put,license,response,new,response,boolean,acknowledged,return,new,put,license,response,acknowledged,licenses,status,valid,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,xpack,plugin,check,ready,for,xpack,custom,metadata,current,state,meta,data,current,metadata,current,state,meta,data,licenses,meta,data,licenses,meta,data,current,metadata,custom,licenses,meta,data,type,version,trial,version,null,if,licenses,meta,data,null,trial,version,licenses,meta,data,get,most,recent,trial,version,meta,data,builder,md,builder,meta,data,builder,current,metadata,md,builder,put,custom,licenses,meta,data,type,new,licenses,meta,data,new,license,trial,version,return,cluster,state,builder,current,state,meta,data,md,builder,build
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1524684173;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license)__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1525334055;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license)__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1527096592;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license)__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1528211342;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license)__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1531179852;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license)__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1532069817;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1532456624;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1533063033;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1534248446;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1534848846;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1541008027;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1542646292;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1544232221;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1544458001;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1544600864;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1544732811;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> private void onUpdate(final LicensesMetaData currentLicensesMetaData);1547625930;Notifies registered licensees of license state change and/or new active license_based on the license in <code>currentLicensesMetaData</code>._Additionally schedules license expiry notifications and event callbacks_relative to the current license's expiry;private void onUpdate(final LicensesMetaData currentLicensesMetaData) {_        final License license = getLicense(currentLicensesMetaData)__        _        _        if (license != null) {_            final License previousLicense = currentLicense.get()__            if (license.equals(previousLicense) == false) {_                currentLicense.set(license)__                license.setOperationModeFileWatcher(operationModeFileWatcher)__                scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license)))__                for (ExpirationCallback expirationCallback : expirationCallbacks) {_                    scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(),_                            (startTime, now) ->_                                    expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now)))__                }_                if (previousLicense != null) {_                    _                    previousLicense.removeOperationModeFileWatcher()__                }_                logger.info("license [{}] mode [{}] - valid", license.uid(),_                        license.operationMode().name().toLowerCase(Locale.ROOT))__            }_            updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion())__        }_    };notifies,registered,licensees,of,license,state,change,and,or,new,active,license,based,on,the,license,in,code,current,licenses,meta,data,code,additionally,schedules,license,expiry,notifications,and,event,callbacks,relative,to,the,current,license,s,expiry;private,void,on,update,final,licenses,meta,data,current,licenses,meta,data,final,license,license,get,license,current,licenses,meta,data,if,license,null,final,license,previous,license,current,license,get,if,license,equals,previous,license,false,current,license,set,license,license,set,operation,mode,file,watcher,operation,mode,file,watcher,scheduler,add,new,scheduler,engine,job,next,license,check,license,for,expiration,callback,expiration,callback,expiration,callbacks,scheduler,add,new,scheduler,engine,job,expiration,callback,get,id,start,time,now,expiration,callback,next,scheduled,time,for,expiry,license,expiry,date,start,time,now,if,previous,license,null,previous,license,remove,operation,mode,file,watcher,logger,info,license,mode,valid,license,uid,license,operation,mode,name,to,lower,case,locale,root,update,license,state,license,current,licenses,meta,data,get,most,recent,trial,version
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1524684173;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster()_                    && (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1525334055;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) || LicenseUtils.signatureNeedsUpdate(currentLicense))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1527096592;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) || LicenseUtils.signatureNeedsUpdate(currentLicense))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1528211342;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1531179852;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1532069817;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1532456624;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1533063033;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1534248446;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1534848846;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1541008027;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1542646292;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1544232221;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1544458001;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1544600864;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1544732811;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> @Override     public void clusterChanged(ClusterChangedEvent event);1547625930;When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}_notify licensees and issue auto-generated license if no license has been installed/issued yet.;@Override_    public void clusterChanged(ClusterChangedEvent event) {_        final ClusterState previousClusterState = event.previousState()__        final ClusterState currentClusterState = event.state()__        if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {_            if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {_                logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}",_                    () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState))__                return__            }__            final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE)__            if (logger.isDebugEnabled()) {_                logger.debug("previous [{}]", prevLicensesMetaData)__                logger.debug("current [{}]", currentLicensesMetaData)__            }_            _            if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)_                    || prevLicensesMetaData == null) {_                if (currentLicensesMetaData != null) {_                    onUpdate(currentLicensesMetaData)__                }_            } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {_                onUpdate(currentLicensesMetaData)__            }__            License currentLicense = null__            boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null__            if (noLicenseInPrevMetadata == false) {_                currentLicense = prevLicensesMetaData.getLicense()__            }_            boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null)__            if (noLicenseInCurrentMetadata == false) {_                currentLicense = currentLicensesMetaData.getLicense()__            }__            boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata__            _            _            if (currentClusterState.getNodes().isLocalNodeElectedMaster() &&_                    (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) ||_                        LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {_                registerOrUpdateSelfGeneratedLicense()__            }_        } else if (logger.isDebugEnabled()) {_            logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK)__        }_    };when,there,is,no,global,block,on,link,org,elasticsearch,gateway,gateway,service,notify,licensees,and,issue,auto,generated,license,if,no,license,has,been,installed,issued,yet;override,public,void,cluster,changed,cluster,changed,event,event,final,cluster,state,previous,cluster,state,event,previous,state,final,cluster,state,current,cluster,state,event,state,if,current,cluster,state,blocks,has,global,block,gateway,service,if,xpack,plugin,is,ready,for,xpack,custom,metadata,current,cluster,state,false,logger,debug,cannot,add,license,to,cluster,as,the,following,nodes,might,not,understand,the,license,metadata,xpack,plugin,nodes,not,ready,for,xpack,custom,metadata,current,cluster,state,return,final,licenses,meta,data,prev,licenses,meta,data,previous,cluster,state,get,meta,data,custom,licenses,meta,data,type,final,licenses,meta,data,current,licenses,meta,data,current,cluster,state,get,meta,data,custom,licenses,meta,data,type,if,logger,is,debug,enabled,logger,debug,previous,prev,licenses,meta,data,logger,debug,current,current,licenses,meta,data,if,previous,cluster,state,blocks,has,global,block,gateway,service,prev,licenses,meta,data,null,if,current,licenses,meta,data,null,on,update,current,licenses,meta,data,else,if,prev,licenses,meta,data,equals,current,licenses,meta,data,on,update,current,licenses,meta,data,license,current,license,null,boolean,no,license,in,prev,metadata,prev,licenses,meta,data,null,prev,licenses,meta,data,get,license,null,if,no,license,in,prev,metadata,false,current,license,prev,licenses,meta,data,get,license,boolean,no,license,in,current,metadata,current,licenses,meta,data,null,current,licenses,meta,data,get,license,null,if,no,license,in,current,metadata,false,current,license,current,licenses,meta,data,get,license,boolean,no,license,no,license,in,prev,metadata,no,license,in,current,metadata,if,current,cluster,state,get,nodes,is,local,node,elected,master,no,license,license,utils,license,needs,extended,current,license,license,utils,signature,needs,update,current,license,current,cluster,state,nodes,register,or,update,self,generated,license,else,if,logger,is,debug,enabled,logger,debug,skipped,license,notifications,reason,gateway,service
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1524684173;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1525334055;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1527096592;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1528211342;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1531179852;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1532069817;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1532456624;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1533063033;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1534248446;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1534848846;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1541008027;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1542646292;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1544232221;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1544458001;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1544600864;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1544732811;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener);1547625930;Remove license from the cluster state metadata;public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {_        clusterService.submitStateUpdateTask("delete license",_                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {_                    @Override_                    protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {_                        return new ClusterStateUpdateResponse(acknowledged)__                    }__                    @Override_                    public ClusterState execute(ClusterState currentState) throws Exception {_                        MetaData metaData = currentState.metaData()__                        final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE)__                        if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {_                            MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                            LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE,_                                    currentLicenses.getMostRecentTrialVersion())__                            mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata)__                            return ClusterState.builder(currentState).metaData(mdBuilder).build()__                        } else {_                            return currentState__                        }_                    }_                })__    };remove,license,from,the,cluster,state,metadata;public,void,remove,license,final,delete,license,request,request,final,action,listener,cluster,state,update,response,listener,cluster,service,submit,state,update,task,delete,license,new,acked,cluster,state,update,task,cluster,state,update,response,request,listener,override,protected,cluster,state,update,response,new,response,boolean,acknowledged,return,new,cluster,state,update,response,acknowledged,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,meta,data,meta,data,current,state,meta,data,final,licenses,meta,data,current,licenses,meta,data,custom,licenses,meta,data,type,if,current,licenses,get,license,licenses,meta,data,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,licenses,meta,data,new,metadata,new,licenses,meta,data,licenses,meta,data,current,licenses,get,most,recent,trial,version,md,builder,put,custom,licenses,meta,data,type,new,metadata,return,cluster,state,builder,current,state,meta,data,md,builder,build,else,return,current,state
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1524684173;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1525334055;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1527096592;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1528211342;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1531179852;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1532069817;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1532456624;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1533063033;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1534248446;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1534848846;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1541008027;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1542646292;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1544232221;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1544458001;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1544600864;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1544732811;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
LicenseService -> private void registerOrUpdateSelfGeneratedLicense();1547625930;Master-only operation to generate a one-time global self generated license._The self generated license is only generated and stored if the current cluster state metadata_has no existing license. If the cluster currently has a basic license that has an expiration date,_a new basic license with no expiration date is generated.;private void registerOrUpdateSelfGeneratedLicense() {_        clusterService.submitStateUpdateTask("maybe generate license for cluster",_                new StartupSelfGeneratedLicenseTask(settings, clock, clusterService))__    };master,only,operation,to,generate,a,one,time,global,self,generated,license,the,self,generated,license,is,only,generated,and,stored,if,the,current,cluster,state,metadata,has,no,existing,license,if,the,cluster,currently,has,a,basic,license,that,has,an,expiration,date,a,new,basic,license,with,no,expiration,date,is,generated;private,void,register,or,update,self,generated,license,cluster,service,submit,state,update,task,maybe,generate,license,for,cluster,new,startup,self,generated,license,task,settings,clock,cluster,service
