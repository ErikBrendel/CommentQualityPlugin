commented;modifiers;parameterAmount;loc;comment;code
false;private;2;30;;private void logExpirationWarning(long expirationMillis, boolean expired) {     String expiredMsg = expired ? "expired" : "will expire".     String general = LoggerMessageFormat.format(null, "License [{}] on [{}].\n" + "# If you have a new license, please update it. Otherwise, please reach out to\n" + "# your support contact.\n" + "# ", expiredMsg, DATE_FORMATTER.formatMillis(expirationMillis)).     if (expired) {         general = general.toUpperCase(Locale.ROOT).     }     StringBuilder builder = new StringBuilder(general).     builder.append(System.lineSeparator()).     if (expired) {         builder.append("# COMMERCIAL PLUGINS OPERATING WITH REDUCED FUNCTIONALITY").     } else {         builder.append("# Commercial plugins operate with reduced functionality on license expiration:").     }     XPackLicenseState.EXPIRATION_MESSAGES.forEach((feature, messages) -> {         if (messages.length > 0) {             builder.append(System.lineSeparator()).             builder.append("# - ").             builder.append(feature).             for (String message : messages) {                 builder.append(System.lineSeparator()).                 builder.append("#  - ").                 builder.append(message).             }         }     }).     logger.warn("{}", builder). }
false;public;1;4;;@Override public void on(License license) {     logExpirationWarning(license.expiryDate(), false). }
false;public;1;4;;@Override public void on(License license) {     logExpirationWarning(license.expiryDate(), false). }
false;public;1;5;;@Override public void on(License license) {     // logged when grace period begins     logExpirationWarning(license.expiryDate(), true). }
false;private;0;21;;private void populateExpirationCallbacks() {     expirationCallbacks.add(new ExpirationCallback.Pre(days(7), days(25), days(1)) {          @Override         public void on(License license) {             logExpirationWarning(license.expiryDate(), false).         }     }).     expirationCallbacks.add(new ExpirationCallback.Pre(days(0), days(7), TimeValue.timeValueMinutes(10)) {          @Override         public void on(License license) {             logExpirationWarning(license.expiryDate(), false).         }     }).     expirationCallbacks.add(new ExpirationCallback.Post(days(0), null, TimeValue.timeValueMinutes(10)) {          @Override         public void on(License license) {             // logged when grace period begins             logExpirationWarning(license.expiryDate(), true).         }     }). }
false;protected;1;4;;@Override protected PutLicenseResponse newResponse(boolean acknowledged) {     return new PutLicenseResponse(acknowledged, LicensesStatus.VALID). }
false;public;1;13;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     XPackPlugin.checkReadyForXPackCustomMetadata(currentState).     MetaData currentMetadata = currentState.metaData().     LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE).     Version trialVersion = null.     if (licensesMetaData != null) {         trialVersion = licensesMetaData.getMostRecentTrialVersion().     }     MetaData.Builder mdBuilder = MetaData.builder(currentMetadata).     mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion)).     return ClusterState.builder(currentState).metaData(mdBuilder).build(). }
true;public;2;64;/**  * Registers new license in the cluster  * Master only operation. Installs a new license on the master provided it is VALID  */ ;/**  * Registers new license in the cluster  * Master only operation. Installs a new license on the master provided it is VALID  */ public void registerLicense(final PutLicenseRequest request, final ActionListener<PutLicenseResponse> listener) {     final License newLicense = request.license().     final long now = clock.millis().     if (!LicenseVerifier.verifyLicense(newLicense) || newLicense.issueDate() > now || newLicense.startDate() > now) {         listener.onResponse(new PutLicenseResponse(true, LicensesStatus.INVALID)).     } else if (newLicense.type().equals("basic")) {         listener.onFailure(new IllegalArgumentException("Registering basic licenses is not allowed.")).     } else if (newLicense.expiryDate() < now) {         listener.onResponse(new PutLicenseResponse(true, LicensesStatus.EXPIRED)).     } else {         if (!request.acknowledged()) {             // TODO: ack messages should be generated on the master, since another node's cluster state may be behind...             final License currentLicense = getLicense().             if (currentLicense != null) {                 Map<String, String[]> acknowledgeMessages = getAckMessages(newLicense, currentLicense).                 if (acknowledgeMessages.isEmpty() == false) {                     // needs acknowledgement                     listener.onResponse(new PutLicenseResponse(false, LicensesStatus.VALID, ACKNOWLEDGEMENT_HEADER, acknowledgeMessages)).                     return.                 }             }         }         if (XPackSettings.SECURITY_ENABLED.get(settings)) {             // should happen on a different level and not in this code             if (newLicense.isProductionLicense() && XPackSettings.TRANSPORT_SSL_ENABLED.get(settings) == false && isProductionMode(settings, clusterService.localNode())) {                 // security is on but TLS is not configured we gonna fail the entire request and throw an exception                 throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() + "] license unless TLS is configured or security is disabled").             } else if (XPackSettings.FIPS_MODE_ENABLED.get(settings) && newLicense.operationMode() != License.OperationMode.PLATINUM && newLicense.operationMode() != License.OperationMode.TRIAL) {                 throw new IllegalStateException("Cannot install a [" + newLicense.operationMode() + "] license unless FIPS mode is disabled").             }         }         clusterService.submitStateUpdateTask("register license [" + newLicense.uid() + "]", new AckedClusterStateUpdateTask<PutLicenseResponse>(request, listener) {              @Override             protected PutLicenseResponse newResponse(boolean acknowledged) {                 return new PutLicenseResponse(acknowledged, LicensesStatus.VALID).             }              @Override             public ClusterState execute(ClusterState currentState) throws Exception {                 XPackPlugin.checkReadyForXPackCustomMetadata(currentState).                 MetaData currentMetadata = currentState.metaData().                 LicensesMetaData licensesMetaData = currentMetadata.custom(LicensesMetaData.TYPE).                 Version trialVersion = null.                 if (licensesMetaData != null) {                     trialVersion = licensesMetaData.getMostRecentTrialVersion().                 }                 MetaData.Builder mdBuilder = MetaData.builder(currentMetadata).                 mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(newLicense, trialVersion)).                 return ClusterState.builder(currentState).metaData(mdBuilder).build().             }         }).     } }
false;public,static;2;16;;public static Map<String, String[]> getAckMessages(License newLicense, License currentLicense) {     Map<String, String[]> acknowledgeMessages = new HashMap<>().     if (// current license is not auto-generated     !License.isAutoGeneratedLicense(currentLicense.signature()) && currentLicense.issueDate() > newLicense.issueDate()) {         // and has a later issue date         acknowledgeMessages.put("license", new String[] { "The new license is older than the currently installed license. " + "Are you sure you want to override the current license?" }).     }     XPackLicenseState.ACKNOWLEDGMENT_MESSAGES.forEach((feature, ackMessages) -> {         String[] messages = ackMessages.apply(currentLicense.operationMode(), newLicense.operationMode()).         if (messages.length > 0) {             acknowledgeMessages.put(feature, messages).         }     }).     return acknowledgeMessages. }
false;private,static;1;3;;private static TimeValue days(int days) {     return TimeValue.timeValueHours(days * 24). }
false;public;1;14;;@Override public void triggered(SchedulerEngine.Event event) {     final LicensesMetaData licensesMetaData = getLicensesMetaData().     if (licensesMetaData != null) {         final License license = licensesMetaData.getLicense().         if (event.getJobName().equals(LICENSE_JOB)) {             updateLicenseState(license, licensesMetaData.getMostRecentTrialVersion()).         } else if (event.getJobName().startsWith(ExpirationCallback.EXPIRATION_JOB_PREFIX)) {             expirationCallbacks.stream().filter(expirationCallback -> expirationCallback.getId().equals(event.getJobName())).forEach(expirationCallback -> expirationCallback.on(license)).         }     } }
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;14;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     MetaData metaData = currentState.metaData().     final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE).     if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {         MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).         LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE, currentLicenses.getMostRecentTrialVersion()).         mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata).         return ClusterState.builder(currentState).metaData(mdBuilder).build().     } else {         return currentState.     } }
true;public;2;24;/**  * Remove license from the cluster state metadata  */ ;/**  * Remove license from the cluster state metadata  */ public void removeLicense(final DeleteLicenseRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     clusterService.submitStateUpdateTask("delete license", new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             MetaData metaData = currentState.metaData().             final LicensesMetaData currentLicenses = metaData.custom(LicensesMetaData.TYPE).             if (currentLicenses.getLicense() != LicensesMetaData.LICENSE_TOMBSTONE) {                 MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).                 LicensesMetaData newMetadata = new LicensesMetaData(LicensesMetaData.LICENSE_TOMBSTONE, currentLicenses.getMostRecentTrialVersion()).                 mdBuilder.putCustom(LicensesMetaData.TYPE, newMetadata).                 return ClusterState.builder(currentState).metaData(mdBuilder).build().             } else {                 return currentState.             }         }     }). }
false;public;0;4;;public License getLicense() {     final License license = getLicense(clusterService.state().metaData()).     return license == LicensesMetaData.LICENSE_TOMBSTONE ? null : license. }
false;private;0;3;;private LicensesMetaData getLicensesMetaData() {     return this.clusterService.state().metaData().custom(LicensesMetaData.TYPE). }
false;;2;8;;void startTrialLicense(PostStartTrialRequest request, final ActionListener<PostStartTrialResponse> listener) {     if (VALID_TRIAL_TYPES.contains(request.getType()) == false) {         throw new IllegalArgumentException("Cannot start trial of type [" + request.getType() + "]. Valid trial types are " + VALID_TRIAL_TYPES + ".").     }     StartTrialClusterTask task = new StartTrialClusterTask(logger, clusterService.getClusterName().value(), clock, request, listener).     clusterService.submitStateUpdateTask("started trial license", task). }
false;;2;4;;void startBasicLicense(PostStartBasicRequest request, final ActionListener<PostStartBasicResponse> listener) {     StartBasicClusterTask task = new StartBasicClusterTask(logger, clusterService.getClusterName().value(), clock, request, listener).     clusterService.submitStateUpdateTask("start basic license", task). }
true;private;0;4;/**  * Master-only operation to generate a one-time global self generated license.  * The self generated license is only generated and stored if the current cluster state metadata  * has no existing license. If the cluster currently has a basic license that has an expiration date,  * a new basic license with no expiration date is generated.  */ ;/**  * Master-only operation to generate a one-time global self generated license.  * The self generated license is only generated and stored if the current cluster state metadata  * has no existing license. If the cluster currently has a basic license that has an expiration date,  * a new basic license with no expiration date is generated.  */ private void registerOrUpdateSelfGeneratedLicense() {     clusterService.submitStateUpdateTask("maybe generate license for cluster", new StartupSelfGeneratedLicenseTask(settings, clock, clusterService)). }
false;protected;0;19;;@Override protected void doStart() throws ElasticsearchException {     clusterService.addListener(this).     scheduler.start(Collections.emptyList()).     logger.debug("initializing license state").     if (clusterService.lifecycleState() == Lifecycle.State.STARTED) {         final ClusterState clusterState = clusterService.state().         if (clusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) == false && clusterState.nodes().getMasterNode() != null && XPackPlugin.isReadyForXPackCustomMetadata(clusterState)) {             final LicensesMetaData currentMetaData = clusterState.metaData().custom(LicensesMetaData.TYPE).             boolean noLicense = currentMetaData == null || currentMetaData.getLicense() == null.             if (clusterState.getNodes().isLocalNodeElectedMaster() && (noLicense || LicenseUtils.licenseNeedsExtended(currentMetaData.getLicense()))) {                 // triggers a cluster changed event eventually notifying the current licensee                 registerOrUpdateSelfGeneratedLicense().             }         }     } }
false;protected;0;7;;@Override protected void doStop() throws ElasticsearchException {     clusterService.removeListener(this).     scheduler.stop().     // clear current license     currentLicense.set(null). }
false;protected;0;3;;@Override protected void doClose() throws ElasticsearchException { }
true;public;1;49;/**  * When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}  * notify licensees and issue auto-generated license if no license has been installed/issued yet.  */ ;/**  * When there is no global block on {@link org.elasticsearch.gateway.GatewayService#STATE_NOT_RECOVERED_BLOCK}  * notify licensees and issue auto-generated license if no license has been installed/issued yet.  */ @Override public void clusterChanged(ClusterChangedEvent event) {     final ClusterState previousClusterState = event.previousState().     final ClusterState currentClusterState = event.state().     if (!currentClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {         if (XPackPlugin.isReadyForXPackCustomMetadata(currentClusterState) == false) {             logger.debug("cannot add license to cluster as the following nodes might not understand the license metadata: {}", () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(currentClusterState)).             return.         }         final LicensesMetaData prevLicensesMetaData = previousClusterState.getMetaData().custom(LicensesMetaData.TYPE).         final LicensesMetaData currentLicensesMetaData = currentClusterState.getMetaData().custom(LicensesMetaData.TYPE).         if (logger.isDebugEnabled()) {             logger.debug("previous [{}]", prevLicensesMetaData).             logger.debug("current [{}]", currentLicensesMetaData).         }         // notify all interested plugins         if (previousClusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) || prevLicensesMetaData == null) {             if (currentLicensesMetaData != null) {                 onUpdate(currentLicensesMetaData).             }         } else if (!prevLicensesMetaData.equals(currentLicensesMetaData)) {             onUpdate(currentLicensesMetaData).         }         License currentLicense = null.         boolean noLicenseInPrevMetadata = prevLicensesMetaData == null || prevLicensesMetaData.getLicense() == null.         if (noLicenseInPrevMetadata == false) {             currentLicense = prevLicensesMetaData.getLicense().         }         boolean noLicenseInCurrentMetadata = (currentLicensesMetaData == null || currentLicensesMetaData.getLicense() == null).         if (noLicenseInCurrentMetadata == false) {             currentLicense = currentLicensesMetaData.getLicense().         }         boolean noLicense = noLicenseInPrevMetadata && noLicenseInCurrentMetadata.         // needs extended or if the license signature needs to be updated. this will trigger a subsequent cluster changed event         if (currentClusterState.getNodes().isLocalNodeElectedMaster() && (noLicense || LicenseUtils.licenseNeedsExtended(currentLicense) || LicenseUtils.signatureNeedsUpdate(currentLicense, currentClusterState.nodes()))) {             registerOrUpdateSelfGeneratedLicense().         }     } else if (logger.isDebugEnabled()) {         logger.debug("skipped license notifications reason: [{}]", GatewayService.STATE_NOT_RECOVERED_BLOCK).     } }
false;private;1;5;;private void updateLicenseState(LicensesMetaData licensesMetaData) {     if (licensesMetaData != null) {         updateLicenseState(getLicense(licensesMetaData), licensesMetaData.getMostRecentTrialVersion()).     } }
false;protected;2;29;;protected void updateLicenseState(final License license, Version mostRecentTrialVersion) {     if (license == LicensesMetaData.LICENSE_TOMBSTONE) {         // implies license has been explicitly deleted         licenseState.update(License.OperationMode.MISSING, false, mostRecentTrialVersion).         return.     }     if (license != null) {         long time = clock.millis().         boolean active.         if (license.expiryDate() == BASIC_SELF_GENERATED_LICENSE_EXPIRATION_MILLIS) {             active = true.         } else {             // We subtract the grace period from the current time to avoid overflowing on an expiration             // date that is near Long.MAX_VALUE             active = time >= license.issueDate() && time - GRACE_PERIOD_DURATION.getMillis() < license.expiryDate().         }         licenseState.update(license.operationMode(), active, mostRecentTrialVersion).         if (active) {             if (time < license.expiryDate()) {                 logger.debug("license [{}] - valid", license.uid()).             } else {                 logger.warn("license [{}] - grace", license.uid()).             }         } else {             logger.warn("license [{}] - expired", license.uid()).         }     } }
true;private;1;25;/**  * Notifies registered licensees of license state change and/or new active license  * based on the license in <code>currentLicensesMetaData</code>.  * Additionally schedules license expiry notifications and event callbacks  * relative to the current license's expiry  */ ;/**  * Notifies registered licensees of license state change and/or new active license  * based on the license in <code>currentLicensesMetaData</code>.  * Additionally schedules license expiry notifications and event callbacks  * relative to the current license's expiry  */ private void onUpdate(final LicensesMetaData currentLicensesMetaData) {     final License license = getLicense(currentLicensesMetaData).     // in this case, it is a no-op     if (license != null) {         final License previousLicense = currentLicense.get().         if (license.equals(previousLicense) == false) {             currentLicense.set(license).             license.setOperationModeFileWatcher(operationModeFileWatcher).             scheduler.add(new SchedulerEngine.Job(LICENSE_JOB, nextLicenseCheck(license))).             for (ExpirationCallback expirationCallback : expirationCallbacks) {                 scheduler.add(new SchedulerEngine.Job(expirationCallback.getId(), (startTime, now) -> expirationCallback.nextScheduledTimeForExpiry(license.expiryDate(), startTime, now))).             }             if (previousLicense != null) {                 // remove operationModeFileWatcher to gc the old license object                 previousLicense.removeOperationModeFileWatcher().             }             logger.info("license [{}] mode [{}] - valid", license.uid(), license.operationMode().name().toLowerCase(Locale.ROOT)).         }         updateLicenseState(license, currentLicensesMetaData.getMostRecentTrialVersion()).     } }
true;static;1;17;// pkg private for tests ;// pkg private for tests static SchedulerEngine.Schedule nextLicenseCheck(License license) {     return (startTime, time) -> {         if (time < license.issueDate()) {             // see https://github.com/elastic/x-plugins/issues/983             return license.issueDate().         } else if (time < license.expiryDate()) {             return license.expiryDate().         } else if (time < license.expiryDate() + GRACE_PERIOD_DURATION.getMillis()) {             return license.expiryDate() + GRACE_PERIOD_DURATION.getMillis().         }         // license is expired, no need to check again         return -1.     }. }
false;public,static;1;4;;public static License getLicense(final MetaData metaData) {     final LicensesMetaData licensesMetaData = metaData.custom(LicensesMetaData.TYPE).     return getLicense(licensesMetaData). }
false;static;1;15;;static License getLicense(final LicensesMetaData metaData) {     if (metaData != null) {         License license = metaData.getLicense().         if (license == LicensesMetaData.LICENSE_TOMBSTONE) {             return license.         } else if (license != null) {             boolean autoGeneratedLicense = License.isAutoGeneratedLicense(license.signature()).             if ((autoGeneratedLicense && SelfGeneratedLicense.verify(license)) || (!autoGeneratedLicense && LicenseVerifier.verifyLicense(license))) {                 return license.             }         }     }     return null. }
false;private,static;2;4;;private static boolean isProductionMode(Settings settings, DiscoveryNode localNode) {     final boolean singleNodeDisco = "single-node".equals(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings)).     return singleNodeDisco == false && isBoundToLoopback(localNode) == false. }
false;private,static;1;3;;private static boolean isBoundToLoopback(DiscoveryNode localNode) {     return localNode.getAddress().address().getAddress().isLoopbackAddress(). }
