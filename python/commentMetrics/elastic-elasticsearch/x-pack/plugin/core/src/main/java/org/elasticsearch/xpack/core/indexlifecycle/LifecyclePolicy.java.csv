commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static LifecyclePolicy parse(XContentParser parser, String name) {     return PARSER.apply(parser, name). }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(type).     out.writeString(name).     out.writeMap(phases, StreamOutput::writeString, (o, val) -> val.writeTo(o)). }
true;public;0;3;/**  * @return the name of this {@link LifecyclePolicy}  */ ;/**  * @return the name of this {@link LifecyclePolicy}  */ public String getName() {     return name. }
true;public;0;3;/**  * @return the type of this {@link LifecyclePolicy}  */ ;/**  * @return the type of this {@link LifecyclePolicy}  */ public LifecycleType getType() {     return type. }
true;public;0;3;/**  * @return the {@link Phase}s for this {@link LifecyclePolicy} in the order  *         in which they will be executed.  */ ;/**  * @return the {@link Phase}s for this {@link LifecyclePolicy} in the order  *         in which they will be executed.  */ public Map<String, Phase> getPhases() {     return phases. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject(PHASES_FIELD.getPreferredName()).     for (Phase phase : phases.values()) {         builder.field(phase.getName(), phase).     }     builder.endObject().     builder.endObject().     return builder. }
true;public;1;56;/**  * This method is used to compile this policy into its execution plan built out  * of {@link Step} instances. The order of the {@link Phase}s and {@link LifecycleAction}s is  * determined by the {@link LifecycleType} associated with this policy.  *  * The order of the policy will have this structure:  *  * - initialize policy context step  * - phase-1 phase-after-step  * - ... phase-1 action steps  * - phase-2 phase-after-step  * - ...  * - terminal policy step  *  * We first initialize the policy's context and ensure that the index has proper settings set.  * Then we begin each phase's after-step along with all its actions as steps. Finally, we have  * a terminal step to inform us that this policy's steps are all complete. Each phase's `after`  * step is associated with the previous phase's phase. For example, the warm phase's `after` is  * associated with the hot phase so that it is clear that we haven't stepped into the warm phase  * just yet (until this step is complete).  *  * @param client The Elasticsearch Client to use during execution of {@link AsyncActionStep}  *               and {@link AsyncWaitStep} steps.  * @return The list of {@link Step} objects in order of their execution.  */ ;/**  * This method is used to compile this policy into its execution plan built out  * of {@link Step} instances. The order of the {@link Phase}s and {@link LifecycleAction}s is  * determined by the {@link LifecycleType} associated with this policy.  *  * The order of the policy will have this structure:  *  * - initialize policy context step  * - phase-1 phase-after-step  * - ... phase-1 action steps  * - phase-2 phase-after-step  * - ...  * - terminal policy step  *  * We first initialize the policy's context and ensure that the index has proper settings set.  * Then we begin each phase's after-step along with all its actions as steps. Finally, we have  * a terminal step to inform us that this policy's steps are all complete. Each phase's `after`  * step is associated with the previous phase's phase. For example, the warm phase's `after` is  * associated with the hot phase so that it is clear that we haven't stepped into the warm phase  * just yet (until this step is complete).  *  * @param client The Elasticsearch Client to use during execution of {@link AsyncActionStep}  *               and {@link AsyncWaitStep} steps.  * @return The list of {@link Step} objects in order of their execution.  */ public List<Step> toSteps(Client client) {     List<Step> steps = new ArrayList<>().     List<Phase> orderedPhases = type.getOrderedPhases(phases).     ListIterator<Phase> phaseIterator = orderedPhases.listIterator(orderedPhases.size()).     // final step so that policy can properly update cluster-state with last action completed     steps.add(TerminalPolicyStep.INSTANCE).     Step.StepKey lastStepKey = TerminalPolicyStep.KEY.     Phase phase = null.     // add steps for each phase, in reverse     while (phaseIterator.hasPrevious()) {         Phase previousPhase = phaseIterator.previous().         // add `after` step for phase before next         if (phase != null) {             // after step should have the name of the previous phase since the index is still in the             // previous phase until the after condition is reached             Step.StepKey afterStepKey = new Step.StepKey(previousPhase.getName(), PhaseCompleteStep.NAME, PhaseCompleteStep.NAME).             Step phaseAfterStep = new PhaseCompleteStep(afterStepKey, lastStepKey).             steps.add(phaseAfterStep).             lastStepKey = phaseAfterStep.getKey().         }         phase = previousPhase.         List<LifecycleAction> orderedActions = type.getOrderedActions(phase).         ListIterator<LifecycleAction> actionIterator = orderedActions.listIterator(orderedActions.size()).         // add steps for each action, in reverse         while (actionIterator.hasPrevious()) {             LifecycleAction action = actionIterator.previous().             List<Step> actionSteps = action.toSteps(client, phase.getName(), lastStepKey).             ListIterator<Step> actionStepsIterator = actionSteps.listIterator(actionSteps.size()).             while (actionStepsIterator.hasPrevious()) {                 Step step = actionStepsIterator.previous().                 steps.add(step).                 lastStepKey = step.getKey().             }         }     }     if (phase != null) {         // The very first after step is in a phase before the hot phase so call this "new"         Step.StepKey afterStepKey = new Step.StepKey("new", PhaseCompleteStep.NAME, PhaseCompleteStep.NAME).         Step phaseAfterStep = new PhaseCompleteStep(afterStepKey, lastStepKey).         steps.add(phaseAfterStep).         lastStepKey = phaseAfterStep.getKey().     }     // init step so that policy is guaranteed to have     steps.add(new InitializePolicyContextStep(InitializePolicyContextStep.KEY, lastStepKey)).     Collections.reverse(steps).     return steps. }
false;public;1;17;;public boolean isActionSafe(StepKey stepKey) {     if ("new".equals(stepKey.getPhase())) {         return true.     }     Phase phase = phases.get(stepKey.getPhase()).     if (phase != null) {         LifecycleAction action = phase.getActions().get(stepKey.getAction()).         if (action != null) {             return action.isSafeAction().         } else {             throw new IllegalArgumentException("Action [" + stepKey.getAction() + "] in phase [" + stepKey.getPhase() + "]  does not exist in policy [" + name + "]").         }     } else {         throw new IllegalArgumentException("Phase [" + stepKey.getPhase() + "]  does not exist in policy [" + name + "]").     } }
true;public,static;1;17;/**  * Validate the name for an policy against some static rules. Intended to match  * {@link org.elasticsearch.cluster.metadata.MetaDataCreateIndexService#validateIndexOrAliasName(String, BiFunction)}  * @param policy the policy name to validate  * @throws IllegalArgumentException if the name is invalid  */ ;/**  * Validate the name for an policy against some static rules. Intended to match  * {@link org.elasticsearch.cluster.metadata.MetaDataCreateIndexService#validateIndexOrAliasName(String, BiFunction)}  * @param policy the policy name to validate  * @throws IllegalArgumentException if the name is invalid  */ public static void validatePolicyName(String policy) {     if (policy.contains(",")) {         throw new IllegalArgumentException("invalid policy name [" + policy + "]: must not contain ','").     }     if (policy.contains(" ")) {         throw new IllegalArgumentException("invalid policy name [" + policy + "]: must not contain spaces").     }     if (policy.charAt(0) == '_') {         throw new IllegalArgumentException("invalid policy name [" + policy + "]: must not start with '_'").     }     int byteCount = 0.     byteCount = policy.getBytes(StandardCharsets.UTF_8).length.     if (byteCount > MAX_INDEX_NAME_BYTES) {         throw new IllegalArgumentException("invalid policy name [" + policy + "]: name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")").     } }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, phases). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj.getClass() != getClass()) {         return false.     }     LifecyclePolicy other = (LifecyclePolicy) obj.     return Objects.equals(name, other.name) && Objects.equals(phases, other.phases). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
