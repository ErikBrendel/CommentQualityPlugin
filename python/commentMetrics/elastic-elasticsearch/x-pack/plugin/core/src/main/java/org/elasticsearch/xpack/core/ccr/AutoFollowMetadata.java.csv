commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static AutoFollowMetadata fromXContent(XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;public;0;3;;public Map<String, AutoFollowPattern> getPatterns() {     return patterns. }
false;public;0;3;;public Map<String, List<String>> getFollowedLeaderIndexUUIDs() {     return followedLeaderIndexUUIDs. }
false;public;0;3;;public Map<String, Map<String, String>> getHeaders() {     return headers. }
false;public;0;5;;@Override public EnumSet<MetaData.XContentContext> context() {     // No XContentContext.API, because the headers should not be serialized as part of clusters state api     return EnumSet.of(MetaData.XContentContext.SNAPSHOT, MetaData.XContentContext.GATEWAY). }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.V_6_5_0.minimumCompatibilityVersion(). }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeMap(patterns, StreamOutput::writeString, (out1, value) -> value.writeTo(out1)).     out.writeMapOfLists(followedLeaderIndexUUIDs, StreamOutput::writeString, StreamOutput::writeString).     out.writeMap(headers, StreamOutput::writeString, (valOut, header) -> valOut.writeMap(header, StreamOutput::writeString, StreamOutput::writeString)). }
false;public;2;22;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(PATTERNS_FIELD.getPreferredName()).     for (Map.Entry<String, AutoFollowPattern> entry : patterns.entrySet()) {         builder.startObject(entry.getKey()).         builder.value(entry.getValue()).         builder.endObject().     }     builder.endObject().     builder.startObject(FOLLOWED_LEADER_INDICES_FIELD.getPreferredName()).     for (Map.Entry<String, List<String>> entry : followedLeaderIndexUUIDs.entrySet()) {         builder.field(entry.getKey(), entry.getValue()).     }     builder.endObject().     builder.startObject(HEADERS.getPreferredName()).     for (Map.Entry<String, Map<String, String>> entry : headers.entrySet()) {         builder.field(entry.getKey(), entry.getValue()).     }     builder.endObject().     return builder. }
false;public;0;4;;@Override public boolean isFragment() {     return true. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     AutoFollowMetadata that = (AutoFollowMetadata) o.     return Objects.equals(patterns, that.patterns) && Objects.equals(followedLeaderIndexUUIDs, that.followedLeaderIndexUUIDs) && Objects.equals(headers, that.headers). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(patterns, followedLeaderIndexUUIDs, headers). }
false;public,static;1;3;;public static AutoFollowPattern readFrom(StreamInput in) throws IOException {     return new AutoFollowPattern(in.readString(), in.readStringList(), in.readOptionalString(), in). }
false;public;1;3;;public boolean match(String indexName) {     return match(leaderIndexPatterns, indexName). }
false;public,static;2;3;;public static boolean match(List<String> leaderIndexPatterns, String indexName) {     return Regex.simpleMatch(leaderIndexPatterns, indexName). }
false;public;0;3;;public String getRemoteCluster() {     return remoteCluster. }
false;public;0;3;;public List<String> getLeaderIndexPatterns() {     return leaderIndexPatterns. }
false;public;0;3;;public String getFollowIndexPattern() {     return followIndexPattern. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(remoteCluster).     out.writeStringCollection(leaderIndexPatterns).     out.writeOptionalString(followIndexPattern).     super.writeTo(out). }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(REMOTE_CLUSTER_FIELD.getPreferredName(), remoteCluster).     builder.array(LEADER_PATTERNS_FIELD.getPreferredName(), leaderIndexPatterns.toArray(new String[0])).     if (followIndexPattern != null) {         builder.field(FOLLOW_PATTERN_FIELD.getPreferredName(), followIndexPattern).     }     toXContentFragment(builder).     return builder. }
false;public;0;4;;@Override public boolean isFragment() {     return true. }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     if (!super.equals(o))         return false.     AutoFollowPattern pattern = (AutoFollowPattern) o.     return remoteCluster.equals(pattern.remoteCluster) && leaderIndexPatterns.equals(pattern.leaderIndexPatterns) && followIndexPattern.equals(pattern.followIndexPattern). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), remoteCluster, leaderIndexPatterns, followIndexPattern). }
