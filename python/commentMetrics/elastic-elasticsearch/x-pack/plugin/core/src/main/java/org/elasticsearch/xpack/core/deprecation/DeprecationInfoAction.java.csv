commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * helper utility function to reduce repeat of running a specific {@link Set} of checks.  *  * @param checks The functional checks to execute using the mapper function  * @param mapper The function that executes the lambda check with the appropriate arguments  * @param <T> The signature of the check (BiFunction, Function, including the appropriate arguments)  * @return The list of {@link DeprecationIssue} that were found in the cluster  */ ;/**  * helper utility function to reduce repeat of running a specific {@link Set} of checks.  *  * @param checks The functional checks to execute using the mapper function  * @param mapper The function that executes the lambda check with the appropriate arguments  * @param <T> The signature of the check (BiFunction, Function, including the appropriate arguments)  * @return The list of {@link DeprecationIssue} that were found in the cluster  */ public static <T> List<DeprecationIssue> filterChecks(List<T> checks, Function<T, DeprecationIssue> mapper) {     return checks.stream().map(mapper).filter(Objects::nonNull).collect(Collectors.toList()). }
false;private,static;1;16;;private static List<DeprecationIssue> mergeNodeIssues(NodesDeprecationCheckResponse response) {     Map<DeprecationIssue, List<String>> issueListMap = new HashMap<>().     for (NodesDeprecationCheckAction.NodeResponse resp : response.getNodes()) {         for (DeprecationIssue issue : resp.getDeprecationIssues()) {             issueListMap.computeIfAbsent(issue, (key) -> new ArrayList<>()).add(resp.getNode().getName()).         }     }     return issueListMap.entrySet().stream().map(entry -> {         DeprecationIssue issue = entry.getKey().         String details = issue.getDetails() != null ? issue.getDetails() + " " : "".         return new DeprecationIssue(issue.getLevel(), issue.getMessage(), issue.getUrl(), details + "(nodes impacted: " + entry.getValue() + ")").     }).collect(Collectors.toList()). }
false;public;0;4;;@Override public Response newResponse() {     return new Response(). }
false;public;0;3;;public List<DeprecationIssue> getClusterSettingsIssues() {     return clusterSettingsIssues. }
false;public;0;3;;public List<DeprecationIssue> getNodeSettingsIssues() {     return nodeSettingsIssues. }
false;public;0;3;;public Map<String, List<DeprecationIssue>> getIndexSettingsIssues() {     return indexSettingsIssues. }
false;public;0;3;;public List<DeprecationIssue> getMlSettingsIssues() {     return mlSettingsIssues. }
false;public;1;12;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     clusterSettingsIssues = in.readList(DeprecationIssue::new).     nodeSettingsIssues = in.readList(DeprecationIssue::new).     indexSettingsIssues = in.readMapOfLists(StreamInput::readString, DeprecationIssue::new).     if (in.getVersion().onOrAfter(Version.V_6_7_0)) {         mlSettingsIssues = in.readList(DeprecationIssue::new).     } else {         mlSettingsIssues = Collections.emptyList().     } }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeList(clusterSettingsIssues).     out.writeList(nodeSettingsIssues).     out.writeMapOfLists(indexSettingsIssues, StreamOutput::writeString, (o, v) -> v.writeTo(o)).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeList(mlSettingsIssues).     } }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.startObject().array("cluster_settings", clusterSettingsIssues.toArray()).array("node_settings", nodeSettingsIssues.toArray()).field("index_settings").map(indexSettingsIssues).array("ml_settings", mlSettingsIssues.toArray()).endObject(). }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Response response = (Response) o.     return Objects.equals(clusterSettingsIssues, response.clusterSettingsIssues) && Objects.equals(nodeSettingsIssues, response.nodeSettingsIssues) && Objects.equals(indexSettingsIssues, response.indexSettingsIssues) && Objects.equals(mlSettingsIssues, response.mlSettingsIssues). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(clusterSettingsIssues, nodeSettingsIssues, indexSettingsIssues, mlSettingsIssues). }
true;public,static;9;30;/**  * This is the function that does the bulk of the logic of taking the appropriate ES dependencies  * like {@link NodeInfo}, {@link ClusterState}. Alongside these objects and the list of deprecation checks,  * this function will run through all the checks and build out the final list of issues that exist in the  * cluster.  *  * @param state The cluster state  * @param indexNameExpressionResolver Used to resolve indices into their concrete names  * @param indices The list of index expressions to evaluate using `indexNameExpressionResolver`  * @param indicesOptions The options to use when resolving and filtering which indices to check  * @param datafeeds The ml datafeed configurations  * @param nodeDeprecationResponse The response containing the deprecation issues found on each node  * @param indexSettingsChecks The list of index-level checks that will be run across all specified  *                            concrete indices  * @param clusterSettingsChecks The list of cluster-level checks  * @param mlSettingsCheck The list of ml checks  * @return The list of deprecation issues found in the cluster  */ ;/**  * This is the function that does the bulk of the logic of taking the appropriate ES dependencies  * like {@link NodeInfo}, {@link ClusterState}. Alongside these objects and the list of deprecation checks,  * this function will run through all the checks and build out the final list of issues that exist in the  * cluster.  *  * @param state The cluster state  * @param indexNameExpressionResolver Used to resolve indices into their concrete names  * @param indices The list of index expressions to evaluate using `indexNameExpressionResolver`  * @param indicesOptions The options to use when resolving and filtering which indices to check  * @param datafeeds The ml datafeed configurations  * @param nodeDeprecationResponse The response containing the deprecation issues found on each node  * @param indexSettingsChecks The list of index-level checks that will be run across all specified  *                            concrete indices  * @param clusterSettingsChecks The list of cluster-level checks  * @param mlSettingsCheck The list of ml checks  * @return The list of deprecation issues found in the cluster  */ public static DeprecationInfoAction.Response from(ClusterState state, IndexNameExpressionResolver indexNameExpressionResolver, String[] indices, IndicesOptions indicesOptions, List<DatafeedConfig> datafeeds, NodesDeprecationCheckResponse nodeDeprecationResponse, List<Function<IndexMetaData, DeprecationIssue>> indexSettingsChecks, List<Function<ClusterState, DeprecationIssue>> clusterSettingsChecks, List<Function<DatafeedConfig, DeprecationIssue>> mlSettingsCheck) {     List<DeprecationIssue> clusterSettingsIssues = filterChecks(clusterSettingsChecks, (c) -> c.apply(state)).     List<DeprecationIssue> nodeSettingsIssues = mergeNodeIssues(nodeDeprecationResponse).     List<DeprecationIssue> mlSettingsIssues = new ArrayList<>().     for (DatafeedConfig config : datafeeds) {         mlSettingsIssues.addAll(filterChecks(mlSettingsCheck, (c) -> c.apply(config))).     }     String[] concreteIndexNames = indexNameExpressionResolver.concreteIndexNames(state, indicesOptions, indices).     Map<String, List<DeprecationIssue>> indexSettingsIssues = new HashMap<>().     for (String concreteIndex : concreteIndexNames) {         IndexMetaData indexMetaData = state.getMetaData().index(concreteIndex).         List<DeprecationIssue> singleIndexIssues = filterChecks(indexSettingsChecks, c -> c.apply(indexMetaData)).         if (singleIndexIssues.size() > 0) {             indexSettingsIssues.put(concreteIndex, singleIndexIssues).         }     }     return new DeprecationInfoAction.Response(clusterSettingsIssues, nodeSettingsIssues, indexSettingsIssues, mlSettingsIssues). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeStringArray(indices). }
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;1;5;;@Override public Request indices(String... indices) {     this.indices = indices.     return this. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return INDICES_OPTIONS. }
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (indices == null) {         validationException = addValidationError("index/indices is missing", validationException).     }     return validationException. }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Request request = (Request) o.     return Arrays.equals(indices, request.indices). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(Arrays.hashCode(indices)). }
false;public;1;4;;public RequestBuilder setIndices(String... indices) {     request.indices(indices).     return this. }
