commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, RollupFieldCaps> getFieldCaps() {     return fieldCapLookup. }
false;public;0;3;;public String getRollupIndex() {     return rollupIndex. }
false;public;0;3;;public String getIndexPattern() {     return indexPattern. }
false;public;0;3;;public String getJobID() {     return jobID. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(jobID).     out.writeString(rollupIndex).     out.writeString(indexPattern).     out.writeMap(fieldCapLookup, StreamOutput::writeString, (o, value) -> value.writeTo(o)). }
false;public;2;18;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.field(JOB_ID.getPreferredName(), jobID).         builder.field(ROLLUP_INDEX.getPreferredName(), rollupIndex).         builder.field(INDEX_PATTERN.getPreferredName(), indexPattern).         builder.startObject(FIELDS.getPreferredName()).         {             for (Map.Entry<String, RollupFieldCaps> fieldCap : fieldCapLookup.entrySet()) {                 builder.array(fieldCap.getKey(), fieldCap.getValue()).             }         }         builder.endObject().     }     builder.endObject().     return builder. }
false;public;1;16;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     RollupJobCaps that = (RollupJobCaps) other.     return Objects.equals(this.jobID, that.jobID) && Objects.equals(this.rollupIndex, that.rollupIndex) && Objects.equals(this.fieldCapLookup, that.fieldCapLookup). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(jobID, rollupIndex, fieldCapLookup, indexPattern). }
false;private,static;1;65;;private static Map<String, RollupFieldCaps> createRollupFieldCaps(final RollupJobConfig rollupJobConfig) {     final Map<String, List<Map<String, Object>>> tempFieldCaps = new HashMap<>().     final GroupConfig groupConfig = rollupJobConfig.getGroupConfig().     if (groupConfig != null) {         // Create RollupFieldCaps for the date histogram         final DateHistogramGroupConfig dateHistogram = groupConfig.getDateHistogram().         final Map<String, Object> dateHistogramAggCap = new HashMap<>().         dateHistogramAggCap.put("agg", DateHistogramAggregationBuilder.NAME).         dateHistogramAggCap.put(DateHistogramGroupConfig.INTERVAL, dateHistogram.getInterval().toString()).         if (dateHistogram.getDelay() != null) {             dateHistogramAggCap.put(DateHistogramGroupConfig.DELAY, dateHistogram.getDelay().toString()).         }         dateHistogramAggCap.put(DateHistogramGroupConfig.TIME_ZONE, dateHistogram.getTimeZone()).         List<Map<String, Object>> dateAggCaps = tempFieldCaps.getOrDefault(dateHistogram.getField(), new ArrayList<>()).         dateAggCaps.add(dateHistogramAggCap).         tempFieldCaps.put(dateHistogram.getField(), dateAggCaps).         // Create RollupFieldCaps for the histogram         final HistogramGroupConfig histogram = groupConfig.getHistogram().         if (histogram != null) {             final Map<String, Object> histogramAggCap = new HashMap<>().             histogramAggCap.put("agg", HistogramAggregationBuilder.NAME).             histogramAggCap.put(HistogramGroupConfig.INTERVAL, histogram.getInterval()).             Arrays.stream(rollupJobConfig.getGroupConfig().getHistogram().getFields()).forEach(field -> {                 List<Map<String, Object>> caps = tempFieldCaps.getOrDefault(field, new ArrayList<>()).                 caps.add(histogramAggCap).                 tempFieldCaps.put(field, caps).             }).         }         // Create RollupFieldCaps for the term         final TermsGroupConfig terms = groupConfig.getTerms().         if (terms != null) {             final Map<String, Object> termsAggCap = singletonMap("agg", TermsAggregationBuilder.NAME).             Arrays.stream(rollupJobConfig.getGroupConfig().getTerms().getFields()).forEach(field -> {                 List<Map<String, Object>> caps = tempFieldCaps.getOrDefault(field, new ArrayList<>()).                 caps.add(termsAggCap).                 tempFieldCaps.put(field, caps).             }).         }     }     // Create RollupFieldCaps for the metrics     final List<MetricConfig> metricsConfig = rollupJobConfig.getMetricsConfig().     if (metricsConfig.size() > 0) {         rollupJobConfig.getMetricsConfig().forEach(metricConfig -> {             final List<Map<String, Object>> metrics = metricConfig.getMetrics().stream().map(metric -> singletonMap("agg", (Object) metric)).collect(Collectors.toList()).             metrics.forEach(m -> {                 List<Map<String, Object>> caps = tempFieldCaps.getOrDefault(metricConfig.getField(), new ArrayList<>()).                 caps.add(m).                 tempFieldCaps.put(metricConfig.getField(), caps).             }).         }).     }     return Collections.unmodifiableMap(tempFieldCaps.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> new RollupFieldCaps(e.getValue())))). }
false;public;0;3;;public List<Map<String, Object>> getAggs() {     return aggs. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeInt(aggs.size()).     for (Map<String, Object> agg : aggs) {         out.writeMap(agg).     } }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     for (Map<String, Object> agg : aggs) {         builder.map(agg).     }     return builder. }
false;public;1;13;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     RollupFieldCaps that = (RollupFieldCaps) other.     return Objects.equals(this.aggs, that.aggs). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(aggs). }
