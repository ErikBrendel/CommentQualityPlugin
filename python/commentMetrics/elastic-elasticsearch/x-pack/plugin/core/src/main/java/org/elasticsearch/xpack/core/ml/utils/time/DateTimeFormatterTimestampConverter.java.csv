commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;23;/**  * Creates a formatter according to the given pattern  * @param pattern the pattern to be used by the formatter, not null.  * See {@link DateTimeFormatter} for the syntax of the accepted patterns  * @param defaultTimezone the timezone to be used for dates without timezone information.  * @return a {@code TimestampConverter}  * @throws IllegalArgumentException if the pattern is invalid or cannot produce a full timestamp  * (e.g. contains a date but not a time)  */ ;/**  * Creates a formatter according to the given pattern  * @param pattern the pattern to be used by the formatter, not null.  * See {@link DateTimeFormatter} for the syntax of the accepted patterns  * @param defaultTimezone the timezone to be used for dates without timezone information.  * @return a {@code TimestampConverter}  * @throws IllegalArgumentException if the pattern is invalid or cannot produce a full timestamp  * (e.g. contains a date but not a time)  */ public static TimestampConverter ofPattern(String pattern, ZoneId defaultTimezone) {     DateTimeFormatter formatter = new DateTimeFormatterBuilder().parseLenient().appendPattern(pattern).parseDefaulting(ChronoField.YEAR_OF_ERA, LocalDate.now(defaultTimezone).getYear()).toFormatter().     String formattedTime = formatter.format(ZonedDateTime.ofInstant(Instant.ofEpochSecond(0), ZoneOffset.UTC)).     try {         TemporalAccessor parsed = formatter.parse(formattedTime).         boolean hasTimeZone = parsed.isSupported(ChronoField.INSTANT_SECONDS).         if (hasTimeZone) {             Instant.from(parsed).         } else {             LocalDateTime.from(parsed).         }         return new DateTimeFormatterTimestampConverter(formatter, hasTimeZone, defaultTimezone).     } catch (DateTimeException e) {         throw new IllegalArgumentException("Timestamp cannot be derived from pattern: " + pattern, e).     } }
false;public;1;4;;@Override public long toEpochSeconds(String timestamp) {     return toInstant(timestamp).getEpochSecond(). }
false;public;1;4;;@Override public long toEpochMillis(String timestamp) {     return toInstant(timestamp).toEpochMilli(). }
false;private;1;7;;private Instant toInstant(String timestamp) {     TemporalAccessor parsed = formatter.parse(timestamp).     if (hasTimeZone) {         return Instant.from(parsed).     }     return toInstantUnsafelyIgnoringAmbiguity(parsed). }
false;private;1;4;;@SuppressForbidden(reason = "TODO https://github.com/elastic/x-pack-elasticsearch/issues/3810") private Instant toInstantUnsafelyIgnoringAmbiguity(TemporalAccessor parsed) {     return LocalDateTime.from(parsed).atZone(defaultZoneId).toInstant(). }
