commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;3;;public final String getId() {     return id. }
false;public,final;0;3;;public final long getFrequency() {     return frequency. }
true;final;2;46;/**  * Calculates the delay for the next trigger time. When <code>now</code> is in a  * valid time bracket with respect to <code>expirationDate</code>, the delay is 0.  * When <code>now</code> is before the time bracket, than delay to the start of the  * time bracket and when <code>now</code> is passed the valid time bracket, the delay  * is <code>null</code>  * @param expirationDate license expiry date in milliseconds  * @param now current time in milliseconds  * @return time delay  */ ;/**  * Calculates the delay for the next trigger time. When <code>now</code> is in a  * valid time bracket with respect to <code>expirationDate</code>, the delay is 0.  * When <code>now</code> is before the time bracket, than delay to the start of the  * time bracket and when <code>now</code> is passed the valid time bracket, the delay  * is <code>null</code>  * @param expirationDate license expiry date in milliseconds  * @param now current time in milliseconds  * @return time delay  */ final TimeValue delay(long expirationDate, long now) {     final TimeValue delay.     switch(orientation) {         case PRE:             if (expirationDate >= now) {                 // license not yet expired                 long preExpiryDuration = expirationDate - now.                 if (preExpiryDuration > max) {                     // license duration is longer than maximum duration, delay it to the first match time                     delay = TimeValue.timeValueMillis(preExpiryDuration - max).                 } else if (preExpiryDuration <= max && preExpiryDuration >= min) {                     // no delay in valid time bracket                     delay = TimeValue.timeValueMillis(0).                 } else {                     // passed last match time                     delay = null.                 }             } else {                 // invalid after license expiry                 delay = null.             }             break.         case POST:             if (expirationDate >= now) {                 // license not yet expired, delay it to the first match time                 delay = TimeValue.timeValueMillis(expirationDate - now + min).             } else {                 // license has expired                 long expiredDuration = now - expirationDate.                 if (expiredDuration < min) {                     // license expiry duration is shorter than minimum duration, delay it to the first match time                     delay = TimeValue.timeValueMillis(min - expiredDuration).                 } else if (expiredDuration >= min && expiredDuration <= max) {                     // no delay in valid time bracket                     delay = TimeValue.timeValueMillis(0).                 } else {                     // passed last match time                     delay = null.                 }             }             break.         default:             throw new IllegalStateException("orientation [" + orientation + "] unknown").     }     return delay. }
true;public,final;3;19;/**  * {@link org.elasticsearch.xpack.core.scheduler.SchedulerEngine.Schedule#nextScheduledTimeAfter(long, long)}  * with respect to license expiry date  */ ;/**  * {@link org.elasticsearch.xpack.core.scheduler.SchedulerEngine.Schedule#nextScheduledTimeAfter(long, long)}  * with respect to license expiry date  */ public final long nextScheduledTimeForExpiry(long expiryDate, long startTime, long time) {     TimeValue delay = delay(expiryDate, time).     if (delay != null) {         long delayInMillis = delay.getMillis().         if (delayInMillis == 0L) {             if (startTime == time) {                 // initial trigger and in time bracket, schedule immediately                 return time.             } else {                 // in time bracket, add frequency                 return time + frequency.             }         } else {             // not in time bracket             return time + delayInMillis.         }     }     return -1. }
true;public,abstract;1;1;/**  * Code to execute when the expiry callback is triggered in a valid  * time bracket  * @param license license to operate on  */ ;/**  * Code to execute when the expiry callback is triggered in a valid  * time bracket  * @param license license to operate on  */ public abstract void on(License license).
false;public,final;0;5;;public final String toString() {     return LoggerMessageFormat.format(null, "ExpirationCallback:(orientation [{}],  min [{}], max [{}], freq [{}])", orientation.name(), TimeValue.timeValueMillis(min), TimeValue.timeValueMillis(max), TimeValue.timeValueMillis(frequency)). }
