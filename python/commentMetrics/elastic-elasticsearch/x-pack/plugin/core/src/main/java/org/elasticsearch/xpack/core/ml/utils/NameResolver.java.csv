commented;modifiers;parameterAmount;loc;comment;code
true;public;2;33;/**  * Expands an expression into the set of matching names.  * For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],  * expressions resolve follows:  * <ul>  *     <li>"foo-1" : ["foo-1"]</li>  *     <li>"bar-1" : ["bar-1"]</li>  *     <li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>  *     <li>"foo-*" : ["foo-1", "foo-2"]</li>  *     <li>"*-1" : ["bar-1", "foo-1"]</li>  *     <li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  *     <li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  * </ul>  *  * @param expression the expression to resolve  * @param allowNoMatch if {@code false}, an error is thrown when no name matches the {@code expression}.  *                     This only applies to wild card expressions, if {@code expression} is not a  *                     wildcard then setting this true will not suppress the exception  * @return the sorted set of matching names  */ ;/**  * Expands an expression into the set of matching names.  * For example, given a set of names ["foo-1", "foo-2", "bar-1", bar-2"],  * expressions resolve follows:  * <ul>  *     <li>"foo-1" : ["foo-1"]</li>  *     <li>"bar-1" : ["bar-1"]</li>  *     <li>"foo-1,foo-2" : ["foo-1", "foo-2"]</li>  *     <li>"foo-*" : ["foo-1", "foo-2"]</li>  *     <li>"*-1" : ["bar-1", "foo-1"]</li>  *     <li>"*" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  *     <li>"_all" : ["bar-1", "bar-2", "foo-1", "foo-2"]</li>  * </ul>  *  * @param expression the expression to resolve  * @param allowNoMatch if {@code false}, an error is thrown when no name matches the {@code expression}.  *                     This only applies to wild card expressions, if {@code expression} is not a  *                     wildcard then setting this true will not suppress the exception  * @return the sorted set of matching names  */ public SortedSet<String> expand(String expression, boolean allowNoMatch) {     SortedSet<String> result = new TreeSet<>().     if (MetaData.ALL.equals(expression) || Regex.isMatchAllPattern(expression)) {         result.addAll(nameSet()).     } else {         String[] tokens = Strings.tokenizeToStringArray(expression, ",").         for (String token : tokens) {             if (Regex.isSimpleMatchPattern(token)) {                 List<String> expanded = keys().stream().filter(key -> Regex.simpleMatch(token, key)).map(this::lookup).flatMap(List::stream).collect(Collectors.toList()).                 if (expanded.isEmpty() && allowNoMatch == false) {                     throw notFoundExceptionSupplier.apply(token).                 }                 result.addAll(expanded).             } else {                 List<String> matchingNames = lookup(token).                 // this isn't so don't check the allowNoMatch here                 if (matchingNames.isEmpty()) {                     throw notFoundExceptionSupplier.apply(token).                 }                 result.addAll(matchingNames).             }         }     }     if (result.isEmpty() && allowNoMatch == false) {         throw notFoundExceptionSupplier.apply(expression).     }     return result. }
true;protected,abstract;0;1;/**  * @return the set of registered keys  */ ;/**  * @return the set of registered keys  */ protected abstract Set<String> keys().
true;protected,abstract;0;1;/**  * @return the set of all names  */ ;/**  * @return the set of all names  */ protected abstract Set<String> nameSet().
true;protected,abstract;1;1;/**  * Looks up a key and returns the matching names.  * @param key the key to look up  * @return a list of the matching names or {@code null} when no matching names exist  */ ;/**  * Looks up a key and returns the matching names.  * @param key the key to look up  * @return a list of the matching names or {@code null} when no matching names exist  */ protected abstract List<String> lookup(String key).
false;protected;0;4;;@Override protected Set<String> keys() {     return nameSet. }
false;protected;0;4;;@Override protected Set<String> nameSet() {     return nameSet. }
false;protected;1;4;;@Override protected List<String> lookup(String key) {     return nameSet.contains(key) ? Collections.singletonList(key) : Collections.emptyList(). }
true;public,static;2;18;/**  * Creates a {@code NameResolver} that has no aliases  * @param nameSet the set of all names  * @param notFoundExceptionSupplier a supplier of {@link ResourceNotFoundException} to be used when an expression matches no name  * @return the unaliased {@code NameResolver}  */ ;/**  * Creates a {@code NameResolver} that has no aliases  * @param nameSet the set of all names  * @param notFoundExceptionSupplier a supplier of {@link ResourceNotFoundException} to be used when an expression matches no name  * @return the unaliased {@code NameResolver}  */ public static NameResolver newUnaliased(Set<String> nameSet, Function<String, ResourceNotFoundException> notFoundExceptionSupplier) {     return new NameResolver(notFoundExceptionSupplier) {          @Override         protected Set<String> keys() {             return nameSet.         }          @Override         protected Set<String> nameSet() {             return nameSet.         }          @Override         protected List<String> lookup(String key) {             return nameSet.contains(key) ? Collections.singletonList(key) : Collections.emptyList().         }     }. }
