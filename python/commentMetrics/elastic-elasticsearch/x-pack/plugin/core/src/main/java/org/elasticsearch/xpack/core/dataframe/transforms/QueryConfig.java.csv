commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.map(source).     return builder. }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeMap(source).     out.writeOptionalNamedWriteable(query). }
false;public;0;3;;public QueryBuilder getQuery() {     return query. }
false;public,static;2;23;;public static QueryConfig fromXContent(final XContentParser parser, boolean lenient) throws IOException {     // we need 2 passes, but the parser can not be cloned, so we parse 1st into a map and then re-parse that for syntax checking     // remember the registry, needed for the 2nd pass     NamedXContentRegistry registry = parser.getXContentRegistry().     Map<String, Object> source = parser.mapOrdered().     QueryBuilder query = null.     try (XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().map(source).         XContentParser sourceParser = XContentType.JSON.xContent().createParser(registry, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(xContentBuilder).streamInput())) {         query = AbstractQueryBuilder.parseInnerQueryBuilder(sourceParser).     } catch (Exception e) {         if (lenient) {             logger.warn(DataFrameMessages.LOG_DATA_FRAME_TRANSFORM_CONFIGURATION_BAD_QUERY, e).         } else {             throw e.         }     }     return new QueryConfig(source, query). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(source, query). }
false;public;1;14;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     final QueryConfig that = (QueryConfig) other.     return Objects.equals(this.source, that.source) && Objects.equals(this.query, that.query). }
false;public;0;3;;public boolean isValid() {     return this.query != null. }
