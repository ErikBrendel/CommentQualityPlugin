commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;5;/**  * Case-insensitive from string method.  * Works with either JSON, json, etc.  *  * @param value String representation  * @return The data format  */ ;/**  * Case-insensitive from string method.  * Works with either JSON, json, etc.  *  * @param value String representation  * @return The data format  */ public static DataFormat forString(String value) {     String valueUpperCase = value.toUpperCase(Locale.ROOT).     return DEPRECATED_DELINEATED.equals(valueUpperCase) ? DELIMITED : DataFormat.valueOf(valueUpperCase). }
false;public,static;1;3;;public static DataFormat readFromStream(StreamInput in) throws IOException {     return in.readEnum(DataFormat.class). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
false;private,static;1;12;;private static ObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {     ObjectParser<Builder, Void> parser = new ObjectParser<>(DATA_DESCRIPTION_FIELD.getPreferredName(), ignoreUnknownFields, Builder::new).     parser.declareString(Builder::setFormat, FORMAT_FIELD).     parser.declareString(Builder::setTimeField, TIME_FIELD_NAME_FIELD).     parser.declareString(Builder::setTimeFormat, TIME_FORMAT_FIELD).     parser.declareField(Builder::setFieldDelimiter, DataDescription::extractChar, FIELD_DELIMITER_FIELD, ValueType.STRING).     parser.declareField(Builder::setQuoteCharacter, DataDescription::extractChar, QUOTE_CHARACTER_FIELD, ValueType.STRING).     return parser. }
false;public;1;18;;@Override public void writeTo(StreamOutput out) throws IOException {     dataFormat.writeTo(out).     out.writeString(timeFieldName).     out.writeString(timeFormat).     if (fieldDelimiter != null) {         out.writeBoolean(true).         out.write(fieldDelimiter).     } else {         out.writeBoolean(false).     }     if (quoteCharacter != null) {         out.writeBoolean(true).         out.write(quoteCharacter).     } else {         out.writeBoolean(false).     } }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (dataFormat != DataFormat.XCONTENT) {         builder.field(FORMAT_FIELD.getPreferredName(), dataFormat).     }     builder.field(TIME_FIELD_NAME_FIELD.getPreferredName(), timeFieldName).     builder.field(TIME_FORMAT_FIELD.getPreferredName(), timeFormat).     if (fieldDelimiter != null) {         builder.field(FIELD_DELIMITER_FIELD.getPreferredName(), String.valueOf(fieldDelimiter)).     }     if (quoteCharacter != null) {         builder.field(QUOTE_CHARACTER_FIELD.getPreferredName(), String.valueOf(quoteCharacter)).     }     builder.endObject().     return builder. }
true;public;0;3;/**  * The format of the data to be processed.  * Defaults to {@link DataDescription.DataFormat#XCONTENT}  *  * @return The data format  */ ;/**  * The format of the data to be processed.  * Defaults to {@link DataDescription.DataFormat#XCONTENT}  *  * @return The data format  */ public DataFormat getFormat() {     return dataFormat. }
true;public;0;3;/**  * The name of the field containing the timestamp  *  * @return A String if set or <code>null</code>  */ ;/**  * The name of the field containing the timestamp  *  * @return A String if set or <code>null</code>  */ public String getTimeField() {     return timeFieldName. }
true;public;0;3;/**  * Either {@value #EPOCH}, {@value #EPOCH_MS} or a SimpleDateTime format string.  * If not set (is <code>null</code> or an empty string) or set to  * {@value #EPOCH_MS} (the default) then the date is assumed to be in  * milliseconds from the epoch.  *  * @return A String if set or <code>null</code>  */ ;/**  * Either {@value #EPOCH}, {@value #EPOCH_MS} or a SimpleDateTime format string.  * If not set (is <code>null</code> or an empty string) or set to  * {@value #EPOCH_MS} (the default) then the date is assumed to be in  * milliseconds from the epoch.  *  * @return A String if set or <code>null</code>  */ public String getTimeFormat() {     return timeFormat. }
true;public;0;3;/**  * If the data is in a delineated format with a header e.g. csv or tsv  * this is the delimiter character used. This is only applicable if  * {@linkplain #getFormat()} is {@link DataDescription.DataFormat#DELIMITED}.  * The default value for delimited format is {@value #DEFAULT_DELIMITER}.  *  * @return A char  */ ;/**  * If the data is in a delineated format with a header e.g. csv or tsv  * this is the delimiter character used. This is only applicable if  * {@linkplain #getFormat()} is {@link DataDescription.DataFormat#DELIMITED}.  * The default value for delimited format is {@value #DEFAULT_DELIMITER}.  *  * @return A char  */ public Character getFieldDelimiter() {     return fieldDelimiter. }
true;public;0;3;/**  * The quote character used in delineated formats.  * The default value for delimited format is {@value #DEFAULT_QUOTE_CHAR}.  *  * @return The delineated format quote character  */ ;/**  * The quote character used in delineated formats.  * The default value for delimited format is {@value #DEFAULT_QUOTE_CHAR}.  *  * @return The delineated format quote character  */ public Character getQuoteCharacter() {     return quoteCharacter. }
true;public;0;3;/**  * Returns true if the data described by this object needs  * transforming before processing by autodetect.  * A transformation must be applied if either a timeformat is  * not in seconds since the epoch or the data is in Json format.  *  * @return True if the data should be transformed.  */ ;/**  * Returns true if the data described by this object needs  * transforming before processing by autodetect.  * A transformation must be applied if either a timeformat is  * not in seconds since the epoch or the data is in Json format.  *  * @return True if the data should be transformed.  */ public boolean transform() {     return dataFormat == DataFormat.XCONTENT || isTransformTime(). }
true;public;0;3;/**  * Return true if the time is in a format that needs transforming.  * Anytime format this isn't {@value #EPOCH} or <code>null</code>  * needs transforming.  *  * @return True if the time field needs to be transformed.  */ ;/**  * Return true if the time is in a format that needs transforming.  * Anytime format this isn't {@value #EPOCH} or <code>null</code>  * needs transforming.  *  * @return True if the time field needs to be transformed.  */ public boolean isTransformTime() {     return timeFormat != null && !EPOCH.equals(timeFormat). }
true;public;0;3;/**  * Return true if the time format is {@value #EPOCH_MS}  *  * @return True if the date is in milli-seconds since the epoch.  */ ;/**  * Return true if the time format is {@value #EPOCH_MS}  *  * @return True if the date is in milli-seconds since the epoch.  */ public boolean isEpochMs() {     return EPOCH_MS.equals(timeFormat). }
false;private,static;1;10;;private static Character extractChar(XContentParser parser) throws IOException {     if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {         String charStr = parser.text().         if (charStr.length() != 1) {             throw new IllegalArgumentException("String must be a single character, found [" + charStr + "]").         }         return charStr.charAt(0).     }     throw new IllegalArgumentException("Unsupported token [" + parser.currentToken() + "]"). }
true;public;1;18;/**  * Overridden equality test  */ ;/**  * Overridden equality test  */ @Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other instanceof DataDescription == false) {         return false.     }     DataDescription that = (DataDescription) other.     return this.dataFormat == that.dataFormat && Objects.equals(this.quoteCharacter, that.quoteCharacter) && Objects.equals(this.timeFieldName, that.timeFieldName) && Objects.equals(this.timeFormat, that.timeFormat) && Objects.equals(this.fieldDelimiter, that.fieldDelimiter). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(dataFormat, quoteCharacter, timeFieldName, timeFormat, fieldDelimiter). }
false;public;1;3;;public void setFormat(DataFormat format) {     dataFormat = ExceptionsHelper.requireNonNull(format, FORMAT_FIELD.getPreferredName() + " must not be null"). }
false;private;1;3;;private void setFormat(String format) {     setFormat(DataFormat.forString(format)). }
false;public;1;3;;public void setTimeField(String fieldName) {     timeFieldName = ExceptionsHelper.requireNonNull(fieldName, TIME_FIELD_NAME_FIELD.getPreferredName() + " must not be null"). }
false;public;1;16;;public void setTimeFormat(String format) {     ExceptionsHelper.requireNonNull(format, TIME_FORMAT_FIELD.getPreferredName() + " must not be null").     switch(format) {         case EPOCH:         case EPOCH_MS:             break.         default:             try {                 DateTimeFormatterTimestampConverter.ofPattern(format, ZoneOffset.UTC).             } catch (IllegalArgumentException e) {                 throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.JOB_CONFIG_INVALID_TIMEFORMAT, format), e.getCause()).             }     }     timeFormat = format. }
false;public;1;3;;public void setFieldDelimiter(Character delimiter) {     fieldDelimiter = delimiter. }
false;public;1;3;;public void setQuoteCharacter(Character value) {     quoteCharacter = value. }
false;public;0;11;;public DataDescription build() {     if (dataFormat == DataFormat.DELIMITED) {         if (fieldDelimiter == null) {             fieldDelimiter = DEFAULT_DELIMITER.         }         if (quoteCharacter == null) {             quoteCharacter = DEFAULT_QUOTE_CHAR.         }     }     return new DataDescription(dataFormat, timeFieldName, timeFormat, fieldDelimiter, quoteCharacter). }
