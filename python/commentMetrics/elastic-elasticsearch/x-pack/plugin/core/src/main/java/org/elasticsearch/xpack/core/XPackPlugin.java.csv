commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override public Void run() {     try {         Class.forName("com.unboundid.util.Debug").         Class.forName("com.unboundid.ldap.sdk.LDAPConnectionOptions").     } catch (ClassNotFoundException e) {         throw new RuntimeException(e).     }     return null. }
true;protected;0;3;// overridable by tests ;// overridable by tests protected Clock getClock() {     return Clock.systemUTC(). }
false;protected;0;1;;protected SSLService getSslService() {     return getSharedSslService(). }
false;protected;0;1;;protected LicenseService getLicenseService() {     return getSharedLicenseService(). }
false;protected;0;1;;protected XPackLicenseState getLicenseState() {     return getSharedLicenseState(). }
false;protected;1;1;;protected void setSslService(SSLService sslService) {     XPackPlugin.sslService.set(sslService). }
false;protected;1;1;;protected void setLicenseService(LicenseService licenseService) {     XPackPlugin.licenseService.set(licenseService). }
false;protected;1;1;;protected void setLicenseState(XPackLicenseState licenseState) {     XPackPlugin.licenseState.set(licenseState). }
false;public,static;0;1;;public static SSLService getSharedSslService() {     return sslService.get(). }
false;public,static;0;1;;public static LicenseService getSharedLicenseService() {     return licenseService.get(). }
false;public,static;0;1;;public static XPackLicenseState getSharedLicenseState() {     return licenseState.get(). }
true;public,static;1;9;/**  * Checks if the cluster state allows this node to add x-pack metadata to the cluster state,  * and throws an exception otherwise.  * This check should be called before installing any x-pack metadata to the cluster state,  * to ensure that the other nodes that are part of the cluster will be able to deserialize  * that metadata. Note that if the cluster state already contains x-pack metadata, this  * check assumes that the nodes are already ready to receive additional x-pack metadata.  * Having this check properly in place everywhere allows to install x-pack into a cluster  * using a rolling restart.  */ ;/**  * Checks if the cluster state allows this node to add x-pack metadata to the cluster state,  * and throws an exception otherwise.  * This check should be called before installing any x-pack metadata to the cluster state,  * to ensure that the other nodes that are part of the cluster will be able to deserialize  * that metadata. Note that if the cluster state already contains x-pack metadata, this  * check assumes that the nodes are already ready to receive additional x-pack metadata.  * Having this check properly in place everywhere allows to install x-pack into a cluster  * using a rolling restart.  */ public static void checkReadyForXPackCustomMetadata(ClusterState clusterState) {     if (alreadyContainsXPackCustomMetadata(clusterState)) {         return.     }     List<DiscoveryNode> notReadyNodes = nodesNotReadyForXPackCustomMetadata(clusterState).     if (notReadyNodes.isEmpty() == false) {         throw new IllegalStateException("The following nodes are not ready yet for enabling x-pack custom metadata: " + notReadyNodes).     } }
true;public,static;1;3;/**  * Checks if the cluster state allows this node to add x-pack metadata to the cluster state.  * See {@link #checkReadyForXPackCustomMetadata} for more details.  */ ;/**  * Checks if the cluster state allows this node to add x-pack metadata to the cluster state.  * See {@link #checkReadyForXPackCustomMetadata} for more details.  */ public static boolean isReadyForXPackCustomMetadata(ClusterState clusterState) {     return alreadyContainsXPackCustomMetadata(clusterState) || nodesNotReadyForXPackCustomMetadata(clusterState).isEmpty(). }
true;public,static;1;13;/**  * Returns the list of nodes that won't allow this node from adding x-pack metadata to the cluster state.  * See {@link #checkReadyForXPackCustomMetadata} for more details.  */ ;/**  * Returns the list of nodes that won't allow this node from adding x-pack metadata to the cluster state.  * See {@link #checkReadyForXPackCustomMetadata} for more details.  */ public static List<DiscoveryNode> nodesNotReadyForXPackCustomMetadata(ClusterState clusterState) {     // check that all nodes would be capable of deserializing newly added x-pack metadata     final List<DiscoveryNode> notReadyNodes = StreamSupport.stream(clusterState.nodes().spliterator(), false).filter(node -> {         final String xpackInstalledAttr = node.getAttributes().getOrDefault(XPACK_INSTALLED_NODE_ATTR, "false").         // we want to prevent x-pack from adding custom metadata         return node.getVersion().before(Version.V_6_3_0) || Booleans.parseBoolean(xpackInstalledAttr) == false.     }).collect(Collectors.toList()).     return notReadyNodes. }
false;private,static;1;7;;private static boolean alreadyContainsXPackCustomMetadata(ClusterState clusterState) {     final MetaData metaData = clusterState.metaData().     return metaData.custom(LicensesMetaData.TYPE) != null || metaData.custom(MlMetadata.TYPE) != null || metaData.custom(WatcherMetaData.TYPE) != null || clusterState.custom(TokenMetaData.TYPE) != null. }
false;public;0;14;;@Override public Settings additionalSettings() {     final String xpackInstalledNodeAttrSetting = "node.attr." + XPACK_INSTALLED_NODE_ATTR.     if (settings.get(xpackInstalledNodeAttrSetting) != null) {         throw new IllegalArgumentException("Directly setting [" + xpackInstalledNodeAttrSetting + "] is not permitted").     }     if (transportClientMode) {         return super.additionalSettings().     } else {         return Settings.builder().put(super.additionalSettings()).put(xpackInstalledNodeAttrSetting, "true").build().     } }
false;public;0;12;;@Override public Collection<Module> createGuiceModules() {     ArrayList<Module> modules = new ArrayList<>().     // modules.add(b -> b.bind(Clock.class).toInstance(getClock())).     // used to get core up and running, we do not bind the actual feature set here     modules.add(b -> XPackPlugin.createFeatureSetMultiBinder(b, EmptyXPackFeatureSet.class)).     if (transportClientMode) {         modules.add(b -> b.bind(XPackLicenseState.class).toProvider(Providers.of(null))).     }     return modules. }
false;public;9;20;;@Override public Collection<Object> createComponents(Client client, ClusterService clusterService, ThreadPool threadPool, ResourceWatcherService resourceWatcherService, ScriptService scriptService, NamedXContentRegistry xContentRegistry, Environment environment, NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry) {     List<Object> components = new ArrayList<>().     // just create the reloader as it will pull all of the loaded ssl configurations and start watching them     new SSLConfigurationReloader(environment, getSslService(), resourceWatcherService).     setLicenseService(new LicenseService(settings, clusterService, getClock(), environment, resourceWatcherService, getLicenseState())).     // It is useful to override these as they are what guice is injecting into actions     components.add(getSslService()).     components.add(getLicenseService()).     components.add(getLicenseState()).     return components. }
false;public;0;10;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> actions = new ArrayList<>().     actions.add(new ActionHandler<>(XPackInfoAction.INSTANCE, TransportXPackInfoAction.class)).     actions.add(new ActionHandler<>(XPackUsageAction.INSTANCE, TransportXPackUsageAction.class)).     actions.add(new ActionHandler<>(TransportFreezeIndexAction.FreezeIndexAction.INSTANCE, TransportFreezeIndexAction.class)).     actions.addAll(licensing.getActions()).     return actions. }
false;public;0;7;;@Override public List<Action<? extends ActionResponse>> getClientActions() {     List<Action<? extends ActionResponse>> actions = new ArrayList<>().     actions.addAll(licensing.getClientActions()).     actions.addAll(super.getClientActions()).     return actions. }
false;public;0;6;;@Override public List<ActionFilter> getActionFilters() {     List<ActionFilter> filters = new ArrayList<>().     filters.addAll(licensing.getActionFilters()).     return filters. }
false;public;7;12;;@Override public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {     List<RestHandler> handlers = new ArrayList<>().     handlers.add(new RestXPackInfoAction(settings, restController)).     handlers.add(new RestXPackUsageAction(settings, restController)).     handlers.add(new RestFreezeIndexAction(settings, restController)).     handlers.addAll(licensing.getRestHandlers(settings, restController, clusterSettings, indexScopedSettings, settingsFilter, indexNameExpressionResolver, nodesInCluster)).     return handlers. }
false;public,static;2;4;;public static void bindFeatureSet(Binder binder, Class<? extends XPackFeatureSet> featureSet) {     Multibinder<XPackFeatureSet> featureSetBinder = createFeatureSetMultiBinder(binder, featureSet).     featureSetBinder.addBinding().to(featureSet). }
false;public,static;2;4;;public static Multibinder<XPackFeatureSet> createFeatureSetMultiBinder(Binder binder, Class<? extends XPackFeatureSet> featureSet) {     binder.bind(featureSet).asEagerSingleton().     return Multibinder.newSetBinder(binder, XPackFeatureSet.class). }
false;public,static;1;3;;public static boolean transportClientMode(Settings settings) {     return TransportClient.CLIENT_TYPE.equals(settings.get(Client.CLIENT_TYPE_SETTING_S.getKey())). }
false;public,static;2;12;;public static Path resolveConfigFile(Environment env, String name) {     Path config = env.configFile().resolve(name).     if (Files.exists(config) == false) {         Path legacyConfig = env.configFile().resolve("x-pack").resolve(name).         if (Files.exists(legacyConfig)) {             deprecationLogger.deprecated("Config file [" + name + "] is in a deprecated location. Move from " + legacyConfig.toString() + " to " + config.toString()).             return legacyConfig.         }     }     return config. }
false;default;0;4;;@Override default Optional<String> getRequiredFeature() {     return XPackClientPlugin.X_PACK_FEATURE. }
false;default;0;4;;@Override default Optional<String> getRequiredFeature() {     return XPackClientPlugin.X_PACK_FEATURE. }
false;default;0;4;;@Override default Optional<String> getRequiredFeature() {     return XPackClientPlugin.X_PACK_FEATURE. }
false;public;2;4;;@Override public Map<String, Repository.Factory> getRepositories(Environment env, NamedXContentRegistry namedXContentRegistry) {     return Collections.singletonMap("source", SourceOnlySnapshotRepository.newRepositoryFactory()). }
false;public;1;10;;@Override public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {     if (indexSettings.getValue(SourceOnlySnapshotRepository.SOURCE_ONLY)) {         return Optional.of(SourceOnlySnapshotRepository.getEngineFactory()).     } else if (indexSettings.getValue(FrozenEngine.INDEX_FROZEN)) {         return Optional.of(FrozenEngine::new).     }     return Optional.empty(). }
false;public;0;7;;@Override public List<Setting<?>> getSettings() {     List<Setting<?>> settings = super.getSettings().     settings.add(SourceOnlySnapshotRepository.SOURCE_ONLY).     settings.add(FrozenEngine.INDEX_FROZEN).     return settings. }
false;public;1;7;;@Override public void onIndexModule(IndexModule indexModule) {     if (FrozenEngine.INDEX_FROZEN.get(indexModule.getSettings())) {         indexModule.addSearchOperationListener(new FrozenEngine.ReacquireEngineSearcherListener()).     }     super.onIndexModule(indexModule). }
