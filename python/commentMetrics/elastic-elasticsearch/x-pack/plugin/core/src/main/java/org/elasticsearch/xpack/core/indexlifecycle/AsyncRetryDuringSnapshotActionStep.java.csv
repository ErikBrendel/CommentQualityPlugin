commented;modifiers;parameterAmount;loc;comment;code
false;public;4;7;;@Override public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer, Listener listener) {     // Wrap the original listener to handle exceptions caused by ongoing snapshots     SnapshotExceptionListener snapshotExceptionListener = new SnapshotExceptionListener(indexMetaData.getIndex(), listener, observer).     performDuringNoSnapshot(indexMetaData, currentClusterState, snapshotExceptionListener). }
true;abstract;3;1;/**  * Method to be performed during which no snapshots for the index are already underway.  */ ;/**  * Method to be performed during which no snapshots for the index are already underway.  */ abstract void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener).
false;public;1;4;;@Override public void onResponse(boolean complete) {     originalListener.onResponse(complete). }
false;public;1;28;;@Override public void onFailure(Exception e) {     if (e instanceof SnapshotInProgressException) {         try {             logger.debug("[{}] attempted to run ILM step but a snapshot is in progress, step will retry at a later time", index.getName()).             observer.waitForNextChange(new NoSnapshotRunningListener(observer, index.getName(), state -> {                 IndexMetaData idxMeta = state.metaData().index(index).                 if (idxMeta == null) {                     // The index has since been deleted, mission accomplished!                     originalListener.onResponse(true).                 }                 // Re-invoke the performAction method with the new state                 performAction(idxMeta, state, observer, originalListener).             }, originalListener::onFailure), // TODO: what is a good timeout value for no new state received during this time?             TimeValue.timeValueHours(12)).         } catch (Exception secondError) {             // There was a second error trying to set up an observer,             // fail the original listener             secondError.addSuppressed(e).             originalListener.onFailure(secondError).         }     } else {         originalListener.onFailure(e).     } }
false;public;1;13;;@Override public void onNewClusterState(ClusterState state) {     try {         if (snapshotInProgress(state)) {             observer.waitForNextChange(this).         } else {             logger.debug("[{}] retrying ILM step after snapshot has completed", indexName).             reRun.accept(state).         }     } catch (Exception e) {         exceptionConsumer.accept(e).     } }
false;private;1;18;;private boolean snapshotInProgress(ClusterState state) {     SnapshotsInProgress snapshotsInProgress = state.custom(SnapshotsInProgress.TYPE).     if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {         // No snapshots are running, new state is acceptable to proceed         return false.     }     for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {         if (snapshot.indices().stream().map(IndexId::getName).anyMatch(name -> name.equals(indexName))) {             // There is a snapshot running with this index name             return true.         }     }     // There are snapshots, but none for this index, so it's okay to proceed with this state     return false. }
false;public;0;4;;@Override public void onClusterServiceClose() { // This means the cluster is being shut down, so nothing to do here }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) {     exceptionConsumer.accept(new IllegalStateException("step timed out while waiting for snapshots to complete")). }
