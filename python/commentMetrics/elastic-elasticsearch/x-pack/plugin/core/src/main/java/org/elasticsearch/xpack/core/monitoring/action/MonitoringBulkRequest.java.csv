commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return the list of {@link MonitoringBulkDoc} to be indexed  */ ;/**  * @return the list of {@link MonitoringBulkDoc} to be indexed  */ public Collection<MonitoringBulkDoc> getDocs() {     return Collections.unmodifiableCollection(new ArrayList<>(this.docs)). }
false;public;0;14;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (docs.isEmpty()) {         validationException = addValidationError("no monitoring documents added", validationException).     }     for (int i = 0. i < docs.size(). i++) {         MonitoringBulkDoc doc = docs.get(i).         if (doc.getSource() == null || doc.getSource().length() == 0) {             validationException = addValidationError("source is missing for monitoring document [" + i + "]", validationException).         }     }     return validationException. }
true;public;1;4;/**  * Adds a monitoring document to the list of documents to be indexed.  */ ;/**  * Adds a monitoring document to the list of documents to be indexed.  */ public MonitoringBulkRequest add(MonitoringBulkDoc doc) {     docs.add(doc).     return this. }
true;public;6;35;/**  * Parses a monitoring bulk request and builds the list of documents to be indexed.  */ ;/**  * Parses a monitoring bulk request and builds the list of documents to be indexed.  */ public MonitoringBulkRequest add(final MonitoredSystem system, final String defaultType, final BytesReference content, final XContentType xContentType, final long timestamp, final long intervalMillis) throws IOException {     // MonitoringBulkRequest accepts a body request that has the same format as the BulkRequest:     // instead of duplicating the parsing logic here we use a new BulkRequest instance to parse the content.     final BulkRequest bulkRequest = Requests.bulkRequest().add(content, null, defaultType, xContentType).     for (DocWriteRequest request : bulkRequest.requests()) {         if (request instanceof IndexRequest) {             final IndexRequest indexRequest = (IndexRequest) request.             // and it was duplicated anyway. by simply dropping it, we allow BWC for older clients that still send it             if (MonitoringIndex.from(indexRequest.index()) != MonitoringIndex.TIMESTAMPED) {                 continue.             }             final BytesReference source = indexRequest.source().             if (source.length() == 0) {                 throw new IllegalArgumentException("source is missing for monitoring document [" + indexRequest.index() + "][" + indexRequest.type() + "][" + indexRequest.id() + "]").             }             // builds a new monitoring document based on the index request             add(new MonitoringBulkDoc(system, indexRequest.type(), indexRequest.id(), timestamp, intervalMillis, source, xContentType)).         } else {             throw new IllegalArgumentException("monitoring bulk requests should only contain index requests").         }     }     return this. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     docs.addAll(in.readList(MonitoringBulkDoc::readFrom)). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeList(docs). }
