commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;4;/**  * Combines a user query with a time range query.  */ ;/**  * Combines a user query with a time range query.  */ public static QueryBuilder wrapInTimeRangeQuery(QueryBuilder userQuery, String timeField, long start, long end) {     QueryBuilder timeQuery = new RangeQueryBuilder(timeField).gte(start).lt(end).format(EPOCH_MILLIS).     return new BoolQueryBuilder().filter(userQuery).filter(timeQuery). }
true;public,static;2;15;/**  * Checks that a {@link SearchResponse} has an OK status code and no shard failures  */ ;/**  * Checks that a {@link SearchResponse} has an OK status code and no shard failures  */ public static void checkSearchWasSuccessful(String jobId, SearchResponse searchResponse) throws IOException {     if (searchResponse.status() != RestStatus.OK) {         throw new IOException("[" + jobId + "] Search request returned status code: " + searchResponse.status() + ". Response was:\n" + searchResponse.toString()).     }     ShardSearchFailure[] shardFailures = searchResponse.getShardFailures().     if (shardFailures != null && shardFailures.length > 0) {         LOGGER.error("[{}] Search request returned shard failures: {}", jobId, Arrays.toString(shardFailures)).         throw new IOException(ExceptionsHelper.shardFailuresToErrorMsg(jobId, shardFailures)).     }     int unavailableShards = searchResponse.getTotalShards() - searchResponse.getSuccessfulShards().     if (unavailableShards > 0) {         throw new IOException("[" + jobId + "] Search request encountered [" + unavailableShards + "] unavailable shards").     } }
true;public,static;1;4;/**  * Find the (date) histogram in {@code aggFactory} and extract its interval.  * Throws if there is no (date) histogram or if the histogram has sibling  * aggregations.  * @param aggFactory Aggregations factory  * @return The histogram interval  */ ;/**  * Find the (date) histogram in {@code aggFactory} and extract its interval.  * Throws if there is no (date) histogram or if the histogram has sibling  * aggregations.  * @param aggFactory Aggregations factory  * @return The histogram interval  */ public static long getHistogramIntervalMillis(AggregatorFactories.Builder aggFactory) {     AggregationBuilder histogram = getHistogramAggregation(aggFactory.getAggregatorFactories()).     return getHistogramIntervalMillis(histogram). }
true;public,static;1;15;/**  * Find and return (date) histogram in {@code aggregations}  * @param aggregations List of aggregations  * @return A {@link HistogramAggregationBuilder} or a {@link DateHistogramAggregationBuilder}  */ ;/**  * Find and return (date) histogram in {@code aggregations}  * @param aggregations List of aggregations  * @return A {@link HistogramAggregationBuilder} or a {@link DateHistogramAggregationBuilder}  */ public static AggregationBuilder getHistogramAggregation(Collection<AggregationBuilder> aggregations) {     if (aggregations.isEmpty()) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.DATAFEED_AGGREGATIONS_REQUIRES_DATE_HISTOGRAM)).     }     if (aggregations.size() != 1) {         throw ExceptionsHelper.badRequestException(Messages.DATAFEED_AGGREGATIONS_REQUIRES_DATE_HISTOGRAM_NO_SIBLINGS).     }     AggregationBuilder agg = aggregations.iterator().next().     if (isHistogram(agg)) {         return agg.     } else {         return getHistogramAggregation(agg.getSubAggregations()).     } }
false;public,static;1;4;;public static boolean isHistogram(AggregationBuilder aggregationBuilder) {     return aggregationBuilder instanceof HistogramAggregationBuilder || aggregationBuilder instanceof DateHistogramAggregationBuilder. }
true;public,static;1;9;/**  * Get the interval from {@code histogramAggregation} or throw an {@code IllegalStateException}  * if {@code histogramAggregation} is not a {@link HistogramAggregationBuilder} or a  * {@link DateHistogramAggregationBuilder}  *  * @param histogramAggregation Must be a {@link HistogramAggregationBuilder} or a  * {@link DateHistogramAggregationBuilder}  * @return The histogram interval  */ ;/**  * Get the interval from {@code histogramAggregation} or throw an {@code IllegalStateException}  * if {@code histogramAggregation} is not a {@link HistogramAggregationBuilder} or a  * {@link DateHistogramAggregationBuilder}  *  * @param histogramAggregation Must be a {@link HistogramAggregationBuilder} or a  * {@link DateHistogramAggregationBuilder}  * @return The histogram interval  */ public static long getHistogramIntervalMillis(AggregationBuilder histogramAggregation) {     if (histogramAggregation instanceof HistogramAggregationBuilder) {         return (long) ((HistogramAggregationBuilder) histogramAggregation).interval().     } else if (histogramAggregation instanceof DateHistogramAggregationBuilder) {         return validateAndGetDateHistogramInterval((DateHistogramAggregationBuilder) histogramAggregation).     } else {         throw new IllegalStateException("Invalid histogram aggregation [" + histogramAggregation.getName() + "]").     } }
true;private,static;1;11;/**  * Returns the date histogram interval as epoch millis if valid, or throws  * an {@link ElasticsearchException} with the validation error  */ ;/**  * Returns the date histogram interval as epoch millis if valid, or throws  * an {@link ElasticsearchException} with the validation error  */ private static long validateAndGetDateHistogramInterval(DateHistogramAggregationBuilder dateHistogram) {     if (dateHistogram.timeZone() != null && dateHistogram.timeZone().normalized().equals(ZoneOffset.UTC) == false) {         throw ExceptionsHelper.badRequestException("ML requires date_histogram.time_zone to be UTC").     }     if (dateHistogram.dateHistogramInterval() != null) {         return validateAndGetCalendarInterval(dateHistogram.dateHistogramInterval().toString()).     } else {         return dateHistogram.interval().     } }
false;public,static;1;35;;public static long validateAndGetCalendarInterval(String calendarInterval) {     TimeValue interval.     Rounding.DateTimeUnit dateTimeUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(calendarInterval).     if (dateTimeUnit != null) {         switch(dateTimeUnit) {             case WEEK_OF_WEEKYEAR:                 interval = new TimeValue(7, TimeUnit.DAYS).                 break.             case DAY_OF_MONTH:                 interval = new TimeValue(1, TimeUnit.DAYS).                 break.             case HOUR_OF_DAY:                 interval = new TimeValue(1, TimeUnit.HOURS).                 break.             case MINUTES_OF_HOUR:                 interval = new TimeValue(1, TimeUnit.MINUTES).                 break.             case SECOND_OF_MINUTE:                 interval = new TimeValue(1, TimeUnit.SECONDS).                 break.             case MONTH_OF_YEAR:             case YEAR_OF_CENTURY:             case QUARTER_OF_YEAR:                 throw ExceptionsHelper.badRequestException(invalidDateHistogramCalendarIntervalMessage(calendarInterval)).             default:                 throw ExceptionsHelper.badRequestException("Unexpected dateTimeUnit [" + dateTimeUnit + "]").         }     } else {         interval = TimeValue.parseTimeValue(calendarInterval, "date_histogram.interval").     }     if (interval.days() > 7) {         throw ExceptionsHelper.badRequestException(invalidDateHistogramCalendarIntervalMessage(calendarInterval)).     }     return interval.millis(). }
false;private,static;1;5;;private static String invalidDateHistogramCalendarIntervalMessage(String interval) {     throw ExceptionsHelper.badRequestException("When specifying a date_histogram calendar interval [" + interval + "], ML does not accept intervals longer than a week because of " + "variable lengths of periods greater than a week"). }
