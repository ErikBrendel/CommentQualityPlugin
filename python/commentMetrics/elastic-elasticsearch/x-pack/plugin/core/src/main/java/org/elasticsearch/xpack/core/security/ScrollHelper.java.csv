# id;timestamp;commentText;codeText;commentWords;codeWords
ScrollHelper -> public static <T> void fetchAllByEntity(Client client, SearchRequest request, final ActionListener<Collection<T>> listener,                                             Function<SearchHit, T> hitParser);1524684173;This method fetches all results for the given search request, parses them using the given hit parser and calls the_listener once done.;public static <T> void fetchAllByEntity(Client client, SearchRequest request, final ActionListener<Collection<T>> listener,_                                            Function<SearchHit, T> hitParser) {_        final List<T> results = new ArrayList<>()__        if (request.scroll() == null) { _            request.scroll(TimeValue.timeValueSeconds(10L))__        }_        final Consumer<SearchResponse> clearScroll = (response) -> {_            if (response != null && response.getScrollId() != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest, ActionListener.wrap((r) -> {}, (e) -> {}))__            }_        }__        _        _        client.search(request, new ContextPreservingActionListener<>(client.threadPool().getThreadContext().newRestorableContext(true),_                new ActionListener<SearchResponse>() {_            private volatile SearchResponse lastResponse = null___            @Override_            public void onResponse(SearchResponse resp) {_                try {_                    lastResponse = resp__                    if (resp.getHits().getHits().length > 0) {_                        for (SearchHit hit : resp.getHits().getHits()) {_                            final T oneResult = hitParser.apply(hit)__                            if (oneResult != null) {_                                results.add(oneResult)__                            }_                        }__                        if (results.size() > resp.getHits().getTotalHits()) {_                            clearScroll.accept(lastResponse)__                            listener.onFailure(new IllegalStateException("scrolling returned more hits [" + results.size()_                                    + "] than expected [" + resp.getHits().getTotalHits() + "] so bailing out to prevent unbounded "_                                    + "memory consumption."))__                        } else if (results.size() == resp.getHits().getTotalHits()) {_                            clearScroll.accept(resp)__                            _                            listener.onResponse(Collections.unmodifiableList(results))__                        } else {_                            SearchScrollRequest scrollRequest = new SearchScrollRequest(resp.getScrollId())__                            scrollRequest.scroll(request.scroll().keepAlive())__                            client.searchScroll(scrollRequest, this)__                        }_                    } else {_                        clearScroll.accept(resp)__                        _                        listener.onResponse(Collections.unmodifiableList(results))__                    }_                } catch (Exception e){_                    onFailure(e)_ _                }_            }__            @Override_            public void onFailure(Exception t) {_                try {_                    _                    clearScroll.accept(lastResponse)__                } finally {_                    if (t instanceof IndexNotFoundException) {_                        _                        listener.onResponse(Collections.<T>emptyList())__                    } else {_                        listener.onFailure(t)__                    }_                }_            }_        }))__    };this,method,fetches,all,results,for,the,given,search,request,parses,them,using,the,given,hit,parser,and,calls,the,listener,once,done;public,static,t,void,fetch,all,by,entity,client,client,search,request,request,final,action,listener,collection,t,listener,function,search,hit,t,hit,parser,final,list,t,results,new,array,list,if,request,scroll,null,request,scroll,time,value,time,value,seconds,10l,final,consumer,search,response,clear,scroll,response,if,response,null,response,get,scroll,id,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,listener,wrap,r,e,client,search,request,new,context,preserving,action,listener,client,thread,pool,get,thread,context,new,restorable,context,true,new,action,listener,search,response,private,volatile,search,response,last,response,null,override,public,void,on,response,search,response,resp,try,last,response,resp,if,resp,get,hits,get,hits,length,0,for,search,hit,hit,resp,get,hits,get,hits,final,t,one,result,hit,parser,apply,hit,if,one,result,null,results,add,one,result,if,results,size,resp,get,hits,get,total,hits,clear,scroll,accept,last,response,listener,on,failure,new,illegal,state,exception,scrolling,returned,more,hits,results,size,than,expected,resp,get,hits,get,total,hits,so,bailing,out,to,prevent,unbounded,memory,consumption,else,if,results,size,resp,get,hits,get,total,hits,clear,scroll,accept,resp,listener,on,response,collections,unmodifiable,list,results,else,search,scroll,request,scroll,request,new,search,scroll,request,resp,get,scroll,id,scroll,request,scroll,request,scroll,keep,alive,client,search,scroll,scroll,request,this,else,clear,scroll,accept,resp,listener,on,response,collections,unmodifiable,list,results,catch,exception,e,on,failure,e,override,public,void,on,failure,exception,t,try,clear,scroll,accept,last,response,finally,if,t,instanceof,index,not,found,exception,listener,on,response,collections,t,empty,list,else,listener,on,failure,t
ScrollHelper -> public static <T> void fetchAllByEntity(Client client, SearchRequest request, final ActionListener<Collection<T>> listener,                                             Function<SearchHit, T> hitParser);1538067637;This method fetches all results for the given search request, parses them using the given hit parser and calls the_listener once done.;public static <T> void fetchAllByEntity(Client client, SearchRequest request, final ActionListener<Collection<T>> listener,_                                            Function<SearchHit, T> hitParser) {_        final List<T> results = new ArrayList<>()__        if (request.scroll() == null) { _            throw new IllegalArgumentException("request must have scroll set")__        }_        final Consumer<SearchResponse> clearScroll = (response) -> {_            if (response != null && response.getScrollId() != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest, ActionListener.wrap((r) -> {}, e ->_                    LOGGER.warn(new ParameterizedMessage("clear scroll failed for scroll id [{}]", response.getScrollId()), e)_                ))__            }_        }__        _        _        client.search(request, new ContextPreservingActionListener<>(client.threadPool().getThreadContext().newRestorableContext(true),_                new ActionListener<SearchResponse>() {_            private volatile SearchResponse lastResponse = null___            @Override_            public void onResponse(SearchResponse resp) {_                try {_                    lastResponse = resp__                    if (resp.getHits().getHits().length > 0) {_                        for (SearchHit hit : resp.getHits().getHits()) {_                            final T oneResult = hitParser.apply(hit)__                            if (oneResult != null) {_                                results.add(oneResult)__                            }_                        }__                        if (results.size() > resp.getHits().getTotalHits()) {_                            clearScroll.accept(lastResponse)__                            listener.onFailure(new IllegalStateException("scrolling returned more hits [" + results.size()_                                    + "] than expected [" + resp.getHits().getTotalHits() + "] so bailing out to prevent unbounded "_                                    + "memory consumption."))__                        } else if (results.size() == resp.getHits().getTotalHits()) {_                            clearScroll.accept(resp)__                            _                            listener.onResponse(Collections.unmodifiableList(results))__                        } else {_                            SearchScrollRequest scrollRequest = new SearchScrollRequest(resp.getScrollId())__                            scrollRequest.scroll(request.scroll().keepAlive())__                            client.searchScroll(scrollRequest, this)__                        }_                    } else {_                        clearScroll.accept(resp)__                        _                        listener.onResponse(Collections.unmodifiableList(results))__                    }_                } catch (Exception e){_                    onFailure(e)_ _                }_            }__            @Override_            public void onFailure(Exception t) {_                try {_                    _                    clearScroll.accept(lastResponse)__                } finally {_                    if (t instanceof IndexNotFoundException) {_                        _                        listener.onResponse(Collections.<T>emptyList())__                    } else {_                        listener.onFailure(t)__                    }_                }_            }_        }))__    };this,method,fetches,all,results,for,the,given,search,request,parses,them,using,the,given,hit,parser,and,calls,the,listener,once,done;public,static,t,void,fetch,all,by,entity,client,client,search,request,request,final,action,listener,collection,t,listener,function,search,hit,t,hit,parser,final,list,t,results,new,array,list,if,request,scroll,null,throw,new,illegal,argument,exception,request,must,have,scroll,set,final,consumer,search,response,clear,scroll,response,if,response,null,response,get,scroll,id,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,listener,wrap,r,e,logger,warn,new,parameterized,message,clear,scroll,failed,for,scroll,id,response,get,scroll,id,e,client,search,request,new,context,preserving,action,listener,client,thread,pool,get,thread,context,new,restorable,context,true,new,action,listener,search,response,private,volatile,search,response,last,response,null,override,public,void,on,response,search,response,resp,try,last,response,resp,if,resp,get,hits,get,hits,length,0,for,search,hit,hit,resp,get,hits,get,hits,final,t,one,result,hit,parser,apply,hit,if,one,result,null,results,add,one,result,if,results,size,resp,get,hits,get,total,hits,clear,scroll,accept,last,response,listener,on,failure,new,illegal,state,exception,scrolling,returned,more,hits,results,size,than,expected,resp,get,hits,get,total,hits,so,bailing,out,to,prevent,unbounded,memory,consumption,else,if,results,size,resp,get,hits,get,total,hits,clear,scroll,accept,resp,listener,on,response,collections,unmodifiable,list,results,else,search,scroll,request,scroll,request,new,search,scroll,request,resp,get,scroll,id,scroll,request,scroll,request,scroll,keep,alive,client,search,scroll,scroll,request,this,else,clear,scroll,accept,resp,listener,on,response,collections,unmodifiable,list,results,catch,exception,e,on,failure,e,override,public,void,on,failure,exception,t,try,clear,scroll,accept,last,response,finally,if,t,instanceof,index,not,found,exception,listener,on,response,collections,t,empty,list,else,listener,on,failure,t
ScrollHelper -> public static <T> void fetchAllByEntity(Client client, SearchRequest request, final ActionListener<Collection<T>> listener,                                             Function<SearchHit, T> hitParser);1544035746;This method fetches all results for the given search request, parses them using the given hit parser and calls the_listener once done.;public static <T> void fetchAllByEntity(Client client, SearchRequest request, final ActionListener<Collection<T>> listener,_                                            Function<SearchHit, T> hitParser) {_        final List<T> results = new ArrayList<>()__        if (request.scroll() == null) { _            throw new IllegalArgumentException("request must have scroll set")__        }_        final Consumer<SearchResponse> clearScroll = (response) -> {_            if (response != null && response.getScrollId() != null) {_                ClearScrollRequest clearScrollRequest = new ClearScrollRequest()__                clearScrollRequest.addScrollId(response.getScrollId())__                client.clearScroll(clearScrollRequest, ActionListener.wrap((r) -> {}, e ->_                    LOGGER.warn(new ParameterizedMessage("clear scroll failed for scroll id [{}]", response.getScrollId()), e)_                ))__            }_        }__        _        _        client.search(request, new ContextPreservingActionListener<>(client.threadPool().getThreadContext().newRestorableContext(true),_                new ActionListener<SearchResponse>() {_            private volatile SearchResponse lastResponse = null___            @Override_            public void onResponse(SearchResponse resp) {_                try {_                    lastResponse = resp__                    if (resp.getHits().getHits().length > 0) {_                        for (SearchHit hit : resp.getHits().getHits()) {_                            final T oneResult = hitParser.apply(hit)__                            if (oneResult != null) {_                                results.add(oneResult)__                            }_                        }__                        if (results.size() > resp.getHits().getTotalHits().value) {_                            clearScroll.accept(lastResponse)__                            listener.onFailure(new IllegalStateException("scrolling returned more hits [" + results.size()_                                    + "] than expected [" + resp.getHits().getTotalHits().value + "] so bailing out to prevent unbounded "_                                    + "memory consumption."))__                        } else if (results.size() == resp.getHits().getTotalHits().value) {_                            clearScroll.accept(resp)__                            _                            listener.onResponse(Collections.unmodifiableList(results))__                        } else {_                            SearchScrollRequest scrollRequest = new SearchScrollRequest(resp.getScrollId())__                            scrollRequest.scroll(request.scroll().keepAlive())__                            client.searchScroll(scrollRequest, this)__                        }_                    } else {_                        clearScroll.accept(resp)__                        _                        listener.onResponse(Collections.unmodifiableList(results))__                    }_                } catch (Exception e){_                    onFailure(e)_ _                }_            }__            @Override_            public void onFailure(Exception t) {_                try {_                    _                    clearScroll.accept(lastResponse)__                } finally {_                    if (t instanceof IndexNotFoundException) {_                        _                        listener.onResponse(Collections.<T>emptyList())__                    } else {_                        listener.onFailure(t)__                    }_                }_            }_        }))__    };this,method,fetches,all,results,for,the,given,search,request,parses,them,using,the,given,hit,parser,and,calls,the,listener,once,done;public,static,t,void,fetch,all,by,entity,client,client,search,request,request,final,action,listener,collection,t,listener,function,search,hit,t,hit,parser,final,list,t,results,new,array,list,if,request,scroll,null,throw,new,illegal,argument,exception,request,must,have,scroll,set,final,consumer,search,response,clear,scroll,response,if,response,null,response,get,scroll,id,null,clear,scroll,request,clear,scroll,request,new,clear,scroll,request,clear,scroll,request,add,scroll,id,response,get,scroll,id,client,clear,scroll,clear,scroll,request,action,listener,wrap,r,e,logger,warn,new,parameterized,message,clear,scroll,failed,for,scroll,id,response,get,scroll,id,e,client,search,request,new,context,preserving,action,listener,client,thread,pool,get,thread,context,new,restorable,context,true,new,action,listener,search,response,private,volatile,search,response,last,response,null,override,public,void,on,response,search,response,resp,try,last,response,resp,if,resp,get,hits,get,hits,length,0,for,search,hit,hit,resp,get,hits,get,hits,final,t,one,result,hit,parser,apply,hit,if,one,result,null,results,add,one,result,if,results,size,resp,get,hits,get,total,hits,value,clear,scroll,accept,last,response,listener,on,failure,new,illegal,state,exception,scrolling,returned,more,hits,results,size,than,expected,resp,get,hits,get,total,hits,value,so,bailing,out,to,prevent,unbounded,memory,consumption,else,if,results,size,resp,get,hits,get,total,hits,value,clear,scroll,accept,resp,listener,on,response,collections,unmodifiable,list,results,else,search,scroll,request,scroll,request,new,search,scroll,request,resp,get,scroll,id,scroll,request,scroll,request,scroll,keep,alive,client,search,scroll,scroll,request,this,else,clear,scroll,accept,resp,listener,on,response,collections,unmodifiable,list,results,catch,exception,e,on,failure,e,override,public,void,on,failure,exception,t,try,clear,scroll,accept,last,response,finally,if,t,instanceof,index,not,found,exception,listener,on,response,collections,t,empty,list,else,listener,on,failure,t
