commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return  The principal of this user - effectively serving as the  *          unique identity of of the user.  */ ;/**  * @return  The principal of this user - effectively serving as the  *          unique identity of of the user.  */ public String principal() {     return this.username. }
true;public;0;3;/**  * @return  The roles this user is associated with. The roles are  *          identified by their unique names and each represents as  *          set of permissions  */ ;/**  * @return  The roles this user is associated with. The roles are  *          identified by their unique names and each represents as  *          set of permissions  */ public String[] roles() {     return this.roles. }
true;public;0;3;/**  * @return  The metadata that is associated with this user. Can never be {@code null}.  */ ;/**  * @return  The metadata that is associated with this user. Can never be {@code null}.  */ public Map<String, Object> metadata() {     return metadata. }
true;public;0;3;/**  * @return  The full name of this user. May be {@code null}.  */ ;/**  * @return  The full name of this user. May be {@code null}.  */ public String fullName() {     return fullName. }
true;public;0;3;/**  * @return  The email of this user. May be {@code null}.  */ ;/**  * @return  The email of this user. May be {@code null}.  */ public String email() {     return email. }
true;public;0;3;/**  * @return whether the user is enabled or not  */ ;/**  * @return whether the user is enabled or not  */ public boolean enabled() {     return enabled. }
true;public;0;3;/**  * @return The user that was originally authenticated.  * This may be the user itself, or a different user which used runAs.  */ ;/**  * @return The user that was originally authenticated.  * This may be the user itself, or a different user which used runAs.  */ public User authenticatedUser() {     return authenticatedUser == null ? this : authenticatedUser. }
true;public;0;3;/**  * Return true if this user was not the originally authenticated user, false otherwise.  */ ;/**  * Return true if this user was not the originally authenticated user, false otherwise.  */ public boolean isRunAs() {     return authenticatedUser != null. }
false;public;0;15;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append("User[username=").append(username).     sb.append(",roles=[").append(Strings.arrayToCommaDelimitedString(roles)).append("]").     sb.append(",fullName=").append(fullName).     sb.append(",email=").append(email).     sb.append(",metadata=").     sb.append(metadata).     if (authenticatedUser != null) {         sb.append(",authenticatedUser=[").append(authenticatedUser.toString()).append("]").     }     sb.append("]").     return sb.toString(). }
false;public;1;16;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o instanceof User == false)         return false.     User user = (User) o.     if (!username.equals(user.username))         return false.     // Probably incorrect - comparing Object[] arrays with Arrays.equals     if (!Arrays.equals(roles, user.roles))         return false.     if (authenticatedUser != null ? !authenticatedUser.equals(user.authenticatedUser) : user.authenticatedUser != null)         return false.     if (!metadata.equals(user.metadata))         return false.     if (fullName != null ? !fullName.equals(user.fullName) : user.fullName != null)         return false.     return !(email != null ? !email.equals(user.email) : user.email != null). }
false;public;0;10;;@Override public int hashCode() {     int result = username.hashCode().     result = 31 * result + Arrays.hashCode(roles).     result = 31 * result + (authenticatedUser != null ? authenticatedUser.hashCode() : 0).     result = 31 * result + metadata.hashCode().     result = 31 * result + (fullName != null ? fullName.hashCode() : 0).     result = 31 * result + (email != null ? email.hashCode() : 0).     return result. }
false;public,final;2;11;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Fields.USERNAME.getPreferredName(), principal()).     builder.array(Fields.ROLES.getPreferredName(), roles()).     builder.field(Fields.FULL_NAME.getPreferredName(), fullName()).     builder.field(Fields.EMAIL.getPreferredName(), email()).     builder.field(Fields.METADATA.getPreferredName(), metadata()).     builder.field(Fields.ENABLED.getPreferredName(), enabled()).     return builder.endObject(). }
false;public,static;2;15;;public static User partialReadFrom(String username, StreamInput input) throws IOException {     String[] roles = input.readStringArray().     Map<String, Object> metadata = input.readMap().     String fullName = input.readOptionalString().     String email = input.readOptionalString().     boolean enabled = input.readBoolean().     User outerUser = new User(username, roles, fullName, email, metadata, enabled, null).     boolean hasInnerUser = input.readBoolean().     if (hasInnerUser) {         User innerUser = readFrom(input).         return new User(outerUser, innerUser).     } else {         return outerUser.     } }
false;public,static;1;6;;public static User readFrom(StreamInput input) throws IOException {     final boolean isInternalUser = input.readBoolean().     assert isInternalUser == false : "should always return false. Internal users should use the InternalUserSerializationHelper".     final String username = input.readString().     return partialReadFrom(username, input). }
false;public,static;2;11;;public static void writeTo(User user, StreamOutput output) throws IOException {     if (user.authenticatedUser == null) {         // no backcompat necessary, since there is no inner user         writeUser(user, output).     } else {         writeUser(user, output).         output.writeBoolean(true).         writeUser(user.authenticatedUser, output).     }     // last user written, regardless of bwc, does not have an inner user     output.writeBoolean(false). }
true;private,static;2;9;/**  * Write just the given {@link User}, but not the inner {@link #authenticatedUser}.  */ ;/**  * Write just the given {@link User}, but not the inner {@link #authenticatedUser}.  */ private static void writeUser(User user, StreamOutput output) throws IOException {     // not a system user     output.writeBoolean(false).     output.writeString(user.username).     output.writeStringArray(user.roles).     output.writeMap(user.metadata).     output.writeOptionalString(user.fullName).     output.writeOptionalString(user.email).     output.writeBoolean(user.enabled). }
