commented;modifiers;parameterAmount;loc;comment;code
false;;1;25;;void readFrom(StreamInput in) throws IOException {     fieldName = in.readString().     size = in.readVInt().     minDocCount = in.readVInt().     shardMinDocCount = in.readVInt().     int numIncludes = in.readVInt().     if (numIncludes > 0) {         includes = new HashMap<>().         for (int i = 0. i < numIncludes. i++) {             TermBoost tb = new TermBoost().             tb.readFrom(in).             includes.put(tb.term, tb).         }     }     int numExcludes = in.readVInt().     if (numExcludes > 0) {         excludes = new HashSet<>().         for (int i = 0. i < numExcludes. i++) {             excludes.add(in.readString()).         }     } }
false;;1;24;;void writeTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeVInt(size).     out.writeVInt(minDocCount).     out.writeVInt(shardMinDocCount).     if (includes != null) {         out.writeVInt(includes.size()).         for (TermBoost tb : includes.values()) {             tb.writeTo(out).         }     } else {         out.writeVInt(0).     }     if (excludes != null) {         out.writeVInt(excludes.size()).         for (String term : excludes) {             out.writeString(term).         }     } else {         out.writeVInt(0).     } }
false;public;0;3;;public String fieldName() {     return fieldName. }
false;public;1;4;;public VertexRequest fieldName(String fieldName) {     this.fieldName = fieldName.     return this. }
false;public;0;3;;public int size() {     return size. }
true;public;1;4;/**  * @param size The maximum number of terms that should be returned from this field as part of this {@link Hop}  */ ;/**  * @param size The maximum number of terms that should be returned from this field as part of this {@link Hop}  */ public VertexRequest size(int size) {     this.size = size.     return this. }
false;public;0;3;;public boolean hasIncludeClauses() {     return includes != null && includes.size() > 0. }
false;public;0;3;;public boolean hasExcludeClauses() {     return excludes != null && excludes.size() > 0. }
true;public;1;9;/**  * Adds a term that should be excluded from results  * @param term A term to be excluded  */ ;/**  * Adds a term that should be excluded from results  * @param term A term to be excluded  */ public void addExclude(String term) {     if (includes != null) {         throw new IllegalArgumentException("Cannot have both include and exclude clauses").     }     if (excludes == null) {         excludes = new HashSet<>().     }     excludes.add(term). }
true;public;2;9;/**  * Adds a term to the set of allowed values - the boost defines the relative  * importance when pursuing connections in subsequent {@link Hop}s. The boost value  * appears as part of the query.  * @param term a required term  * @param boost an optional boost  */ ;/**  * Adds a term to the set of allowed values - the boost defines the relative  * importance when pursuing connections in subsequent {@link Hop}s. The boost value  * appears as part of the query.  * @param term a required term  * @param boost an optional boost  */ public void addInclude(String term, float boost) {     if (excludes != null) {         throw new IllegalArgumentException("Cannot have both include and exclude clauses").     }     if (includes == null) {         includes = new HashMap<>().     }     includes.put(term, new TermBoost(term, boost)). }
false;public;0;3;;public TermBoost[] includeValues() {     return includes.values().toArray(new TermBoost[includes.size()]). }
false;public;0;8;;public String[] includeValuesAsStringArray() {     String[] result = new String[includes.size()].     int i = 0.     for (TermBoost tb : includes.values()) {         result[i++] = tb.term.     }     return result. }
false;public;0;3;;public String[] excludesAsArray() {     return excludes.toArray(new String[excludes.size()]). }
false;public;0;3;;public int minDocCount() {     return minDocCount. }
true;public;1;4;/**  * A "certainty" threshold which defines the weight-of-evidence required before  * a term found in this field is identified as a useful connection  *  * @param value The minimum number of documents that contain this term found in the samples used across all shards  */ ;/**  * A "certainty" threshold which defines the weight-of-evidence required before  * a term found in this field is identified as a useful connection  *  * @param value The minimum number of documents that contain this term found in the samples used across all shards  */ public VertexRequest minDocCount(int value) {     minDocCount = value.     return this. }
false;public;0;3;;public int shardMinDocCount() {     return Math.min(shardMinDocCount, minDocCount). }
true;public;1;4;/**  * A "certainty" threshold which defines the weight-of-evidence required before  * a term found in this field is identified as a useful connection  *  * @param value The minimum number of documents that contain this term found in the samples used across all shards  */ ;/**  * A "certainty" threshold which defines the weight-of-evidence required before  * a term found in this field is identified as a useful connection  *  * @param value The minimum number of documents that contain this term found in the samples used across all shards  */ public VertexRequest shardMinDocCount(int value) {     shardMinDocCount = value.     return this. }
false;public;2;33;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("field", fieldName).     if (size != DEFAULT_SIZE) {         builder.field("size", size).     }     if (minDocCount != DEFAULT_MIN_DOC_COUNT) {         builder.field("min_doc_count", minDocCount).     }     if (shardMinDocCount != DEFAULT_SHARD_MIN_DOC_COUNT) {         builder.field("shard_min_doc_count", shardMinDocCount).     }     if (includes != null) {         builder.startArray("include").         for (TermBoost tb : includes.values()) {             builder.startObject().             builder.field("term", tb.term).             builder.field("boost", tb.boost).             builder.endObject().         }         builder.endArray().     }     if (excludes != null) {         builder.startArray("exclude").         for (String value : excludes) {             builder.value(value).         }         builder.endArray().     }     builder.endObject().     return builder. }
