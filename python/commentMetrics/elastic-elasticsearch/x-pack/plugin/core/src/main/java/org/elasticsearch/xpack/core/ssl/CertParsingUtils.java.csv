commented;modifiers;parameterAmount;loc;comment;code
true;static;2;7;/**  * Resolves a path with or without an {@link Environment} as we may be running in a transport client where we do not have access to  * the environment  */ ;/**  * Resolves a path with or without an {@link Environment} as we may be running in a transport client where we do not have access to  * the environment  */ @SuppressForbidden(reason = "we don't have the environment to resolve files from when running in a transport client") static Path resolvePath(String path, @Nullable Environment environment) {     if (environment != null) {         return environment.configFile().resolve(path).     }     return PathUtils.get(path).normalize(). }
false;public,static;3;9;;public static KeyStore readKeyStore(Path path, String type, char[] password) throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {     try (InputStream in = Files.newInputStream(path)) {         KeyStore store = KeyStore.getInstance(type).         assert password != null.         store.load(in, password).         return store.     } }
true;public,static;2;5;/**  * Reads the provided paths and parses them into {@link Certificate} objects  *  * @param certPaths   the paths to the PEM encoded certificates  * @param environment the environment to resolve files against. May be {@code null}  * @return an array of {@link Certificate} objects  */ ;/**  * Reads the provided paths and parses them into {@link Certificate} objects  *  * @param certPaths   the paths to the PEM encoded certificates  * @param environment the environment to resolve files against. May be {@code null}  * @return an array of {@link Certificate} objects  */ public static Certificate[] readCertificates(List<String> certPaths, @Nullable Environment environment) throws CertificateException, IOException {     final List<Path> resolvedPaths = certPaths.stream().map(p -> resolvePath(p, environment)).collect(Collectors.toList()).     return readCertificates(resolvedPaths). }
false;public,static;1;10;;public static Certificate[] readCertificates(List<Path> certPaths) throws CertificateException, IOException {     Collection<Certificate> certificates = new ArrayList<>().     CertificateFactory certFactory = CertificateFactory.getInstance("X.509").     for (Path path : certPaths) {         try (InputStream input = Files.newInputStream(path)) {             certificates.addAll((Collection<Certificate>) certFactory.generateCertificates(input)).         }     }     return certificates.toArray(new Certificate[0]). }
false;public,static;1;10;;public static X509Certificate[] readX509Certificates(List<Path> certPaths) throws CertificateException, IOException {     Collection<X509Certificate> certificates = new ArrayList<>().     CertificateFactory certFactory = CertificateFactory.getInstance("X.509").     for (Path path : certPaths) {         try (InputStream input = Files.newInputStream(path)) {             certificates.addAll((Collection<X509Certificate>) certFactory.generateCertificates(input)).         }     }     return certificates.toArray(new X509Certificate[0]). }
false;public,static;1;5;;public static List<Certificate> readCertificates(InputStream input) throws CertificateException, IOException {     CertificateFactory certFactory = CertificateFactory.getInstance("X.509").     Collection<Certificate> certificates = (Collection<Certificate>) certFactory.generateCertificates(input).     return new ArrayList<>(certificates). }
true;public,static;3;14;/**  * Read all certificate-key pairs from a PKCS#12 container.  *  * @param path        The path to the PKCS#12 container file.  * @param password    The password for the container file  * @param keyPassword A supplier for the password for each key. The key alias is supplied as an argument to the function, and it should  *                    return the password for that key. If it returns {@code null}, then the key-pair for that alias is not read.  */ ;/**  * Read all certificate-key pairs from a PKCS#12 container.  *  * @param path        The path to the PKCS#12 container file.  * @param password    The password for the container file  * @param keyPassword A supplier for the password for each key. The key alias is supplied as an argument to the function, and it should  *                    return the password for that key. If it returns {@code null}, then the key-pair for that alias is not read.  */ public static Map<Certificate, Key> readPkcs12KeyPairs(Path path, char[] password, Function<String, char[]> keyPassword) throws CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException, UnrecoverableKeyException {     final KeyStore store = readKeyStore(path, "PKCS12", password).     final Enumeration<String> enumeration = store.aliases().     final Map<Certificate, Key> map = new HashMap<>(store.size()).     while (enumeration.hasMoreElements()) {         final String alias = enumeration.nextElement().         if (store.isKeyEntry(alias)) {             final char[] pass = keyPassword.apply(alias).             map.put(store.getCertificate(alias), store.getKey(alias, pass)).         }     }     return map. }
true;public,static;3;6;/**  * Creates a {@link KeyStore} from a PEM encoded certificate and key file  */ ;/**  * Creates a {@link KeyStore} from a PEM encoded certificate and key file  */ public static KeyStore getKeyStoreFromPEM(Path certificatePath, Path keyPath, char[] keyPassword) throws IOException, CertificateException, KeyStoreException, NoSuchAlgorithmException {     final PrivateKey key = PemUtils.readPrivateKey(keyPath, () -> keyPassword).     final Certificate[] certificates = readCertificates(Collections.singletonList(certificatePath)).     return getKeyStore(certificates, key, keyPassword). }
true;public,static;3;5;/**  * Returns a {@link X509ExtendedKeyManager} that is built from the provided private key and certificate chain  */ ;/**  * Returns a {@link X509ExtendedKeyManager} that is built from the provided private key and certificate chain  */ public static X509ExtendedKeyManager keyManager(Certificate[] certificateChain, PrivateKey privateKey, char[] password) throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, IOException, CertificateException {     KeyStore keyStore = getKeyStore(certificateChain, privateKey, password).     return keyManager(keyStore, password, KeyManagerFactory.getDefaultAlgorithm()). }
false;private,static;3;8;;private static KeyStore getKeyStore(Certificate[] certificateChain, PrivateKey privateKey, char[] password) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {     KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()).     keyStore.load(null, null).     // password must be non-null for keystore...     keyStore.setKeyEntry("key", privateKey, password, certificateChain).     return keyStore. }
true;public,static;3;12;/**  * Returns a {@link X509ExtendedKeyManager} that is built from the provided keystore  */ ;/**  * Returns a {@link X509ExtendedKeyManager} that is built from the provided keystore  */ public static X509ExtendedKeyManager keyManager(KeyStore keyStore, char[] password, String algorithm) throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException {     KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm).     kmf.init(keyStore, password).     KeyManager[] keyManagers = kmf.getKeyManagers().     for (KeyManager keyManager : keyManagers) {         if (keyManager instanceof X509ExtendedKeyManager) {             return (X509ExtendedKeyManager) keyManager.         }     }     throw new IllegalStateException("failed to find a X509ExtendedKeyManager"). }
false;public,static;4;12;;public static X509ExtendedKeyManager getKeyManager(X509KeyPairSettings keyPair, Settings settings, @Nullable String trustStoreAlgorithm, Environment environment) {     if (trustStoreAlgorithm == null) {         trustStoreAlgorithm = TrustManagerFactory.getDefaultAlgorithm().     }     final KeyConfig keyConfig = createKeyConfig(keyPair, settings, trustStoreAlgorithm).     if (keyConfig == null) {         return null.     } else {         return keyConfig.createKeyManager(environment).     } }
false;static;3;31;;static KeyConfig createKeyConfig(X509KeyPairSettings keyPair, Settings settings, String trustStoreAlgorithm) {     String keyPath = keyPair.keyPath.get(settings).orElse(null).     String keyStorePath = keyPair.keystorePath.get(settings).orElse(null).     String keyStoreType = getKeyStoreType(keyPair.keystoreType, settings, keyStorePath).     if (keyPath != null && keyStorePath != null) {         throw new IllegalArgumentException("you cannot specify a keystore and key file").     }     if (keyPath != null) {         SecureString keyPassword = keyPair.keyPassword.get(settings).         String certPath = keyPair.certificatePath.get(settings).orElse(null).         if (certPath == null) {             throw new IllegalArgumentException("you must specify the certificates [" + keyPair.certificatePath.getKey() + "] to use with the key [" + keyPair.keyPath.getKey() + "]").         }         return new PEMKeyConfig(keyPath, keyPassword, certPath).     }     if (keyStorePath != null || keyStoreType.equalsIgnoreCase("pkcs11")) {         SecureString keyStorePassword = keyPair.keystorePassword.get(settings).         String keyStoreAlgorithm = keyPair.keystoreAlgorithm.get(settings).         SecureString keyStoreKeyPassword = keyPair.keystoreKeyPassword.get(settings).         if (keyStoreKeyPassword.length() == 0) {             keyStoreKeyPassword = keyStorePassword.         }         return new StoreKeyConfig(keyStorePath, keyStoreType, keyStorePassword, keyStoreKeyPassword, keyStoreAlgorithm, trustStoreAlgorithm).     }     return null. }
true;public,static;1;5;/**  * Creates a {@link X509ExtendedTrustManager} based on the provided certificates  *  * @param certificates the certificates to trust  * @return a trust manager that trusts the provided certificates  */ ;/**  * Creates a {@link X509ExtendedTrustManager} based on the provided certificates  *  * @param certificates the certificates to trust  * @return a trust manager that trusts the provided certificates  */ public static X509ExtendedTrustManager trustManager(Certificate[] certificates) throws NoSuchAlgorithmException, KeyStoreException, IOException, CertificateException {     KeyStore store = trustStore(certificates).     return trustManager(store, TrustManagerFactory.getDefaultAlgorithm()). }
false;static;1;12;;static KeyStore trustStore(Certificate[] certificates) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {     assert certificates != null : "Cannot create trust store with null certificates".     KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType()).     store.load(null, null).     int counter = 0.     for (Certificate certificate : certificates) {         store.setCertificateEntry("cert" + counter, certificate).         counter++.     }     return store. }
true;public,static;5;6;/**  * Loads the truststore and creates a {@link X509ExtendedTrustManager}  *  * @param trustStorePath      the path to the truststore  * @param trustStorePassword  the password to the truststore  * @param trustStoreAlgorithm the algorithm to use for the truststore  * @param env                 the environment to use for file resolution. May be {@code null}  * @return a trust manager with the trust material from the store  */ ;/**  * Loads the truststore and creates a {@link X509ExtendedTrustManager}  *  * @param trustStorePath      the path to the truststore  * @param trustStorePassword  the password to the truststore  * @param trustStoreAlgorithm the algorithm to use for the truststore  * @param env                 the environment to use for file resolution. May be {@code null}  * @return a trust manager with the trust material from the store  */ public static X509ExtendedTrustManager trustManager(String trustStorePath, String trustStoreType, char[] trustStorePassword, String trustStoreAlgorithm, @Nullable Environment env) throws NoSuchAlgorithmException, KeyStoreException, IOException, CertificateException {     KeyStore trustStore = readKeyStore(resolvePath(trustStorePath, env), trustStoreType, trustStorePassword).     return trustManager(trustStore, trustStoreAlgorithm). }
true;public,static;2;12;/**  * Creates a {@link X509ExtendedTrustManager} based on the trust material in the provided {@link KeyStore}  */ ;/**  * Creates a {@link X509ExtendedTrustManager} based on the trust material in the provided {@link KeyStore}  */ public static X509ExtendedTrustManager trustManager(KeyStore keyStore, String algorithm) throws NoSuchAlgorithmException, KeyStoreException {     TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm).     tmf.init(keyStore).     TrustManager[] trustManagers = tmf.getTrustManagers().     for (TrustManager trustManager : trustManagers) {         if (trustManager instanceof X509ExtendedTrustManager) {             return (X509ExtendedTrustManager) trustManager.         }     }     throw new IllegalStateException("failed to find a X509ExtendedTrustManager"). }
