commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;13;/**  * Loads a built-in index lifecycle policy and returns its source.  */ ;/**  * Loads a built-in index lifecycle policy and returns its source.  */ public static LifecyclePolicy loadPolicy(String name, String resource, NamedXContentRegistry xContentRegistry) {     try {         BytesReference source = load(resource).         validate(source).         try (XContentParser parser = XContentType.JSON.xContent().createParser(xContentRegistry, LoggingDeprecationHandler.THROW_UNSUPPORTED_OPERATION, source.utf8ToString())) {             return LifecyclePolicy.parse(parser, name).         }     } catch (Exception e) {         throw new IllegalArgumentException("unable to load policy [" + name + "] from [" + resource + "]", e).     } }
true;private,static;1;8;/**  * Loads a resource from the classpath and returns it as a {@link BytesReference}  */ ;/**  * Loads a resource from the classpath and returns it as a {@link BytesReference}  */ private static BytesReference load(String name) throws IOException {     try (InputStream is = LifecyclePolicyUtils.class.getResourceAsStream(name)) {         try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {             Streams.copy(is, out).             return new BytesArray(out.toByteArray()).         }     } }
true;private,static;1;13;/**  * Parses and validates that the source is not empty.  */ ;/**  * Parses and validates that the source is not empty.  */ private static void validate(BytesReference source) {     if (source == null) {         throw new ElasticsearchParseException("policy must not be null").     }     try {         XContentHelper.convertToMap(source, false, XContentType.JSON).v2().     } catch (NotXContentException e) {         throw new ElasticsearchParseException("policy must not be empty").     } catch (Exception e) {         throw new ElasticsearchParseException("invalid policy", e).     } }
