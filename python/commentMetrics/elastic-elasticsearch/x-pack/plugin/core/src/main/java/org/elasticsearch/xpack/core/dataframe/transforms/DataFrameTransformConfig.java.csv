commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;47;;private static ConstructingObjectParser<DataFrameTransformConfig, String> createParser(boolean lenient) {     ConstructingObjectParser<DataFrameTransformConfig, String> parser = new ConstructingObjectParser<>(NAME, lenient, (args, optionalId) -> {         String id = (String) args[0].         // if the id has been specified in the body and the path, they must match         if (id == null) {             id = optionalId.         } else if (optionalId != null && id.equals(optionalId) == false) {             throw new IllegalArgumentException(DataFrameMessages.getMessage(DataFrameMessages.REST_PUT_DATA_FRAME_INCONSISTENT_ID, id, optionalId)).         }         String source = (String) args[1].         String dest = (String) args[2].         // on strict parsing do not allow injection of headers         if (lenient == false && args[3] != null) {             throw new IllegalArgumentException("Found [headers], not allowed for strict parsing").         }         @SuppressWarnings("unchecked")         Map<String, String> headers = (Map<String, String>) args[3].         // default handling: if the user does not specify a query, we default to match_all         QueryConfig queryConfig = null.         if (args[4] == null) {             queryConfig = new QueryConfig(Collections.singletonMap(MatchAllQueryBuilder.NAME, Collections.emptyMap()), new MatchAllQueryBuilder()).         } else {             queryConfig = (QueryConfig) args[4].         }         PivotConfig pivotConfig = (PivotConfig) args[5].         return new DataFrameTransformConfig(id, source, dest, headers, queryConfig, pivotConfig).     }).     parser.declareString(optionalConstructorArg(), DataFrameField.ID).     parser.declareString(constructorArg(), SOURCE).     parser.declareString(constructorArg(), DESTINATION).     parser.declareObject(optionalConstructorArg(), (p, c) -> p.mapStrings(), HEADERS).     parser.declareObject(optionalConstructorArg(), (p, c) -> QueryConfig.fromXContent(p, lenient), QUERY).     parser.declareObject(optionalConstructorArg(), (p, c) -> PivotConfig.fromXContent(p, lenient), PIVOT_TRANSFORM).     return parser. }
false;public,static;1;3;;public static String documentId(String transformId) {     return "data_frame-" + transformId. }
false;public;0;3;;public String getId() {     return id. }
false;public;0;3;;public String getCron() {     return "*". }
false;public;0;3;;public String getSource() {     return source. }
false;public;0;3;;public String getDestination() {     return dest. }
false;public;0;3;;public Map<String, String> getHeaders() {     return headers. }
false;public;1;3;;public void setHeaders(Map<String, String> headers) {     this.headers = headers. }
false;public;0;3;;public PivotConfig getPivotConfig() {     return pivotConfig. }
false;public;0;3;;public QueryConfig getQueryConfig() {     return queryConfig. }
false;public;0;12;;public boolean isValid() {     // collect validation results from all child objects     if (queryConfig != null && queryConfig.isValid() == false) {         return false.     }     if (pivotConfig != null && pivotConfig.isValid() == false) {         return false.     }     return true. }
false;public;1;9;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeString(id).     out.writeString(source).     out.writeString(dest).     out.writeMap(headers, StreamOutput::writeString, StreamOutput::writeString).     out.writeOptionalWriteable(queryConfig).     out.writeOptionalWriteable(pivotConfig). }
false;public;2;19;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     builder.startObject().     builder.field(DataFrameField.ID.getPreferredName(), id).     builder.field(SOURCE.getPreferredName(), source).     builder.field(DESTINATION.getPreferredName(), dest).     if (queryConfig != null) {         builder.field(QUERY.getPreferredName(), queryConfig).     }     if (pivotConfig != null) {         builder.field(PIVOT_TRANSFORM.getPreferredName(), pivotConfig).     }     if (headers.isEmpty() == false && params.paramAsBoolean(DataFrameField.FOR_INTERNAL_STORAGE, false) == true) {         builder.field(HEADERS.getPreferredName(), headers).     }     builder.endObject().     return builder. }
false;public;1;19;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     final DataFrameTransformConfig that = (DataFrameTransformConfig) other.     return Objects.equals(this.id, that.id) && Objects.equals(this.source, that.source) && Objects.equals(this.dest, that.dest) && Objects.equals(this.headers, that.headers) && Objects.equals(this.queryConfig, that.queryConfig) && Objects.equals(this.pivotConfig, that.pivotConfig). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(id, source, dest, headers, queryConfig, pivotConfig). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
false;public,static;3;5;;public static DataFrameTransformConfig fromXContent(final XContentParser parser, @Nullable final String optionalTransformId, boolean lenient) throws IOException {     return lenient ? LENIENT_PARSER.apply(parser, optionalTransformId) : STRICT_PARSER.apply(parser, optionalTransformId). }
