commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;33;;private static ObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {     ObjectParser<Builder, Void> parser = new ObjectParser<>("job_details", ignoreUnknownFields, Builder::new).     parser.declareString(Builder::setId, ID).     parser.declareString(Builder::setJobType, JOB_TYPE).     parser.declareString(Builder::setJobVersion, JOB_VERSION).     parser.declareStringArray(Builder::setGroups, GROUPS).     parser.declareStringOrNull(Builder::setDescription, DESCRIPTION).     parser.declareField(Builder::setCreateTime, p -> TimeUtils.parseTimeField(p, CREATE_TIME.getPreferredName()), CREATE_TIME, ValueType.VALUE).     parser.declareField(Builder::setFinishedTime, p -> TimeUtils.parseTimeField(p, FINISHED_TIME.getPreferredName()), FINISHED_TIME, ValueType.VALUE).     parser.declareObject(Builder::setAnalysisConfig, ignoreUnknownFields ? AnalysisConfig.LENIENT_PARSER : AnalysisConfig.STRICT_PARSER, ANALYSIS_CONFIG).     parser.declareObject(Builder::setAnalysisLimits, ignoreUnknownFields ? AnalysisLimits.LENIENT_PARSER : AnalysisLimits.STRICT_PARSER, ANALYSIS_LIMITS).     parser.declareObject(Builder::setDataDescription, ignoreUnknownFields ? DataDescription.LENIENT_PARSER : DataDescription.STRICT_PARSER, DATA_DESCRIPTION).     parser.declareObject(Builder::setModelPlotConfig, ignoreUnknownFields ? ModelPlotConfig.LENIENT_PARSER : ModelPlotConfig.STRICT_PARSER, MODEL_PLOT_CONFIG).     parser.declareLong(Builder::setRenormalizationWindowDays, RENORMALIZATION_WINDOW_DAYS).     parser.declareString((builder, val) -> builder.setBackgroundPersistInterval(TimeValue.parseTimeValue(val, BACKGROUND_PERSIST_INTERVAL.getPreferredName())), BACKGROUND_PERSIST_INTERVAL).     parser.declareLong(Builder::setResultsRetentionDays, RESULTS_RETENTION_DAYS).     parser.declareLong(Builder::setModelSnapshotRetentionDays, MODEL_SNAPSHOT_RETENTION_DAYS).     parser.declareField(Builder::setCustomSettings, (p, c) -> p.mapOrdered(), CUSTOM_SETTINGS, ValueType.OBJECT).     parser.declareStringOrNull(Builder::setModelSnapshotId, MODEL_SNAPSHOT_ID).     parser.declareStringOrNull(Builder::setModelSnapshotMinVersion, MODEL_SNAPSHOT_MIN_VERSION).     parser.declareString(Builder::setResultsIndexName, RESULTS_INDEX_NAME).     parser.declareBoolean(Builder::setDeleting, DELETING).     return parser. }
true;public,static;1;10;/**  * Get the persisted job document name from the Job Id.  * Throws if {@code jobId} is not a valid job Id.  *  * @param jobId The job id  * @return The id of document the job is persisted in  */ ;/**  * Get the persisted job document name from the Job Id.  * Throws if {@code jobId} is not a valid job Id.  *  * @param jobId The job id  * @return The id of document the job is persisted in  */ public static String documentId(String jobId) {     if (!MlStrings.isValidId(jobId)) {         throw new IllegalArgumentException(Messages.getMessage(Messages.INVALID_ID, ID.getPreferredName(), jobId)).     }     if (!MlStrings.hasValidLengthForId(jobId)) {         throw new IllegalArgumentException(Messages.getMessage(Messages.JOB_CONFIG_ID_TOO_LONG, MlStrings.ID_LENGTH_LIMIT)).     }     return ANOMALY_DETECTOR_JOB_TYPE + "-" + jobId. }
true;public;0;3;/**  * Return the Job Id.  *  * @return The job Id string  */ ;/**  * Return the Job Id.  *  * @return The job Id string  */ public String getId() {     return jobId. }
false;public;0;3;;public String getJobType() {     return jobType. }
false;public;0;3;;public Version getJobVersion() {     return jobVersion. }
false;public;0;3;;public List<String> getGroups() {     return groups. }
true;public;0;3;/**  * A good starting name for the index storing the job's results.  * This defaults to the shared results index if a specific index name is not set.  * This method must <em>only</em> be used during initial job creation.  * After that the read/write aliases must always be used to access the job's  * results index, as the underlying index may roll or be reindexed.  * @return The job's initial results index name  */ ;/**  * A good starting name for the index storing the job's results.  * This defaults to the shared results index if a specific index name is not set.  * This method must <em>only</em> be used during initial job creation.  * After that the read/write aliases must always be used to access the job's  * results index, as the underlying index may roll or be reindexed.  * @return The job's initial results index name  */ public String getInitialResultsIndexName() {     return AnomalyDetectorsIndexFields.RESULTS_INDEX_PREFIX + resultsIndexName. }
true;private;0;3;/**  * Get the unmodified <code>results_index_name</code> field from the job.  * This is provided to allow a job to be copied via the builder.  * After creation this does not necessarily reflect the actual concrete  * index used by the job.  A job's results must always be read and written  * using the read and write aliases.  * @return The job's configured "index name"  */ ;/**  * Get the unmodified <code>results_index_name</code> field from the job.  * This is provided to allow a job to be copied via the builder.  * After creation this does not necessarily reflect the actual concrete  * index used by the job.  A job's results must always be read and written  * using the read and write aliases.  * @return The job's configured "index name"  */ private String getResultsIndexNameNoPrefix() {     return resultsIndexName. }
true;public;0;3;/**  * The job description  *  * @return job description  */ ;/**  * The job description  *  * @return job description  */ public String getDescription() {     return description. }
true;public;0;3;/**  * The Job creation time. This name is preferred when serialising to the  * REST API.  *  * @return The date the job was created  */ ;/**  * The Job creation time. This name is preferred when serialising to the  * REST API.  *  * @return The date the job was created  */ public Date getCreateTime() {     return createTime. }
true;public;0;3;/**  * The time the job was finished or <code>null</code> if not finished.  *  * @return The date the job was last retired or <code>null</code>  */ ;/**  * The time the job was finished or <code>null</code> if not finished.  *  * @return The date the job was last retired or <code>null</code>  */ public Date getFinishedTime() {     return finishedTime. }
true;public;0;3;/**  * The analysis configuration object  *  * @return The AnalysisConfig  */ ;/**  * The analysis configuration object  *  * @return The AnalysisConfig  */ public AnalysisConfig getAnalysisConfig() {     return analysisConfig. }
true;public;0;3;/**  * The analysis options object  *  * @return The AnalysisLimits  */ ;/**  * The analysis options object  *  * @return The AnalysisLimits  */ public AnalysisLimits getAnalysisLimits() {     return analysisLimits. }
false;public;0;3;;public ModelPlotConfig getModelPlotConfig() {     return modelPlotConfig. }
true;public;0;3;/**  * If not set the input data is assumed to be csv with a '_time' field in  * epoch format.  *  * @return A DataDescription or <code>null</code>  * @see DataDescription  */ ;/**  * If not set the input data is assumed to be csv with a '_time' field in  * epoch format.  *  * @return A DataDescription or <code>null</code>  * @see DataDescription  */ public DataDescription getDataDescription() {     return dataDescription. }
true;public;0;3;/**  * The duration of the renormalization window in days  *  * @return renormalization window in days  */ ;/**  * The duration of the renormalization window in days  *  * @return renormalization window in days  */ public Long getRenormalizationWindowDays() {     return renormalizationWindowDays. }
true;public;0;3;/**  * The background persistence interval  *  * @return background persistence interval  */ ;/**  * The background persistence interval  *  * @return background persistence interval  */ public TimeValue getBackgroundPersistInterval() {     return backgroundPersistInterval. }
false;public;0;3;;public Long getModelSnapshotRetentionDays() {     return modelSnapshotRetentionDays. }
false;public;0;3;;public Long getResultsRetentionDays() {     return resultsRetentionDays. }
false;public;0;3;;public Map<String, Object> getCustomSettings() {     return customSettings. }
false;public;0;3;;public String getModelSnapshotId() {     return modelSnapshotId. }
false;public;0;3;;public Version getModelSnapshotMinVersion() {     return modelSnapshotMinVersion. }
false;public;0;3;;public boolean isDeleting() {     return deleting. }
true;public;0;24;/**  * Get all input data fields mentioned in the job configuration,  * namely analysis fields and the time field.  *  * @return the collection of fields - never <code>null</code>  */ ;/**  * Get all input data fields mentioned in the job configuration,  * namely analysis fields and the time field.  *  * @return the collection of fields - never <code>null</code>  */ public Collection<String> allInputFields() {     Set<String> allFields = new TreeSet<>().     // analysis fields     if (analysisConfig != null) {         allFields.addAll(analysisConfig.analysisFields()).     }     // time field     if (dataDescription != null) {         String timeField = dataDescription.getTimeField().         if (timeField != null) {             allFields.add(timeField).         }     }     // remove empty strings     allFields.remove("").     // the categorisation field isn't an input field     allFields.remove(AnalysisConfig.ML_CATEGORY_FIELD).     return allFields. }
true;public;1;10;/**  * Returns the timestamp before which data is not accepted by the job.  * This is the latest record timestamp minus the job latency.  * @param dataCounts the job data counts  * @return the timestamp before which data is not accepted by the job  */ ;/**  * Returns the timestamp before which data is not accepted by the job.  * This is the latest record timestamp minus the job latency.  * @param dataCounts the job data counts  * @return the timestamp before which data is not accepted by the job  */ public long earliestValidTimestamp(DataCounts dataCounts) {     long currentTime = 0.     Date latestRecordTimestamp = dataCounts.getLatestRecordTimeStamp().     if (latestRecordTimestamp != null) {         TimeValue latency = analysisConfig.getLatency().         long latencyMillis = latency == null ? 0 : latency.millis().         currentTime = latestRecordTimestamp.getTime() - latencyMillis.     }     return currentTime. }
false;public;1;50;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(jobId).     out.writeString(jobType).     if (jobVersion != null) {         out.writeBoolean(true).         Version.writeVersion(jobVersion, out).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeStringCollection(groups).     }     out.writeOptionalString(description).     out.writeVLong(createTime.getTime()).     if (finishedTime != null) {         out.writeBoolean(true).         out.writeVLong(finishedTime.getTime()).     } else {         out.writeBoolean(false).     }     // for removed last_data_time field     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeBoolean(false).     }     // for removed establishedModelMemory field     if (out.getVersion().onOrAfter(Version.V_6_1_0) && out.getVersion().before(Version.V_7_0_0)) {         out.writeOptionalLong(null).     }     analysisConfig.writeTo(out).     out.writeOptionalWriteable(analysisLimits).     out.writeOptionalWriteable(dataDescription).     out.writeOptionalWriteable(modelPlotConfig).     out.writeOptionalLong(renormalizationWindowDays).     out.writeOptionalTimeValue(backgroundPersistInterval).     out.writeOptionalLong(modelSnapshotRetentionDays).     out.writeOptionalLong(resultsRetentionDays).     out.writeMap(customSettings).     out.writeOptionalString(modelSnapshotId).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         if (modelSnapshotMinVersion != null) {             out.writeBoolean(true).             Version.writeVersion(modelSnapshotMinVersion, out).         } else {             out.writeBoolean(false).         }     }     out.writeString(resultsIndexName).     out.writeBoolean(deleting). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     doXContentBody(builder, params).     builder.endObject().     return builder. }
false;public;2;56;;public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     final String humanReadableSuffix = "_string".     builder.field(ID.getPreferredName(), jobId).     builder.field(JOB_TYPE.getPreferredName(), jobType).     if (jobVersion != null) {         builder.field(JOB_VERSION.getPreferredName(), jobVersion).     }     if (groups.isEmpty() == false) {         builder.field(GROUPS.getPreferredName(), groups).     }     if (description != null) {         builder.field(DESCRIPTION.getPreferredName(), description).     }     builder.timeField(CREATE_TIME.getPreferredName(), CREATE_TIME.getPreferredName() + humanReadableSuffix, createTime.getTime()).     if (finishedTime != null) {         builder.timeField(FINISHED_TIME.getPreferredName(), FINISHED_TIME.getPreferredName() + humanReadableSuffix, finishedTime.getTime()).     }     builder.field(ANALYSIS_CONFIG.getPreferredName(), analysisConfig, params).     if (analysisLimits != null) {         builder.field(ANALYSIS_LIMITS.getPreferredName(), analysisLimits, params).     }     if (dataDescription != null) {         builder.field(DATA_DESCRIPTION.getPreferredName(), dataDescription, params).     }     if (modelPlotConfig != null) {         builder.field(MODEL_PLOT_CONFIG.getPreferredName(), modelPlotConfig, params).     }     if (renormalizationWindowDays != null) {         builder.field(RENORMALIZATION_WINDOW_DAYS.getPreferredName(), renormalizationWindowDays).     }     if (backgroundPersistInterval != null) {         builder.field(BACKGROUND_PERSIST_INTERVAL.getPreferredName(), backgroundPersistInterval.getStringRep()).     }     if (modelSnapshotRetentionDays != null) {         builder.field(MODEL_SNAPSHOT_RETENTION_DAYS.getPreferredName(), modelSnapshotRetentionDays).     }     if (resultsRetentionDays != null) {         builder.field(RESULTS_RETENTION_DAYS.getPreferredName(), resultsRetentionDays).     }     if (customSettings != null) {         builder.field(CUSTOM_SETTINGS.getPreferredName(), customSettings).     }     if (modelSnapshotId != null) {         builder.field(MODEL_SNAPSHOT_ID.getPreferredName(), modelSnapshotId).     }     if (modelSnapshotMinVersion != null) {         builder.field(MODEL_SNAPSHOT_MIN_VERSION.getPreferredName(), modelSnapshotMinVersion).     }     builder.field(RESULTS_INDEX_NAME.getPreferredName(), resultsIndexName).     if (deleting) {         builder.field(DELETING.getPreferredName(), deleting).     }     return builder. }
false;public;1;32;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other instanceof Job == false) {         return false.     }     Job that = (Job) other.     return Objects.equals(this.jobId, that.jobId) && Objects.equals(this.jobType, that.jobType) && Objects.equals(this.jobVersion, that.jobVersion) && Objects.equals(this.groups, that.groups) && Objects.equals(this.description, that.description) && Objects.equals(this.createTime, that.createTime) && Objects.equals(this.finishedTime, that.finishedTime) && Objects.equals(this.analysisConfig, that.analysisConfig) && Objects.equals(this.analysisLimits, that.analysisLimits) && Objects.equals(this.dataDescription, that.dataDescription) && Objects.equals(this.modelPlotConfig, that.modelPlotConfig) && Objects.equals(this.renormalizationWindowDays, that.renormalizationWindowDays) && Objects.equals(this.backgroundPersistInterval, that.backgroundPersistInterval) && Objects.equals(this.modelSnapshotRetentionDays, that.modelSnapshotRetentionDays) && Objects.equals(this.resultsRetentionDays, that.resultsRetentionDays) && Objects.equals(this.customSettings, that.customSettings) && Objects.equals(this.modelSnapshotId, that.modelSnapshotId) && Objects.equals(this.modelSnapshotMinVersion, that.modelSnapshotMinVersion) && Objects.equals(this.resultsIndexName, that.resultsIndexName) && Objects.equals(this.deleting, that.deleting). }
false;public;0;7;;@Override public int hashCode() {     return Objects.hash(jobId, jobType, jobVersion, groups, description, createTime, finishedTime, analysisConfig, analysisLimits, dataDescription, modelPlotConfig, renormalizationWindowDays, backgroundPersistInterval, modelSnapshotRetentionDays, resultsRetentionDays, customSettings, modelSnapshotId, modelSnapshotMinVersion, resultsIndexName, deleting). }
true;public,final;0;4;// Class already extends from AbstractDiffable, so copied from ToXContentToBytes#toString() ;// Class already extends from AbstractDiffable, so copied from ToXContentToBytes#toString() @Override public final String toString() {     return Strings.toString(this). }
false;private,static;3;5;;private static void checkValueNotLessThan(long minVal, String name, Long value) {     if (value != null && value < minVal) {         throw new IllegalArgumentException(Messages.getMessage(Messages.JOB_CONFIG_FIELD_VALUE_TOO_LOW, name, minVal, value)).     } }
true;public,static;1;5;/**  * Returns the job types that are compatible with a node running on {@code nodeVersion}  * @param nodeVersion the version of the node  * @return the compatible job types  */ ;/**  * Returns the job types that are compatible with a node running on {@code nodeVersion}  * @param nodeVersion the version of the node  * @return the compatible job types  */ public static Set<String> getCompatibleJobTypes(Version nodeVersion) {     Set<String> compatibleTypes = new HashSet<>().     compatibleTypes.add(ANOMALY_DETECTOR_JOB_TYPE).     return compatibleTypes. }
false;public;1;4;;public Builder setId(String id) {     this.id = id.     return this. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setJobVersion(Version jobVersion) {     this.jobVersion = jobVersion. }
false;private;1;3;;private void setJobVersion(String jobVersion) {     this.jobVersion = Version.fromString(jobVersion). }
false;private;1;3;;private void setJobType(String jobType) {     this.jobType = jobType. }
false;public;1;3;;public void setGroups(List<String> groups) {     this.groups = groups == null ? Collections.emptyList() : groups. }
false;public;0;3;;public List<String> getGroups() {     return groups. }
false;public;1;4;;public Builder setCustomSettings(Map<String, Object> customSettings) {     this.customSettings = customSettings.     return this. }
false;public;1;4;;public Builder setDescription(String description) {     this.description = description.     return this. }
false;public;1;4;;public Builder setAnalysisConfig(AnalysisConfig.Builder configBuilder) {     analysisConfig = ExceptionsHelper.requireNonNull(configBuilder, ANALYSIS_CONFIG.getPreferredName()).build().     return this. }
false;public;0;3;;public AnalysisConfig getAnalysisConfig() {     return analysisConfig. }
false;public;1;4;;public Builder setAnalysisLimits(AnalysisLimits analysisLimits) {     this.analysisLimits = ExceptionsHelper.requireNonNull(analysisLimits, ANALYSIS_LIMITS.getPreferredName()).     return this. }
false;public;1;4;;public Builder setCreateTime(Date createTime) {     this.createTime = createTime.     return this. }
false;public;1;4;;public Builder setFinishedTime(Date finishedTime) {     this.finishedTime = finishedTime.     return this. }
false;public;1;4;;public Builder setDataDescription(DataDescription.Builder description) {     dataDescription = ExceptionsHelper.requireNonNull(description, DATA_DESCRIPTION.getPreferredName()).build().     return this. }
false;public;1;4;;public Builder setModelPlotConfig(ModelPlotConfig modelPlotConfig) {     this.modelPlotConfig = modelPlotConfig.     return this. }
false;public;1;4;;public Builder setBackgroundPersistInterval(TimeValue backgroundPersistInterval) {     this.backgroundPersistInterval = backgroundPersistInterval.     return this. }
false;public;1;4;;public Builder setRenormalizationWindowDays(Long renormalizationWindowDays) {     this.renormalizationWindowDays = renormalizationWindowDays.     return this. }
false;public;1;4;;public Builder setModelSnapshotRetentionDays(Long modelSnapshotRetentionDays) {     this.modelSnapshotRetentionDays = modelSnapshotRetentionDays.     return this. }
false;public;1;4;;public Builder setResultsRetentionDays(Long resultsRetentionDays) {     this.resultsRetentionDays = resultsRetentionDays.     return this. }
false;public;1;4;;public Builder setModelSnapshotId(String modelSnapshotId) {     this.modelSnapshotId = modelSnapshotId.     return this. }
false;public;1;4;;public Builder setModelSnapshotMinVersion(Version modelSnapshotMinVersion) {     this.modelSnapshotMinVersion = modelSnapshotMinVersion.     return this. }
false;;1;4;;Builder setModelSnapshotMinVersion(String modelSnapshotMinVersion) {     this.modelSnapshotMinVersion = Version.fromString(modelSnapshotMinVersion).     return this. }
false;public;1;4;;public Builder setResultsIndexName(String resultsIndexName) {     this.resultsIndexName = resultsIndexName.     return this. }
false;public;1;4;;public Builder setDeleting(boolean deleting) {     this.deleting = deleting.     return this. }
true;public;0;13;/**  * Return the list of fields that have been set and are invalid to  * be set when the job is created e.g. model snapshot Id should not  * be set at job creation.  * @return List of fields set fields that should not be.  */ ;/**  * Return the list of fields that have been set and are invalid to  * be set when the job is created e.g. model snapshot Id should not  * be set at job creation.  * @return List of fields set fields that should not be.  */ public List<String> invalidCreateTimeSettings() {     List<String> invalidCreateValues = new ArrayList<>().     if (modelSnapshotId != null) {         invalidCreateValues.add(MODEL_SNAPSHOT_ID.getPreferredName()).     }     if (finishedTime != null) {         invalidCreateValues.add(FINISHED_TIME.getPreferredName()).     }     if (createTime != null) {         invalidCreateValues.add(CREATE_TIME.getPreferredName()).     }     return invalidCreateValues. }
false;public;1;55;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(id).     out.writeString(jobType).     if (jobVersion != null) {         out.writeBoolean(true).         Version.writeVersion(jobVersion, out).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeStringCollection(groups).     }     out.writeOptionalString(description).     if (createTime != null) {         out.writeBoolean(true).         out.writeVLong(createTime.getTime()).     } else {         out.writeBoolean(false).     }     if (finishedTime != null) {         out.writeBoolean(true).         out.writeVLong(finishedTime.getTime()).     } else {         out.writeBoolean(false).     }     // for removed last_data_time field     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeBoolean(false).     }     // for removed establishedModelMemory field     if (out.getVersion().onOrAfter(Version.V_6_1_0) && out.getVersion().before(Version.V_7_0_0)) {         out.writeOptionalLong(null).     }     out.writeOptionalWriteable(analysisConfig).     out.writeOptionalWriteable(analysisLimits).     out.writeOptionalWriteable(dataDescription).     out.writeOptionalWriteable(modelPlotConfig).     out.writeOptionalLong(renormalizationWindowDays).     out.writeOptionalTimeValue(backgroundPersistInterval).     out.writeOptionalLong(modelSnapshotRetentionDays).     out.writeOptionalLong(resultsRetentionDays).     out.writeMap(customSettings).     out.writeOptionalString(modelSnapshotId).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         if (modelSnapshotMinVersion != null) {             out.writeBoolean(true).             Version.writeVersion(modelSnapshotMinVersion, out).         } else {             out.writeBoolean(false).         }     }     out.writeOptionalString(resultsIndexName).     out.writeBoolean(deleting). }
false;public;2;62;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (id != null) {         builder.field(ID.getPreferredName(), id).     }     builder.field(JOB_TYPE.getPreferredName(), jobType).     if (jobVersion != null) {         builder.field(JOB_VERSION.getPreferredName(), jobVersion).     }     if (description != null) {         builder.field(DESCRIPTION.getPreferredName(), description).     }     if (createTime != null) {         builder.field(CREATE_TIME.getPreferredName(), createTime.getTime()).     }     if (finishedTime != null) {         builder.field(FINISHED_TIME.getPreferredName(), finishedTime.getTime()).     }     if (analysisConfig != null) {         builder.field(ANALYSIS_CONFIG.getPreferredName(), analysisConfig, params).     }     if (analysisLimits != null) {         builder.field(ANALYSIS_LIMITS.getPreferredName(), analysisLimits, params).     }     if (dataDescription != null) {         builder.field(DATA_DESCRIPTION.getPreferredName(), dataDescription, params).     }     if (modelPlotConfig != null) {         builder.field(MODEL_PLOT_CONFIG.getPreferredName(), modelPlotConfig, params).     }     if (renormalizationWindowDays != null) {         builder.field(RENORMALIZATION_WINDOW_DAYS.getPreferredName(), renormalizationWindowDays).     }     if (backgroundPersistInterval != null) {         builder.field(BACKGROUND_PERSIST_INTERVAL.getPreferredName(), backgroundPersistInterval.getStringRep()).     }     if (modelSnapshotRetentionDays != null) {         builder.field(MODEL_SNAPSHOT_RETENTION_DAYS.getPreferredName(), modelSnapshotRetentionDays).     }     if (resultsRetentionDays != null) {         builder.field(RESULTS_RETENTION_DAYS.getPreferredName(), resultsRetentionDays).     }     if (customSettings != null) {         builder.field(CUSTOM_SETTINGS.getPreferredName(), customSettings).     }     if (modelSnapshotId != null) {         builder.field(MODEL_SNAPSHOT_ID.getPreferredName(), modelSnapshotId).     }     if (modelSnapshotMinVersion != null) {         builder.field(MODEL_SNAPSHOT_MIN_VERSION.getPreferredName(), modelSnapshotMinVersion).     }     if (resultsIndexName != null) {         builder.field(RESULTS_INDEX_NAME.getPreferredName(), resultsIndexName).     }     if (deleting) {         builder.field(DELETING.getPreferredName(), deleting).     }     builder.endObject().     return builder. }
false;public;1;27;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Job.Builder that = (Job.Builder) o.     return Objects.equals(this.id, that.id) && Objects.equals(this.jobType, that.jobType) && Objects.equals(this.jobVersion, that.jobVersion) && Objects.equals(this.groups, that.groups) && Objects.equals(this.description, that.description) && Objects.equals(this.analysisConfig, that.analysisConfig) && Objects.equals(this.analysisLimits, that.analysisLimits) && Objects.equals(this.dataDescription, that.dataDescription) && Objects.equals(this.createTime, that.createTime) && Objects.equals(this.finishedTime, that.finishedTime) && Objects.equals(this.modelPlotConfig, that.modelPlotConfig) && Objects.equals(this.renormalizationWindowDays, that.renormalizationWindowDays) && Objects.equals(this.backgroundPersistInterval, that.backgroundPersistInterval) && Objects.equals(this.modelSnapshotRetentionDays, that.modelSnapshotRetentionDays) && Objects.equals(this.resultsRetentionDays, that.resultsRetentionDays) && Objects.equals(this.customSettings, that.customSettings) && Objects.equals(this.modelSnapshotId, that.modelSnapshotId) && Objects.equals(this.modelSnapshotMinVersion, that.modelSnapshotMinVersion) && Objects.equals(this.resultsIndexName, that.resultsIndexName) && Objects.equals(this.deleting, that.deleting). }
false;public;0;7;;@Override public int hashCode() {     return Objects.hash(id, jobType, jobVersion, groups, description, analysisConfig, analysisLimits, dataDescription, createTime, finishedTime, modelPlotConfig, renormalizationWindowDays, backgroundPersistInterval, modelSnapshotRetentionDays, resultsRetentionDays, customSettings, modelSnapshotId, modelSnapshotMinVersion, resultsIndexName, deleting). }
true;public;0;34;/**  * Call this method to validate that the job JSON provided by a user is valid.  * Throws an exception if there are any problems. normal return implies valid.  */ ;/**  * Call this method to validate that the job JSON provided by a user is valid.  * Throws an exception if there are any problems. normal return implies valid.  */ public void validateInputFields() {     if (analysisConfig == null) {         throw new IllegalArgumentException(Messages.getMessage(Messages.JOB_CONFIG_MISSING_ANALYSISCONFIG)).     }     if (dataDescription == null) {         throw new IllegalArgumentException(Messages.getMessage(Messages.JOB_CONFIG_MISSING_DATA_DESCRIPTION)).     }     checkTimeFieldNotInAnalysisConfig(dataDescription, analysisConfig).     checkValidBackgroundPersistInterval().     checkValueNotLessThan(0, RENORMALIZATION_WINDOW_DAYS.getPreferredName(), renormalizationWindowDays).     checkValueNotLessThan(0, MODEL_SNAPSHOT_RETENTION_DAYS.getPreferredName(), modelSnapshotRetentionDays).     checkValueNotLessThan(0, RESULTS_RETENTION_DAYS.getPreferredName(), resultsRetentionDays).     if (!MlStrings.isValidId(id)) {         throw new IllegalArgumentException(Messages.getMessage(Messages.INVALID_ID, ID.getPreferredName(), id)).     }     if (!MlStrings.hasValidLengthForId(id)) {         throw new IllegalArgumentException(Messages.getMessage(Messages.JOB_CONFIG_ID_TOO_LONG, MlStrings.ID_LENGTH_LIMIT)).     }     validateGroups().     // Results index name not specified in user input means use the default, so is acceptable in this validation     if (!Strings.isNullOrEmpty(resultsIndexName) && !MlStrings.isValidId(resultsIndexName)) {         throw new IllegalArgumentException(Messages.getMessage(Messages.INVALID_ID, RESULTS_INDEX_NAME.getPreferredName(), resultsIndexName)).     } // Creation time is NOT required in user input, hence validated only on build }
true;public;1;4;/**  * This is meant to be called when a new job is created.  * It will optionally validate the model memory limit against the max limit  * and it will set the current version defaults to missing values.  */ ;/**  * This is meant to be called when a new job is created.  * It will optionally validate the model memory limit against the max limit  * and it will set the current version defaults to missing values.  */ public void validateAnalysisLimitsAndSetDefaults(@Nullable ByteSizeValue maxModelMemoryLimit) {     analysisLimits = AnalysisLimits.validateAndSetDefaults(analysisLimits, maxModelMemoryLimit, AnalysisLimits.DEFAULT_MODEL_MEMORY_LIMIT_MB). }
false;private;0;11;;private void validateGroups() {     for (String group : this.groups) {         if (MlStrings.isValidId(group) == false) {             throw new IllegalArgumentException(Messages.getMessage(Messages.INVALID_GROUP, group)).         }         if (this.id.equals(group)) {             // cannot have a group name the same as the job id             throw new ResourceAlreadyExistsException(Messages.getMessage(Messages.JOB_AND_GROUP_NAMES_MUST_BE_UNIQUE, group)).         }     } }
true;public;1;5;/**  * Builds a job with the given {@code createTime} and the current version.  * This should be used when a new job is created as opposed to {@link #build()}.  *  * @param createTime The time this job was created  * @return The job  */ ;/**  * Builds a job with the given {@code createTime} and the current version.  * This should be used when a new job is created as opposed to {@link #build()}.  *  * @param createTime The time this job was created  * @return The job  */ public Job build(Date createTime) {     setCreateTime(createTime).     setJobVersion(Version.CURRENT).     return build(). }
true;public;0;30;/**  * Builds a job.  * This should be used when an existing job is being built  * as opposed to {@link #build(Date)}.  *  * @return The job  */ ;/**  * Builds a job.  * This should be used when an existing job is being built  * as opposed to {@link #build(Date)}.  *  * @return The job  */ public Job build() {     // If at the build stage there are missing values from analysis limits,     // it means we are reading a pre 6.3 job. Since 6.1, the model_memory_limit     // is always populated. So, if the value is missing, we fill with the pre 6.1     // default. We do not need to check against the max limit here so we pass null.     analysisLimits = AnalysisLimits.validateAndSetDefaults(analysisLimits, null, AnalysisLimits.PRE_6_1_DEFAULT_MODEL_MEMORY_LIMIT_MB).     validateInputFields().     // Creation time is NOT required in user input, hence validated only on build     ExceptionsHelper.requireNonNull(createTime, CREATE_TIME.getPreferredName()).     if (Strings.isNullOrEmpty(resultsIndexName)) {         resultsIndexName = AnomalyDetectorsIndexFields.RESULTS_INDEX_DEFAULT.     } else if (!resultsIndexName.equals(AnomalyDetectorsIndexFields.RESULTS_INDEX_DEFAULT)) {         // User-defined names are prepended with "custom"         // Conditional guards against multiple prepending due to updates instead of first creation         resultsIndexName = resultsIndexName.startsWith("custom-") ? resultsIndexName : "custom-" + resultsIndexName.     }     return new Job(id, jobType, jobVersion, groups, description, createTime, finishedTime, analysisConfig, analysisLimits, dataDescription, modelPlotConfig, renormalizationWindowDays, backgroundPersistInterval, modelSnapshotRetentionDays, resultsRetentionDays, customSettings, modelSnapshotId, modelSnapshotMinVersion, resultsIndexName, deleting). }
false;private;0;7;;private void checkValidBackgroundPersistInterval() {     if (backgroundPersistInterval != null) {         TimeUtils.checkMultiple(backgroundPersistInterval, TimeUnit.SECONDS, BACKGROUND_PERSIST_INTERVAL).         checkValueNotLessThan(MIN_BACKGROUND_PERSIST_INTERVAL.getSeconds(), BACKGROUND_PERSIST_INTERVAL.getPreferredName(), backgroundPersistInterval.getSeconds()).     } }
false;static;2;5;;static void checkTimeFieldNotInAnalysisConfig(DataDescription dataDescription, AnalysisConfig analysisConfig) {     if (analysisConfig.analysisFields().contains(dataDescription.getTimeField())) {         throw new IllegalArgumentException(Messages.getMessage(Messages.JOB_CONFIG_TIME_FIELD_NOT_ALLOWED_IN_ANALYSIS_CONFIG)).     } }
