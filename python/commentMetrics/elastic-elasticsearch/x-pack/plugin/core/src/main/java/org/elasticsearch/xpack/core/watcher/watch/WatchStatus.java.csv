commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public State state() {     return state. }
false;public;0;3;;public boolean checked() {     return lastChecked != null. }
false;public;0;3;;public ZonedDateTime lastChecked() {     return lastChecked. }
false;public;0;3;;public ZonedDateTime lastMetCondition() {     return lastMetCondition. }
false;public;1;3;;public ActionStatus actionStatus(String actionId) {     return actions.get(actionId). }
false;public;0;3;;public long version() {     return version. }
false;public;1;3;;public void version(long version) {     this.version = version. }
false;public;1;3;;public void setExecutionState(ExecutionState executionState) {     this.executionState = executionState. }
false;public;0;3;;public ExecutionState getExecutionState() {     return executionState. }
false;public;0;3;;public Map<String, String> getHeaders() {     return headers. }
false;public;1;3;;public void setHeaders(Map<String, String> headers) {     this.headers = headers. }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     WatchStatus that = (WatchStatus) o.     return Objects.equals(lastChecked, that.lastChecked) && Objects.equals(lastMetCondition, that.lastMetCondition) && Objects.equals(version, that.version) && Objects.equals(executionState, that.executionState) && Objects.equals(actions, that.actions) && Objects.equals(headers, that.headers). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(lastChecked, lastMetCondition, actions, version, executionState, headers). }
true;public;2;10;/**  * Called whenever an watch is checked, ie. the condition of the watch is evaluated to see if  * the watch should be executed.  *  * @param metCondition  indicates whether the watch's condition was met.  */ ;/**  * Called whenever an watch is checked, ie. the condition of the watch is evaluated to see if  * the watch should be executed.  *  * @param metCondition  indicates whether the watch's condition was met.  */ public void onCheck(boolean metCondition, ZonedDateTime timestamp) {     lastChecked = timestamp.     if (metCondition) {         lastMetCondition = timestamp.     } else {         for (ActionStatus status : actions.values()) {             status.resetAckStatus(timestamp).         }     } }
false;public;3;4;;public void onActionResult(String actionId, ZonedDateTime timestamp, Action.Result result) {     ActionStatus status = actions.get(actionId).     status.update(timestamp, result). }
true;;2;25;/**  * Notifies this status that the givne actions were acked. If the current state of one of these actions is  * {@link ActionStatus.AckStatus.State#ACKABLE ACKABLE},  * then we'll it'll change to {@link ActionStatus.AckStatus.State#ACKED ACKED}  * (when set to {@link ActionStatus.AckStatus.State#ACKED ACKED}, the AckThrottler  * will throttle the execution of the action.  *  * @return {@code true} if the state of changed due to the ack, {@code false} otherwise.  */ ;/**  * Notifies this status that the givne actions were acked. If the current state of one of these actions is  * {@link ActionStatus.AckStatus.State#ACKABLE ACKABLE},  * then we'll it'll change to {@link ActionStatus.AckStatus.State#ACKED ACKED}  * (when set to {@link ActionStatus.AckStatus.State#ACKED ACKED}, the AckThrottler  * will throttle the execution of the action.  *  * @return {@code true} if the state of changed due to the ack, {@code false} otherwise.  */ boolean onAck(ZonedDateTime timestamp, String... actionIds) {     boolean changed = false.     boolean containsAll = false.     for (String actionId : actionIds) {         if (actionId.equals(WatchField.ALL_ACTIONS_ID)) {             containsAll = true.             break.         }     }     if (containsAll) {         for (ActionStatus status : actions.values()) {             changed |= status.onAck(timestamp).         }         return changed.     }     for (String actionId : actionIds) {         ActionStatus status = actions.get(actionId).         if (status != null) {             changed |= status.onAck(timestamp).         }     }     return changed. }
false;;2;7;;boolean setActive(boolean active, ZonedDateTime now) {     boolean change = this.state.active != active.     if (change) {         this.state = new State(active, now).     }     return change. }
false;public;1;22;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeLong(version).     writeOptionalDate(out, lastChecked).     writeOptionalDate(out, lastMetCondition).     out.writeInt(actions.size()).     for (Map.Entry<String, ActionStatus> entry : actions.entrySet()) {         out.writeString(entry.getKey()).         ActionStatus.writeTo(entry.getValue(), out).     }     out.writeBoolean(state.active).     writeDate(out, state.timestamp).     out.writeBoolean(executionState != null).     if (executionState != null) {         out.writeString(executionState.id()).     }     boolean statusHasHeaders = headers != null && headers.isEmpty() == false.     out.writeBoolean(statusHasHeaders).     if (statusHasHeaders) {         out.writeMap(headers, StreamOutput::writeString, StreamOutput::writeString).     } }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;2;28;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (params.paramAsBoolean(INCLUDE_STATE, true)) {         builder.field(Field.STATE.getPreferredName(), state, params).     }     if (lastChecked != null) {         writeDate(Field.LAST_CHECKED.getPreferredName(), builder, lastChecked).     }     if (lastMetCondition != null) {         writeDate(Field.LAST_MET_CONDITION.getPreferredName(), builder, lastMetCondition).     }     if (actions != null) {         builder.startObject(Field.ACTIONS.getPreferredName()).         for (Map.Entry<String, ActionStatus> entry : actions.entrySet()) {             builder.field(entry.getKey(), entry.getValue(), params).         }         builder.endObject().     }     if (executionState != null) {         builder.field(Field.EXECUTION_STATE.getPreferredName(), executionState.id()).     }     if (headers != null && headers.isEmpty() == false && WatcherParams.hideHeaders(params) == false) {         builder.field(Field.HEADERS.getPreferredName(), headers).     }     builder.field(Field.VERSION.getPreferredName(), version).     return builder.endObject(). }
false;public,static;2;83;;public static WatchStatus parse(String watchId, WatcherXContentParser parser) throws IOException {     State state = null.     ExecutionState executionState = null.     ZonedDateTime lastChecked = null.     ZonedDateTime lastMetCondition = null.     Map<String, ActionStatus> actions = null.     long version = -1.     Map<String, String> headers = Collections.emptyMap().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.STATE.match(currentFieldName, parser.getDeprecationHandler())) {             try {                 state = State.parse(parser).             } catch (ElasticsearchParseException e) {                 throw new ElasticsearchParseException("could not parse watch status for [{}]. failed to parse field [{}]", e, watchId, currentFieldName).             }         } else if (Field.VERSION.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 version = parser.longValue().             } else {                 throw new ElasticsearchParseException("could not parse watch status for [{}]. expecting field [{}] to hold a long " + "value, found [{}] instead", watchId, currentFieldName, token).             }         } else if (Field.LAST_CHECKED.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 lastChecked = parseDate(currentFieldName, parser, ZoneOffset.UTC).             } else {                 throw new ElasticsearchParseException("could not parse watch status for [{}]. expecting field [{}] to hold a date " + "value, found [{}] instead", watchId, currentFieldName, token).             }         } else if (Field.LAST_MET_CONDITION.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 lastMetCondition = parseDate(currentFieldName, parser, ZoneOffset.UTC).             } else {                 throw new ElasticsearchParseException("could not parse watch status for [{}]. expecting field [{}] to hold a date " + "value, found [{}] instead", watchId, currentFieldName, token).             }         } else if (Field.EXECUTION_STATE.match(currentFieldName, parser.getDeprecationHandler())) {             if (token.isValue()) {                 executionState = ExecutionState.resolve(parser.text()).             } else {                 throw new ElasticsearchParseException("could not parse watch status for [{}]. expecting field [{}] to hold a string " + "value, found [{}] instead", watchId, currentFieldName, token).             }         } else if (Field.ACTIONS.match(currentFieldName, parser.getDeprecationHandler())) {             actions = new HashMap<>().             if (token == XContentParser.Token.START_OBJECT) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else {                         ActionStatus actionStatus = ActionStatus.parse(watchId, currentFieldName, parser).                         actions.put(currentFieldName, actionStatus).                     }                 }             } else {                 throw new ElasticsearchParseException("could not parse watch status for [{}]. expecting field [{}] to be an object, " + "found [{}] instead", watchId, currentFieldName, token).             }         } else if (Field.HEADERS.match(currentFieldName, parser.getDeprecationHandler())) {             if (token == XContentParser.Token.START_OBJECT) {                 headers = parser.mapStrings().             }         } else {             parser.skipChildren().         }     }     // contain the state     if (state == null) {         state = new State(true, parser.getParseDateTime()).     }     actions = actions == null ? emptyMap() : unmodifiableMap(actions).     return new WatchStatus(version, state, executionState, lastChecked, lastMetCondition, actions, headers). }
false;public;0;3;;public boolean isActive() {     return active. }
false;public;0;3;;public ZonedDateTime getTimestamp() {     return timestamp. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Field.ACTIVE.getPreferredName(), active).     writeDate(Field.TIMESTAMP.getPreferredName(), builder, timestamp).     return builder.endObject(). }
false;public,static;1;21;;public static State parse(XContentParser parser) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_OBJECT) {         throw new ElasticsearchParseException("expected an object but found [{}] instead", parser.currentToken()).     }     boolean active = true.     ZonedDateTime timestamp = ZonedDateTime.now(ZoneOffset.UTC).     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (Field.ACTIVE.match(currentFieldName, parser.getDeprecationHandler())) {             active = parser.booleanValue().         } else if (Field.TIMESTAMP.match(currentFieldName, parser.getDeprecationHandler())) {             timestamp = parseDate(currentFieldName, parser, ZoneOffset.UTC).         } else {             parser.skipChildren().         }     }     return new State(active, timestamp). }
