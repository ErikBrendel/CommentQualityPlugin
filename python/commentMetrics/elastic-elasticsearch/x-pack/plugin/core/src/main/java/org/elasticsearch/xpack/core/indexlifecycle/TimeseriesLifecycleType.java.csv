commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;@Override public void writeTo(StreamOutput out) throws IOException { }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;1;17;;public List<Phase> getOrderedPhases(Map<String, Phase> phases) {     List<Phase> orderedPhases = new ArrayList<>(VALID_PHASES.size()).     for (String phaseName : VALID_PHASES) {         Phase phase = phases.get(phaseName).         if (phase != null) {             Map<String, LifecycleAction> actions = phase.getActions().             if (actions.containsKey(UnfollowAction.NAME) == false && (actions.containsKey(RolloverAction.NAME) || actions.containsKey(ShrinkAction.NAME))) {                 Map<String, LifecycleAction> actionMap = new HashMap<>(phase.getActions()).                 actionMap.put(UnfollowAction.NAME, new UnfollowAction()).                 phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap).             }             orderedPhases.add(phase).         }     }     return orderedPhases. }
false;public;2;19;;@Override public String getNextPhaseName(String currentPhaseName, Map<String, Phase> phases) {     int index = VALID_PHASES.indexOf(currentPhaseName).     if (index < 0 && "new".equals(currentPhaseName) == false) {         throw new IllegalArgumentException("[" + currentPhaseName + "] is not a valid phase for lifecycle type [" + TYPE + "]").     } else {         // Find the next phase after `index` that exists in `phases` and return it         while (++index < VALID_PHASES.size()) {             String phaseName = VALID_PHASES.get(index).             if (phases.containsKey(phaseName)) {                 return phaseName.             }         }         // available         return null.     } }
false;public;2;21;;public String getPreviousPhaseName(String currentPhaseName, Map<String, Phase> phases) {     if ("new".equals(currentPhaseName)) {         return null.     }     int index = VALID_PHASES.indexOf(currentPhaseName).     if (index < 0) {         throw new IllegalArgumentException("[" + currentPhaseName + "] is not a valid phase for lifecycle type [" + TYPE + "]").     } else {         // Find the previous phase before `index` that exists in `phases` and return it         while (--index >= 0) {             String phaseName = VALID_PHASES.get(index).             if (phases.containsKey(phaseName)) {                 return phaseName.             }         }         // available         return null.     } }
false;public;1;19;;public List<LifecycleAction> getOrderedActions(Phase phase) {     Map<String, LifecycleAction> actions = phase.getActions().     switch(phase.getName()) {         case "hot":             return ORDERED_VALID_HOT_ACTIONS.stream().map(a -> actions.getOrDefault(a, null)).filter(Objects::nonNull).collect(Collectors.toList()).         case "warm":             return ORDERED_VALID_WARM_ACTIONS.stream().map(a -> actions.getOrDefault(a, null)).filter(Objects::nonNull).collect(Collectors.toList()).         case "cold":             return ORDERED_VALID_COLD_ACTIONS.stream().map(a -> actions.getOrDefault(a, null)).filter(Objects::nonNull).collect(Collectors.toList()).         case "delete":             return ORDERED_VALID_DELETE_ACTIONS.stream().map(a -> actions.getOrDefault(a, null)).filter(Objects::nonNull).collect(Collectors.toList()).         default:             throw new IllegalArgumentException("lifecycle type[" + TYPE + "] does not support phase[" + phase.getName() + "]").     } }
false;public;2;38;;@Override public String getNextActionName(String currentActionName, Phase phase) {     List<String> orderedActionNames.     switch(phase.getName()) {         case "hot":             orderedActionNames = ORDERED_VALID_HOT_ACTIONS.             break.         case "warm":             orderedActionNames = ORDERED_VALID_WARM_ACTIONS.             break.         case "cold":             orderedActionNames = ORDERED_VALID_COLD_ACTIONS.             break.         case "delete":             orderedActionNames = ORDERED_VALID_DELETE_ACTIONS.             break.         default:             throw new IllegalArgumentException("lifecycle type[" + TYPE + "] does not support phase[" + phase.getName() + "]").     }     int index = orderedActionNames.indexOf(currentActionName).     if (index < 0) {         throw new IllegalArgumentException("[" + currentActionName + "] is not a valid action for phase [" + phase.getName() + "] in lifecycle type [" + TYPE + "]").     } else {         // Find the next action after `index` that exists in the phase and return it         while (++index < orderedActionNames.size()) {             String actionName = orderedActionNames.get(index).             if (phase.getActions().containsKey(actionName)) {                 return actionName.             }         }         // action available         return null.     } }
false;public;1;14;;@Override public void validate(Collection<Phase> phases) {     phases.forEach(phase -> {         if (ALLOWED_ACTIONS.containsKey(phase.getName()) == false) {             throw new IllegalArgumentException("Timeseries lifecycle does not support phase [" + phase.getName() + "]").         }         phase.getActions().forEach((actionName, action) -> {             if (ALLOWED_ACTIONS.get(phase.getName()).contains(actionName) == false) {                 throw new IllegalArgumentException("invalid action [" + actionName + "] " + "defined in phase [" + phase.getName() + "]").             }         }).     }). }
