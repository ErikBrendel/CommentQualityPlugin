commented;modifiers;parameterAmount;loc;comment;code
false;public;2;43;;@Override public Result isConditionMet(Index index, ClusterState clusterState) {     IndexMetaData idxMeta = clusterState.metaData().index(index).     if (idxMeta == null) {         // Index must have been since deleted, ignore it         logger.debug("[{}] lifecycle action for index [{}] executed but index no longer exists", getKey().getAction(), index.getName()).         return new Result(false, null).     }     // How many shards the node should have     int expectedShardCount = idxMeta.getNumberOfShards().     // The id of the node the shards should be on     final String idShardsShouldBeOn = idxMeta.getSettings().get(IndexMetaData.INDEX_ROUTING_REQUIRE_GROUP_PREFIX + "._id").     if (idShardsShouldBeOn == null) {         throw new IllegalStateException("Cannot check shrink allocation as there are no allocation rules by _id").     }     final IndexRoutingTable routingTable = clusterState.getRoutingTable().index(index).     int foundShards = 0.     for (ShardRouting shard : routingTable.shardsWithState(ShardRoutingState.STARTED)) {         final String currentNodeId = shard.currentNodeId().         if (idShardsShouldBeOn.equals(currentNodeId) && shard.relocating() == false) {             foundShards++.         }     }     logger.trace("{} checking for shrink readiness on [{}], found {} shards and need {}", index, idShardsShouldBeOn, foundShards, expectedShardCount).     if (foundShards == expectedShardCount) {         logger.trace("{} successfully found {} allocated shards for shrink readiness on node [{}] ({})", index, expectedShardCount, idShardsShouldBeOn, getKey().getAction()).         return new Result(true, null).     } else {         logger.trace("{} failed to find {} allocated shards (found {}) on node [{}] for shrink readiness ({})", index, expectedShardCount, foundShards, idShardsShouldBeOn, getKey().getAction()).         return new Result(false, new CheckShrinkReadyStep.Info(idShardsShouldBeOn, expectedShardCount, expectedShardCount - foundShards)).     } }
false;public;0;4;;@Override public int hashCode() {     return 612. }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     return super.equals(obj). }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(MESSAGE.getPreferredName(), message).     builder.field(NODE_ID.getPreferredName(), nodeId).     builder.field(SHARDS_TO_ALLOCATE.getPreferredName(), numberShardsLeftToAllocate).     builder.field(EXPECTED_SHARDS.getPreferredName(), actualReplicas).     builder.endObject().     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(nodeId, actualReplicas, numberShardsLeftToAllocate). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     CheckShrinkReadyStep.Info other = (CheckShrinkReadyStep.Info) obj.     return Objects.equals(actualReplicas, other.actualReplicas) && Objects.equals(numberShardsLeftToAllocate, other.numberShardsLeftToAllocate) && Objects.equals(nodeId, other.nodeId). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
