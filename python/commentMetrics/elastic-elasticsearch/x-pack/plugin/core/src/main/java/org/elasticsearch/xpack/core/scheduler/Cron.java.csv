commented;modifiers;parameterAmount;loc;comment;code
true;public;1;405;/**  * Returns the next date/time <I>after</I> the given date/time which  * satisfies the cron expression.  *  * @param time the time since the epoch, or -1 if next time is unsupported (e.g. the cron expression points to  *             a time that is previous to the given time)  * @return the next valid time (since the epoch)  */ ;/**  * Returns the next date/time <I>after</I> the given date/time which  * satisfies the cron expression.  *  * @param time the time since the epoch, or -1 if next time is unsupported (e.g. the cron expression points to  *             a time that is previous to the given time)  * @return the next valid time (since the epoch)  */ public long getNextValidTimeAfter(final long time) {     // Computation is based on Gregorian year only.     Calendar cl = new java.util.GregorianCalendar(UTC, Locale.ROOT).     // move ahead one second, since we're computing the time *after* the     // given time     final long afterTime = time + 1000.     // CronTrigger does not deal with milliseconds     cl.setTimeInMillis(afterTime).     cl.set(Calendar.MILLISECOND, 0).     boolean gotOne = false.     // loop until we've computed the next time, or we've past the endTime     while (!gotOne) {         if (cl.get(Calendar.YEAR) > 2999) {             // prevent endless loop...             return -1.         }         SortedSet<Integer> st = null.         int t = 0.         int sec = cl.get(Calendar.SECOND).         int min = cl.get(Calendar.MINUTE).         // get second.................................................         st = seconds.tailSet(sec).         if (st != null && st.size() != 0) {             sec = st.first().         } else {             sec = seconds.first().             min++.             cl.set(Calendar.MINUTE, min).         }         cl.set(Calendar.SECOND, sec).         min = cl.get(Calendar.MINUTE).         int hr = cl.get(Calendar.HOUR_OF_DAY).         t = -1.         // get minute.................................................         st = minutes.tailSet(min).         if (st != null && st.size() != 0) {             t = min.             min = st.first().         } else {             min = minutes.first().             hr++.         }         if (min != t) {             cl.set(Calendar.SECOND, 0).             cl.set(Calendar.MINUTE, min).             setCalendarHour(cl, hr).             continue.         }         cl.set(Calendar.MINUTE, min).         hr = cl.get(Calendar.HOUR_OF_DAY).         int day = cl.get(Calendar.DAY_OF_MONTH).         t = -1.         // get hour...................................................         st = hours.tailSet(hr).         if (st != null && st.size() != 0) {             t = hr.             hr = st.first().         } else {             hr = hours.first().             day++.         }         if (hr != t) {             cl.set(Calendar.SECOND, 0).             cl.set(Calendar.MINUTE, 0).             cl.set(Calendar.DAY_OF_MONTH, day).             setCalendarHour(cl, hr).             continue.         }         cl.set(Calendar.HOUR_OF_DAY, hr).         day = cl.get(Calendar.DAY_OF_MONTH).         int mon = cl.get(Calendar.MONTH) + 1.         // '+ 1' because calendar is 0-based for this field, and we are         // 1-based         t = -1.         int tmon = mon.         // get day...................................................         boolean dayOfMSpec = !daysOfMonth.contains(NO_SPEC).         boolean dayOfWSpec = !daysOfWeek.contains(NO_SPEC).         if (dayOfMSpec && !dayOfWSpec) {             // get day by day of month rule             st = daysOfMonth.tailSet(day).             if (lastdayOfMonth) {                 if (!nearestWeekday) {                     t = day.                     day = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                     day -= lastdayOffset.                     if (t > day) {                         mon++.                         if (mon > 12) {                             mon = 1.                             // ensure test of mon != tmon further below fails                             tmon = 3333.                             cl.add(Calendar.YEAR, 1).                         }                         day = 1.                     }                 } else {                     t = day.                     day = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                     day -= lastdayOffset.                     Calendar tcal = Calendar.getInstance(UTC, Locale.ROOT).                     tcal.set(Calendar.SECOND, 0).                     tcal.set(Calendar.MINUTE, 0).                     tcal.set(Calendar.HOUR_OF_DAY, 0).                     tcal.set(Calendar.DAY_OF_MONTH, day).                     tcal.set(Calendar.MONTH, mon - 1).                     tcal.set(Calendar.YEAR, cl.get(Calendar.YEAR)).                     int ldom = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                     int dow = tcal.get(Calendar.DAY_OF_WEEK).                     if (dow == Calendar.SATURDAY && day == 1) {                         day += 2.                     } else if (dow == Calendar.SATURDAY) {                         day -= 1.                     } else if (dow == Calendar.SUNDAY && day == ldom) {                         day -= 2.                     } else if (dow == Calendar.SUNDAY) {                         day += 1.                     }                     tcal.set(Calendar.SECOND, sec).                     tcal.set(Calendar.MINUTE, min).                     tcal.set(Calendar.HOUR_OF_DAY, hr).                     tcal.set(Calendar.DAY_OF_MONTH, day).                     tcal.set(Calendar.MONTH, mon - 1).                     long nTime = tcal.getTimeInMillis().                     if (nTime < afterTime) {                         day = 1.                         mon++.                     }                 }             } else if (nearestWeekday) {                 t = day.                 day = daysOfMonth.first().                 Calendar tcal = Calendar.getInstance(UTC, Locale.ROOT).                 tcal.set(Calendar.SECOND, 0).                 tcal.set(Calendar.MINUTE, 0).                 tcal.set(Calendar.HOUR_OF_DAY, 0).                 tcal.set(Calendar.DAY_OF_MONTH, day).                 tcal.set(Calendar.MONTH, mon - 1).                 tcal.set(Calendar.YEAR, cl.get(Calendar.YEAR)).                 int ldom = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                 int dow = tcal.get(Calendar.DAY_OF_WEEK).                 if (dow == Calendar.SATURDAY && day == 1) {                     day += 2.                 } else if (dow == Calendar.SATURDAY) {                     day -= 1.                 } else if (dow == Calendar.SUNDAY && day == ldom) {                     day -= 2.                 } else if (dow == Calendar.SUNDAY) {                     day += 1.                 }                 tcal.set(Calendar.SECOND, sec).                 tcal.set(Calendar.MINUTE, min).                 tcal.set(Calendar.HOUR_OF_DAY, hr).                 tcal.set(Calendar.DAY_OF_MONTH, day).                 tcal.set(Calendar.MONTH, mon - 1).                 long nTime = tcal.getTimeInMillis().                 if (nTime < afterTime) {                     day = daysOfMonth.first().                     mon++.                 }             } else if (st != null && st.size() != 0) {                 t = day.                 day = st.first().                 // make sure we don't over-run a short month, such as february                 int lastDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                 if (day > lastDay) {                     day = daysOfMonth.first().                     mon++.                 }             } else {                 day = daysOfMonth.first().                 mon++.             }             if (day != t || mon != tmon) {                 cl.set(Calendar.SECOND, 0).                 cl.set(Calendar.MINUTE, 0).                 cl.set(Calendar.HOUR_OF_DAY, 0).                 cl.set(Calendar.DAY_OF_MONTH, day).                 cl.set(Calendar.MONTH, mon - 1).                 // are 1-based                 continue.             }         } else if (dayOfWSpec && !dayOfMSpec) {             // get day by day of week rule             if (lastdayOfWeek) {                 // are we looking for the last XXX day of                 // the month?                 // desired                 int dow = daysOfWeek.first().                 // d-o-w                 // current d-o-w                 int cDow = cl.get(Calendar.DAY_OF_WEEK).                 int daysToAdd = 0.                 if (cDow < dow) {                     daysToAdd = dow - cDow.                 }                 if (cDow > dow) {                     daysToAdd = dow + (7 - cDow).                 }                 int lDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                 if (day + daysToAdd > lDay) {                     // did we already miss the                     // last one?                     cl.set(Calendar.SECOND, 0).                     cl.set(Calendar.MINUTE, 0).                     cl.set(Calendar.HOUR_OF_DAY, 0).                     cl.set(Calendar.DAY_OF_MONTH, 1).                     cl.set(Calendar.MONTH, mon).                     // no '- 1' here because we are promoting the month                     continue.                 }                 // find date of last occurrence of this day in this month...                 while ((day + daysToAdd + 7) <= lDay) {                     daysToAdd += 7.                 }                 day += daysToAdd.                 if (daysToAdd > 0) {                     cl.set(Calendar.SECOND, 0).                     cl.set(Calendar.MINUTE, 0).                     cl.set(Calendar.HOUR_OF_DAY, 0).                     cl.set(Calendar.DAY_OF_MONTH, day).                     cl.set(Calendar.MONTH, mon - 1).                     // '- 1' here because we are not promoting the month                     continue.                 }             } else if (nthdayOfWeek != 0) {                 // are we looking for the Nth XXX day in the month?                 // desired                 int dow = daysOfWeek.first().                 // d-o-w                 // current d-o-w                 int cDow = cl.get(Calendar.DAY_OF_WEEK).                 int daysToAdd = 0.                 if (cDow < dow) {                     daysToAdd = dow - cDow.                 } else if (cDow > dow) {                     daysToAdd = dow + (7 - cDow).                 }                 boolean dayShifted = false.                 if (daysToAdd > 0) {                     dayShifted = true.                 }                 day += daysToAdd.                 int weekOfMonth = day / 7.                 if (day % 7 > 0) {                     weekOfMonth++.                 }                 daysToAdd = (nthdayOfWeek - weekOfMonth) * 7.                 day += daysToAdd.                 if (daysToAdd < 0 || day > getLastDayOfMonth(mon, cl.get(Calendar.YEAR))) {                     cl.set(Calendar.SECOND, 0).                     cl.set(Calendar.MINUTE, 0).                     cl.set(Calendar.HOUR_OF_DAY, 0).                     cl.set(Calendar.DAY_OF_MONTH, 1).                     cl.set(Calendar.MONTH, mon).                     // no '- 1' here because we are promoting the month                     continue.                 } else if (daysToAdd > 0 || dayShifted) {                     cl.set(Calendar.SECOND, 0).                     cl.set(Calendar.MINUTE, 0).                     cl.set(Calendar.HOUR_OF_DAY, 0).                     cl.set(Calendar.DAY_OF_MONTH, day).                     cl.set(Calendar.MONTH, mon - 1).                     // '- 1' here because we are NOT promoting the month                     continue.                 }             } else {                 // current d-o-w                 int cDow = cl.get(Calendar.DAY_OF_WEEK).                 // desired                 int dow = daysOfWeek.first().                 // d-o-w                 st = daysOfWeek.tailSet(cDow).                 if (st != null && st.size() > 0) {                     dow = st.first().                 }                 int daysToAdd = 0.                 if (cDow < dow) {                     daysToAdd = dow - cDow.                 }                 if (cDow > dow) {                     daysToAdd = dow + (7 - cDow).                 }                 int lDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR)).                 if (day + daysToAdd > lDay) {                     // will we pass the end of                     // the month?                     cl.set(Calendar.SECOND, 0).                     cl.set(Calendar.MINUTE, 0).                     cl.set(Calendar.HOUR_OF_DAY, 0).                     cl.set(Calendar.DAY_OF_MONTH, 1).                     cl.set(Calendar.MONTH, mon).                     // no '- 1' here because we are promoting the month                     continue.                 } else if (daysToAdd > 0) {                     // are we swithing days?                     cl.set(Calendar.SECOND, 0).                     cl.set(Calendar.MINUTE, 0).                     cl.set(Calendar.HOUR_OF_DAY, 0).                     cl.set(Calendar.DAY_OF_MONTH, day + daysToAdd).                     cl.set(Calendar.MONTH, mon - 1).                     // and we are 1-based                     continue.                 }             }         } else {             // dayOfWSpec && !dayOfMSpec             return -1.         // throw new UnsupportedOperationException(         // "Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.").         }         cl.set(Calendar.DAY_OF_MONTH, day).         mon = cl.get(Calendar.MONTH) + 1.         // '+ 1' because calendar is 0-based for this field, and we are         // 1-based         int year = cl.get(Calendar.YEAR).         t = -1.         // but keep looping...         if (year > MAX_YEAR) {             return -1.         // throw new ElasticsearchIllegalArgumentException("given time is not supported by cron [" + formatter.print(time) + "]").         }         // get month...................................................         st = months.tailSet(mon).         if (st != null && st.size() != 0) {             t = mon.             mon = st.first().         } else {             mon = months.first().             year++.         }         if (mon != t) {             cl.set(Calendar.SECOND, 0).             cl.set(Calendar.MINUTE, 0).             cl.set(Calendar.HOUR_OF_DAY, 0).             cl.set(Calendar.DAY_OF_MONTH, 1).             cl.set(Calendar.MONTH, mon - 1).             // '- 1' because calendar is 0-based for this field, and we are             // 1-based             cl.set(Calendar.YEAR, year).             continue.         }         cl.set(Calendar.MONTH, mon - 1).         // '- 1' because calendar is 0-based for this field, and we are         // 1-based         year = cl.get(Calendar.YEAR).         t = -1.         // get year...................................................         st = years.tailSet(year).         if (st != null && st.size() != 0) {             t = year.             year = st.first().         } else {             return -1.         // throw new ElasticsearchIllegalArgumentException("given time is not supported by cron [" + formatter.print(time) + "]").         }         if (year != t) {             cl.set(Calendar.SECOND, 0).             cl.set(Calendar.MINUTE, 0).             cl.set(Calendar.HOUR_OF_DAY, 0).             cl.set(Calendar.DAY_OF_MONTH, 1).             cl.set(Calendar.MONTH, 0).             // '- 1' because calendar is 0-based for this field, and we are             // 1-based             cl.set(Calendar.YEAR, year).             continue.         }         cl.set(Calendar.YEAR, year).         gotOne = true.     }     return cl.getTimeInMillis(). }
false;public;0;3;;public String expression() {     return expression. }
false;public;0;39;;public String getExpressionSummary() {     StringBuilder buf = new StringBuilder().     buf.append("seconds: ").     buf.append(expressionSetSummary(seconds)).     buf.append("\n").     buf.append("minutes: ").     buf.append(expressionSetSummary(minutes)).     buf.append("\n").     buf.append("hours: ").     buf.append(expressionSetSummary(hours)).     buf.append("\n").     buf.append("daysOfMonth: ").     buf.append(expressionSetSummary(daysOfMonth)).     buf.append("\n").     buf.append("months: ").     buf.append(expressionSetSummary(months)).     buf.append("\n").     buf.append("daysOfWeek: ").     buf.append(expressionSetSummary(daysOfWeek)).     buf.append("\n").     buf.append("lastdayOfWeek: ").     buf.append(lastdayOfWeek).     buf.append("\n").     buf.append("nearestWeekday: ").     buf.append(nearestWeekday).     buf.append("\n").     buf.append("NthDayOfWeek: ").     buf.append(nthdayOfWeek).     buf.append("\n").     buf.append("lastdayOfMonth: ").     buf.append(lastdayOfMonth).     buf.append("\n").     buf.append("years: ").     buf.append(expressionSetSummary(years)).     buf.append("\n").     return buf.toString(). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(expression). }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     final Cron other = (Cron) obj.     return Objects.equals(this.expression, other.expression). }
true;public;0;4;/**  * Returns the string representation of the <CODE>CronExpression</CODE>  *  * @return a string representation of the <CODE>CronExpression</CODE>  */ ;/**  * Returns the string representation of the <CODE>CronExpression</CODE>  *  * @return a string representation of the <CODE>CronExpression</CODE>  */ @Override public String toString() {     return expression. }
true;public,static;1;8;/**  * Indicates whether the specified cron expression can be parsed into a  * valid cron expression  *  * @param expression the expression to evaluate  * @return a boolean indicating whether the given expression is a valid cron  *         expression  */ ;/**  * Indicates whether the specified cron expression can be parsed into a  * valid cron expression  *  * @param expression the expression to evaluate  * @return a boolean indicating whether the given expression is a valid cron  *         expression  */ public static boolean isValid(String expression) {     try {         validate(expression).     } catch (IllegalArgumentException pe) {         return false.     }     return true. }
false;public,static;1;3;;public static void validate(String expression) throws IllegalArgumentException {     new Cron(expression). }
false;private;1;79;;// ////////////////////////////////////////////////////////////////////////// //  // Expression Parsing Functions //  // ////////////////////////////////////////////////////////////////////////// private void buildExpression(String expression) {     try {         if (seconds == null) {             seconds = new TreeSet<Integer>().         }         if (minutes == null) {             minutes = new TreeSet<Integer>().         }         if (hours == null) {             hours = new TreeSet<Integer>().         }         if (daysOfMonth == null) {             daysOfMonth = new TreeSet<Integer>().         }         if (months == null) {             months = new TreeSet<Integer>().         }         if (daysOfWeek == null) {             daysOfWeek = new TreeSet<Integer>().         }         if (years == null) {             years = new TreeSet<Integer>().         }         int exprOn = SECOND.         StringTokenizer exprsTok = new StringTokenizer(expression, " \t", false).         while (exprsTok.hasMoreTokens() && exprOn <= YEAR) {             String expr = exprsTok.nextToken().trim().             // throw an exception if L is used with other days of the month             if (exprOn == DAY_OF_MONTH && expr.indexOf('L') != -1 && expr.length() > 1 && expr.contains(",")) {                 throw illegalArgument("support for specifying 'L' and 'LW' with other days of the month is not implemented").             }             // throw an exception if L is used with other days of the week             if (exprOn == DAY_OF_WEEK && expr.indexOf('L') != -1 && expr.length() > 1 && expr.contains(",")) {                 throw illegalArgument("support for specifying 'L' with other days of the week is not implemented").             }             if (exprOn == DAY_OF_WEEK && expr.indexOf('#') != -1 && expr.indexOf('#', expr.indexOf('#') + 1) != -1) {                 throw illegalArgument("support for specifying multiple \"nth\" days is not implemented.").             }             StringTokenizer vTok = new StringTokenizer(expr, ",").             while (vTok.hasMoreTokens()) {                 String v = vTok.nextToken().                 storeExpressionVals(0, v, exprOn).             }             exprOn++.         }         if (exprOn <= DAY_OF_WEEK) {             throw illegalArgument("unexpected end of expression at pos [{}].", expression.length()).         }         if (exprOn <= YEAR) {             storeExpressionVals(0, "*", YEAR).         }         TreeSet<Integer> dow = getSet(DAY_OF_WEEK).         TreeSet<Integer> dom = getSet(DAY_OF_MONTH).         // Copying the logic from the UnsupportedOperationException below         boolean dayOfMSpec = !dom.contains(NO_SPEC).         boolean dayOfWSpec = !dow.contains(NO_SPEC).         if (!dayOfMSpec || dayOfWSpec) {             if (!dayOfWSpec || dayOfMSpec) {                 throw illegalArgument("support for specifying both a day-of-week AND a day-of-month parameter is not implemented.").             }         }     } catch (Exception e) {         throw illegalArgument("illegal cron expression format [{}]", e.toString()).     } }
false;private;3;176;;private int storeExpressionVals(int pos, String s, int type) throws ElasticsearchParseException {     int incr = 0.     int i = skipWhiteSpace(pos, s).     if (i >= s.length()) {         return i.     }     char c = s.charAt(i).     if ((c >= 'A') && (c <= 'Z') && (!s.equals("L")) && (!s.equals("LW")) && (!s.matches("^L-[0-9]*[W]?"))) {         String sub = s.substring(i, i + 3).         int sval = -1.         int eval = -1.         if (type == MONTH) {             sval = getMonthNumber(sub) + 1.             if (sval <= 0) {                 throw illegalArgument("invalid Month value [{}] at pos [{}]", sub, i).             }             if (s.length() > i + 3) {                 c = s.charAt(i + 3).                 if (c == '-') {                     i += 4.                     sub = s.substring(i, i + 3).                     eval = getMonthNumber(sub) + 1.                     if (eval <= 0) {                         throw illegalArgument("invalid Month value [{}] at pos [{}]", sub, i).                     }                 }             }         } else if (type == DAY_OF_WEEK) {             sval = getDayOfWeekNumber(sub).             if (sval < 0) {                 throw illegalArgument("invalid Day-of-Week value [{}] at pos [{}]", sub, i).             }             if (s.length() > i + 3) {                 c = s.charAt(i + 3).                 if (c == '-') {                     i += 4.                     sub = s.substring(i, i + 3).                     eval = getDayOfWeekNumber(sub).                     if (eval < 0) {                         throw illegalArgument("invalid Day-of-Week value [{}] at pos [{}]", sub, i).                     }                 } else if (c == '#') {                     try {                         i += 4.                         nthdayOfWeek = Integer.parseInt(s.substring(i)).                         if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {                             throw new Exception().                         }                     } catch (Exception e) {                         throw illegalArgument("a numeric value between 1 and 5 must follow the '#' option at pos [{}]", i).                     }                 } else if (c == 'L') {                     lastdayOfWeek = true.                     i++.                 }             }         } else {             throw illegalArgument("illegal characters [{}] at pos [{}] '", sub, i).         }         if (eval != -1) {             incr = 1.         }         addToSet(sval, eval, incr, type).         return (i + 3).     }     if (c == '?') {         i++.         if ((i + 1) < s.length() && (s.charAt(i) != ' ' && s.charAt(i + 1) != '\t')) {             throw illegalArgument("illegal character [{}] after '?' at pos [{}]", s.charAt(i), i).         }         if (type != DAY_OF_WEEK && type != DAY_OF_MONTH) {             throw illegalArgument("'?' can only be specified for Day-of-Month or Day-of-Week. at pos [{}]", i).         }         if (type == DAY_OF_WEEK && !lastdayOfMonth) {             int val = daysOfMonth.last().             if (val == NO_SPEC_INT) {                 throw illegalArgument("'?' can only be specified for Day-of-Month -OR- Day-of-Week. at pos [{}]", i).             }         }         addToSet(NO_SPEC_INT, -1, 0, type).         return i.     }     if (c == '*' || c == '/') {         if (c == '*' && (i + 1) >= s.length()) {             addToSet(ALL_SPEC_INT, -1, incr, type).             return i + 1.         } else if (c == '/' && ((i + 1) >= s.length() || s.charAt(i + 1) == ' ' || s.charAt(i + 1) == '\t')) {             throw illegalArgument("'/' must be followed by an integer. at pos [{}]", i).         } else if (c == '*') {             i++.         }         c = s.charAt(i).         if (c == '/') {             // is an increment specified?             i++.             if (i >= s.length()) {                 throw illegalArgument("Unexpected end of string. at pos [{}]", i).             }             incr = getNumericValue(s, i).             i++.             if (incr > 10) {                 i++.             }             if (incr > 59 && (type == SECOND || type == MINUTE)) {                 throw illegalArgument("increment [{}] > 60 at pos [{}]", incr, i).             } else if (incr > 23 && (type == HOUR)) {                 throw illegalArgument("increment [{}] > 24 at pos [{}]", incr, i).             } else if (incr > 31 && (type == DAY_OF_MONTH)) {                 throw illegalArgument("increment [{}] > 31 at pos [{}] ", incr, i).             } else if (incr > 7 && (type == DAY_OF_WEEK)) {                 throw illegalArgument("increment [{}] > 7 at pos [{}] ", incr, i).             } else if (incr > 12 && (type == MONTH)) {                 throw illegalArgument("increment [{}] > 12 at pos [{}]", incr, i).             }         } else {             incr = 1.         }         addToSet(ALL_SPEC_INT, -1, incr, type).         return i.     } else if (c == 'L') {         i++.         if (type == DAY_OF_MONTH) {             lastdayOfMonth = true.         }         if (type == DAY_OF_WEEK) {             addToSet(7, 7, 0, type).         }         if (type == DAY_OF_MONTH && s.length() > i) {             c = s.charAt(i).             if (c == '-') {                 ValueSet vs = getValue(0, s, i + 1).                 lastdayOffset = vs.value.                 if (lastdayOffset > 30)                     throw illegalArgument("offset from last day must be <= 30 at pos [{}]", i + 1).                 i = vs.pos.             }             if (s.length() > i) {                 c = s.charAt(i).                 if (c == 'W') {                     nearestWeekday = true.                     i++.                 }             }         }         return i.     } else if (c >= '0' && c <= '9') {         int val = Integer.parseInt(String.valueOf(c)).         i++.         if (i >= s.length()) {             addToSet(val, -1, -1, type).         } else {             c = s.charAt(i).             if (c >= '0' && c <= '9') {                 ValueSet vs = getValue(val, s, i).                 val = vs.value.                 i = vs.pos.             }             i = checkNext(i, s, val, type).             return i.         }     } else {         throw illegalArgument("Unexpected character [{}] at pos [{}] ", c, i).     }     return i. }
false;private;4;128;;private int checkNext(int pos, String s, int val, int type) throws ElasticsearchParseException {     int end = -1.     int i = pos.     if (i >= s.length()) {         addToSet(val, end, -1, type).         return i.     }     char c = s.charAt(pos).     if (c == 'L') {         if (type == DAY_OF_WEEK) {             if (val < 1 || val > 7)                 throw illegalArgument("Day-of-Week values must be between 1 and 7").             lastdayOfWeek = true.         } else {             throw illegalArgument("'L' option is not valid here. at pos [{}]", i).         }         TreeSet<Integer> set = getSet(type).         set.add(val).         i++.         return i.     }     if (c == 'W') {         if (type == DAY_OF_MONTH) {             nearestWeekday = true.         } else {             throw illegalArgument("'W' option is not valid here. at pos [{}]", i).         }         if (val > 31)             throw illegalArgument("the 'W' option does not make sense with values larger than 31 (max number of days in a month) at " + "pos [{}]", i).         TreeSet<Integer> set = getSet(type).         set.add(val).         i++.         return i.     }     if (c == '#') {         if (type != DAY_OF_WEEK) {             throw illegalArgument("'#' option is not valid here. at pos [{}]", i).         }         i++.         try {             nthdayOfWeek = Integer.parseInt(s.substring(i)).             if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {                 throw new Exception().             }         } catch (Exception e) {             throw illegalArgument("a numeric value between 1 and 5 must follow the '#' option at pos [{}]", i).         }         TreeSet<Integer> set = getSet(type).         set.add(val).         i++.         return i.     }     if (c == '-') {         i++.         c = s.charAt(i).         int v = Integer.parseInt(String.valueOf(c)).         end = v.         i++.         if (i >= s.length()) {             addToSet(val, end, 1, type).             return i.         }         c = s.charAt(i).         if (c >= '0' && c <= '9') {             ValueSet vs = getValue(v, s, i).             end = vs.value.             i = vs.pos.         }         if (i < s.length() && ((c = s.charAt(i)) == '/')) {             i++.             c = s.charAt(i).             int v2 = Integer.parseInt(String.valueOf(c)).             i++.             if (i >= s.length()) {                 addToSet(val, end, v2, type).                 return i.             }             c = s.charAt(i).             if (c >= '0' && c <= '9') {                 ValueSet vs = getValue(v2, s, i).                 int v3 = vs.value.                 addToSet(val, end, v3, type).                 i = vs.pos.                 return i.             } else {                 addToSet(val, end, v2, type).                 return i.             }         } else {             addToSet(val, end, 1, type).             return i.         }     }     if (c == '/') {         i++.         c = s.charAt(i).         int v2 = Integer.parseInt(String.valueOf(c)).         i++.         if (i >= s.length()) {             addToSet(val, end, v2, type).             return i.         }         c = s.charAt(i).         if (c >= '0' && c <= '9') {             ValueSet vs = getValue(v2, s, i).             int v3 = vs.value.             addToSet(val, end, v3, type).             i = vs.pos.             return i.         } else {             throw illegalArgument("Unexpected character [{}] after '/' at pos [{}]", c, i).         }     }     addToSet(val, end, 0, type).     i++.     return i. }
false;private,static;1;25;;private static String expressionSetSummary(java.util.Set<Integer> set) {     if (set.contains(NO_SPEC)) {         return "?".     }     if (set.contains(ALL_SPEC)) {         return "*".     }     StringBuilder buf = new StringBuilder().     Iterator<Integer> itr = set.iterator().     boolean first = true.     while (itr.hasNext()) {         Integer iVal = itr.next().         String val = iVal.toString().         if (!first) {             buf.append(",").         }         buf.append(val).         first = false.     }     return buf.toString(). }
false;private,static;2;7;;private static int skipWhiteSpace(int i, String s) {     for (. i < s.length() && (s.charAt(i) == ' ' || s.charAt(i) == '\t'). i++) {     // intentionally empty     }     return i. }
false;private,static;2;7;;private static int findNextWhiteSpace(int i, String s) {     for (. i < s.length() && (s.charAt(i) != ' ' || s.charAt(i) != '\t'). i++) {     // intentionally empty     }     return i. }
false;private;4;139;;private void addToSet(int val, int end, int incr, int type) throws ElasticsearchParseException {     TreeSet<Integer> set = getSet(type).     if (type == SECOND || type == MINUTE) {         if ((val < 0 || val > 59 || end > 59) && (val != ALL_SPEC_INT)) {             throw illegalArgument("Minute and Second values must be between 0 and 59").         }     } else if (type == HOUR) {         if ((val < 0 || val > 23 || end > 23) && (val != ALL_SPEC_INT)) {             throw illegalArgument("Hour values must be between 0 and 23").         }     } else if (type == DAY_OF_MONTH) {         if ((val < 1 || val > 31 || end > 31) && (val != ALL_SPEC_INT) && (val != NO_SPEC_INT)) {             throw illegalArgument("Day of month values must be between 1 and 31").         }     } else if (type == MONTH) {         if ((val < 1 || val > 12 || end > 12) && (val != ALL_SPEC_INT)) {             throw illegalArgument("Month values must be between 1 and 12").         }     } else if (type == DAY_OF_WEEK) {         if ((val == 0 || val > 7 || end > 7) && (val != ALL_SPEC_INT) && (val != NO_SPEC_INT)) {             throw illegalArgument("Day-of-Week values must be between 1 and 7").         }     }     if ((incr == 0 || incr == -1) && val != ALL_SPEC_INT) {         if (val != -1) {             set.add(val).         } else {             set.add(NO_SPEC).         }         return.     }     int startAt = val.     int stopAt = end.     if (val == ALL_SPEC_INT && incr <= 0) {         incr = 1.         // put in a marker, but also fill values         set.add(ALL_SPEC).     }     if (type == SECOND || type == MINUTE) {         if (stopAt == -1) {             stopAt = 59.         }         if (startAt == -1 || startAt == ALL_SPEC_INT) {             startAt = 0.         }     } else if (type == HOUR) {         if (stopAt == -1) {             stopAt = 23.         }         if (startAt == -1 || startAt == ALL_SPEC_INT) {             startAt = 0.         }     } else if (type == DAY_OF_MONTH) {         if (stopAt == -1) {             stopAt = 31.         }         if (startAt == -1 || startAt == ALL_SPEC_INT) {             startAt = 1.         }     } else if (type == MONTH) {         if (stopAt == -1) {             stopAt = 12.         }         if (startAt == -1 || startAt == ALL_SPEC_INT) {             startAt = 1.         }     } else if (type == DAY_OF_WEEK) {         if (stopAt == -1) {             stopAt = 7.         }         if (startAt == -1 || startAt == ALL_SPEC_INT) {             startAt = 1.         }     } else if (type == YEAR) {         if (stopAt == -1) {             stopAt = MAX_YEAR.         }         if (startAt == -1 || startAt == ALL_SPEC_INT) {             startAt = 1970.         }     }     // if the end of the range is before the start, then we need to overflow into     // the next day, month etc. This is done by adding the maximum amount for that     // type, and using modulus max to determine the value being added.     int max = -1.     if (stopAt < startAt) {         switch(type) {             case SECOND:                 max = 60.                 break.             case MINUTE:                 max = 60.                 break.             case HOUR:                 max = 24.                 break.             case MONTH:                 max = 12.                 break.             case DAY_OF_WEEK:                 max = 7.                 break.             case DAY_OF_MONTH:                 max = 31.                 break.             case YEAR:                 throw new IllegalArgumentException("Start year must be less than stop year").             default:                 throw new IllegalArgumentException("Unexpected type encountered").         }         stopAt += max.     }     for (int i = startAt. i <= stopAt. i += incr) {         if (max == -1) {             // ie: there's no max to overflow over             set.add(i).         } else {             // take the modulus to get the real value             int i2 = i % max.             // 1-indexed ranges should not include 0, and should include their max             if (i2 == 0 && (type == MONTH || type == DAY_OF_WEEK || type == DAY_OF_MONTH)) {                 i2 = max.             }             set.add(i2).         }     } }
false;private;1;20;;private TreeSet<Integer> getSet(int type) {     switch(type) {         case SECOND:             return seconds.         case MINUTE:             return minutes.         case HOUR:             return hours.         case DAY_OF_MONTH:             return daysOfMonth.         case MONTH:             return months.         case DAY_OF_WEEK:             return daysOfWeek.         case YEAR:             return years.         default:             return null.     } }
false;private;3;17;;private ValueSet getValue(int v, String s, int i) {     char c = s.charAt(i).     StringBuilder s1 = new StringBuilder(String.valueOf(v)).     while (c >= '0' && c <= '9') {         s1.append(c).         i++.         if (i >= s.length()) {             break.         }         c = s.charAt(i).     }     ValueSet val = new ValueSet().     val.pos = (i < s.length()) ? i : i + 1.     val.value = Integer.parseInt(s1.toString()).     return val. }
false;private;2;5;;private int getNumericValue(String s, int i) {     int endOfVal = findNextWhiteSpace(i, s).     String val = s.substring(i, endOfVal).     return Integer.parseInt(val). }
false;private;1;9;;private int getMonthNumber(String s) {     Integer integer = monthMap.get(s).     if (integer == null) {         return -1.     }     return integer. }
false;private;1;9;;private int getDayOfWeekNumber(String s) {     Integer integer = dayMap.get(s).     if (integer == null) {         return -1.     }     return integer. }
true;private,static;2;6;/**  * Advance the calendar to the particular hour paying particular attention  * to daylight saving problems.  *  * @param cal the calendar to operate on  * @param hour the hour to set  */ ;/**  * Advance the calendar to the particular hour paying particular attention  * to daylight saving problems.  *  * @param cal the calendar to operate on  * @param hour the hour to set  */ private static void setCalendarHour(Calendar cal, int hour) {     cal.set(java.util.Calendar.HOUR_OF_DAY, hour).     if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {         cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1).     } }
false;private,static;1;3;;private static boolean isLeapYear(int year) {     return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)). }
false;private;2;32;;private int getLastDayOfMonth(int monthNum, int year) {     switch(monthNum) {         case 1:             return 31.         case 2:             return (isLeapYear(year)) ? 29 : 28.         case 3:             return 31.         case 4:             return 30.         case 5:             return 31.         case 6:             return 30.         case 7:             return 31.         case 8:             return 31.         case 9:             return 30.         case 10:             return 31.         case 11:             return 30.         case 12:             return 31.         default:             throw new IllegalArgumentException("Illegal month number: " + monthNum).     } }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.value(toString()). }
