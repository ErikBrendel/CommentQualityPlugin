commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Read encrypted private key file content with default pass phrase  */ ;/**  * Read encrypted private key file content with default pass phrase  */ public static PrivateKey readEncryptedPrivateKey(byte[] fileContents) {     return readEncryptedPrivateKey(fileContents, DEFAULT_PASS_PHRASE, false). }
true;public,static;1;3;/**  * Returns encrypted private key file content with default pass phrase  */ ;/**  * Returns encrypted private key file content with default pass phrase  */ public static byte[] writeEncryptedPrivateKey(PrivateKey privateKey) {     return writeEncryptedPrivateKey(privateKey, DEFAULT_PASS_PHRASE). }
true;public,static;3;9;/**  * Read encrypted private key file content with provided <code>passPhrase</code>  */ ;/**  * Read encrypted private key file content with provided <code>passPhrase</code>  */ public static PrivateKey readEncryptedPrivateKey(byte[] fileContents, char[] passPhrase, boolean preV4) {     byte[] keyBytes = preV4 ? decryptV3Format(fileContents) : decrypt(fileContents, passPhrase).     PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyBytes).     try {         return KeyFactory.getInstance(KEY_ALGORITHM).generatePrivate(privateKeySpec).     } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {         throw new IllegalStateException(e).     } }
true;public,static;1;8;/**  * Read public key file content  */ ;/**  * Read public key file content  */ public static PublicKey readPublicKey(byte[] fileContents) {     X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(fileContents).     try {         return KeyFactory.getInstance(CryptUtils.KEY_ALGORITHM).generatePublic(publicKeySpec).     } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {         throw new IllegalStateException(e).     } }
true;public,static;1;4;/**  * Returns encrypted public key file content with provided <code>passPhrase</code>  */ ;/**  * Returns encrypted public key file content with provided <code>passPhrase</code>  */ public static byte[] writeEncryptedPublicKey(PublicKey publicKey) {     X509EncodedKeySpec encodedKeySpec = new X509EncodedKeySpec(publicKey.getEncoded()).     return encrypt(encodedKeySpec.getEncoded(), DEFAULT_PASS_PHRASE). }
true;public,static;2;4;/**  * Returns encrypted private key file content with provided <code>passPhrase</code>  */ ;/**  * Returns encrypted private key file content with provided <code>passPhrase</code>  */ public static byte[] writeEncryptedPrivateKey(PrivateKey privateKey, char[] passPhrase) {     PKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded()).     return encrypt(encodedKeySpec.getEncoded(), passPhrase). }
true;static;1;3;/**  * Encrypts provided <code>data</code> with <code>DEFAULT_PASS_PHRASE</code>  */ ;/**  * Encrypts provided <code>data</code> with <code>DEFAULT_PASS_PHRASE</code>  */ static byte[] encrypt(byte[] data) {     return encrypt(data, DEFAULT_PASS_PHRASE). }
true;static;1;3;/**  * Decrypts provided <code>encryptedData</code> with <code>DEFAULT_PASS_PHRASE</code>  */ ;/**  * Decrypts provided <code>encryptedData</code> with <code>DEFAULT_PASS_PHRASE</code>  */ static byte[] decrypt(byte[] encryptedData) {     return decrypt(encryptedData, DEFAULT_PASS_PHRASE). }
true;private,static;2;8;/**  * Encrypts provided <code>data</code> with <code>passPhrase</code>  */ ;/**  * Encrypts provided <code>data</code> with <code>passPhrase</code>  */ private static byte[] encrypt(byte[] data, char[] passPhrase) {     try {         final Cipher encryptionCipher = getEncryptionCipher(deriveSecretKey(passPhrase)).         return encryptionCipher.doFinal(data).     } catch (IllegalBlockSizeException | BadPaddingException e) {         throw new IllegalStateException(e).     } }
true;private,static;2;8;/**  * Decrypts provided <code>encryptedData</code> with <code>passPhrase</code>  */ ;/**  * Decrypts provided <code>encryptedData</code> with <code>passPhrase</code>  */ private static byte[] decrypt(byte[] encryptedData, char[] passPhrase) {     try {         final Cipher cipher = getDecryptionCipher(deriveSecretKey(passPhrase)).         return cipher.doFinal(encryptedData).     } catch (IllegalBlockSizeException | BadPaddingException e) {         throw new IllegalStateException(e).     } }
false;static;1;9;;static byte[] encryptV3Format(byte[] data) {     try {         SecretKey encryptionKey = getV3Key().         final Cipher encryptionCipher = getEncryptionCipher(encryptionKey).         return encryptionCipher.doFinal(pad(data, 20)).     } catch (GeneralSecurityException e) {         throw new IllegalStateException(e).     } }
false;static;1;9;;static byte[] decryptV3Format(byte[] data) {     try {         SecretKey decryptionKey = getV3Key().         final Cipher decryptionCipher = getDecryptionCipher(decryptionKey).         return unPad(decryptionCipher.doFinal(data)).     } catch (GeneralSecurityException e) {         throw new IllegalStateException(e).     } }
false;private,static;0;19;;private static SecretKey getV3Key() throws NoSuchAlgorithmException, InvalidKeySpecException {     final byte[] salt = { (byte) 0xA9, (byte) 0xA2, (byte) 0xB5, (byte) 0xDE, (byte) 0x2A, (byte) 0x8A, (byte) 0x9A, (byte) 0xE6 }.     final byte[] passBytes = "elasticsearch-license".getBytes(StandardCharsets.UTF_8).     final byte[] digest = MessageDigest.getInstance("SHA-512").digest(passBytes).     final char[] hashedPassphrase = Base64.getEncoder().encodeToString(digest).toCharArray().     PBEKeySpec keySpec = new PBEKeySpec(hashedPassphrase, salt, 1024, 128).     byte[] shortKey = SecretKeyFactory.getInstance("PBEWithSHA1AndDESede").generateSecret(keySpec).getEncoded().     byte[] intermediaryKey = new byte[16].     for (int i = 0, j = 0. i < 16. i++) {         intermediaryKey[i] = shortKey[j].         if (++j == shortKey.length)             j = 0.     }     return new SecretKeySpec(intermediaryKey, "AES"). }
false;private,static;1;11;;private static SecretKey deriveSecretKey(char[] passPhrase) {     try {         PBEKeySpec keySpec = new PBEKeySpec(passPhrase, SALT, KDF_ITERATION_COUNT, ENCRYPTION_KEY_LENGTH).         SecretKey secretKey = SecretKeyFactory.getInstance(KDF_ALGORITHM).generateSecret(keySpec).         return new SecretKeySpec(secretKey.getEncoded(), CIPHER_ALGORITHM).     } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {         throw new IllegalStateException(e).     } }
false;private,static;1;3;;private static Cipher getEncryptionCipher(SecretKey secretKey) {     return getCipher(Cipher.ENCRYPT_MODE, secretKey). }
false;private,static;1;3;;private static Cipher getDecryptionCipher(SecretKey secretKey) {     return getCipher(Cipher.DECRYPT_MODE, secretKey). }
false;private,static;2;9;;private static Cipher getCipher(int mode, SecretKey secretKey) {     try {         Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM).         cipher.init(mode, secretKey, RANDOM).         return cipher.     } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException e) {         throw new IllegalStateException(e).     } }
false;private,static;2;25;;private static byte[] pad(byte[] bytes, int length) {     if (bytes.length >= length) {         byte[] out = new byte[bytes.length + 1].         System.arraycopy(bytes, 0, out, 0, bytes.length).         out[bytes.length] = (byte) 1.         return out.     }     byte[] out = new byte[length + 1].     int i = 0.     for (. i < bytes.length. i++) out[i] = bytes[i].     int padded = length - i.     // fill the rest with random bytes     byte[] fill = new byte[padded - 1].     RANDOM.nextBytes(fill).     System.arraycopy(fill, 0, out, i, padded - 1).     out[length] = (byte) (padded + 1).     return out. }
false;private,static;1;10;;private static byte[] unPad(byte[] bytes) {     int padded = (int) bytes[bytes.length - 1].     int targetLength = bytes.length - padded.     byte[] out = new byte[targetLength].     System.arraycopy(bytes, 0, out, 0, targetLength).     return out. }
