# id;timestamp;commentText;codeText;commentWords;codeWords
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1524684173;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1526449283;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1527622193;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1531729807;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1538170812;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1541008027;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1541092382;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1541190643;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols Supported protocols_@param ciphers Supported ciphers_@param verifier Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1541476610;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols  Supported protocols_@param ciphers    Supported ciphers_@param verifier   Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1543334812;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols  Supported protocols_@param ciphers    Supported ciphers_@param verifier   Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1545354122;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols  Supported protocols_@param ciphers    Supported ciphers_@param verifier   Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1545957094;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols  Supported protocols_@param ciphers    Supported ciphers_@param verifier   Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1547499982;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols  Supported protocols_@param ciphers    Supported ciphers_@param verifier   Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier);1549035251;This method only exists to simplify testing of {@link #sslIOSessionStrategy(Settings)} because {@link SSLIOSessionStrategy} does_not expose any of the parameters that you give it.__@param sslContext SSL Context used to handle SSL / TCP requests_@param protocols  Supported protocols_@param ciphers    Supported ciphers_@param verifier   Hostname verifier_@return Never {@code null}.;SSLIOSessionStrategy sslIOSessionStrategy(SSLContext sslContext, String[] protocols, String[] ciphers, HostnameVerifier verifier) {_        return new SSLIOSessionStrategy(sslContext, protocols, ciphers, verifier)__    };this,method,only,exists,to,simplify,testing,of,link,ssl,iosession,strategy,settings,because,link,ssliosession,strategy,does,not,expose,any,of,the,parameters,that,you,give,it,param,ssl,context,ssl,context,used,to,handle,ssl,tcp,requests,param,protocols,supported,protocols,param,ciphers,supported,ciphers,param,verifier,hostname,verifier,return,never,code,null;ssliosession,strategy,ssl,iosession,strategy,sslcontext,ssl,context,string,protocols,string,ciphers,hostname,verifier,verifier,return,new,ssliosession,strategy,ssl,context,protocols,ciphers,verifier
SSLService -> public SSLService createDynamicSSLService();1524684173;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1526449283;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1527622193;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1531729807;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1538170812;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1541008027;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1541092382;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1541190643;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1541476610;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1543334812;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1545354122;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1545957094;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, globalSSLConfiguration, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,global,sslconfiguration,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1547499982;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService();1549035251;Creates a new SSLService that supports dynamic creation of SSLContext instances. Instances created by this service will not be_cached and will not be monitored for reloading. This dynamic server does have access to the cached and monitored instances that_have been created during initialization;public SSLService createDynamicSSLService() {_        return new SSLService(settings, env, sslConfigurations, sslContexts) {__            @Override_            Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_                _                return Collections.emptyMap()__            }__            _            @Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            }_        }__    };creates,a,new,sslservice,that,supports,dynamic,creation,of,sslcontext,instances,instances,created,by,this,service,will,not,be,cached,and,will,not,be,monitored,for,reloading,this,dynamic,server,does,have,access,to,the,cached,and,monitored,instances,that,have,been,created,during,initialization;public,sslservice,create,dynamic,sslservice,return,new,sslservice,settings,env,ssl,configurations,ssl,contexts,override,map,sslconfiguration,sslcontext,holder,load,sslconfigurations,return,collections,empty,map,override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLConfiguration sslConfiguration(Settings settings);1547499982;Returns the existing {@link SSLConfiguration} for the given settings__@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings;public SSLConfiguration sslConfiguration(Settings settings) {_        return new SSLConfiguration(settings)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings;public,sslconfiguration,ssl,configuration,settings,settings,return,new,sslconfiguration,settings
SSLService -> public SSLConfiguration sslConfiguration(Settings settings);1549035251;Returns the existing {@link SSLConfiguration} for the given settings__@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings;public SSLConfiguration sslConfiguration(Settings settings) {_        return new SSLConfiguration(settings)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings;public,sslconfiguration,ssl,configuration,settings,settings,return,new,sslconfiguration,settings
SSLService -> public SSLService(Settings settings, Environment environment);1526449283;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        super(settings)__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,super,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1527622193;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        super(settings)__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,super,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1531729807;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        super(settings)__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,super,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1538170812;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        super(settings)__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,super,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1541008027;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        super(settings)__        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,super,settings,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1541092382;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1541190643;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1541476610;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1543334812;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1545354122;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1545957094;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.globalSSLConfiguration = new SSLConfiguration(settings.getByPrefix(XPackSettings.GLOBAL_SSL_PREFIX))__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,global,sslconfiguration,new,sslconfiguration,settings,get,by,prefix,xpack,settings,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1547499982;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLService(Settings settings, Environment environment);1549035251;Create a new SSLService that parses the settings for the ssl contexts that need to be created, creates them, and then caches them_for use later;public SSLService(Settings settings, Environment environment) {_        this.settings = settings__        this.env = environment__        this.sslConfigurations = new HashMap<>()__        this.sslContexts = loadSSLConfigurations()__    };create,a,new,sslservice,that,parses,the,settings,for,the,ssl,contexts,that,need,to,be,created,creates,them,and,then,caches,them,for,use,later;public,sslservice,settings,settings,environment,environment,this,settings,settings,this,env,environment,this,ssl,configurations,new,hash,map,this,ssl,contexts,load,sslconfigurations
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1524684173;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #sslConfiguration(Settings, Settings);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,ssl,configuration,settings,settings;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1526449283;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #sslConfiguration(Settings, Settings);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,ssl,configuration,settings,settings;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1527622193;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #sslConfiguration(Settings, Settings);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,ssl,configuration,settings,settings;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1531729807;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1538170812;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1541008027;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1541092382;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1541190643;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param configuration the ssl configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1541476610;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled__@param configuration the ssl configuration_@param host          the host of the remote endpoint. If using hostname verification, this should match what is in the remote_endpoint's certificate_@param port          the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1543334812;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled__@param configuration the ssl configuration_@param host          the host of the remote endpoint. If using hostname verification, this should match what is in the remote_endpoint's certificate_@param port          the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1545354122;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled__@param configuration the ssl configuration_@param host          the host of the remote endpoint. If using hostname verification, this should match what is in the remote_endpoint's certificate_@param port          the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1545957094;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled__@param configuration the ssl configuration_@param host          the host of the remote endpoint. If using hostname verification, this should match what is in the remote_endpoint's certificate_@param port          the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1547499982;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled__@param configuration the ssl configuration_@param host          the host of the remote endpoint. If using hostname verification, this should match what is in the remote_endpoint's certificate_@param port          the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port);1549035251;Creates an {@link SSLEngine} based on the provided configuration. This SSLEngine can be used for a connection that requires_hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled__@param configuration the ssl configuration_@param host          the host of the remote endpoint. If using hostname verification, this should match what is in the remote_endpoint's certificate_@param port          the port of the remote endpoint_@return {@link SSLEngine}_@see #getSSLConfiguration(String);public SSLEngine createSSLEngine(SSLConfiguration configuration, String host, int port) {_        SSLContext sslContext = sslContext(configuration)__        SSLEngine sslEngine = sslContext.createSSLEngine(host, port)__        String[] ciphers = supportedCiphers(sslEngine.getSupportedCipherSuites(), configuration.cipherSuites(), false)__        String[] supportedProtocols = configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        SSLParameters parameters = new SSLParameters(ciphers, supportedProtocols)__        if (configuration.verificationMode().isHostnameVerificationEnabled() && host != null) {_            _            _            _            parameters.setEndpointIdentificationAlgorithm("HTTPS")__        }_        _        parameters.setUseCipherSuitesOrder(true)__        configuration.sslClientAuth().configure(parameters)___        _        _        _        sslEngine.setSSLParameters(parameters)__        return sslEngine__    };creates,an,link,sslengine,based,on,the,provided,configuration,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,configuration,the,ssl,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine,see,get,sslconfiguration,string;public,sslengine,create,sslengine,sslconfiguration,configuration,string,host,int,port,sslcontext,ssl,context,ssl,context,configuration,sslengine,ssl,engine,ssl,context,create,sslengine,host,port,string,ciphers,supported,ciphers,ssl,engine,get,supported,cipher,suites,configuration,cipher,suites,false,string,supported,protocols,configuration,supported,protocols,to,array,strings,sslparameters,parameters,new,sslparameters,ciphers,supported,protocols,if,configuration,verification,mode,is,hostname,verification,enabled,host,null,parameters,set,endpoint,identification,algorithm,https,parameters,set,use,cipher,suites,order,true,configuration,ssl,client,auth,configure,parameters,ssl,engine,set,sslparameters,parameters,return,ssl,engine
SSLService -> public VerificationMode getVerificationMode(Settings settings, Settings fallback);1524684173;Returns the {@link VerificationMode} that is specified in the settings (or the default)_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix_@param fallback the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration;public VerificationMode getVerificationMode(Settings settings, Settings fallback) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings, fallback)__        return sslConfiguration.verificationMode()__    };returns,the,link,verification,mode,that,is,specified,in,the,settings,or,the,default,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,param,fallback,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration;public,verification,mode,get,verification,mode,settings,settings,settings,fallback,sslconfiguration,ssl,configuration,ssl,configuration,settings,fallback,return,ssl,configuration,verification,mode
SSLService -> public VerificationMode getVerificationMode(Settings settings, Settings fallback);1526449283;Returns the {@link VerificationMode} that is specified in the settings (or the default)_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix_@param fallback the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration;public VerificationMode getVerificationMode(Settings settings, Settings fallback) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings, fallback)__        return sslConfiguration.verificationMode()__    };returns,the,link,verification,mode,that,is,specified,in,the,settings,or,the,default,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,param,fallback,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration;public,verification,mode,get,verification,mode,settings,settings,settings,fallback,sslconfiguration,ssl,configuration,ssl,configuration,settings,fallback,return,ssl,configuration,verification,mode
SSLService -> public VerificationMode getVerificationMode(Settings settings, Settings fallback);1527622193;Returns the {@link VerificationMode} that is specified in the settings (or the default)_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix_@param fallback the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration;public VerificationMode getVerificationMode(Settings settings, Settings fallback) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings, fallback)__        return sslConfiguration.verificationMode()__    };returns,the,link,verification,mode,that,is,specified,in,the,settings,or,the,default,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,param,fallback,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration;public,verification,mode,get,verification,mode,settings,settings,settings,fallback,sslconfiguration,ssl,configuration,ssl,configuration,settings,fallback,return,ssl,configuration,verification,mode
SSLService -> SSLContext sslContext();1524684173;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1526449283;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1527622193;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1531729807;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1538170812;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1541008027;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1541092382;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1541190643;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> SSLContext sslContext();1541476610;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1531729807;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = SecurityField.setting("authc.realms.")__        Settings realmsSettings = settings.getByPrefix(prefix)__        for (String name : realmsSettings.names()) {_            Settings realmSSLSettings = realmsSettings.getAsSettings(name).getByPrefix("ssl.")__            _            sslSettings.put(prefix + name + ".ssl", realmSSLSettings)__        }_        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,security,field,setting,authc,realms,settings,realms,settings,settings,get,by,prefix,prefix,for,string,name,realms,settings,names,settings,realm,sslsettings,realms,settings,get,as,settings,name,get,by,prefix,ssl,ssl,settings,put,prefix,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1538170812;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = SecurityField.setting("authc.realms.")__        Settings realmsSettings = settings.getByPrefix(prefix)__        for (String name : realmsSettings.names()) {_            Settings realmSSLSettings = realmsSettings.getAsSettings(name).getByPrefix("ssl.")__            _            sslSettings.put(prefix + name + ".ssl", realmSSLSettings)__        }_        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,security,field,setting,authc,realms,settings,realms,settings,settings,get,by,prefix,prefix,for,string,name,realms,settings,names,settings,realm,sslsettings,realms,settings,get,as,settings,name,get,by,prefix,ssl,ssl,settings,put,prefix,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1541008027;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = SecurityField.setting("authc.realms.")__        Settings realmsSettings = settings.getByPrefix(prefix)__        for (String name : realmsSettings.names()) {_            Settings realmSSLSettings = realmsSettings.getAsSettings(name).getByPrefix("ssl.")__            _            sslSettings.put(prefix + name + ".ssl", realmSSLSettings)__        }_        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,security,field,setting,authc,realms,settings,realms,settings,settings,get,by,prefix,prefix,for,string,name,realms,settings,names,settings,realm,sslsettings,realms,settings,get,as,settings,name,get,by,prefix,ssl,ssl,settings,put,prefix,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1541092382;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = SecurityField.setting("authc.realms.")__        Settings realmsSettings = settings.getByPrefix(prefix)__        for (String name : realmsSettings.names()) {_            Settings realmSSLSettings = realmsSettings.getAsSettings(name).getByPrefix("ssl.")__            _            sslSettings.put(prefix + name + ".ssl", realmSSLSettings)__        }_        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,security,field,setting,authc,realms,settings,realms,settings,settings,get,by,prefix,prefix,for,string,name,realms,settings,names,settings,realm,sslsettings,realms,settings,get,as,settings,name,get,by,prefix,ssl,ssl,settings,put,prefix,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1541190643;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = SecurityField.setting("authc.realms.")__        Settings realmsSettings = settings.getByPrefix(prefix)__        for (String name : realmsSettings.names()) {_            Settings realmSSLSettings = realmsSettings.getAsSettings(name).getByPrefix("ssl.")__            _            sslSettings.put(prefix + name + ".ssl", realmSSLSettings)__        }_        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,security,field,setting,authc,realms,settings,realms,settings,settings,get,by,prefix,prefix,for,string,name,realms,settings,names,settings,realm,sslsettings,realms,settings,get,as,settings,name,get,by,prefix,ssl,ssl,settings,put,prefix,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1541476610;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        final Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = "xpack.security.authc.realms."__        final Map<String, Settings> settingsByRealmType = settings.getGroups(prefix)__        settingsByRealmType.forEach((realmType, typeSettings) ->_            typeSettings.getAsGroups().forEach((realmName, realmSettings) -> {_                Settings realmSSLSettings = realmSettings.getByPrefix("ssl.")__                _                sslSettings.put(prefix + realmType + "." + realmName + ".ssl", realmSSLSettings)__            })_        )__        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,final,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,xpack,security,authc,realms,final,map,string,settings,settings,by,realm,type,settings,get,groups,prefix,settings,by,realm,type,for,each,realm,type,type,settings,type,settings,get,as,groups,for,each,realm,name,realm,settings,settings,realm,sslsettings,realm,settings,get,by,prefix,ssl,ssl,settings,put,prefix,realm,type,realm,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1543334812;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        final Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = "xpack.security.authc.realms."__        final Map<String, Settings> settingsByRealmType = settings.getGroups(prefix)__        settingsByRealmType.forEach((realmType, typeSettings) ->_            typeSettings.getAsGroups().forEach((realmName, realmSettings) -> {_                Settings realmSSLSettings = realmSettings.getByPrefix("ssl.")__                _                sslSettings.put(prefix + realmType + "." + realmName + ".ssl", realmSSLSettings)__            })_        )__        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,final,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,xpack,security,authc,realms,final,map,string,settings,settings,by,realm,type,settings,get,groups,prefix,settings,by,realm,type,for,each,realm,type,type,settings,type,settings,get,as,groups,for,each,realm,name,realm,settings,settings,realm,sslsettings,realm,settings,get,by,prefix,ssl,ssl,settings,put,prefix,realm,type,realm,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1545354122;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        final Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = "xpack.security.authc.realms."__        final Map<String, Settings> settingsByRealmType = settings.getGroups(prefix)__        settingsByRealmType.forEach((realmType, typeSettings) -> {_                final Optional<String> nonDottedSetting = typeSettings.keySet().stream().filter(k -> k.indexOf('.') == -1).findAny()__                if (nonDottedSetting.isPresent()) {_                    logger.warn("Skipping any SSL configuration from realm [{}{}] because the key [{}] is not in the correct format",_                        prefix, realmType, nonDottedSetting.get())__                } else {_                    typeSettings.getAsGroups().forEach((realmName, realmSettings) -> {_                        Settings realmSSLSettings = realmSettings.getByPrefix("ssl.")__                        _                        sslSettings.put(prefix + realmType + "." + realmName + ".ssl", realmSSLSettings)__                    })__                }_            }_        )__        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,final,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,xpack,security,authc,realms,final,map,string,settings,settings,by,realm,type,settings,get,groups,prefix,settings,by,realm,type,for,each,realm,type,type,settings,final,optional,string,non,dotted,setting,type,settings,key,set,stream,filter,k,k,index,of,1,find,any,if,non,dotted,setting,is,present,logger,warn,skipping,any,ssl,configuration,from,realm,because,the,key,is,not,in,the,correct,format,prefix,realm,type,non,dotted,setting,get,else,type,settings,get,as,groups,for,each,realm,name,realm,settings,settings,realm,sslsettings,realm,settings,get,by,prefix,ssl,ssl,settings,put,prefix,realm,type,realm,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1545957094;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        final Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = "xpack.security.authc.realms."__        final Map<String, Settings> settingsByRealmType = settings.getGroups(prefix)__        settingsByRealmType.forEach((realmType, typeSettings) -> {_                final Optional<String> nonDottedSetting = typeSettings.keySet().stream().filter(k -> k.indexOf('.') == -1).findAny()__                if (nonDottedSetting.isPresent()) {_                    logger.warn("Skipping any SSL configuration from realm [{}{}] because the key [{}] is not in the correct format",_                        prefix, realmType, nonDottedSetting.get())__                } else {_                    typeSettings.getAsGroups().forEach((realmName, realmSettings) -> {_                        Settings realmSSLSettings = realmSettings.getByPrefix("ssl.")__                        _                        sslSettings.put(prefix + realmType + "." + realmName + ".ssl", realmSSLSettings)__                    })__                }_            }_        )__        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,final,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,xpack,security,authc,realms,final,map,string,settings,settings,by,realm,type,settings,get,groups,prefix,settings,by,realm,type,for,each,realm,type,type,settings,final,optional,string,non,dotted,setting,type,settings,key,set,stream,filter,k,k,index,of,1,find,any,if,non,dotted,setting,is,present,logger,warn,skipping,any,ssl,configuration,from,realm,because,the,key,is,not,in,the,correct,format,prefix,realm,type,non,dotted,setting,get,else,type,settings,get,as,groups,for,each,realm,name,realm,settings,settings,realm,sslsettings,realm,settings,get,by,prefix,ssl,ssl,settings,put,prefix,realm,type,realm,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1547499982;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        final Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = "xpack.security.authc.realms."__        final Map<String, Settings> settingsByRealmType = settings.getGroups(prefix)__        settingsByRealmType.forEach((realmType, typeSettings) -> {_                final Optional<String> nonDottedSetting = typeSettings.keySet().stream().filter(k -> k.indexOf('.') == -1).findAny()__                if (nonDottedSetting.isPresent()) {_                    logger.warn("Skipping any SSL configuration from realm [{}{}] because the key [{}] is not in the correct format",_                        prefix, realmType, nonDottedSetting.get())__                } else {_                    typeSettings.getAsGroups().forEach((realmName, realmSettings) -> {_                        Settings realmSSLSettings = realmSettings.getByPrefix("ssl.")__                        _                        sslSettings.put(prefix + realmType + "." + realmName + ".ssl", realmSSLSettings)__                    })__                }_            }_        )__        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,final,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,xpack,security,authc,realms,final,map,string,settings,settings,by,realm,type,settings,get,groups,prefix,settings,by,realm,type,for,each,realm,type,type,settings,final,optional,string,non,dotted,setting,type,settings,key,set,stream,filter,k,k,index,of,1,find,any,if,non,dotted,setting,is,present,logger,warn,skipping,any,ssl,configuration,from,realm,because,the,key,is,not,in,the,correct,format,prefix,realm,type,non,dotted,setting,get,else,type,settings,get,as,groups,for,each,realm,name,realm,settings,settings,realm,sslsettings,realm,settings,get,by,prefix,ssl,ssl,settings,put,prefix,realm,type,realm,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> private static Map<String, Settings> getRealmsSSLSettings(Settings settings);1549035251;@return A map of Settings prefix to Settings object;private static Map<String, Settings> getRealmsSSLSettings(Settings settings) {_        final Map<String, Settings> sslSettings = new HashMap<>()__        final String prefix = "xpack.security.authc.realms."__        final Map<String, Settings> settingsByRealmType = settings.getGroups(prefix)__        settingsByRealmType.forEach((realmType, typeSettings) -> {_                final Optional<String> nonDottedSetting = typeSettings.keySet().stream().filter(k -> k.indexOf('.') == -1).findAny()__                if (nonDottedSetting.isPresent()) {_                    logger.warn("Skipping any SSL configuration from realm [{}{}] because the key [{}] is not in the correct format",_                        prefix, realmType, nonDottedSetting.get())__                } else {_                    typeSettings.getAsGroups().forEach((realmName, realmSettings) -> {_                        Settings realmSSLSettings = realmSettings.getByPrefix("ssl.")__                        _                        sslSettings.put(prefix + realmType + "." + realmName + ".ssl", realmSSLSettings)__                    })__                }_            }_        )__        return sslSettings__    };return,a,map,of,settings,prefix,to,settings,object;private,static,map,string,settings,get,realms,sslsettings,settings,settings,final,map,string,settings,ssl,settings,new,hash,map,final,string,prefix,xpack,security,authc,realms,final,map,string,settings,settings,by,realm,type,settings,get,groups,prefix,settings,by,realm,type,for,each,realm,type,type,settings,final,optional,string,non,dotted,setting,type,settings,key,set,stream,filter,k,k,index,of,1,find,any,if,non,dotted,setting,is,present,logger,warn,skipping,any,ssl,configuration,from,realm,because,the,key,is,not,in,the,correct,format,prefix,realm,type,non,dotted,setting,get,else,type,settings,get,as,groups,for,each,realm,name,realm,settings,settings,realm,sslsettings,realm,settings,get,by,prefix,ssl,ssl,settings,put,prefix,realm,type,realm,name,ssl,realm,sslsettings,return,ssl,settings
SSLService -> public boolean isSSLClientAuthEnabled(Settings settings, Settings fallback);1524684173;Indicates whether client authentication is enabled for a particular configuration_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix_@param fallback the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration;public boolean isSSLClientAuthEnabled(Settings settings, Settings fallback) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings, fallback)__        return isSSLClientAuthEnabled(sslConfiguration)__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,param,fallback,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration;public,boolean,is,sslclient,auth,enabled,settings,settings,settings,fallback,sslconfiguration,ssl,configuration,ssl,configuration,settings,fallback,return,is,sslclient,auth,enabled,ssl,configuration
SSLService -> public boolean isSSLClientAuthEnabled(Settings settings, Settings fallback);1526449283;Indicates whether client authentication is enabled for a particular configuration_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix_@param fallback the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration;public boolean isSSLClientAuthEnabled(Settings settings, Settings fallback) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings, fallback)__        return isSSLClientAuthEnabled(sslConfiguration)__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,param,fallback,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration;public,boolean,is,sslclient,auth,enabled,settings,settings,settings,fallback,sslconfiguration,ssl,configuration,ssl,configuration,settings,fallback,return,is,sslclient,auth,enabled,ssl,configuration
SSLService -> public boolean isSSLClientAuthEnabled(Settings settings, Settings fallback);1527622193;Indicates whether client authentication is enabled for a particular configuration_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix_@param fallback the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration;public boolean isSSLClientAuthEnabled(Settings settings, Settings fallback) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings, fallback)__        return isSSLClientAuthEnabled(sslConfiguration)__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,param,fallback,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration;public,boolean,is,sslclient,auth,enabled,settings,settings,settings,fallback,sslconfiguration,ssl,configuration,ssl,configuration,settings,fallback,return,is,sslclient,auth,enabled,ssl,configuration
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1524684173;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1526449283;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1527622193;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1531729807;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1538170812;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1541008027;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1541092382;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1541190643;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1541476610;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1543334812;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1545354122;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1545957094;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1547499982;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> Collection<SSLConfiguration> getLoadedSSLConfigurations();1549035251;Accessor to the loaded ssl configuration objects at the current point in time. This is useful for testing;Collection<SSLConfiguration> getLoadedSSLConfigurations() {_        return Collections.unmodifiableSet(new HashSet<>(sslContexts.keySet()))__    };accessor,to,the,loaded,ssl,configuration,objects,at,the,current,point,in,time,this,is,useful,for,testing;collection,sslconfiguration,get,loaded,sslconfigurations,return,collections,unmodifiable,set,new,hash,set,ssl,contexts,key,set
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1524684173;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1526449283;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1527622193;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1531729807;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1538170812;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1541008027;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1541092382;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1541190643;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host._@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1541476610;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host.__@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1543334812;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host.__@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1545354122;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host.__@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1545957094;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host.__@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1547499982;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host.__@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException;1549035251;Returns information about each certificate that is referenced by any SSL configuration._This includes certificates used for identity (with a private key) and those used for trust, but excludes_certificates that are provided by the JRE._Due to the nature of KeyStores, this may include certificates that are available, but never used_such as a CA certificate that is no longer in use, or a server certificate for an unrelated host.__@see TrustConfig#certificates(Environment);public Set<CertificateInfo> getLoadedCertificates() throws GeneralSecurityException, IOException {_        Set<CertificateInfo> certificates = new HashSet<>()__        for (SSLConfiguration config : this.getLoadedSSLConfigurations()) {_            certificates.addAll(config.getDefinedCertificates(env))__        }_        return certificates__    };returns,information,about,each,certificate,that,is,referenced,by,any,ssl,configuration,this,includes,certificates,used,for,identity,with,a,private,key,and,those,used,for,trust,but,excludes,certificates,that,are,provided,by,the,jre,due,to,the,nature,of,key,stores,this,may,include,certificates,that,are,available,but,never,used,such,as,a,ca,certificate,that,is,no,longer,in,use,or,a,server,certificate,for,an,unrelated,host,see,trust,config,certificates,environment;public,set,certificate,info,get,loaded,certificates,throws,general,security,exception,ioexception,set,certificate,info,certificates,new,hash,set,for,sslconfiguration,config,this,get,loaded,sslconfigurations,certificates,add,all,config,get,defined,certificates,env,return,certificates
SSLService -> public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings, String host, int port);1524684173;Creates an {@link SSLEngine} based on the provided settings. The settings are used to identify the ssl configuration that should be_used to create the engine. This SSLEngine can be used for a connection that requires hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a SSLEngine created from the default configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine};public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings, String host, int port) {_        SSLConfiguration configuration = sslConfiguration(settings, fallbackSettings)__        return createSSLEngine(configuration, host, port)__    };creates,an,link,sslengine,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,engine,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,sslengine,created,from,the,default,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine;public,sslengine,create,sslengine,settings,settings,settings,fallback,settings,string,host,int,port,sslconfiguration,configuration,ssl,configuration,settings,fallback,settings,return,create,sslengine,configuration,host,port
SSLService -> public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings, String host, int port);1526449283;Creates an {@link SSLEngine} based on the provided settings. The settings are used to identify the ssl configuration that should be_used to create the engine. This SSLEngine can be used for a connection that requires hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a SSLEngine created from the default configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine};public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings, String host, int port) {_        SSLConfiguration configuration = sslConfiguration(settings, fallbackSettings)__        return createSSLEngine(configuration, host, port)__    };creates,an,link,sslengine,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,engine,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,sslengine,created,from,the,default,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine;public,sslengine,create,sslengine,settings,settings,settings,fallback,settings,string,host,int,port,sslconfiguration,configuration,ssl,configuration,settings,fallback,settings,return,create,sslengine,configuration,host,port
SSLService -> public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings, String host, int port);1527622193;Creates an {@link SSLEngine} based on the provided settings. The settings are used to identify the ssl configuration that should be_used to create the engine. This SSLEngine can be used for a connection that requires hostname verification assuming the provided_host and port are correct. The SSLEngine created by this method is most useful for clients with hostname verification enabled_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a SSLEngine created from the default configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@param host the host of the remote endpoint. If using hostname verification, this should match what is in the remote endpoint's_certificate_@param port the port of the remote endpoint_@return {@link SSLEngine};public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings, String host, int port) {_        SSLConfiguration configuration = sslConfiguration(settings, fallbackSettings)__        return createSSLEngine(configuration, host, port)__    };creates,an,link,sslengine,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,engine,this,sslengine,can,be,used,for,a,connection,that,requires,hostname,verification,assuming,the,provided,host,and,port,are,correct,the,sslengine,created,by,this,method,is,most,useful,for,clients,with,hostname,verification,enabled,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,sslengine,created,from,the,default,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,param,host,the,host,of,the,remote,endpoint,if,using,hostname,verification,this,should,match,what,is,in,the,remote,endpoint,s,certificate,param,port,the,port,of,the,remote,endpoint,return,link,sslengine;public,sslengine,create,sslengine,settings,settings,settings,fallback,settings,string,host,int,port,sslconfiguration,configuration,ssl,configuration,settings,fallback,settings,return,create,sslengine,configuration,host,port
SSLService -> public SSLConfiguration sslConfiguration(Settings settings, Settings fallbackSettings);1524684173;Returns the existing {@link SSLConfiguration} for the given settings and applies the provided fallback settings instead of the global_configuration_@param settings the settings for the ssl configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;public SSLConfiguration sslConfiguration(Settings settings, Settings fallbackSettings) {_        if (settings.isEmpty() && fallbackSettings.isEmpty()) {_            return globalSSLConfiguration__        }_        SSLConfiguration fallback = sslConfiguration(fallbackSettings)__        return new SSLConfiguration(settings, fallback)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,and,applies,the,provided,fallback,settings,instead,of,the,global,configuration,param,settings,the,settings,for,the,ssl,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;public,sslconfiguration,ssl,configuration,settings,settings,settings,fallback,settings,if,settings,is,empty,fallback,settings,is,empty,return,global,sslconfiguration,sslconfiguration,fallback,ssl,configuration,fallback,settings,return,new,sslconfiguration,settings,fallback
SSLService -> public SSLConfiguration sslConfiguration(Settings settings, Settings fallbackSettings);1526449283;Returns the existing {@link SSLConfiguration} for the given settings and applies the provided fallback settings instead of the global_configuration_@param settings the settings for the ssl configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;public SSLConfiguration sslConfiguration(Settings settings, Settings fallbackSettings) {_        if (settings.isEmpty() && fallbackSettings.isEmpty()) {_            return globalSSLConfiguration__        }_        SSLConfiguration fallback = sslConfiguration(fallbackSettings)__        return new SSLConfiguration(settings, fallback)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,and,applies,the,provided,fallback,settings,instead,of,the,global,configuration,param,settings,the,settings,for,the,ssl,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;public,sslconfiguration,ssl,configuration,settings,settings,settings,fallback,settings,if,settings,is,empty,fallback,settings,is,empty,return,global,sslconfiguration,sslconfiguration,fallback,ssl,configuration,fallback,settings,return,new,sslconfiguration,settings,fallback
SSLService -> public SSLConfiguration sslConfiguration(Settings settings, Settings fallbackSettings);1527622193;Returns the existing {@link SSLConfiguration} for the given settings and applies the provided fallback settings instead of the global_configuration_@param settings the settings for the ssl configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;public SSLConfiguration sslConfiguration(Settings settings, Settings fallbackSettings) {_        if (settings.isEmpty() && fallbackSettings.isEmpty()) {_            return globalSSLConfiguration__        }_        SSLConfiguration fallback = sslConfiguration(fallbackSettings)__        return new SSLConfiguration(settings, fallback)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,and,applies,the,provided,fallback,settings,instead,of,the,global,configuration,param,settings,the,settings,for,the,ssl,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;public,sslconfiguration,ssl,configuration,settings,settings,settings,fallback,settings,if,settings,is,empty,fallback,settings,is,empty,return,global,sslconfiguration,sslconfiguration,fallback,ssl,configuration,fallback,settings,return,new,sslconfiguration,settings,fallback
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1524684173;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1526449283;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1527622193;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1531729807;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1538170812;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1541008027;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1541092382;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1541190643;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> SSLContext sslContext(SSLConfiguration configuration);1541476610;Returns the {@link SSLContext} for the configuration;SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration;sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> public SSLContext sslContext();1543334812;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;public SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> public SSLContext sslContext();1545354122;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;public SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> public SSLContext sslContext();1545957094;Returns the {@link SSLContext} for the global configuration. Mainly used for testing;public SSLContext sslContext() {_        return sslContextHolder(globalSSLConfiguration).sslContext()__    };returns,the,link,sslcontext,for,the,global,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,return,ssl,context,holder,global,sslconfiguration,ssl,context
SSLService -> public SSLContext sslContext(SSLConfiguration configuration);1543334812;Returns the {@link SSLContext} for the configuration. Mainly used for testing;public SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> public SSLContext sslContext(SSLConfiguration configuration);1545354122;Returns the {@link SSLContext} for the configuration. Mainly used for testing;public SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> public SSLContext sslContext(SSLConfiguration configuration);1545957094;Returns the {@link SSLContext} for the configuration. Mainly used for testing;public SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> public SSLContext sslContext(SSLConfiguration configuration);1547499982;Returns the {@link SSLContext} for the configuration. Mainly used for testing;public SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> public SSLContext sslContext(SSLConfiguration configuration);1549035251;Returns the {@link SSLContext} for the configuration. Mainly used for testing;public SSLContext sslContext(SSLConfiguration configuration) {_        return sslContextHolder(configuration).sslContext()__    };returns,the,link,sslcontext,for,the,configuration,mainly,used,for,testing;public,sslcontext,ssl,context,sslconfiguration,configuration,return,ssl,context,holder,configuration,ssl,context
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1538170812;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1541008027;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1541092382;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1541190643;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1541476610;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1543334812;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1545354122;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1545957094;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1547499982;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> static void invalidateSessions(SSLSessionContext sslSessionContext);1549035251;Invalidates the sessions in the provided {@link SSLSessionContext};static void invalidateSessions(SSLSessionContext sslSessionContext) {_        Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__        while (sessionIds.hasMoreElements()) {_            byte[] sessionId = sessionIds.nextElement()__            SSLSession session = sslSessionContext.getSession(sessionId)__            _            _            _            _            if (session != null) {_                session.invalidate()__            }_        }_    };invalidates,the,sessions,in,the,provided,link,sslsession,context;static,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,sslsession,session,ssl,session,context,get,session,session,id,if,session,null,session,invalidate
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1524684173;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        ReloadableTrustManager trustManager =_                new ReloadableTrustManager(sslConfiguration.trustConfig().createTrustManager(env), sslConfiguration.trustConfig())__        ReloadableX509KeyManager keyManager =_                new ReloadableX509KeyManager(sslConfiguration.keyConfig().createKeyManager(env), sslConfiguration.keyConfig())__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,reloadable,trust,manager,trust,manager,new,reloadable,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,ssl,configuration,trust,config,reloadable,x509key,manager,key,manager,new,reloadable,x509key,manager,ssl,configuration,key,config,create,key,manager,env,ssl,configuration,key,config,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1526449283;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1527622193;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1531729807;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1538170812;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1541008027;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1541092382;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1541190643;Creates an {@link SSLContext} based on the provided configuration_@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1541476610;Creates an {@link SSLContext} based on the provided configuration__@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1543334812;Creates an {@link SSLContext} based on the provided configuration__@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1545354122;Creates an {@link SSLContext} based on the provided configuration__@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1545957094;Creates an {@link SSLContext} based on the provided configuration__@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1547499982;Creates an {@link SSLContext} based on the provided configuration__@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration);1549035251;Creates an {@link SSLContext} based on the provided configuration__@param sslConfiguration the configuration to use for context creation_@return the created SSLContext;private SSLContextHolder createSslContext(SSLConfiguration sslConfiguration) {_        if (logger.isDebugEnabled()) {_            logger.debug("using ssl settings [{}]", sslConfiguration)__        }_        X509ExtendedTrustManager trustManager = sslConfiguration.trustConfig().createTrustManager(env)__        X509ExtendedKeyManager keyManager = sslConfiguration.keyConfig().createKeyManager(env)__        return createSslContext(keyManager, trustManager, sslConfiguration)__    };creates,an,link,sslcontext,based,on,the,provided,configuration,param,ssl,configuration,the,configuration,to,use,for,context,creation,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,sslconfiguration,ssl,configuration,if,logger,is,debug,enabled,logger,debug,using,ssl,settings,ssl,configuration,x509extended,trust,manager,trust,manager,ssl,configuration,trust,config,create,trust,manager,env,x509extended,key,manager,key,manager,ssl,configuration,key,config,create,key,manager,env,return,create,ssl,context,key,manager,trust,manager,ssl,configuration
SSLService -> public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1524684173;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}.;public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        SSLContext sslContext = sslContext(config)__        String[] ciphers = supportedCiphers(sslParameters(sslContext).getCipherSuites(), config.cipherSuites(), false)__        String[] supportedProtocols = config.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        HostnameVerifier verifier___        if (config.verificationMode().isHostnameVerificationEnabled()) {_            verifier = SSLIOSessionStrategy.getDefaultHostnameVerifier()__        } else {_            verifier = NoopHostnameVerifier.INSTANCE__        }__        return sslIOSessionStrategy(sslContext, supportedProtocols, ciphers, verifier)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null;public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,sslcontext,ssl,context,ssl,context,config,string,ciphers,supported,ciphers,ssl,parameters,ssl,context,get,cipher,suites,config,cipher,suites,false,string,supported,protocols,config,supported,protocols,to,array,strings,hostname,verifier,verifier,if,config,verification,mode,is,hostname,verification,enabled,verifier,ssliosession,strategy,get,default,hostname,verifier,else,verifier,noop,hostname,verifier,instance,return,ssl,iosession,strategy,ssl,context,supported,protocols,ciphers,verifier
SSLService -> public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1526449283;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}.;public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        SSLContext sslContext = sslContext(config)__        String[] ciphers = supportedCiphers(sslParameters(sslContext).getCipherSuites(), config.cipherSuites(), false)__        String[] supportedProtocols = config.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        HostnameVerifier verifier___        if (config.verificationMode().isHostnameVerificationEnabled()) {_            verifier = SSLIOSessionStrategy.getDefaultHostnameVerifier()__        } else {_            verifier = NoopHostnameVerifier.INSTANCE__        }__        return sslIOSessionStrategy(sslContext, supportedProtocols, ciphers, verifier)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null;public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,sslcontext,ssl,context,ssl,context,config,string,ciphers,supported,ciphers,ssl,parameters,ssl,context,get,cipher,suites,config,cipher,suites,false,string,supported,protocols,config,supported,protocols,to,array,strings,hostname,verifier,verifier,if,config,verification,mode,is,hostname,verification,enabled,verifier,ssliosession,strategy,get,default,hostname,verifier,else,verifier,noop,hostname,verifier,instance,return,ssl,iosession,strategy,ssl,context,supported,protocols,ciphers,verifier
SSLService -> public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1527622193;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}.;public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        SSLContext sslContext = sslContext(config)__        String[] ciphers = supportedCiphers(sslParameters(sslContext).getCipherSuites(), config.cipherSuites(), false)__        String[] supportedProtocols = config.supportedProtocols().toArray(Strings.EMPTY_ARRAY)__        HostnameVerifier verifier___        if (config.verificationMode().isHostnameVerificationEnabled()) {_            verifier = SSLIOSessionStrategy.getDefaultHostnameVerifier()__        } else {_            verifier = NoopHostnameVerifier.INSTANCE__        }__        return sslIOSessionStrategy(sslContext, supportedProtocols, ciphers, verifier)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null;public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,sslcontext,ssl,context,ssl,context,config,string,ciphers,supported,ciphers,ssl,parameters,ssl,context,get,cipher,suites,config,cipher,suites,false,string,supported,protocols,config,supported,protocols,to,array,strings,hostname,verifier,verifier,if,config,verification,mode,is,hostname,verification,enabled,verifier,ssliosession,strategy,get,default,hostname,verifier,else,verifier,noop,hostname,verifier,instance,return,ssl,iosession,strategy,ssl,context,supported,protocols,ciphers,verifier
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1524684173;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1526449283;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1527622193;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1531729807;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1538170812;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1541008027;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1541092382;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1541190643;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1541476610;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1543334812;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1545354122;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1545957094;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1547499982;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">JCA Standard Algorithm Name_Documentation for Java 8</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            return "TLSv1.2"__        }__        String algorithm = "SSL"__        for (String supportedProtocol : supportedProtocols) {_            switch (supportedProtocol) {_                case "TLSv1.2":_                    return "TLSv1.2"__                case "TLSv1.1":_                    if ("TLSv1.2".equals(algorithm) == false) {_                        algorithm = "TLSv1.1"__                    }_                    break__                case "TLSv1":_                    switch (algorithm) {_                        case "TLSv1.2":_                        case "TLSv1.1":_                            break__                        default:_                            algorithm = "TLSv1"__                    }_                    break__                case "SSLv3":_                    switch (algorithm) {_                        case "SSLv2":_                        case "SSL":_                            algorithm = "SSLv3"__                    }_                    break__                case "SSLv2":_                case "SSLv2Hello":_                    break__                default:_                    throw new IllegalArgumentException("found unexpected value in supported protocols: " + supportedProtocol)__            }_        }_        return algorithm__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,http,docs,oracle,com,javase,8,docs,technotes,guides,security,standard,names,html,jca,standard,algorithm,name,documentation,for,java,8,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,return,tlsv1,2,string,algorithm,ssl,for,string,supported,protocol,supported,protocols,switch,supported,protocol,case,tlsv1,2,return,tlsv1,2,case,tlsv1,1,if,tlsv1,2,equals,algorithm,false,algorithm,tlsv1,1,break,case,tlsv1,switch,algorithm,case,tlsv1,2,case,tlsv1,1,break,default,algorithm,tlsv1,break,case,sslv3,switch,algorithm,case,sslv2,case,ssl,algorithm,sslv3,break,case,sslv2,case,sslv2hello,break,default,throw,new,illegal,argument,exception,found,unexpected,value,in,supported,protocols,supported,protocol,return,algorithm
SSLService -> private static String sslContextAlgorithm(List<String> supportedProtocols);1549035251;Maps the supported protocols to an appropriate ssl context algorithm. We make an attempt to use the "best" algorithm when_possible. The names in this method are taken from the_<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#sslcontext-algorithms">Java Security_Standard Algorithm Names Documentation for Java 11</a>.;private static String sslContextAlgorithm(List<String> supportedProtocols) {_        if (supportedProtocols.isEmpty()) {_            throw new IllegalArgumentException("no SSL/TLS protocols have been configured")__        }_        for (Entry<String, String> entry : ORDERED_PROTOCOL_ALGORITHM_MAP.entrySet()) {_            if (supportedProtocols.contains(entry.getKey())) {_                return entry.getValue()__            }_        }_        throw new IllegalArgumentException("no supported SSL/TLS protocol was found in the configured supported protocols: "_            + supportedProtocols)__    };maps,the,supported,protocols,to,an,appropriate,ssl,context,algorithm,we,make,an,attempt,to,use,the,best,algorithm,when,possible,the,names,in,this,method,are,taken,from,the,a,href,https,docs,oracle,com,en,java,javase,11,docs,specs,security,standard,names,html,sslcontext,algorithms,java,security,standard,algorithm,names,documentation,for,java,11,a;private,static,string,ssl,context,algorithm,list,string,supported,protocols,if,supported,protocols,is,empty,throw,new,illegal,argument,exception,no,ssl,tls,protocols,have,been,configured,for,entry,string,string,entry,entry,set,if,supported,protocols,contains,entry,get,key,return,entry,get,value,throw,new,illegal,argument,exception,no,supported,ssl,tls,protocol,was,found,in,the,configured,supported,protocols,supported,protocols
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1524684173;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1526449283;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1527622193;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1531729807;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1538170812;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1541008027;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1541092382;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1541190643;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested._@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1541476610;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested.__@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1543334812;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested.__@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1545354122;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested.__@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1545957094;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested.__@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1547499982;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested.__@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log);1549035251;Returns the intersection of the supported ciphers with the requested ciphers. This method will also optionally log if unsupported_ciphers were requested.__@throws IllegalArgumentException if no supported ciphers are in the requested ciphers;String[] supportedCiphers(String[] supportedCiphers, List<String> requestedCiphers, boolean log) {_        List<String> supportedCiphersList = new ArrayList<>(requestedCiphers.size())__        List<String> unsupportedCiphers = new LinkedList<>()__        boolean found__        for (String requestedCipher : requestedCiphers) {_            found = false__            for (String supportedCipher : supportedCiphers) {_                if (supportedCipher.equals(requestedCipher)) {_                    found = true__                    supportedCiphersList.add(requestedCipher)__                    break__                }_            }__            if (!found) {_                unsupportedCiphers.add(requestedCipher)__            }_        }__        if (supportedCiphersList.isEmpty()) {_            throw new IllegalArgumentException("none of the ciphers " + Arrays.toString(requestedCiphers.toArray())_                    + " are supported by this JVM")__        }__        if (log && !unsupportedCiphers.isEmpty()) {_            logger.error("unsupported ciphers [{}] were requested but cannot be used in this JVM, however there are supported ciphers " +_                    "that will be used [{}]. If you are trying to use ciphers with a key length greater than 128 bits on an Oracle JVM, " +_                    "you will need to install the unlimited strength JCE policy files.", unsupportedCiphers, supportedCiphersList)__        }__        return supportedCiphersList.toArray(new String[supportedCiphersList.size()])__    };returns,the,intersection,of,the,supported,ciphers,with,the,requested,ciphers,this,method,will,also,optionally,log,if,unsupported,ciphers,were,requested,throws,illegal,argument,exception,if,no,supported,ciphers,are,in,the,requested,ciphers;string,supported,ciphers,string,supported,ciphers,list,string,requested,ciphers,boolean,log,list,string,supported,ciphers,list,new,array,list,requested,ciphers,size,list,string,unsupported,ciphers,new,linked,list,boolean,found,for,string,requested,cipher,requested,ciphers,found,false,for,string,supported,cipher,supported,ciphers,if,supported,cipher,equals,requested,cipher,found,true,supported,ciphers,list,add,requested,cipher,break,if,found,unsupported,ciphers,add,requested,cipher,if,supported,ciphers,list,is,empty,throw,new,illegal,argument,exception,none,of,the,ciphers,arrays,to,string,requested,ciphers,to,array,are,supported,by,this,jvm,if,log,unsupported,ciphers,is,empty,logger,error,unsupported,ciphers,were,requested,but,cannot,be,used,in,this,jvm,however,there,are,supported,ciphers,that,will,be,used,if,you,are,trying,to,use,ciphers,with,a,key,length,greater,than,128,bits,on,an,oracle,jvm,you,will,need,to,install,the,unlimited,strength,jce,policy,files,unsupported,ciphers,supported,ciphers,list,return,supported,ciphers,list,to,array,new,string,supported,ciphers,list,size
SSLService -> public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings);1524684173;Creates an {@link SSLEngine} based on the provided settings. The settings are used to identify the ssl configuration that should be_used to create the engine. This SSLEngine cannot be used for hostname verification since the engine will not be created with the_host and port. This method is useful to obtain an SSLEngine that will be used for server connections or client connections that_will not use hostname verification._@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a SSLEngine created from the default configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@return {@link SSLEngine};public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings) {_        return createSSLEngine(settings, fallbackSettings, null, -1)__    };creates,an,link,sslengine,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,engine,this,sslengine,cannot,be,used,for,hostname,verification,since,the,engine,will,not,be,created,with,the,host,and,port,this,method,is,useful,to,obtain,an,sslengine,that,will,be,used,for,server,connections,or,client,connections,that,will,not,use,hostname,verification,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,sslengine,created,from,the,default,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,return,link,sslengine;public,sslengine,create,sslengine,settings,settings,settings,fallback,settings,return,create,sslengine,settings,fallback,settings,null,1
SSLService -> public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings);1526449283;Creates an {@link SSLEngine} based on the provided settings. The settings are used to identify the ssl configuration that should be_used to create the engine. This SSLEngine cannot be used for hostname verification since the engine will not be created with the_host and port. This method is useful to obtain an SSLEngine that will be used for server connections or client connections that_will not use hostname verification._@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a SSLEngine created from the default configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@return {@link SSLEngine};public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings) {_        return createSSLEngine(settings, fallbackSettings, null, -1)__    };creates,an,link,sslengine,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,engine,this,sslengine,cannot,be,used,for,hostname,verification,since,the,engine,will,not,be,created,with,the,host,and,port,this,method,is,useful,to,obtain,an,sslengine,that,will,be,used,for,server,connections,or,client,connections,that,will,not,use,hostname,verification,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,sslengine,created,from,the,default,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,return,link,sslengine;public,sslengine,create,sslengine,settings,settings,settings,fallback,settings,return,create,sslengine,settings,fallback,settings,null,1
SSLService -> public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings);1527622193;Creates an {@link SSLEngine} based on the provided settings. The settings are used to identify the ssl configuration that should be_used to create the engine. This SSLEngine cannot be used for hostname verification since the engine will not be created with the_host and port. This method is useful to obtain an SSLEngine that will be used for server connections or client connections that_will not use hostname verification._@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a SSLEngine created from the default configuration_@param fallbackSettings the settings that should be used for the fallback of the SSLConfiguration. Using {@link Settings#EMPTY}_results in a fallback to the global configuration_@return {@link SSLEngine};public SSLEngine createSSLEngine(Settings settings, Settings fallbackSettings) {_        return createSSLEngine(settings, fallbackSettings, null, -1)__    };creates,an,link,sslengine,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,engine,this,sslengine,cannot,be,used,for,hostname,verification,since,the,engine,will,not,be,created,with,the,host,and,port,this,method,is,useful,to,obtain,an,sslengine,that,will,be,used,for,server,connections,or,client,connections,that,will,not,use,hostname,verification,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,sslengine,created,from,the,default,configuration,param,fallback,settings,the,settings,that,should,be,used,for,the,fallback,of,the,sslconfiguration,using,link,settings,empty,results,in,a,fallback,to,the,global,configuration,return,link,sslengine;public,sslengine,create,sslengine,settings,settings,settings,fallback,settings,return,create,sslengine,settings,fallback,settings,null,1
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1524684173;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1526449283;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1527622193;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1531729807;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1538170812;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1541008027;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1541092382;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1541190643;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1541476610;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1543334812;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1545354122;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1545957094;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1547499982;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration);1549035251;Indicates whether client authentication is enabled for a particular configuration;public boolean isSSLClientAuthEnabled(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.sslClientAuth().enabled()__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration;public,boolean,is,sslclient,auth,enabled,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,ssl,client,auth,enabled
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1524684173;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1526449283;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1527622193;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1531729807;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1538170812;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541008027;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541092382;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541190643;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541476610;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1543334812;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1545354122;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1545957094;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1547499982;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> public SSLService createDynamicSSLService() -> null -> @Override             SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1549035251;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;@Override_            SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_                SSLContextHolder holder = sslContexts.get(sslConfiguration)__                if (holder == null) {_                    _                    holder = createSslContext(sslConfiguration)__                }_                return holder__            };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;override,sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,holder,create,ssl,context,ssl,configuration,return,holder
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1531729807;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1538170812;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1541008027;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1541092382;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1541190643;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1541476610;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1543334812;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1545354122;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1545957094;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1547499982;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> @Deprecated     public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings);1549035251;Create a new {@link SSLIOSessionStrategy} based on the provided settings. The settings are used to identify the SSL configuration_that should be used to create the context.__@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a context created from the default configuration_@return Never {@code null}._@deprecated This method will fail if the SSL configuration uses a {@link org.elasticsearch.common.settings.SecureSetting} but the_{@link org.elasticsearch.common.settings.SecureSettings} have been closed. Use {@link #getSSLConfiguration(String)}_and {@link #sslIOSessionStrategy(SSLConfiguration)} (Deprecated, but not removed because monitoring uses dynamic SSL settings);@Deprecated_    public SSLIOSessionStrategy sslIOSessionStrategy(Settings settings) {_        SSLConfiguration config = sslConfiguration(settings)__        return sslIOSessionStrategy(config)__    };create,a,new,link,ssliosession,strategy,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,context,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,context,created,from,the,default,configuration,return,never,code,null,deprecated,this,method,will,fail,if,the,ssl,configuration,uses,a,link,org,elasticsearch,common,settings,secure,setting,but,the,link,org,elasticsearch,common,settings,secure,settings,have,been,closed,use,link,get,sslconfiguration,string,and,link,ssl,iosession,strategy,sslconfiguration,deprecated,but,not,removed,because,monitoring,uses,dynamic,ssl,settings;deprecated,public,ssliosession,strategy,ssl,iosession,strategy,settings,settings,sslconfiguration,config,ssl,configuration,settings,return,ssl,iosession,strategy,config
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1524684173;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1526449283;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1527622193;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1531729807;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1538170812;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1541008027;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1541092382;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1541190643;Returns whether the provided settings results in a valid configuration that can be used for server connections_@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1541476610;Returns whether the provided settings results in a valid configuration that can be used for server connections__@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1543334812;Returns whether the provided settings results in a valid configuration that can be used for server connections__@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1545354122;Returns whether the provided settings results in a valid configuration that can be used for server connections__@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1545957094;Returns whether the provided settings results in a valid configuration that can be used for server connections__@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1547499982;Returns whether the provided settings results in a valid configuration that can be used for server connections__@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration);1549035251;Returns whether the provided settings results in a valid configuration that can be used for server connections__@param sslConfiguration the configuration to check;public boolean isConfigurationValidForServerUsage(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSLConfiguration cannot be null")__        return sslConfiguration.keyConfig() != KeyConfig.NONE__    };returns,whether,the,provided,settings,results,in,a,valid,configuration,that,can,be,used,for,server,connections,param,ssl,configuration,the,configuration,to,check;public,boolean,is,configuration,valid,for,server,usage,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,sslconfiguration,cannot,be,null,return,ssl,configuration,key,config,key,config,none
SSLService -> public boolean isSSLClientAuthEnabled(Settings settings);1524684173;Indicates whether client authentication is enabled for a particular configuration_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. The global configuration_will be used for fallback;public boolean isSSLClientAuthEnabled(Settings settings) {_        return isSSLClientAuthEnabled(settings, Settings.EMPTY)__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,the,global,configuration,will,be,used,for,fallback;public,boolean,is,sslclient,auth,enabled,settings,settings,return,is,sslclient,auth,enabled,settings,settings,empty
SSLService -> public boolean isSSLClientAuthEnabled(Settings settings);1526449283;Indicates whether client authentication is enabled for a particular configuration_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. The global configuration_will be used for fallback;public boolean isSSLClientAuthEnabled(Settings settings) {_        return isSSLClientAuthEnabled(settings, Settings.EMPTY)__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,the,global,configuration,will,be,used,for,fallback;public,boolean,is,sslclient,auth,enabled,settings,settings,return,is,sslclient,auth,enabled,settings,settings,empty
SSLService -> public boolean isSSLClientAuthEnabled(Settings settings);1527622193;Indicates whether client authentication is enabled for a particular configuration_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. The global configuration_will be used for fallback;public boolean isSSLClientAuthEnabled(Settings settings) {_        return isSSLClientAuthEnabled(settings, Settings.EMPTY)__    };indicates,whether,client,authentication,is,enabled,for,a,particular,configuration,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,the,global,configuration,will,be,used,for,fallback;public,boolean,is,sslclient,auth,enabled,settings,settings,return,is,sslclient,auth,enabled,settings,settings,empty
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1524684173;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1526449283;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1527622193;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1531729807;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1538170812;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1541008027;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1541092382;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1541190643;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1541476610;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1543334812;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1545354122;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1545957094;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1547499982;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLParameters sslParameters(SSLContext sslContext);1549035251;The {@link SSLParameters} that are associated with the {@code sslContext}._<p>_This method exists to simplify testing since {@link SSLContext#getSupportedSSLParameters()} is {@code final}.__@param sslContext The SSL context for the current SSL settings_@return Never {@code null}.;SSLParameters sslParameters(SSLContext sslContext) {_        return sslContext.getSupportedSSLParameters()__    };the,link,sslparameters,that,are,associated,with,the,code,ssl,context,p,this,method,exists,to,simplify,testing,since,link,sslcontext,get,supported,sslparameters,is,code,final,param,ssl,context,the,ssl,context,for,the,current,ssl,settings,return,never,code,null;sslparameters,ssl,parameters,sslcontext,ssl,context,return,ssl,context,get,supported,sslparameters
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1524684173;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1526449283;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1527622193;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1531729807;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1538170812;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541008027;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541092382;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541190643;Returns the existing {@link SSLContextHolder} for the configuration_@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1541476610;Returns the existing {@link SSLContextHolder} for the configuration__@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1543334812;Returns the existing {@link SSLContextHolder} for the configuration__@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1545354122;Returns the existing {@link SSLContextHolder} for the configuration__@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1545957094;Returns the existing {@link SSLContextHolder} for the configuration__@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1547499982;Returns the existing {@link SSLContextHolder} for the configuration__@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration);1549035251;Returns the existing {@link SSLContextHolder} for the configuration__@throws IllegalArgumentException if not found;SSLContextHolder sslContextHolder(SSLConfiguration sslConfiguration) {_        Objects.requireNonNull(sslConfiguration, "SSL Configuration cannot be null")__        SSLContextHolder holder = sslContexts.get(sslConfiguration)__        if (holder == null) {_            throw new IllegalArgumentException("did not find a SSLContext for [" + sslConfiguration.toString() + "]")__        }_        return holder__    };returns,the,existing,link,sslcontext,holder,for,the,configuration,throws,illegal,argument,exception,if,not,found;sslcontext,holder,ssl,context,holder,sslconfiguration,ssl,configuration,objects,require,non,null,ssl,configuration,ssl,configuration,cannot,be,null,sslcontext,holder,holder,ssl,contexts,get,ssl,configuration,if,holder,null,throw,new,illegal,argument,exception,did,not,find,a,sslcontext,for,ssl,configuration,to,string,return,holder
SSLService -> public SSLSocketFactory sslSocketFactory(Settings settings);1524684173;Create a new {@link SSLSocketFactory} based on the provided settings. The settings are used to identify the ssl configuration that_should be used to create the socket factory. The socket factory will also properly configure the ciphers and protocols on each_socket that is created_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a factory created from the default configuration_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(Settings settings) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings)__        SSLSocketFactory socketFactory = sslContext(sslConfiguration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, sslConfiguration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), sslConfiguration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,socket,factory,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,factory,created,from,the,default,configuration,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,settings,settings,sslconfiguration,ssl,configuration,ssl,configuration,settings,sslsocket,factory,socket,factory,ssl,context,ssl,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,ssl,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,ssl,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(Settings settings);1526449283;Create a new {@link SSLSocketFactory} based on the provided settings. The settings are used to identify the ssl configuration that_should be used to create the socket factory. The socket factory will also properly configure the ciphers and protocols on each_socket that is created_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a factory created from the default configuration_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(Settings settings) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings)__        SSLSocketFactory socketFactory = sslContext(sslConfiguration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, sslConfiguration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), sslConfiguration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,socket,factory,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,factory,created,from,the,default,configuration,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,settings,settings,sslconfiguration,ssl,configuration,ssl,configuration,settings,sslsocket,factory,socket,factory,ssl,context,ssl,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,ssl,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,ssl,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(Settings settings);1527622193;Create a new {@link SSLSocketFactory} based on the provided settings. The settings are used to identify the ssl configuration that_should be used to create the socket factory. The socket factory will also properly configure the ciphers and protocols on each_socket that is created_@param settings the settings used to identify the ssl configuration, typically under a *.ssl. prefix. An empty settings will return_a factory created from the default configuration_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(Settings settings) {_        SSLConfiguration sslConfiguration = sslConfiguration(settings)__        SSLSocketFactory socketFactory = sslContext(sslConfiguration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, sslConfiguration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), sslConfiguration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,settings,the,settings,are,used,to,identify,the,ssl,configuration,that,should,be,used,to,create,the,socket,factory,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,settings,the,settings,used,to,identify,the,ssl,configuration,typically,under,a,ssl,prefix,an,empty,settings,will,return,a,factory,created,from,the,default,configuration,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,settings,settings,sslconfiguration,ssl,configuration,ssl,configuration,settings,sslsocket,factory,socket,factory,ssl,context,ssl,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,ssl,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,ssl,configuration,cipher,suites,false
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1524684173;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1526449283;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1527622193;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1531729807;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1538170812;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1541008027;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1541092382;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1541190643;Returns the existing {@link SSLConfiguration} for the given settings_@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1541476610;Returns the existing {@link SSLConfiguration} for the given settings__@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1543334812;Returns the existing {@link SSLConfiguration} for the given settings__@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1545354122;Returns the existing {@link SSLConfiguration} for the given settings__@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> SSLConfiguration sslConfiguration(Settings settings);1545957094;Returns the existing {@link SSLConfiguration} for the given settings__@param settings the settings for the ssl configuration_@return the ssl configuration for the provided settings. If the settings are empty, the global configuration is returned;SSLConfiguration sslConfiguration(Settings settings) {_        if (settings.isEmpty()) {_            return globalSSLConfiguration__        }_        return new SSLConfiguration(settings, globalSSLConfiguration)__    };returns,the,existing,link,sslconfiguration,for,the,given,settings,param,settings,the,settings,for,the,ssl,configuration,return,the,ssl,configuration,for,the,provided,settings,if,the,settings,are,empty,the,global,configuration,is,returned;sslconfiguration,ssl,configuration,settings,settings,if,settings,is,empty,return,global,sslconfiguration,return,new,sslconfiguration,settings,global,sslconfiguration
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1526449283;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslConfigurations = new HashMap<>()__        sslConfigurations.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        List<Settings> sslSettingsList = new ArrayList<>()__        sslSettingsList.add(getHttpTransportSSLSettings(settings))__        sslSettingsList.add(settings.getByPrefix("xpack.http.ssl."))__        sslSettingsList.addAll(getRealmsSSLSettings(settings))__        sslSettingsList.addAll(getMonitoringExporterSettings(settings))___        sslSettingsList.forEach((sslSettings) ->_                sslConfigurations.computeIfAbsent(new SSLConfiguration(sslSettings, globalSSLConfiguration), this::createSslContext))___        _        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        List<Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslConfigurations.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((profileSetting) ->_            sslConfigurations.computeIfAbsent(new SSLConfiguration(profileSetting, transportSSLConfiguration), this::createSslContext))__        return Collections.unmodifiableMap(sslConfigurations)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,configurations,new,hash,map,ssl,configurations,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,list,settings,ssl,settings,list,new,array,list,ssl,settings,list,add,get,http,transport,sslsettings,settings,ssl,settings,list,add,settings,get,by,prefix,xpack,http,ssl,ssl,settings,list,add,all,get,realms,sslsettings,settings,ssl,settings,list,add,all,get,monitoring,exporter,settings,settings,ssl,settings,list,for,each,ssl,settings,ssl,configurations,compute,if,absent,new,sslconfiguration,ssl,settings,global,sslconfiguration,this,create,ssl,context,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,list,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,configurations,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,profile,setting,ssl,configurations,compute,if,absent,new,sslconfiguration,profile,setting,transport,sslconfiguration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,configurations
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1527622193;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslConfigurations = new HashMap<>()__        sslConfigurations.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        List<Settings> sslSettingsList = new ArrayList<>()__        sslSettingsList.add(getHttpTransportSSLSettings(settings))__        sslSettingsList.add(settings.getByPrefix("xpack.http.ssl."))__        sslSettingsList.addAll(getRealmsSSLSettings(settings))__        sslSettingsList.addAll(getMonitoringExporterSettings(settings))___        sslSettingsList.forEach((sslSettings) ->_                sslConfigurations.computeIfAbsent(new SSLConfiguration(sslSettings, globalSSLConfiguration), this::createSslContext))___        _        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        List<Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslConfigurations.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((profileSetting) ->_            sslConfigurations.computeIfAbsent(new SSLConfiguration(profileSetting, transportSSLConfiguration), this::createSslContext))__        return Collections.unmodifiableMap(sslConfigurations)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,configurations,new,hash,map,ssl,configurations,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,list,settings,ssl,settings,list,new,array,list,ssl,settings,list,add,get,http,transport,sslsettings,settings,ssl,settings,list,add,settings,get,by,prefix,xpack,http,ssl,ssl,settings,list,add,all,get,realms,sslsettings,settings,ssl,settings,list,add,all,get,monitoring,exporter,settings,settings,ssl,settings,list,for,each,ssl,settings,ssl,configurations,compute,if,absent,new,sslconfiguration,ssl,settings,global,sslconfiguration,this,create,ssl,context,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,list,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,configurations,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,profile,setting,ssl,configurations,compute,if,absent,new,sslconfiguration,profile,setting,transport,sslconfiguration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,configurations
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1531729807;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1538170812;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1541008027;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1541092382;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1541190643;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1541476610;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1543334812;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1545354122;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1545957094;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()__        sslContextHolders.put(globalSSLConfiguration, createSslContext(globalSSLConfiguration))__        this.sslConfigurations.put("xpack.ssl", globalSSLConfiguration)___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            if (sslSettings.isEmpty()) {_                storeSslConfiguration(key, globalSSLConfiguration)__            } else {_                final SSLConfiguration configuration = new SSLConfiguration(sslSettings, globalSSLConfiguration)__                storeSslConfiguration(key, configuration)__                sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__            }_        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings, globalSSLConfiguration)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting, transportSSLConfiguration)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,ssl,context,holders,put,global,sslconfiguration,create,ssl,context,global,sslconfiguration,this,ssl,configurations,put,xpack,ssl,global,sslconfiguration,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,if,ssl,settings,is,empty,store,ssl,configuration,key,global,sslconfiguration,else,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,global,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,global,sslconfiguration,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,transport,sslconfiguration,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1547499982;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            final SSLConfiguration configuration = new SSLConfiguration(sslSettings)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations();1549035251;Parses the settings to load all SSLConfiguration objects that will be used.;Map<SSLConfiguration, SSLContextHolder> loadSSLConfigurations() {_        Map<SSLConfiguration, SSLContextHolder> sslContextHolders = new HashMap<>()___        Map<String, Settings> sslSettingsMap = new HashMap<>()__        sslSettingsMap.put(XPackSettings.HTTP_SSL_PREFIX, getHttpTransportSSLSettings(settings))__        sslSettingsMap.put("xpack.http.ssl", settings.getByPrefix("xpack.http.ssl."))__        sslSettingsMap.putAll(getRealmsSSLSettings(settings))__        sslSettingsMap.putAll(getMonitoringExporterSettings(settings))___        sslSettingsMap.forEach((key, sslSettings) -> {_            final SSLConfiguration configuration = new SSLConfiguration(sslSettings)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        final Settings transportSSLSettings = settings.getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX)__        final SSLConfiguration transportSSLConfiguration = new SSLConfiguration(transportSSLSettings)__        this.transportSSLConfiguration.set(transportSSLConfiguration)__        storeSslConfiguration(XPackSettings.TRANSPORT_SSL_PREFIX, transportSSLConfiguration)__        Map<String, Settings> profileSettings = getTransportProfileSSLSettings(settings)__        sslContextHolders.computeIfAbsent(transportSSLConfiguration, this::createSslContext)__        profileSettings.forEach((key, profileSetting) -> {_            final SSLConfiguration configuration = new SSLConfiguration(profileSetting)__            storeSslConfiguration(key, configuration)__            sslContextHolders.computeIfAbsent(configuration, this::createSslContext)__        })___        return Collections.unmodifiableMap(sslContextHolders)__    };parses,the,settings,to,load,all,sslconfiguration,objects,that,will,be,used;map,sslconfiguration,sslcontext,holder,load,sslconfigurations,map,sslconfiguration,sslcontext,holder,ssl,context,holders,new,hash,map,map,string,settings,ssl,settings,map,new,hash,map,ssl,settings,map,put,xpack,settings,get,http,transport,sslsettings,settings,ssl,settings,map,put,xpack,http,ssl,settings,get,by,prefix,xpack,http,ssl,ssl,settings,map,put,all,get,realms,sslsettings,settings,ssl,settings,map,put,all,get,monitoring,exporter,settings,settings,ssl,settings,map,for,each,key,ssl,settings,final,sslconfiguration,configuration,new,sslconfiguration,ssl,settings,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,final,settings,transport,sslsettings,settings,get,by,prefix,xpack,settings,final,sslconfiguration,transport,sslconfiguration,new,sslconfiguration,transport,sslsettings,this,transport,sslconfiguration,set,transport,sslconfiguration,store,ssl,configuration,xpack,settings,transport,sslconfiguration,map,string,settings,profile,settings,get,transport,profile,sslsettings,settings,ssl,context,holders,compute,if,absent,transport,sslconfiguration,this,create,ssl,context,profile,settings,for,each,key,profile,setting,final,sslconfiguration,configuration,new,sslconfiguration,profile,setting,store,ssl,configuration,key,configuration,ssl,context,holders,compute,if,absent,configuration,this,create,ssl,context,return,collections,unmodifiable,map,ssl,context,holders
SSLService -> SSLContextHolder -> private void invalidateSessions(SSLSessionContext sslSessionContext);1526449283;Invalidates the sessions in the provided {@link SSLSessionContext};private void invalidateSessions(SSLSessionContext sslSessionContext) {_            Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__            while (sessionIds.hasMoreElements()) {_                byte[] sessionId = sessionIds.nextElement()__                sslSessionContext.getSession(sessionId).invalidate()__            }_        };invalidates,the,sessions,in,the,provided,link,sslsession,context;private,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,ssl,session,context,get,session,session,id,invalidate
SSLService -> SSLContextHolder -> private void invalidateSessions(SSLSessionContext sslSessionContext);1527622193;Invalidates the sessions in the provided {@link SSLSessionContext};private void invalidateSessions(SSLSessionContext sslSessionContext) {_            Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__            while (sessionIds.hasMoreElements()) {_                byte[] sessionId = sessionIds.nextElement()__                sslSessionContext.getSession(sessionId).invalidate()__            }_        };invalidates,the,sessions,in,the,provided,link,sslsession,context;private,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,ssl,session,context,get,session,session,id,invalidate
SSLService -> SSLContextHolder -> private void invalidateSessions(SSLSessionContext sslSessionContext);1531729807;Invalidates the sessions in the provided {@link SSLSessionContext};private void invalidateSessions(SSLSessionContext sslSessionContext) {_            Enumeration<byte[]> sessionIds = sslSessionContext.getIds()__            while (sessionIds.hasMoreElements()) {_                byte[] sessionId = sessionIds.nextElement()__                sslSessionContext.getSession(sessionId).invalidate()__            }_        };invalidates,the,sessions,in,the,provided,link,sslsession,context;private,void,invalidate,sessions,sslsession,context,ssl,session,context,enumeration,byte,session,ids,ssl,session,context,get,ids,while,session,ids,has,more,elements,byte,session,id,session,ids,next,element,ssl,session,context,get,session,session,id,invalidate
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1531729807;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1538170812;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1541008027;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1541092382;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1541190643;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1541476610;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1543334812;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1545354122;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        SSLSocketFactory socketFactory = sslContext(configuration).getSocketFactory()__        return new SecuritySSLSocketFactory(socketFactory, configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_                supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,sslsocket,factory,socket,factory,ssl,context,configuration,get,socket,factory,return,new,security,sslsocket,factory,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1545957094;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        final SSLContextHolder contextHolder = sslContextHolder(configuration)__        SSLSocketFactory socketFactory = contextHolder.sslContext().getSocketFactory()__        final SecuritySSLSocketFactory securitySSLSocketFactory = new SecuritySSLSocketFactory(_            () -> contextHolder.sslContext().getSocketFactory(),_            configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_            supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__        contextHolder.addReloadListener(securitySSLSocketFactory::reload)__        return securitySSLSocketFactory__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,final,sslcontext,holder,context,holder,ssl,context,holder,configuration,sslsocket,factory,socket,factory,context,holder,ssl,context,get,socket,factory,final,security,sslsocket,factory,security,sslsocket,factory,new,security,sslsocket,factory,context,holder,ssl,context,get,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false,context,holder,add,reload,listener,security,sslsocket,factory,reload,return,security,sslsocket,factory
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1547499982;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        final SSLContextHolder contextHolder = sslContextHolder(configuration)__        SSLSocketFactory socketFactory = contextHolder.sslContext().getSocketFactory()__        final SecuritySSLSocketFactory securitySSLSocketFactory = new SecuritySSLSocketFactory(_            () -> contextHolder.sslContext().getSocketFactory(),_            configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_            supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__        contextHolder.addReloadListener(securitySSLSocketFactory::reload)__        return securitySSLSocketFactory__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,final,sslcontext,holder,context,holder,ssl,context,holder,configuration,sslsocket,factory,socket,factory,context,holder,ssl,context,get,socket,factory,final,security,sslsocket,factory,security,sslsocket,factory,new,security,sslsocket,factory,context,holder,ssl,context,get,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false,context,holder,add,reload,listener,security,sslsocket,factory,reload,return,security,sslsocket,factory
SSLService -> public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration);1549035251;Create a new {@link SSLSocketFactory} based on the provided configuration._The socket factory will also properly configure the ciphers and protocols on each socket that is created_@param configuration The SSL configuration to use. Typically obtained from {@link #getSSLConfiguration(String)}_@return Never {@code null}.;public SSLSocketFactory sslSocketFactory(SSLConfiguration configuration) {_        final SSLContextHolder contextHolder = sslContextHolder(configuration)__        SSLSocketFactory socketFactory = contextHolder.sslContext().getSocketFactory()__        final SecuritySSLSocketFactory securitySSLSocketFactory = new SecuritySSLSocketFactory(_            () -> contextHolder.sslContext().getSocketFactory(),_            configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),_            supportedCiphers(socketFactory.getSupportedCipherSuites(), configuration.cipherSuites(), false))__        contextHolder.addReloadListener(securitySSLSocketFactory::reload)__        return securitySSLSocketFactory__    };create,a,new,link,sslsocket,factory,based,on,the,provided,configuration,the,socket,factory,will,also,properly,configure,the,ciphers,and,protocols,on,each,socket,that,is,created,param,configuration,the,ssl,configuration,to,use,typically,obtained,from,link,get,sslconfiguration,string,return,never,code,null;public,sslsocket,factory,ssl,socket,factory,sslconfiguration,configuration,final,sslcontext,holder,context,holder,ssl,context,holder,configuration,sslsocket,factory,socket,factory,context,holder,ssl,context,get,socket,factory,final,security,sslsocket,factory,security,sslsocket,factory,new,security,sslsocket,factory,context,holder,ssl,context,get,socket,factory,configuration,supported,protocols,to,array,strings,supported,ciphers,socket,factory,get,supported,cipher,suites,configuration,cipher,suites,false,context,holder,add,reload,listener,security,sslsocket,factory,reload,return,security,sslsocket,factory
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1526449283;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1527622193;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1531729807;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1538170812;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1541008027;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1541092382;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1541190643;Creates an {@link SSLContext} based on the provided configuration and trust/key managers_@param sslConfiguration the configuration to use for context creation_@param keyManager the key manager to use_@param trustManager the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[] { keyManager }, new X509ExtendedTrustManager[] { trustManager }, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1541476610;Creates an {@link SSLContext} based on the provided configuration and trust/key managers__@param sslConfiguration the configuration to use for context creation_@param keyManager       the key manager to use_@param trustManager     the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[]{keyManager}, new X509ExtendedTrustManager[]{trustManager}, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1543334812;Creates an {@link SSLContext} based on the provided configuration and trust/key managers__@param sslConfiguration the configuration to use for context creation_@param keyManager       the key manager to use_@param trustManager     the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[]{keyManager}, new X509ExtendedTrustManager[]{trustManager}, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1545354122;Creates an {@link SSLContext} based on the provided configuration and trust/key managers__@param sslConfiguration the configuration to use for context creation_@param keyManager       the key manager to use_@param trustManager     the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[]{keyManager}, new X509ExtendedTrustManager[]{trustManager}, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1545957094;Creates an {@link SSLContext} based on the provided configuration and trust/key managers__@param sslConfiguration the configuration to use for context creation_@param keyManager       the key manager to use_@param trustManager     the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[]{keyManager}, new X509ExtendedTrustManager[]{trustManager}, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1547499982;Creates an {@link SSLContext} based on the provided configuration and trust/key managers__@param sslConfiguration the configuration to use for context creation_@param keyManager       the key manager to use_@param trustManager     the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[]{keyManager}, new X509ExtendedTrustManager[]{trustManager}, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
SSLService -> private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,                                               SSLConfiguration sslConfiguration);1549035251;Creates an {@link SSLContext} based on the provided configuration and trust/key managers__@param sslConfiguration the configuration to use for context creation_@param keyManager       the key manager to use_@param trustManager     the trust manager to use_@return the created SSLContext;private SSLContextHolder createSslContext(X509ExtendedKeyManager keyManager, X509ExtendedTrustManager trustManager,_                                              SSLConfiguration sslConfiguration) {_        _        try {_            SSLContext sslContext = SSLContext.getInstance(sslContextAlgorithm(sslConfiguration.supportedProtocols()))__            sslContext.init(new X509ExtendedKeyManager[]{keyManager}, new X509ExtendedTrustManager[]{trustManager}, null)___            _            supportedCiphers(sslContext.getSupportedSSLParameters().getCipherSuites(), sslConfiguration.cipherSuites(), true)___            return new SSLContextHolder(sslContext, sslConfiguration)__        } catch (NoSuchAlgorithmException | KeyManagementException e) {_            throw new ElasticsearchException("failed to initialize the SSLContext", e)__        }_    };creates,an,link,sslcontext,based,on,the,provided,configuration,and,trust,key,managers,param,ssl,configuration,the,configuration,to,use,for,context,creation,param,key,manager,the,key,manager,to,use,param,trust,manager,the,trust,manager,to,use,return,the,created,sslcontext;private,sslcontext,holder,create,ssl,context,x509extended,key,manager,key,manager,x509extended,trust,manager,trust,manager,sslconfiguration,ssl,configuration,try,sslcontext,ssl,context,sslcontext,get,instance,ssl,context,algorithm,ssl,configuration,supported,protocols,ssl,context,init,new,x509extended,key,manager,key,manager,new,x509extended,trust,manager,trust,manager,null,supported,ciphers,ssl,context,get,supported,sslparameters,get,cipher,suites,ssl,configuration,cipher,suites,true,return,new,sslcontext,holder,ssl,context,ssl,configuration,catch,no,such,algorithm,exception,key,management,exception,e,throw,new,elasticsearch,exception,failed,to,initialize,the,sslcontext,e
