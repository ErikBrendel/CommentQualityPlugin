commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Returns non-zero positive number when <code>opMode1</code> is greater than <code>opMode2</code>  */ ;/**  * Returns non-zero positive number when <code>opMode1</code> is greater than <code>opMode2</code>  */ public static int compare(OperationMode opMode1, OperationMode opMode2) {     return Integer.compare(opMode1.id, opMode2.id). }
false;public,static;1;24;;public static OperationMode resolve(String type) {     switch(type.toLowerCase(Locale.ROOT)) {         case "missing":             return MISSING.         case "trial":         // bwc for 1.x subscription_type field         case "none":         // bwc for 1.x subscription_type field         case "dev":         case // bwc for 1.x subscription_type field         "development":             return TRIAL.         case "basic":             return BASIC.         case "standard":             return STANDARD.         case "silver":         case "gold":             return GOLD.         case "platinum":         case "cloud_internal":         case // bwc for 1.x subscription_type field         "internal":             return PLATINUM.         default:             throw new IllegalArgumentException("unknown type [" + type + "]").     } }
true;public;0;3;/**  * @return version of the license  */ ;/**  * @return version of the license  */ public int version() {     return version. }
true;public;0;3;/**  * @return a unique identifier for a license  */ ;/**  * @return a unique identifier for a license  */ public String uid() {     return uid. }
true;public;0;3;/**  * @return type of the license [trial, subscription, internal]  */ ;/**  * @return type of the license [trial, subscription, internal]  */ public String type() {     return type. }
true;public;0;3;/**  * @return the issueDate in milliseconds  */ ;/**  * @return the issueDate in milliseconds  */ public long issueDate() {     return issueDate. }
true;public;0;3;/**  * @return the startDate in milliseconds  */ ;/**  * @return the startDate in milliseconds  */ public long startDate() {     return startDate. }
true;public;0;3;/**  * @return the expiry date in milliseconds  */ ;/**  * @return the expiry date in milliseconds  */ public long expiryDate() {     return expiryDate. }
true;public;0;3;/**  * @return the maximum number of nodes this license has been issued for  */ ;/**  * @return the maximum number of nodes this license has been issued for  */ public int maxNodes() {     return maxNodes. }
true;public;0;3;/**  * @return a string representing the entity this licenses has been issued to  */ ;/**  * @return a string representing the entity this licenses has been issued to  */ public String issuedTo() {     return issuedTo. }
true;public;0;3;/**  * @return a string representing the entity responsible for issuing this license (internal)  */ ;/**  * @return a string representing the entity responsible for issuing this license (internal)  */ public String issuer() {     return issuer. }
true;public;0;3;/**  * @return a string representing the signature of the license used for license verification  */ ;/**  * @return a string representing the signature of the license used for license verification  */ public String signature() {     return signature. }
true;public;0;8;/**  * @return the operation mode of the license as computed from the license type or from  * the license mode file  */ ;/**  * @return the operation mode of the license as computed from the license type or from  * the license mode file  */ public OperationMode operationMode() {     synchronized (this) {         if (canReadOperationModeFromFile() && operationModeFileWatcher != null) {             return operationModeFileWatcher.getCurrentOperationMode().         }     }     return operationMode. }
false;private;0;3;;private boolean canReadOperationModeFromFile() {     return type.equals("cloud_internal"). }
true;public,synchronized;1;6;/**  * Sets the operation mode file watcher for the license and initializes the  * file watcher when the license type allows to override operation mode from file  */ ;/**  * Sets the operation mode file watcher for the license and initializes the  * file watcher when the license type allows to override operation mode from file  */ public synchronized void setOperationModeFileWatcher(final OperationModeFileWatcher operationModeFileWatcher) {     this.operationModeFileWatcher = operationModeFileWatcher.     if (canReadOperationModeFromFile()) {         this.operationModeFileWatcher.init().     } }
true;public,synchronized;0;3;/**  * Removes operation mode file watcher, so unused license objects can be gc'ed  */ ;/**  * Removes operation mode file watcher, so unused license objects can be gc'ed  */ public synchronized void removeOperationModeFileWatcher() {     this.operationModeFileWatcher = null. }
true;public;0;9;/**  * @return the current license's status  */ ;/**  * @return the current license's status  */ public LicenseStatus status() {     long now = System.currentTimeMillis().     if (issueDate > now) {         return LicenseStatus.INVALID.     } else if (expiryDate < now) {         return LicenseStatus.EXPIRED.     }     return LicenseStatus.ACTIVE. }
false;private;0;23;;private void validate() {     if (issuer == null) {         throw new IllegalStateException("issuer can not be null").     } else if (issuedTo == null) {         throw new IllegalStateException("issuedTo can not be null").     } else if (issueDate == -1) {         throw new IllegalStateException("issueDate has to be set").     } else if (type == null) {         throw new IllegalStateException("type can not be null").     } else if (subscriptionType == null && version == VERSION_START) {         throw new IllegalStateException("subscriptionType can not be null").     } else if (uid == null) {         throw new IllegalStateException("uid can not be null").     } else if (feature == null && version == VERSION_START) {         throw new IllegalStateException("feature can not be null").     } else if (maxNodes == -1) {         throw new IllegalStateException("maxNodes has to be set").     } else if (expiryDate == -1) {         throw new IllegalStateException("expiryDate has to be set").     } else if (expiryDate == LicenseService.BASIC_SELF_GENERATED_LICENSE_EXPIRATION_MILLIS && "basic".equals(type) == false) {         throw new IllegalStateException("only basic licenses are allowed to have no expiration").     } }
false;public,static;1;27;;public static License readLicense(StreamInput in) throws IOException {     // Version for future extensibility     int version = in.readVInt().     if (version > VERSION_CURRENT) {         throw new ElasticsearchException("Unknown license version found, please upgrade all nodes to the latest elasticsearch-license" + " plugin").     }     Builder builder = builder().     builder.version(version).     builder.uid(in.readString()).     builder.type(in.readString()).     if (version == VERSION_START) {         builder.subscriptionType(in.readString()).     }     builder.issueDate(in.readLong()).     if (version == VERSION_START) {         builder.feature(in.readString()).     }     builder.expiryDate(in.readLong()).     builder.maxNodes(in.readInt()).     builder.issuedTo(in.readString()).     builder.issuer(in.readString()).     builder.signature(in.readOptionalString()).     if (version >= VERSION_START_DATE) {         builder.startDate(in.readLong()).     }     return builder.build(). }
false;public;1;20;;public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(version).     out.writeString(uid).     out.writeString(type).     if (version == VERSION_START) {         out.writeString(subscriptionType).     }     out.writeLong(issueDate).     if (version == VERSION_START) {         out.writeString(feature).     }     out.writeLong(expiryDate).     out.writeInt(maxNodes).     out.writeString(issuedTo).     out.writeString(issuer).     out.writeOptionalString(signature).     if (version >= VERSION_START_DATE) {         out.writeLong(startDate).     } }
false;public;0;10;;@Override public String toString() {     try {         final XContentBuilder builder = XContentFactory.jsonBuilder().         toXContent(builder, ToXContent.EMPTY_PARAMS).         return Strings.toString(builder).     } catch (IOException e) {         return "".     } }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     toInnerXContent(builder, params).     builder.endObject().     return builder. }
false;public;2;47;;public XContentBuilder toInnerXContent(XContentBuilder builder, Params params) throws IOException {     boolean licenseSpecMode = params.paramAsBoolean(LICENSE_SPEC_VIEW_MODE, false).     boolean restViewMode = params.paramAsBoolean(REST_VIEW_MODE, false).     boolean previouslyHumanReadable = builder.humanReadable().     if (licenseSpecMode && restViewMode) {         throw new IllegalArgumentException("can have either " + REST_VIEW_MODE + " or " + LICENSE_SPEC_VIEW_MODE).     } else if (restViewMode) {         if (!previouslyHumanReadable) {             builder.humanReadable(true).         }     }     final int version.     if (params.param(LICENSE_VERSION_MODE) != null && restViewMode) {         version = Integer.parseInt(params.param(LICENSE_VERSION_MODE)).     } else {         version = this.version.     }     if (restViewMode) {         builder.field(Fields.STATUS, status().label()).     }     builder.field(Fields.UID, uid).     builder.field(Fields.TYPE, type).     if (version == VERSION_START) {         builder.field(Fields.SUBSCRIPTION_TYPE, subscriptionType).     }     builder.timeField(Fields.ISSUE_DATE_IN_MILLIS, Fields.ISSUE_DATE, issueDate).     if (version == VERSION_START) {         builder.field(Fields.FEATURE, feature).     }     if (expiryDate != LicenseService.BASIC_SELF_GENERATED_LICENSE_EXPIRATION_MILLIS) {         builder.timeField(Fields.EXPIRY_DATE_IN_MILLIS, Fields.EXPIRY_DATE, expiryDate).     }     builder.field(Fields.MAX_NODES, maxNodes).     builder.field(Fields.ISSUED_TO, issuedTo).     builder.field(Fields.ISSUER, issuer).     if (!licenseSpecMode && !restViewMode && signature != null) {         builder.field(Fields.SIGNATURE, signature).     }     if (restViewMode) {         builder.humanReadable(previouslyHumanReadable).     }     if (version >= VERSION_START_DATE) {         builder.timeField(Fields.START_DATE_IN_MILLIS, Fields.START_DATE, startDate).     }     return builder. }
false;public,static;1;79;;public static License fromXContent(XContentParser parser) throws IOException {     Builder builder = new Builder().     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             String currentFieldName = parser.currentName().             token = parser.nextToken().             if (token.isValue()) {                 if (Fields.UID.equals(currentFieldName)) {                     builder.uid(parser.text()).                 } else if (Fields.TYPE.equals(currentFieldName)) {                     builder.type(parser.text()).                 } else if (Fields.SUBSCRIPTION_TYPE.equals(currentFieldName)) {                     builder.subscriptionType(parser.text()).                 } else if (Fields.ISSUE_DATE.equals(currentFieldName)) {                     builder.issueDate(parseDate(parser, "issue", false)).                 } else if (Fields.ISSUE_DATE_IN_MILLIS.equals(currentFieldName)) {                     builder.issueDate(parser.longValue()).                 } else if (Fields.FEATURE.equals(currentFieldName)) {                     builder.feature(parser.text()).                 } else if (Fields.EXPIRY_DATE.equals(currentFieldName)) {                     builder.expiryDate(parseDate(parser, "expiration", true)).                 } else if (Fields.EXPIRY_DATE_IN_MILLIS.equals(currentFieldName)) {                     builder.expiryDate(parser.longValue()).                 } else if (Fields.START_DATE.equals(currentFieldName)) {                     builder.startDate(parseDate(parser, "start", false)).                 } else if (Fields.START_DATE_IN_MILLIS.equals(currentFieldName)) {                     builder.startDate(parser.longValue()).                 } else if (Fields.MAX_NODES.equals(currentFieldName)) {                     builder.maxNodes(parser.intValue()).                 } else if (Fields.ISSUED_TO.equals(currentFieldName)) {                     builder.issuedTo(parser.text()).                 } else if (Fields.ISSUER.equals(currentFieldName)) {                     builder.issuer(parser.text()).                 } else if (Fields.SIGNATURE.equals(currentFieldName)) {                     builder.signature(parser.text()).                 } else if (Fields.VERSION.equals(currentFieldName)) {                     builder.version(parser.intValue()).                 }             // Ignore unknown elements - might be new version of license             } else if (token == XContentParser.Token.START_ARRAY) {                 // It was probably created by newer version - ignoring                 parser.skipChildren().             } else if (token == XContentParser.Token.START_OBJECT) {                 // It was probably created by newer version - ignoring                 parser.skipChildren().             }         }     }     // not a license spec     if (builder.signature != null) {         int version.         // just throwing the BufferUnderflowException or the IllegalArgumentException         try {             byte[] signatureBytes = Base64.getDecoder().decode(builder.signature).             ByteBuffer byteBuffer = ByteBuffer.wrap(signatureBytes).             version = byteBuffer.getInt().         } catch (Exception e) {             throw new ElasticsearchException("malformed signature for license [" + builder.uid + "]", e).         }         // and positive version means that the license was signed         if (version < 0) {             version *= -1.         }         if (version == 0) {             throw new ElasticsearchException("malformed signature for license [" + builder.uid + "]").         } else if (version > VERSION_CURRENT) {             throw new ElasticsearchException("Unknown license version found, please upgrade all nodes to the latest " + "elasticsearch-license plugin").         }         // signature version is the source of truth         builder.version(version).     }     return builder.build(). }
true;public,static;1;9;/**  * Returns true if the license was auto-generated (by license plugin),  * false otherwise  */ ;/**  * Returns true if the license was auto-generated (by license plugin),  * false otherwise  */ public static boolean isAutoGeneratedLicense(String signature) {     try {         byte[] signatureBytes = Base64.getDecoder().decode(signature).         ByteBuffer byteBuffer = ByteBuffer.wrap(signatureBytes).         return byteBuffer.getInt() < 0.     } catch (IllegalArgumentException e) {         throw new IllegalStateException(e).     } }
false;public,static;2;50;;public static License fromSource(BytesReference bytes, XContentType xContentType) throws IOException {     if (bytes == null || bytes.length() == 0) {         throw new ElasticsearchParseException("failed to parse license - no content provided").     }     if (xContentType == null) {         throw new ElasticsearchParseException("failed to parse license - no content-type provided").     }     // EMPTY is safe here because we don't call namedObject     try (InputStream byteStream = bytes.streamInput().         XContentParser parser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, byteStream)) {         License license = null.         if (parser.nextToken() == XContentParser.Token.START_OBJECT) {             if (parser.nextToken() == XContentParser.Token.FIELD_NAME) {                 String currentFieldName = parser.currentName().                 if (Fields.LICENSES.equals(currentFieldName)) {                     final List<License> pre20Licenses = new ArrayList<>().                     if (parser.nextToken() == XContentParser.Token.START_ARRAY) {                         while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                             pre20Licenses.add(License.fromXContent(parser)).                         }                         // take the latest issued unexpired license                         CollectionUtil.timSort(pre20Licenses, LATEST_ISSUE_DATE_FIRST).                         long now = System.currentTimeMillis().                         for (License oldLicense : pre20Licenses) {                             if (oldLicense.expiryDate() > now) {                                 license = oldLicense.                                 break.                             }                         }                         if (license == null && !pre20Licenses.isEmpty()) {                             license = pre20Licenses.get(0).                         }                     } else {                         throw new ElasticsearchParseException("failed to parse licenses expected an array of licenses").                     }                 } else if (Fields.LICENSE.equals(currentFieldName)) {                     license = License.fromXContent(parser).                 }             // Ignore all other fields - might be created with new version             } else {                 throw new ElasticsearchParseException("failed to parse licenses expected field").             }         } else {             throw new ElasticsearchParseException("failed to parse licenses expected start object").         }         return license.     } }
false;public;1;22;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     License license = (License) o.     if (issueDate != license.issueDate)         return false.     if (expiryDate != license.expiryDate)         return false.     if (startDate != license.startDate)         return false.     if (maxNodes != license.maxNodes)         return false.     if (version != license.version)         return false.     if (uid != null ? !uid.equals(license.uid) : license.uid != null)         return false.     if (issuer != null ? !issuer.equals(license.issuer) : license.issuer != null)         return false.     if (issuedTo != null ? !issuedTo.equals(license.issuedTo) : license.issuedTo != null)         return false.     if (type != null ? !type.equals(license.type) : license.type != null)         return false.     if (subscriptionType != null ? !subscriptionType.equals(license.subscriptionType) : license.subscriptionType != null)         return false.     if (feature != null ? !feature.equals(license.feature) : license.feature != null)         return false.     return !(signature != null ? !signature.equals(license.signature) : license.signature != null). }
false;public;0;16;;@Override public int hashCode() {     int result = uid != null ? uid.hashCode() : 0.     result = 31 * result + (issuer != null ? issuer.hashCode() : 0).     result = 31 * result + (issuedTo != null ? issuedTo.hashCode() : 0).     result = 31 * result + (int) (issueDate ^ (issueDate >>> 32)).     result = 31 * result + (type != null ? type.hashCode() : 0).     result = 31 * result + (subscriptionType != null ? subscriptionType.hashCode() : 0).     result = 31 * result + (feature != null ? feature.hashCode() : 0).     result = 31 * result + (signature != null ? signature.hashCode() : 0).     result = 31 * result + (int) (expiryDate ^ (expiryDate >>> 32)).     result = 31 * result + (int) (startDate ^ (startDate >>> 32)).     result = 31 * result + maxNodes.     result = 31 * result + version.     return result. }
false;private,static;3;15;;private static long parseDate(XContentParser parser, String description, boolean endOfTheDay) throws IOException {     if (parser.currentToken() == XContentParser.Token.VALUE_NUMBER) {         return parser.longValue().     } else {         try {             if (endOfTheDay) {                 return DateUtils.endOfTheDay(parser.text()).             } else {                 return DateUtils.beginningOfTheDay(parser.text()).             }         } catch (IllegalArgumentException ex) {             throw new ElasticsearchParseException("invalid " + description + " date format " + parser.text()).         }     } }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public;1;4;;public Builder uid(String uid) {     this.uid = uid.     return this. }
false;public;1;4;;public Builder version(int version) {     this.version = version.     return this. }
false;public;1;4;;public Builder issuer(String issuer) {     this.issuer = issuer.     return this. }
false;public;1;4;;public Builder issuedTo(String issuedTo) {     this.issuedTo = issuedTo.     return this. }
false;public;1;4;;public Builder issueDate(long issueDate) {     this.issueDate = issueDate.     return this. }
false;public;1;4;;public Builder type(String type) {     this.type = type.     return this. }
false;public;1;4;;public Builder subscriptionType(String subscriptionType) {     this.subscriptionType = subscriptionType.     return this. }
false;public;1;4;;public Builder feature(String feature) {     this.feature = feature.     return this. }
false;public;1;4;;public Builder expiryDate(long expiryDate) {     this.expiryDate = expiryDate.     return this. }
false;public;1;4;;public Builder maxNodes(int maxNodes) {     this.maxNodes = maxNodes.     return this. }
false;public;1;6;;public Builder signature(String signature) {     if (signature != null) {         this.signature = signature.     }     return this. }
false;public;1;4;;public Builder startDate(long startDate) {     this.startDate = startDate.     return this. }
false;public;2;14;;public Builder fromLicenseSpec(License license, String signature) {     return uid(license.uid()).version(license.version()).issuedTo(license.issuedTo()).issueDate(license.issueDate()).startDate(license.startDate()).type(license.type()).subscriptionType(license.subscriptionType).feature(license.feature).maxNodes(license.maxNodes()).expiryDate(license.expiryDate()).issuer(license.issuer()).signature(signature). }
true;public;1;7;/**  * Returns a builder that converts pre 2.0 licenses  * to the new license format  */ ;/**  * Returns a builder that converts pre 2.0 licenses  * to the new license format  */ public Builder fromPre20LicenseSpec(License pre20License) {     return uid(pre20License.uid()).issuedTo(pre20License.issuedTo()).issueDate(pre20License.issueDate()).maxNodes(pre20License.maxNodes()).expiryDate(pre20License.expiryDate()). }
false;public;0;4;;public License build() {     return new License(version, uid, issuer, issuedTo, issueDate, type, subscriptionType, feature, signature, expiryDate, maxNodes, startDate). }
false;public;0;20;;public Builder validate() {     if (issuer == null) {         throw new IllegalStateException("issuer can not be null").     } else if (issuedTo == null) {         throw new IllegalStateException("issuedTo can not be null").     } else if (issueDate == -1) {         throw new IllegalStateException("issueDate has to be set").     } else if (type == null) {         throw new IllegalStateException("type can not be null").     } else if (uid == null) {         throw new IllegalStateException("uid can not be null").     } else if (signature == null) {         throw new IllegalStateException("signature can not be null").     } else if (maxNodes == -1) {         throw new IllegalStateException("maxNodes has to be set").     } else if (expiryDate == -1) {         throw new IllegalStateException("expiryDate has to be set").     }     return this. }
true;public;0;15;/**  * Returns <code>true</code> iff the license is a production licnese  */ ;/**  * Returns <code>true</code> iff the license is a production licnese  */ public boolean isProductionLicense() {     switch(operationMode()) {         case MISSING:         case TRIAL:         case BASIC:             return false.         case STANDARD:         case GOLD:         case PLATINUM:             return true.         default:             throw new AssertionError("unknown operation mode: " + operationMode()).     } }
