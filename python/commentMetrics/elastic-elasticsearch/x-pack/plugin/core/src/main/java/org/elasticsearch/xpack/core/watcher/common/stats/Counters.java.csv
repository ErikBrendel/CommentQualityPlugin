commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Sets a counter. This ensures that the counter is there, even though it is never incremented.  * @param name Name of the counter  */ ;/**  * Sets a counter. This ensures that the counter is there, even though it is never incremented.  * @param name Name of the counter  */ public void set(String name) {     counters.put(name, 0). }
true;public;1;3;/**  * Increment the counter by one  * @param name Name of the counter  */ ;/**  * Increment the counter by one  * @param name Name of the counter  */ public void inc(String name) {     inc(name, 1). }
true;public;2;3;/**  * Increment the counter by configured number  * @param name The name of the counter  * @param count Incremental value  */ ;/**  * Increment the counter by configured number  * @param name The name of the counter  * @param count Incremental value  */ public void inc(String name, long count) {     counters.addTo(name, count). }
false;public;1;3;;public long get(String name) {     return counters.get(name). }
false;public;0;3;;public long size() {     return counters.size(). }
false;public;0;3;;public boolean hasCounters() {     return size() > 0. }
true;public;0;28;/**  * Convert the counters to a nested map, using the "." as a splitter to create deeper maps  * @return A nested map with all the current configured counters  */ ;/**  * Convert the counters to a nested map, using the "." as a splitter to create deeper maps  * @return A nested map with all the current configured counters  */ @SuppressWarnings("unchecked") public Map<String, Object> toNestedMap() {     Map<String, Object> map = new HashMap<>().     for (ObjectLongCursor<String> counter : counters) {         if (counter.key.contains(".")) {             String[] parts = counter.key.split("\\.").             Map<String, Object> curr = map.             for (int i = 0. i < parts.length. i++) {                 String part = parts[i].                 boolean isLast = i == parts.length - 1.                 if (isLast == false) {                     if (curr.containsKey(part) == false) {                         curr.put(part, new HashMap<String, Object>()).                         curr = (Map<String, Object>) curr.get(part).                     } else {                         curr = (Map<String, Object>) curr.get(part).                     }                 } else {                     curr.put(part, counter.value).                 }             }         } else {             map.put(counter.key, counter.value).         }     }     return map. }
false;public;1;7;;@Override public void readFrom(StreamInput in) throws IOException {     int counters = in.readVInt().     for (int i = 0. i < counters. i++) {         inc(in.readString(), in.readVLong()).     } }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(counters.size()).     for (ObjectLongCursor<String> cursor : counters) {         out.writeString(cursor.key).         out.writeVLong(cursor.value).     } }
false;public,static;1;5;;public static Counters read(StreamInput in) throws IOException {     Counters counters = new Counters().     counters.readFrom(in).     return counters. }
false;public,static;1;10;;public static Counters merge(List<Counters> counters) {     Counters result = new Counters().     for (Counters c : counters) {         for (ObjectLongCursor<String> cursor : c.counters) {             result.inc(cursor.key, cursor.value).         }     }     return result. }
