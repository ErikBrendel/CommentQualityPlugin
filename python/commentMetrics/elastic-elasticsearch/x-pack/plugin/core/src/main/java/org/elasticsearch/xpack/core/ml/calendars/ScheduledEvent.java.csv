commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;28;;private static ObjectParser<ScheduledEvent.Builder, Void> createParser(boolean ignoreUnknownFields) {     ObjectParser<ScheduledEvent.Builder, Void> parser = new ObjectParser<>("scheduled_event", ignoreUnknownFields, Builder::new).     parser.declareString(ScheduledEvent.Builder::description, DESCRIPTION).     parser.declareField(ScheduledEvent.Builder::startTime, p -> {         if (p.currentToken() == XContentParser.Token.VALUE_NUMBER) {             return Instant.ofEpochMilli(p.longValue()).         } else if (p.currentToken() == XContentParser.Token.VALUE_STRING) {             return Instant.ofEpochMilli(TimeUtils.dateStringToEpoch(p.text())).         }         throw new IllegalArgumentException("unexpected token [" + p.currentToken() + "] for [" + START_TIME.getPreferredName() + "]").     }, START_TIME, ObjectParser.ValueType.VALUE).     parser.declareField(ScheduledEvent.Builder::endTime, p -> {         if (p.currentToken() == XContentParser.Token.VALUE_NUMBER) {             return Instant.ofEpochMilli(p.longValue()).         } else if (p.currentToken() == XContentParser.Token.VALUE_STRING) {             return Instant.ofEpochMilli(TimeUtils.dateStringToEpoch(p.text())).         }         throw new IllegalArgumentException("unexpected token [" + p.currentToken() + "] for [" + END_TIME.getPreferredName() + "]").     }, END_TIME, ObjectParser.ValueType.VALUE).     parser.declareString(ScheduledEvent.Builder::calendarId, Calendar.ID).     parser.declareString((builder, s) -> {     }, TYPE).     return parser. }
false;public,static;1;3;;public static String documentId(String eventId) {     return DOCUMENT_ID_PREFIX + eventId. }
false;public;0;3;;public String getDescription() {     return description. }
false;public;0;3;;public Instant getStartTime() {     return startTime. }
false;public;0;3;;public Instant getEndTime() {     return endTime. }
false;public;0;3;;public String getCalendarId() {     return calendarId. }
false;public;0;3;;public String getEventId() {     return eventId. }
true;public;1;14;/**  * Convert the scheduled event to a detection rule.  * The rule will have 2 time based conditions for the start and  * end of the event.  *  * The rule's start and end times are aligned with the bucket span  * so the start time is rounded down to a bucket interval and the  * end time rounded up.  *  * @param bucketSpan Bucket span to align to  * @return The event as a detection rule.  */ ;/**  * Convert the scheduled event to a detection rule.  * The rule will have 2 time based conditions for the start and  * end of the event.  *  * The rule's start and end times are aligned with the bucket span  * so the start time is rounded down to a bucket interval and the  * end time rounded up.  *  * @param bucketSpan Bucket span to align to  * @return The event as a detection rule.  */ public DetectionRule toDetectionRule(TimeValue bucketSpan) {     List<RuleCondition> conditions = new ArrayList<>().     long bucketSpanSecs = bucketSpan.getSeconds().     long bucketStartTime = Intervals.alignToFloor(getStartTime().getEpochSecond(), bucketSpanSecs).     conditions.add(RuleCondition.createTime(Operator.GTE, bucketStartTime)).     long bucketEndTime = Intervals.alignToCeil(getEndTime().getEpochSecond(), bucketSpanSecs).     conditions.add(RuleCondition.createTime(Operator.LT, bucketEndTime)).     DetectionRule.Builder builder = new DetectionRule.Builder(conditions).     builder.setActions(RuleAction.SKIP_RESULT, RuleAction.SKIP_MODEL_UPDATE).     return builder.build(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(description).     out.writeVLong(startTime.toEpochMilli()).     out.writeVLong(endTime.toEpochMilli()).     out.writeString(calendarId).     out.writeOptionalString(eventId). }
false;public;2;16;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(DESCRIPTION.getPreferredName(), description).     builder.timeField(START_TIME.getPreferredName(), START_TIME.getPreferredName() + "_string", startTime.toEpochMilli()).     builder.timeField(END_TIME.getPreferredName(), END_TIME.getPreferredName() + "_string", endTime.toEpochMilli()).     builder.field(Calendar.ID.getPreferredName(), calendarId).     if (eventId != null) {         builder.field(EVENT_ID.getPreferredName(), eventId).     }     if (params.paramAsBoolean(ToXContentParams.INCLUDE_TYPE, false)) {         builder.field(TYPE.getPreferredName(), SCHEDULED_EVENT_TYPE).     }     builder.endObject().     return builder. }
false;public;1;24;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (!(obj instanceof ScheduledEvent)) {         return false.     }     ScheduledEvent other = (ScheduledEvent) obj.     // which isn't the case in tests where the time zone is randomised.     return description.equals(other.description) && Objects.equals(startTime.getEpochSecond(), other.startTime.getEpochSecond()) && Objects.equals(endTime.getEpochSecond(), other.endTime.getEpochSecond()) && calendarId.equals(other.calendarId). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(description, startTime, endTime, calendarId). }
false;public;1;4;;public Builder description(String description) {     this.description = description.     return this. }
false;public;1;4;;public Builder startTime(Instant startTime) {     this.startTime = startTime.     return this. }
false;public;1;4;;public Builder endTime(Instant endTime) {     this.endTime = endTime.     return this. }
false;public;1;4;;public Builder calendarId(String calendarId) {     this.calendarId = calendarId.     return this. }
false;public;0;3;;public String getCalendarId() {     return calendarId. }
false;public;1;4;;public Builder eventId(String eventId) {     this.eventId = eventId.     return this. }
false;public;0;30;;public ScheduledEvent build() {     if (description == null) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.FIELD_CANNOT_BE_NULL, DESCRIPTION.getPreferredName())).     }     if (startTime == null) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.FIELD_CANNOT_BE_NULL, START_TIME.getPreferredName())).     }     if (endTime == null) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.FIELD_CANNOT_BE_NULL, END_TIME.getPreferredName())).     }     if (calendarId == null) {         throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.FIELD_CANNOT_BE_NULL, Calendar.ID.getPreferredName())).     }     if (startTime.isBefore(endTime) == false) {         throw ExceptionsHelper.badRequestException("Event start time [" + startTime + "] must come before end time [" + endTime + "]").     }     ScheduledEvent event = new ScheduledEvent(description, startTime, endTime, calendarId, eventId).     return event. }
