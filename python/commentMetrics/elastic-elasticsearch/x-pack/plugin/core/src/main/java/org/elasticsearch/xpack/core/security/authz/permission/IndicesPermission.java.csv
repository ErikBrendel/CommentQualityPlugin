commented;modifiers;parameterAmount;loc;comment;code
false;static;1;21;;static Predicate<String> indexMatcher(Collection<String> indices) {     Set<String> exactMatch = new HashSet<>().     List<String> nonExactMatch = new ArrayList<>().     for (String indexPattern : indices) {         if (indexPattern.startsWith("/") || indexPattern.contains("*") || indexPattern.contains("?")) {             nonExactMatch.add(indexPattern).         } else {             exactMatch.add(indexPattern).         }     }     if (exactMatch.isEmpty() && nonExactMatch.isEmpty()) {         return s -> false.     } else if (exactMatch.isEmpty()) {         return buildAutomataPredicate(nonExactMatch).     } else if (nonExactMatch.isEmpty()) {         return buildExactMatchPredicate(exactMatch).     } else {         return buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch)).     } }
false;private,static;1;7;;private static Predicate<String> buildExactMatchPredicate(Set<String> indices) {     if (indices.size() == 1) {         final String singleValue = indices.iterator().next().         return singleValue::equals.     }     return indices::contains. }
false;private,static;1;12;;private static Predicate<String> buildAutomataPredicate(List<String> indices) {     try {         return Automatons.predicate(indices).     } catch (TooComplexToDeterminizeException e) {         LogManager.getLogger(IndicesPermission.class).debug("Index pattern automaton [{}] is too complex", indices).         String description = Strings.collectionToCommaDelimitedString(indices).         if (description.length() > 80) {             description = Strings.cleanTruncate(description, 80) + "...".         }         throw new ElasticsearchSecurityException("The set of permitted index patterns [{}] is too complex to evaluate", e, description).     } }
false;public;0;3;;public Group[] groups() {     return groups. }
true;public;1;3;/**  * @return A predicate that will match all the indices that this permission  * has the privilege for executing the given action on.  */ ;/**  * @return A predicate that will match all the indices that this permission  * has the privilege for executing the given action on.  */ public Predicate<String> allowedIndicesMatcher(String action) {     return allowedIndicesMatchersForAction.computeIfAbsent(action, a -> Group.buildIndexMatcherPredicateForAction(a, groups)). }
true;public;1;8;/**  * Checks if the permission matches the provided action, without looking at indices.  * To be used in very specific cases where indices actions need to be authorized regardless of their indices.  * The usecase for this is composite actions that are initially only authorized based on the action name (indices are not  * checked on the coordinating node), and properly authorized later at the shard level checking their indices as well.  */ ;/**  * Checks if the permission matches the provided action, without looking at indices.  * To be used in very specific cases where indices actions need to be authorized regardless of their indices.  * The usecase for this is composite actions that are initially only authorized based on the action name (indices are not  * checked on the coordinating node), and properly authorized later at the shard level checking their indices as well.  */ public boolean check(String action) {     for (Group group : groups) {         if (group.check(action)) {             return true.         }     }     return false. }
true;public;3;32;/**  * For given index patterns and index privileges determines allowed privileges and creates an instance of {@link ResourcePrivilegesMap}  * holding a map of resource to {@link ResourcePrivileges} where resource is index pattern and the map of index privilege to whether it  * is allowed or not.  *  * @param checkForIndexPatterns check permission grants for the set of index patterns  * @param allowRestrictedIndices if {@code true} then checks permission grants even for restricted indices by index matching  * @param checkForPrivileges check permission grants for the set of index privileges  * @return an instance of {@link ResourcePrivilegesMap}  */ ;/**  * For given index patterns and index privileges determines allowed privileges and creates an instance of {@link ResourcePrivilegesMap}  * holding a map of resource to {@link ResourcePrivileges} where resource is index pattern and the map of index privilege to whether it  * is allowed or not.  *  * @param checkForIndexPatterns check permission grants for the set of index patterns  * @param allowRestrictedIndices if {@code true} then checks permission grants even for restricted indices by index matching  * @param checkForPrivileges check permission grants for the set of index privileges  * @return an instance of {@link ResourcePrivilegesMap}  */ public ResourcePrivilegesMap checkResourcePrivileges(Set<String> checkForIndexPatterns, boolean allowRestrictedIndices, Set<String> checkForPrivileges) {     final ResourcePrivilegesMap.Builder resourcePrivilegesMapBuilder = ResourcePrivilegesMap.builder().     final Map<IndicesPermission.Group, Automaton> predicateCache = new HashMap<>().     for (String forIndexPattern : checkForIndexPatterns) {         final Automaton checkIndexAutomaton = IndicesPermission.Group.buildIndexMatcherAutomaton(allowRestrictedIndices, forIndexPattern).         Automaton allowedIndexPrivilegesAutomaton = null.         for (Group group : groups) {             final Automaton groupIndexAutomaton = predicateCache.computeIfAbsent(group, g -> IndicesPermission.Group.buildIndexMatcherAutomaton(g.allowRestrictedIndices(), g.indices())).             if (Operations.subsetOf(checkIndexAutomaton, groupIndexAutomaton)) {                 if (allowedIndexPrivilegesAutomaton != null) {                     allowedIndexPrivilegesAutomaton = Automatons.unionAndMinimize(Arrays.asList(allowedIndexPrivilegesAutomaton, group.privilege().getAutomaton())).                 } else {                     allowedIndexPrivilegesAutomaton = group.privilege().getAutomaton().                 }             }         }         for (String privilege : checkForPrivileges) {             IndexPrivilege indexPrivilege = IndexPrivilege.get(Collections.singleton(privilege)).             if (allowedIndexPrivilegesAutomaton != null && Operations.subsetOf(indexPrivilege.getAutomaton(), allowedIndexPrivilegesAutomaton)) {                 resourcePrivilegesMapBuilder.addResourcePrivilege(forIndexPattern, privilege, Boolean.TRUE).             } else {                 resourcePrivilegesMapBuilder.addResourcePrivilege(forIndexPattern, privilege, Boolean.FALSE).             }         }     }     return resourcePrivilegesMapBuilder.build(). }
false;public;1;9;;public Automaton allowedActionsMatcher(String index) {     List<Automaton> automatonList = new ArrayList<>().     for (Group group : groups) {         if (group.indexNameMatcher.test(index)) {             automatonList.add(group.privilege.getAutomaton()).         }     }     return automatonList.isEmpty() ? Automatons.EMPTY : Automatons.unionAndMinimize(automatonList). }
true;public;4;75;/**  * Authorizes the provided action against the provided indices, given the current cluster metadata  */ ;/**  * Authorizes the provided action against the provided indices, given the current cluster metadata  */ public Map<String, IndicesAccessControl.IndexAccessControl> authorize(String action, Set<String> requestedIndicesOrAliases, Map<String, AliasOrIndex> allAliasesAndIndices, FieldPermissionsCache fieldPermissionsCache) {     // now... every index that is associated with the request, must be granted     // by at least one indices permission group     Map<String, Set<FieldPermissions>> fieldPermissionsByIndex = new HashMap<>().     Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>().     Map<String, Boolean> grantedBuilder = new HashMap<>().     for (String indexOrAlias : requestedIndicesOrAliases) {         boolean granted = false.         Set<String> concreteIndices = new HashSet<>().         AliasOrIndex aliasOrIndex = allAliasesAndIndices.get(indexOrAlias).         if (aliasOrIndex != null) {             for (IndexMetaData indexMetaData : aliasOrIndex.getIndices()) {                 concreteIndices.add(indexMetaData.getIndex().getName()).             }         }         for (Group group : groups) {             if (group.check(action, indexOrAlias)) {                 granted = true.                 for (String index : concreteIndices) {                     Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>()).                     fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions).                     fieldPermissions.add(group.getFieldPermissions()).                     DocumentLevelPermissions permissions = roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions()).                     roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions).                     if (group.hasQuery()) {                         permissions.addAll(group.getQuery()).                     } else {                         // if more than one permission matches for a concrete index here and if                         // a single permission doesn't have a role query then DLS will not be                         // applied even when other permissions do have a role query                         permissions.setAllowAll(true).                     }                 }             }         }         if (concreteIndices.isEmpty()) {             grantedBuilder.put(indexOrAlias, granted).         } else {             grantedBuilder.put(indexOrAlias, granted).             for (String concreteIndex : concreteIndices) {                 grantedBuilder.put(concreteIndex, granted).             }         }     }     Map<String, IndicesAccessControl.IndexAccessControl> indexPermissions = new HashMap<>().     for (Map.Entry<String, Boolean> entry : grantedBuilder.entrySet()) {         String index = entry.getKey().         DocumentLevelPermissions permissions = roleQueriesByIndex.get(index).         final Set<BytesReference> roleQueries.         if (permissions != null && permissions.isAllowAll() == false) {             roleQueries = unmodifiableSet(permissions.queries).         } else {             roleQueries = null.         }         final FieldPermissions fieldPermissions.         final Set<FieldPermissions> indexFieldPermissions = fieldPermissionsByIndex.get(index).         if (indexFieldPermissions != null && indexFieldPermissions.isEmpty() == false) {             fieldPermissions = indexFieldPermissions.size() == 1 ? indexFieldPermissions.iterator().next() : fieldPermissionsCache.getFieldPermissions(indexFieldPermissions).         } else {             fieldPermissions = FieldPermissions.DEFAULT.         }         indexPermissions.put(index, new IndicesAccessControl.IndexAccessControl(entry.getValue(), fieldPermissions, (roleQueries != null) ? DocumentPermissions.filteredBy(roleQueries) : DocumentPermissions.allowAll())).     }     return unmodifiableMap(indexPermissions). }
false;public;0;3;;public IndexPrivilege privilege() {     return privilege. }
false;public;0;3;;public String[] indices() {     return indices. }
false;public;0;4;;@Nullable public Set<BytesReference> getQuery() {     return query. }
false;public;0;3;;public FieldPermissions getFieldPermissions() {     return fieldPermissions. }
false;private;1;3;;private boolean check(String action) {     return actionMatcher.test(action). }
false;private;2;5;;private boolean check(String action, String index) {     assert index != null.     return check(action) && indexNameMatcher.test(index) && (allowRestrictedIndices || (false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index))). }
false;;0;3;;boolean hasQuery() {     return query != null. }
false;public;0;3;;public boolean allowRestrictedIndices() {     return allowRestrictedIndices. }
false;public,static;2;8;;public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndices, String... indices) {     final Automaton indicesAutomaton = Automatons.patterns(indices).     if (allowRestrictedIndices) {         return indicesAutomaton.     } else {         return Automatons.minusAndMinimize(indicesAutomaton, RestrictedIndicesNames.NAMES_AUTOMATON).     } }
false;private,static;2;25;;private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {     final Set<String> ordinaryIndices = new HashSet<>().     final Set<String> restrictedIndices = new HashSet<>().     for (final Group group : groups) {         if (group.actionMatcher.test(action)) {             if (group.allowRestrictedIndices) {                 restrictedIndices.addAll(Arrays.asList(group.indices())).             } else {                 ordinaryIndices.addAll(Arrays.asList(group.indices())).             }         }     }     final Predicate<String> predicate.     if (restrictedIndices.isEmpty()) {         predicate = indexMatcher(ordinaryIndices).and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)).     } else if (ordinaryIndices.isEmpty()) {         predicate = indexMatcher(restrictedIndices).     } else {         predicate = indexMatcher(restrictedIndices).or(indexMatcher(ordinaryIndices).and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index))).     }     return predicate. }
false;private;1;8;;private void addAll(Set<BytesReference> query) {     if (allowAll == false) {         if (queries == null) {             queries = new HashSet<>().         }         queries.addAll(query).     } }
false;private;0;3;;private boolean isAllowAll() {     return allowAll. }
false;private;1;3;;private void setAllowAll(boolean allowAll) {     this.allowAll = allowAll. }
