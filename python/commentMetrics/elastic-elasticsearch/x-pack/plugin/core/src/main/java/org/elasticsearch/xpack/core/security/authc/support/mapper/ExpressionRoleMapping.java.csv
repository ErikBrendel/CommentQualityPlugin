commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeBoolean(enabled).     out.writeStringCollection(roles).     ExpressionParser.writeExpression(expression, out).     out.writeMap(metadata). }
true;public;0;3;/**  * The name of this mapping. The name exists for the sole purpose of providing a meaningful identifier for each mapping, so that it may  * be referred to for update, retrieval or deletion. The name does not affect the set of roles that a mapping provides.  */ ;/**  * The name of this mapping. The name exists for the sole purpose of providing a meaningful identifier for each mapping, so that it may  * be referred to for update, retrieval or deletion. The name does not affect the set of roles that a mapping provides.  */ public String getName() {     return name. }
true;public;0;3;/**  * The expression that determines whether the roles in this mapping should be applied to any given user.  * If the expression  * {@link RoleMapperExpression#match(org.elasticsearch.xpack.security.authc.support.mapper.expressiondsl.ExpressionModel) matches} a  * org.elasticsearch.xpack.security.authc.support.UserRoleMapper.UserData user, then the user should be assigned this mapping's  * {@link #getRoles() roles}  */ ;/**  * The expression that determines whether the roles in this mapping should be applied to any given user.  * If the expression  * {@link RoleMapperExpression#match(org.elasticsearch.xpack.security.authc.support.mapper.expressiondsl.ExpressionModel) matches} a  * org.elasticsearch.xpack.security.authc.support.UserRoleMapper.UserData user, then the user should be assigned this mapping's  * {@link #getRoles() roles}  */ public RoleMapperExpression getExpression() {     return expression. }
true;public;0;3;/**  * The list of {@link RoleDescriptor roles} (specified by name) that should be assigned to users  * that match the {@link #getExpression() expression} in this mapping.  */ ;/**  * The list of {@link RoleDescriptor roles} (specified by name) that should be assigned to users  * that match the {@link #getExpression() expression} in this mapping.  */ public List<String> getRoles() {     return Collections.unmodifiableList(roles). }
true;public;0;3;/**  * Meta-data for this mapping. This exists for external systems of user to track information about this mapping such as where it was  * sourced from, when it was loaded, etc.  * This is not used within the mapping process, and does not affect whether the expression matches, nor which roles are assigned.  */ ;/**  * Meta-data for this mapping. This exists for external systems of user to track information about this mapping such as where it was  * sourced from, when it was loaded, etc.  * This is not used within the mapping process, and does not affect whether the expression matches, nor which roles are assigned.  */ public Map<String, Object> getMetadata() {     return Collections.unmodifiableMap(metadata). }
true;public;0;3;/**  * Whether this mapping is enabled. Mappings that are not enabled are not applied to users.  */ ;/**  * Whether this mapping is enabled. Mappings that are not enabled are not applied to users.  */ public boolean isEnabled() {     return enabled. }
false;public;0;4;;@Override public String toString() {     return getClass().getSimpleName() + "<" + name + " . " + roles + " = " + Strings.toString(expression) + ">". }
true;public,static;3;8;/**  * Parse an {@link ExpressionRoleMapping} from the provided <em>XContent</em>  */ ;/**  * Parse an {@link ExpressionRoleMapping} from the provided <em>XContent</em>  */ public static ExpressionRoleMapping parse(String name, BytesReference source, XContentType xContentType) throws IOException {     final NamedXContentRegistry registry = NamedXContentRegistry.EMPTY.     try (InputStream stream = source.streamInput().         XContentParser parser = xContentType.xContent().createParser(registry, LoggingDeprecationHandler.INSTANCE, stream)) {         return parse(name, parser).     } }
true;public,static;2;8;/**  * Parse an {@link ExpressionRoleMapping} from the provided <em>XContent</em>  */ ;/**  * Parse an {@link ExpressionRoleMapping} from the provided <em>XContent</em>  */ public static ExpressionRoleMapping parse(String name, XContentParser parser) throws IOException {     try {         final Builder builder = PARSER.parse(parser, null).         return builder.build(name).     } catch (IllegalArgumentException | IllegalStateException e) {         throw new ParsingException(parser.getTokenLocation(), e.getMessage(), e).     } }
true;public;2;4;/**  * Converts this {@link ExpressionRoleMapping} into <em>XContent</em> that is compatible with  *  the format handled by {@link #parse(String, XContentParser)}.  */ ;/**  * Converts this {@link ExpressionRoleMapping} into <em>XContent</em> that is compatible with  *  the format handled by {@link #parse(String, XContentParser)}.  */ @Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return toXContent(builder, params, false). }
false;public;3;18;;public XContentBuilder toXContent(XContentBuilder builder, Params params, boolean includeDocType) throws IOException {     builder.startObject().     builder.field(Fields.ENABLED.getPreferredName(), enabled).     builder.startArray(Fields.ROLES.getPreferredName()).     for (String r : roles) {         builder.value(r).     }     builder.endArray().     builder.field(Fields.RULES.getPreferredName()).     expression.toXContent(builder, params).     builder.field(Fields.METADATA.getPreferredName(), metadata).     if (includeDocType) {         builder.field(NativeRoleMappingStoreField.DOC_TYPE_FIELD, NativeRoleMappingStoreField.DOC_TYPE_ROLE_MAPPING).     }     return builder.endObject(). }
false;;1;4;;Builder rules(RoleMapperExpression expression) {     this.rules = expression.     return this. }
false;;1;4;;Builder roles(List<String> roles) {     this.roles = roles.     return this. }
false;;1;4;;Builder metadata(Map<String, Object> metadata) {     this.metadata = metadata.     return this. }
false;;1;4;;Builder enabled(boolean enabled) {     this.enabled = enabled.     return this. }
false;private;1;12;;private ExpressionRoleMapping build(String name) {     if (roles == null) {         throw missingField(name, Fields.ROLES).     }     if (rules == null) {         throw missingField(name, Fields.RULES).     }     if (enabled == null) {         throw missingField(name, Fields.ENABLED).     }     return new ExpressionRoleMapping(name, rules, roles, metadata, enabled). }
false;private;2;3;;private IllegalStateException missingField(String id, ParseField field) {     return new IllegalStateException("failed to parse role-mapping [" + id + "]. missing field [" + field + "]"). }
