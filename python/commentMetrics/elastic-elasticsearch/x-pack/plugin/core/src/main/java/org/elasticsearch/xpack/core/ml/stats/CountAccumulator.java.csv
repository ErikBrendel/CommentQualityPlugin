commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public void merge(CountAccumulator other) {     counts = Stream.of(counts, other.counts).flatMap(m -> m.entrySet().stream()).collect(Collectors.toMap(Entry::getKey, Entry::getValue, (x, y) -> x + y)). }
false;public;2;3;;public void add(String key, Long count) {     counts.put(key, counts.getOrDefault(key, 0L) + count). }
false;public;0;3;;public Map<String, Long> asMap() {     return counts. }
false;public,static;1;4;;public static CountAccumulator fromTermsAggregation(StringTerms termsAggregation) {     return new CountAccumulator(termsAggregation.getBuckets().stream().collect(Collectors.toMap(bucket -> bucket.getKeyAsString(), bucket -> bucket.getDocCount()))). }
false;public;1;3;;public void writeTo(StreamOutput out) throws IOException {     out.writeMap(counts, StreamOutput::writeString, StreamOutput::writeLong). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(counts). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     CountAccumulator other = (CountAccumulator) obj.     return Objects.equals(counts, other.counts). }
