# id;timestamp;commentText;codeText;commentWords;codeWords
PemUtils -> private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,             GeneralSecurityException;1527622193;Parses a DER encoded EC key to an {@link ECPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link ECPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,_            GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        String keyHex = parser.readAsn1Object().getString()__        BigInteger privateKeyInt = new BigInteger(keyHex, 16)__        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC")__        AlgorithmParameterSpec prime256v1ParamSpec = new ECGenParameterSpec("secp256r1")__        keyPairGenerator.initialize(prime256v1ParamSpec)__        ECParameterSpec parameterSpec = ((ECKey) keyPairGenerator.generateKeyPair().getPrivate()).getParams()__        return new ECPrivateKeySpec(privateKeyInt, parameterSpec)__    };parses,a,der,encoded,ec,key,to,an,link,ecprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,ecprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,ecprivate,key,spec,parse,ec,der,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,string,key,hex,parser,read,asn1object,get,string,big,integer,private,key,int,new,big,integer,key,hex,16,key,pair,generator,key,pair,generator,key,pair,generator,get,instance,ec,algorithm,parameter,spec,prime256v1param,spec,new,ecgen,parameter,spec,secp256r1,key,pair,generator,initialize,prime256v1param,spec,ecparameter,spec,parameter,spec,eckey,key,pair,generator,generate,key,pair,get,private,get,params,return,new,ecprivate,key,spec,private,key,int,parameter,spec
PemUtils -> private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,             GeneralSecurityException;1531179852;Parses a DER encoded EC key to an {@link ECPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link ECPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,_            GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        String keyHex = parser.readAsn1Object().getString()__        BigInteger privateKeyInt = new BigInteger(keyHex, 16)__        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC")__        AlgorithmParameterSpec prime256v1ParamSpec = new ECGenParameterSpec("secp256r1")__        keyPairGenerator.initialize(prime256v1ParamSpec)__        ECParameterSpec parameterSpec = ((ECKey) keyPairGenerator.generateKeyPair().getPrivate()).getParams()__        return new ECPrivateKeySpec(privateKeyInt, parameterSpec)__    };parses,a,der,encoded,ec,key,to,an,link,ecprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,ecprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,ecprivate,key,spec,parse,ec,der,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,string,key,hex,parser,read,asn1object,get,string,big,integer,private,key,int,new,big,integer,key,hex,16,key,pair,generator,key,pair,generator,key,pair,generator,get,instance,ec,algorithm,parameter,spec,prime256v1param,spec,new,ecgen,parameter,spec,secp256r1,key,pair,generator,initialize,prime256v1param,spec,ecparameter,spec,parameter,spec,eckey,key,pair,generator,generate,key,pair,get,private,get,params,return,new,ecprivate,key,spec,private,key,int,parameter,spec
PemUtils -> private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,             GeneralSecurityException;1534434117;Parses a DER encoded EC key to an {@link ECPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link ECPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,_            GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        String keyHex = parser.readAsn1Object().getString()__        BigInteger privateKeyInt = new BigInteger(keyHex, 16)__        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC")__        AlgorithmParameterSpec prime256v1ParamSpec = new ECGenParameterSpec("secp256r1")__        keyPairGenerator.initialize(prime256v1ParamSpec)__        ECParameterSpec parameterSpec = ((ECKey) keyPairGenerator.generateKeyPair().getPrivate()).getParams()__        return new ECPrivateKeySpec(privateKeyInt, parameterSpec)__    };parses,a,der,encoded,ec,key,to,an,link,ecprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,ecprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,ecprivate,key,spec,parse,ec,der,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,string,key,hex,parser,read,asn1object,get,string,big,integer,private,key,int,new,big,integer,key,hex,16,key,pair,generator,key,pair,generator,key,pair,generator,get,instance,ec,algorithm,parameter,spec,prime256v1param,spec,new,ecgen,parameter,spec,secp256r1,key,pair,generator,initialize,prime256v1param,spec,ecparameter,spec,parameter,spec,eckey,key,pair,generator,generate,key,pair,get,private,get,params,return,new,ecprivate,key,spec,private,key,int,parameter,spec
PemUtils -> private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,             GeneralSecurityException;1535552903;Parses a DER encoded EC key to an {@link ECPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link ECPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static ECPrivateKeySpec parseEcDer(byte[] keyBytes) throws IOException,_            GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        String keyHex = parser.readAsn1Object().getString()__        BigInteger privateKeyInt = new BigInteger(keyHex, 16)__        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC")__        AlgorithmParameterSpec prime256v1ParamSpec = new ECGenParameterSpec("secp256r1")__        keyPairGenerator.initialize(prime256v1ParamSpec)__        ECParameterSpec parameterSpec = ((ECKey) keyPairGenerator.generateKeyPair().getPrivate()).getParams()__        return new ECPrivateKeySpec(privateKeyInt, parameterSpec)__    };parses,a,der,encoded,ec,key,to,an,link,ecprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,ecprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,ecprivate,key,spec,parse,ec,der,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,string,key,hex,parser,read,asn1object,get,string,big,integer,private,key,int,new,big,integer,key,hex,16,key,pair,generator,key,pair,generator,key,pair,generator,get,instance,ec,algorithm,parameter,spec,prime256v1param,spec,new,ecgen,parameter,spec,secp256r1,key,pair,generator,initialize,prime256v1param,spec,ecparameter,spec,parameter,spec,eckey,key,pair,generator,generate,key,pair,get,private,get,params,return,new,ecprivate,key,spec,private,key,int,parameter,spec
PemUtils -> private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1527622193;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an RSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link RSAPrivateCrtKeySpec};private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (PKCS1_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || PKCS1_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        RSAPrivateCrtKeySpec spec = parseRsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("RSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,rsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,rsaprivate,crt,key,spec;private,static,private,key,parse,pkcs1rsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,rsaprivate,crt,key,spec,spec,parse,rsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,rsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1531179852;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an RSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link RSAPrivateCrtKeySpec};private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (PKCS1_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || PKCS1_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        RSAPrivateCrtKeySpec spec = parseRsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("RSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,rsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,rsaprivate,crt,key,spec;private,static,private,key,parse,pkcs1rsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,rsaprivate,crt,key,spec,spec,parse,rsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,rsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1534434117;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an RSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link RSAPrivateCrtKeySpec};private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (PKCS1_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || PKCS1_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        RSAPrivateCrtKeySpec spec = parseRsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("RSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,rsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,rsaprivate,crt,key,spec;private,static,private,key,parse,pkcs1rsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,rsaprivate,crt,key,spec,spec,parse,rsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,rsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1535552903;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an RSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link RSAPrivateCrtKeySpec};private static PrivateKey parsePKCS1Rsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (PKCS1_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || PKCS1_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        RSAPrivateCrtKeySpec spec = parseRsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("RSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,rsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,rsaprivate,crt,key,spec;private,static,private,key,parse,pkcs1rsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,rsaprivate,crt,key,spec,spec,parse,rsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,rsa,return,key,factory,generate,private,spec
PemUtils -> private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException;1527622193;Removes the EC Headers that OpenSSL adds to EC private keys as the information in them_is redundant__@param bReader_@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_EC_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, EC Parameters footer is missing")__        }_        _        if (OPENSSL_EC_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, EC Key header is missing")__        }_        return bReader__    };removes,the,ec,headers,that,open,ssl,adds,to,ec,private,keys,as,the,information,in,them,is,redundant,param,b,reader,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,echeaders,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,ec,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,ec,key,header,is,missing,return,b,reader
PemUtils -> private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException;1531179852;Removes the EC Headers that OpenSSL adds to EC private keys as the information in them_is redundant__@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_EC_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, EC Parameters footer is missing")__        }_        _        if (OPENSSL_EC_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, EC Key header is missing")__        }_        return bReader__    };removes,the,ec,headers,that,open,ssl,adds,to,ec,private,keys,as,the,information,in,them,is,redundant,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,echeaders,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,ec,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,ec,key,header,is,missing,return,b,reader
PemUtils -> private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException;1534434117;Removes the EC Headers that OpenSSL adds to EC private keys as the information in them_is redundant__@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_EC_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, EC Parameters footer is missing")__        }_        _        if (OPENSSL_EC_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, EC Key header is missing")__        }_        return bReader__    };removes,the,ec,headers,that,open,ssl,adds,to,ec,private,keys,as,the,information,in,them,is,redundant,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,echeaders,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,ec,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,ec,key,header,is,missing,return,b,reader
PemUtils -> private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException;1535552903;Removes the EC Headers that OpenSSL adds to EC private keys as the information in them_is redundant__@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeECHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_EC_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, EC Parameters footer is missing")__        }_        _        if (OPENSSL_EC_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, EC Key header is missing")__        }_        return bReader__    };removes,the,ec,headers,that,open,ssl,adds,to,ec,private,keys,as,the,information,in,them,is,redundant,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,echeaders,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,ec,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,ec,key,header,is,missing,return,b,reader
PemUtils -> private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,         GeneralSecurityException;1527622193;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an encrypted private key encoded in_PKCS#8__@param bReader     the {@link BufferedReader} containing the key file contents_@param keyPassword The password for the encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_ENCRYPTED_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_ENCRYPTED_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())___        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(keyBytes)__        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName())__        SecretKey secretKey = secretKeyFactory.generateSecret(new PBEKeySpec(keyPassword))__        Arrays.fill(keyPassword, '\u0000')__        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName())__        cipher.init(Cipher.DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters())__        PKCS8EncodedKeySpec keySpec = encryptedPrivateKeyInfo.getKeySpec(cipher)__        String keyAlgo = getKeyAlgorithmIdentifier(keySpec.getEncoded())__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(keySpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,encrypted,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,key,password,the,password,for,the,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8encrypted,buffered,reader,b,reader,char,key,password,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,encrypted,private,key,info,encrypted,private,key,info,new,encrypted,private,key,info,key,bytes,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,encrypted,private,key,info,get,alg,name,secret,key,secret,key,secret,key,factory,generate,secret,new,pbekey,spec,key,password,arrays,fill,key,password,u0000,cipher,cipher,cipher,get,instance,encrypted,private,key,info,get,alg,name,cipher,init,cipher,secret,key,encrypted,private,key,info,get,alg,parameters,pkcs8encoded,key,spec,key,spec,encrypted,private,key,info,get,key,spec,cipher,string,key,algo,get,key,algorithm,identifier,key,spec,get,encoded,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,key,spec
PemUtils -> private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,         GeneralSecurityException;1531179852;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an encrypted private key encoded in_PKCS#8__@param bReader     the {@link BufferedReader} containing the key file contents_@param keyPassword The password for the encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_ENCRYPTED_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_ENCRYPTED_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())___        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(keyBytes)__        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName())__        SecretKey secretKey = secretKeyFactory.generateSecret(new PBEKeySpec(keyPassword))__        Arrays.fill(keyPassword, '\u0000')__        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName())__        cipher.init(Cipher.DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters())__        PKCS8EncodedKeySpec keySpec = encryptedPrivateKeyInfo.getKeySpec(cipher)__        String keyAlgo = getKeyAlgorithmIdentifier(keySpec.getEncoded())__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(keySpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,encrypted,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,key,password,the,password,for,the,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8encrypted,buffered,reader,b,reader,char,key,password,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,encrypted,private,key,info,encrypted,private,key,info,new,encrypted,private,key,info,key,bytes,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,encrypted,private,key,info,get,alg,name,secret,key,secret,key,secret,key,factory,generate,secret,new,pbekey,spec,key,password,arrays,fill,key,password,u0000,cipher,cipher,cipher,get,instance,encrypted,private,key,info,get,alg,name,cipher,init,cipher,secret,key,encrypted,private,key,info,get,alg,parameters,pkcs8encoded,key,spec,key,spec,encrypted,private,key,info,get,key,spec,cipher,string,key,algo,get,key,algorithm,identifier,key,spec,get,encoded,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,key,spec
PemUtils -> private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,         GeneralSecurityException;1534434117;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an encrypted private key encoded in_PKCS#8__@param bReader     the {@link BufferedReader} containing the key file contents_@param keyPassword The password for the encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_ENCRYPTED_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_ENCRYPTED_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())___        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(keyBytes)__        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName())__        SecretKey secretKey = secretKeyFactory.generateSecret(new PBEKeySpec(keyPassword))__        Arrays.fill(keyPassword, '\u0000')__        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName())__        cipher.init(Cipher.DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters())__        PKCS8EncodedKeySpec keySpec = encryptedPrivateKeyInfo.getKeySpec(cipher)__        String keyAlgo = getKeyAlgorithmIdentifier(keySpec.getEncoded())__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(keySpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,encrypted,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,key,password,the,password,for,the,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8encrypted,buffered,reader,b,reader,char,key,password,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,encrypted,private,key,info,encrypted,private,key,info,new,encrypted,private,key,info,key,bytes,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,encrypted,private,key,info,get,alg,name,secret,key,secret,key,secret,key,factory,generate,secret,new,pbekey,spec,key,password,arrays,fill,key,password,u0000,cipher,cipher,cipher,get,instance,encrypted,private,key,info,get,alg,name,cipher,init,cipher,secret,key,encrypted,private,key,info,get,alg,parameters,pkcs8encoded,key,spec,key,spec,encrypted,private,key,info,get,key,spec,cipher,string,key,algo,get,key,algorithm,identifier,key,spec,get,encoded,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,key,spec
PemUtils -> private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,         GeneralSecurityException;1535552903;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an encrypted private key encoded in_PKCS#8__@param bReader     the {@link BufferedReader} containing the key file contents_@param keyPassword The password for the encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8Encrypted(BufferedReader bReader, char[] keyPassword) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_ENCRYPTED_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_ENCRYPTED_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())___        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(keyBytes)__        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName())__        SecretKey secretKey = secretKeyFactory.generateSecret(new PBEKeySpec(keyPassword))__        Arrays.fill(keyPassword, '\u0000')__        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName())__        cipher.init(Cipher.DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters())__        PKCS8EncodedKeySpec keySpec = encryptedPrivateKeyInfo.getKeySpec(cipher)__        String keyAlgo = getKeyAlgorithmIdentifier(keySpec.getEncoded())__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(keySpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,encrypted,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,key,password,the,password,for,the,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8encrypted,buffered,reader,b,reader,char,key,password,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,encrypted,private,key,info,encrypted,private,key,info,new,encrypted,private,key,info,key,bytes,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,encrypted,private,key,info,get,alg,name,secret,key,secret,key,secret,key,factory,generate,secret,new,pbekey,spec,key,password,arrays,fill,key,password,u0000,cipher,cipher,cipher,get,instance,encrypted,private,key,info,get,alg,name,cipher,init,cipher,secret,key,encrypted,private,key,info,get,alg,parameters,pkcs8encoded,key,spec,key,spec,encrypted,private,key,info,get,key,spec,cipher,string,key,algo,get,key,algorithm,identifier,key,spec,get,encoded,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,key,spec
PemUtils -> private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException;1527622193;Removes the DSA Params Headers that OpenSSL adds to DSA private keys as the information in them_is redundant__@param bReader_@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, DSA Parameters footer is missing")__        }_        _        if (OPENSSL_DSA_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, DSA Key header is missing")__        }_        return bReader__    };removes,the,dsa,params,headers,that,open,ssl,adds,to,dsa,private,keys,as,the,information,in,them,is,redundant,param,b,reader,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,dsa,headers,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,dsa,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,dsa,key,header,is,missing,return,b,reader
PemUtils -> private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException;1531179852;Removes the DSA Params Headers that OpenSSL adds to DSA private keys as the information in them_is redundant__@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, DSA Parameters footer is missing")__        }_        _        if (OPENSSL_DSA_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, DSA Key header is missing")__        }_        return bReader__    };removes,the,dsa,params,headers,that,open,ssl,adds,to,dsa,private,keys,as,the,information,in,them,is,redundant,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,dsa,headers,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,dsa,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,dsa,key,header,is,missing,return,b,reader
PemUtils -> private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException;1534434117;Removes the DSA Params Headers that OpenSSL adds to DSA private keys as the information in them_is redundant__@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, DSA Parameters footer is missing")__        }_        _        if (OPENSSL_DSA_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, DSA Key header is missing")__        }_        return bReader__    };removes,the,dsa,params,headers,that,open,ssl,adds,to,dsa,private,keys,as,the,information,in,them,is,redundant,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,dsa,headers,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,dsa,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,dsa,key,header,is,missing,return,b,reader
PemUtils -> private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException;1535552903;Removes the DSA Params Headers that OpenSSL adds to DSA private keys as the information in them_is redundant__@throws IOException if the EC Parameter footer is missing;private static BufferedReader removeDsaHeaders(BufferedReader bReader) throws IOException {_        String line = bReader.readLine()__        while (line != null) {_            if (OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim())) {_                break__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, DSA Parameters footer is missing")__        }_        _        if (OPENSSL_DSA_HEADER.equals(bReader.readLine()) == false) {_            throw new IOException("Malformed PEM file, DSA Key header is missing")__        }_        return bReader__    };removes,the,dsa,params,headers,that,open,ssl,adds,to,dsa,private,keys,as,the,information,in,them,is,redundant,throws,ioexception,if,the,ec,parameter,footer,is,missing;private,static,buffered,reader,remove,dsa,headers,buffered,reader,b,reader,throws,ioexception,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,dsa,parameters,footer,is,missing,if,equals,b,reader,read,line,false,throw,new,ioexception,malformed,pem,file,dsa,key,header,is,missing,return,b,reader
PemUtils -> private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException;1527622193;Parses a DER encoded DSA key to a {@link DSAPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link DSAPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger p = parser.readAsn1Object().getInteger()__        BigInteger q = parser.readAsn1Object().getInteger()__        BigInteger g = parser.readAsn1Object().getInteger()__        parser.readAsn1Object().getInteger()_ _        BigInteger x = parser.readAsn1Object().getInteger()__        return new DSAPrivateKeySpec(x, p, q, g)__    };parses,a,der,encoded,dsa,key,to,a,link,dsaprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,dsaprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,dsaprivate,key,spec,parse,dsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,p,parser,read,asn1object,get,integer,big,integer,q,parser,read,asn1object,get,integer,big,integer,g,parser,read,asn1object,get,integer,parser,read,asn1object,get,integer,big,integer,x,parser,read,asn1object,get,integer,return,new,dsaprivate,key,spec,x,p,q,g
PemUtils -> private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException;1531179852;Parses a DER encoded DSA key to a {@link DSAPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link DSAPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger p = parser.readAsn1Object().getInteger()__        BigInteger q = parser.readAsn1Object().getInteger()__        BigInteger g = parser.readAsn1Object().getInteger()__        parser.readAsn1Object().getInteger()_ _        BigInteger x = parser.readAsn1Object().getInteger()__        return new DSAPrivateKeySpec(x, p, q, g)__    };parses,a,der,encoded,dsa,key,to,a,link,dsaprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,dsaprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,dsaprivate,key,spec,parse,dsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,p,parser,read,asn1object,get,integer,big,integer,q,parser,read,asn1object,get,integer,big,integer,g,parser,read,asn1object,get,integer,parser,read,asn1object,get,integer,big,integer,x,parser,read,asn1object,get,integer,return,new,dsaprivate,key,spec,x,p,q,g
PemUtils -> private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException;1534434117;Parses a DER encoded DSA key to a {@link DSAPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link DSAPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger p = parser.readAsn1Object().getInteger()__        BigInteger q = parser.readAsn1Object().getInteger()__        BigInteger g = parser.readAsn1Object().getInteger()__        parser.readAsn1Object().getInteger()_ _        BigInteger x = parser.readAsn1Object().getInteger()__        return new DSAPrivateKeySpec(x, p, q, g)__    };parses,a,der,encoded,dsa,key,to,a,link,dsaprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,dsaprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,dsaprivate,key,spec,parse,dsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,p,parser,read,asn1object,get,integer,big,integer,q,parser,read,asn1object,get,integer,big,integer,g,parser,read,asn1object,get,integer,parser,read,asn1object,get,integer,big,integer,x,parser,read,asn1object,get,integer,return,new,dsaprivate,key,spec,x,p,q,g
PemUtils -> private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException;1535552903;Parses a DER encoded DSA key to a {@link DSAPrivateKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link DSAPrivateKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static DSAPrivateKeySpec parseDsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger p = parser.readAsn1Object().getInteger()__        BigInteger q = parser.readAsn1Object().getInteger()__        BigInteger g = parser.readAsn1Object().getInteger()__        parser.readAsn1Object().getInteger()_ _        BigInteger x = parser.readAsn1Object().getInteger()__        return new DSAPrivateKeySpec(x, p, q, g)__    };parses,a,der,encoded,dsa,key,to,a,link,dsaprivate,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,dsaprivate,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,dsaprivate,key,spec,parse,dsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,p,parser,read,asn1object,get,integer,big,integer,q,parser,read,asn1object,get,integer,big,integer,g,parser,read,asn1object,get,integer,parser,read,asn1object,get,integer,big,integer,x,parser,read,asn1object,get,integer,return,new,dsaprivate,key,spec,x,p,q,g
PemUtils -> private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1527622193;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an EC private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link ECPrivateKeySpec};private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()__        while (line != null) {_            if (OPENSSL_EC_FOOTER.equals(line.trim())) {_                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        KeyFactory keyFactory = KeyFactory.getInstance("EC")__        ECPrivateKeySpec ecSpec = parseEcDer(keyBytes)__        return keyFactory.generatePrivate(ecSpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,ec,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,ecprivate,key,spec;private,static,private,key,parse,open,ssl,ec,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,key,factory,key,factory,key,factory,get,instance,ec,ecprivate,key,spec,ec,spec,parse,ec,der,key,bytes,return,key,factory,generate,private,ec,spec
PemUtils -> private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1531179852;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an EC private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link ECPrivateKeySpec};private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()__        while (line != null) {_            if (OPENSSL_EC_FOOTER.equals(line.trim())) {_                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        KeyFactory keyFactory = KeyFactory.getInstance("EC")__        ECPrivateKeySpec ecSpec = parseEcDer(keyBytes)__        return keyFactory.generatePrivate(ecSpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,ec,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,ecprivate,key,spec;private,static,private,key,parse,open,ssl,ec,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,key,factory,key,factory,key,factory,get,instance,ec,ecprivate,key,spec,ec,spec,parse,ec,der,key,bytes,return,key,factory,generate,private,ec,spec
PemUtils -> private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1534434117;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an EC private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link ECPrivateKeySpec};private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()__        while (line != null) {_            if (OPENSSL_EC_FOOTER.equals(line.trim())) {_                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        KeyFactory keyFactory = KeyFactory.getInstance("EC")__        ECPrivateKeySpec ecSpec = parseEcDer(keyBytes)__        return keyFactory.generatePrivate(ecSpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,ec,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,ecprivate,key,spec;private,static,private,key,parse,open,ssl,ec,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,key,factory,key,factory,key,factory,get,instance,ec,ecprivate,key,spec,ec,spec,parse,ec,der,key,bytes,return,key,factory,generate,private,ec,spec
PemUtils -> private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1535552903;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an EC private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link ECPrivateKeySpec};private static PrivateKey parseOpenSslEC(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()__        while (line != null) {_            if (OPENSSL_EC_FOOTER.equals(line.trim())) {_                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_EC_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        KeyFactory keyFactory = KeyFactory.getInstance("EC")__        ECPrivateKeySpec ecSpec = parseEcDer(keyBytes)__        return keyFactory.generatePrivate(ecSpec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,ec,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,ecprivate,key,spec;private,static,private,key,parse,open,ssl,ec,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,key,factory,key,factory,key,factory,get,instance,ec,ecprivate,key,spec,ec,spec,parse,ec,der,key,bytes,return,key,factory,generate,private,ec,spec
PemUtils -> private static byte[] hexStringToByteArray(String hexString);1527622193;Converts a hexadecimal string to a byte array;private static byte[] hexStringToByteArray(String hexString) {_        int len = hexString.length()__        if (len % 2 == 0) {_            byte[] data = new byte[len / 2]__            for (int i = 0_ i < len_ i += 2) {_                final int k = Character.digit(hexString.charAt(i), 16)__                final int l = Character.digit(hexString.charAt(i + 1), 16)__                if (k == -1 || l == -1) {_                    throw new IllegalStateException("String is not hexadecimal")__                }_                data[i / 2] = (byte) ((k << 4) + l)__            }_            return data__        } else {_            throw new IllegalStateException("Hexadeciamal string length is odd, can't convert to byte array")__        }_    };converts,a,hexadecimal,string,to,a,byte,array;private,static,byte,hex,string,to,byte,array,string,hex,string,int,len,hex,string,length,if,len,2,0,byte,data,new,byte,len,2,for,int,i,0,i,len,i,2,final,int,k,character,digit,hex,string,char,at,i,16,final,int,l,character,digit,hex,string,char,at,i,1,16,if,k,1,l,1,throw,new,illegal,state,exception,string,is,not,hexadecimal,data,i,2,byte,k,4,l,return,data,else,throw,new,illegal,state,exception,hexadeciamal,string,length,is,odd,can,t,convert,to,byte,array
PemUtils -> private static byte[] hexStringToByteArray(String hexString);1531179852;Converts a hexadecimal string to a byte array;private static byte[] hexStringToByteArray(String hexString) {_        int len = hexString.length()__        if (len % 2 == 0) {_            byte[] data = new byte[len / 2]__            for (int i = 0_ i < len_ i += 2) {_                final int k = Character.digit(hexString.charAt(i), 16)__                final int l = Character.digit(hexString.charAt(i + 1), 16)__                if (k == -1 || l == -1) {_                    throw new IllegalStateException("String is not hexadecimal")__                }_                data[i / 2] = (byte) ((k << 4) + l)__            }_            return data__        } else {_            throw new IllegalStateException("Hexadeciamal string length is odd, can't convert to byte array")__        }_    };converts,a,hexadecimal,string,to,a,byte,array;private,static,byte,hex,string,to,byte,array,string,hex,string,int,len,hex,string,length,if,len,2,0,byte,data,new,byte,len,2,for,int,i,0,i,len,i,2,final,int,k,character,digit,hex,string,char,at,i,16,final,int,l,character,digit,hex,string,char,at,i,1,16,if,k,1,l,1,throw,new,illegal,state,exception,string,is,not,hexadecimal,data,i,2,byte,k,4,l,return,data,else,throw,new,illegal,state,exception,hexadeciamal,string,length,is,odd,can,t,convert,to,byte,array
PemUtils -> private static byte[] hexStringToByteArray(String hexString);1534434117;Converts a hexadecimal string to a byte array;private static byte[] hexStringToByteArray(String hexString) {_        int len = hexString.length()__        if (len % 2 == 0) {_            byte[] data = new byte[len / 2]__            for (int i = 0_ i < len_ i += 2) {_                final int k = Character.digit(hexString.charAt(i), 16)__                final int l = Character.digit(hexString.charAt(i + 1), 16)__                if (k == -1 || l == -1) {_                    throw new IllegalStateException("String is not hexadecimal")__                }_                data[i / 2] = (byte) ((k << 4) + l)__            }_            return data__        } else {_            throw new IllegalStateException("Hexadeciamal string length is odd, can't convert to byte array")__        }_    };converts,a,hexadecimal,string,to,a,byte,array;private,static,byte,hex,string,to,byte,array,string,hex,string,int,len,hex,string,length,if,len,2,0,byte,data,new,byte,len,2,for,int,i,0,i,len,i,2,final,int,k,character,digit,hex,string,char,at,i,16,final,int,l,character,digit,hex,string,char,at,i,1,16,if,k,1,l,1,throw,new,illegal,state,exception,string,is,not,hexadecimal,data,i,2,byte,k,4,l,return,data,else,throw,new,illegal,state,exception,hexadeciamal,string,length,is,odd,can,t,convert,to,byte,array
PemUtils -> private static byte[] hexStringToByteArray(String hexString);1535552903;Converts a hexadecimal string to a byte array;private static byte[] hexStringToByteArray(String hexString) {_        int len = hexString.length()__        if (len % 2 == 0) {_            byte[] data = new byte[len / 2]__            for (int i = 0_ i < len_ i += 2) {_                final int k = Character.digit(hexString.charAt(i), 16)__                final int l = Character.digit(hexString.charAt(i + 1), 16)__                if (k == -1 || l == -1) {_                    throw new IllegalStateException("String is not hexadecimal")__                }_                data[i / 2] = (byte) ((k << 4) + l)__            }_            return data__        } else {_            throw new IllegalStateException("Hexadeciamal string length is odd, can't convert to byte array")__        }_    };converts,a,hexadecimal,string,to,a,byte,array;private,static,byte,hex,string,to,byte,array,string,hex,string,int,len,hex,string,length,if,len,2,0,byte,data,new,byte,len,2,for,int,i,0,i,len,i,2,final,int,k,character,digit,hex,string,char,at,i,16,final,int,l,character,digit,hex,string,char,at,i,1,16,if,k,1,l,1,throw,new,illegal,state,exception,string,is,not,hexadecimal,data,i,2,byte,k,4,l,return,data,else,throw,new,illegal,state,exception,hexadeciamal,string,length,is,odd,can,t,convert,to,byte,array
PemUtils -> private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException;1527622193;Parses a DER encoded RSA key to a {@link RSAPrivateCrtKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link RSAPrivateCrtKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger modulus = parser.readAsn1Object().getInteger()__        BigInteger publicExponent = parser.readAsn1Object().getInteger()__        BigInteger privateExponent = parser.readAsn1Object().getInteger()__        BigInteger prime1 = parser.readAsn1Object().getInteger()__        BigInteger prime2 = parser.readAsn1Object().getInteger()__        BigInteger exponent1 = parser.readAsn1Object().getInteger()__        BigInteger exponent2 = parser.readAsn1Object().getInteger()__        BigInteger coefficient = parser.readAsn1Object().getInteger()__        return new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1, prime2, exponent1, exponent2, coefficient)__    };parses,a,der,encoded,rsa,key,to,a,link,rsaprivate,crt,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,rsaprivate,crt,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,rsaprivate,crt,key,spec,parse,rsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,modulus,parser,read,asn1object,get,integer,big,integer,public,exponent,parser,read,asn1object,get,integer,big,integer,private,exponent,parser,read,asn1object,get,integer,big,integer,prime1,parser,read,asn1object,get,integer,big,integer,prime2,parser,read,asn1object,get,integer,big,integer,exponent1,parser,read,asn1object,get,integer,big,integer,exponent2,parser,read,asn1object,get,integer,big,integer,coefficient,parser,read,asn1object,get,integer,return,new,rsaprivate,crt,key,spec,modulus,public,exponent,private,exponent,prime1,prime2,exponent1,exponent2,coefficient
PemUtils -> private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException;1531179852;Parses a DER encoded RSA key to a {@link RSAPrivateCrtKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link RSAPrivateCrtKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger modulus = parser.readAsn1Object().getInteger()__        BigInteger publicExponent = parser.readAsn1Object().getInteger()__        BigInteger privateExponent = parser.readAsn1Object().getInteger()__        BigInteger prime1 = parser.readAsn1Object().getInteger()__        BigInteger prime2 = parser.readAsn1Object().getInteger()__        BigInteger exponent1 = parser.readAsn1Object().getInteger()__        BigInteger exponent2 = parser.readAsn1Object().getInteger()__        BigInteger coefficient = parser.readAsn1Object().getInteger()__        return new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1, prime2, exponent1, exponent2, coefficient)__    };parses,a,der,encoded,rsa,key,to,a,link,rsaprivate,crt,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,rsaprivate,crt,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,rsaprivate,crt,key,spec,parse,rsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,modulus,parser,read,asn1object,get,integer,big,integer,public,exponent,parser,read,asn1object,get,integer,big,integer,private,exponent,parser,read,asn1object,get,integer,big,integer,prime1,parser,read,asn1object,get,integer,big,integer,prime2,parser,read,asn1object,get,integer,big,integer,exponent1,parser,read,asn1object,get,integer,big,integer,exponent2,parser,read,asn1object,get,integer,big,integer,coefficient,parser,read,asn1object,get,integer,return,new,rsaprivate,crt,key,spec,modulus,public,exponent,private,exponent,prime1,prime2,exponent1,exponent2,coefficient
PemUtils -> private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException;1534434117;Parses a DER encoded RSA key to a {@link RSAPrivateCrtKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link RSAPrivateCrtKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger modulus = parser.readAsn1Object().getInteger()__        BigInteger publicExponent = parser.readAsn1Object().getInteger()__        BigInteger privateExponent = parser.readAsn1Object().getInteger()__        BigInteger prime1 = parser.readAsn1Object().getInteger()__        BigInteger prime2 = parser.readAsn1Object().getInteger()__        BigInteger exponent1 = parser.readAsn1Object().getInteger()__        BigInteger exponent2 = parser.readAsn1Object().getInteger()__        BigInteger coefficient = parser.readAsn1Object().getInteger()__        return new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1, prime2, exponent1, exponent2, coefficient)__    };parses,a,der,encoded,rsa,key,to,a,link,rsaprivate,crt,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,rsaprivate,crt,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,rsaprivate,crt,key,spec,parse,rsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,modulus,parser,read,asn1object,get,integer,big,integer,public,exponent,parser,read,asn1object,get,integer,big,integer,private,exponent,parser,read,asn1object,get,integer,big,integer,prime1,parser,read,asn1object,get,integer,big,integer,prime2,parser,read,asn1object,get,integer,big,integer,exponent1,parser,read,asn1object,get,integer,big,integer,exponent2,parser,read,asn1object,get,integer,big,integer,coefficient,parser,read,asn1object,get,integer,return,new,rsaprivate,crt,key,spec,modulus,public,exponent,private,exponent,prime1,prime2,exponent1,exponent2,coefficient
PemUtils -> private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException;1535552903;Parses a DER encoded RSA key to a {@link RSAPrivateCrtKeySpec} using a minimal {@link DerParser}__@param keyBytes the private key raw bytes_@return {@link RSAPrivateCrtKeySpec}_@throws IOException if the DER encoded key can't be parsed;private static RSAPrivateCrtKeySpec parseRsaDer(byte[] keyBytes) throws IOException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        BigInteger modulus = parser.readAsn1Object().getInteger()__        BigInteger publicExponent = parser.readAsn1Object().getInteger()__        BigInteger privateExponent = parser.readAsn1Object().getInteger()__        BigInteger prime1 = parser.readAsn1Object().getInteger()__        BigInteger prime2 = parser.readAsn1Object().getInteger()__        BigInteger exponent1 = parser.readAsn1Object().getInteger()__        BigInteger exponent2 = parser.readAsn1Object().getInteger()__        BigInteger coefficient = parser.readAsn1Object().getInteger()__        return new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1, prime2, exponent1, exponent2, coefficient)__    };parses,a,der,encoded,rsa,key,to,a,link,rsaprivate,crt,key,spec,using,a,minimal,link,der,parser,param,key,bytes,the,private,key,raw,bytes,return,link,rsaprivate,crt,key,spec,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,rsaprivate,crt,key,spec,parse,rsa,der,byte,key,bytes,throws,ioexception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,big,integer,modulus,parser,read,asn1object,get,integer,big,integer,public,exponent,parser,read,asn1object,get,integer,big,integer,private,exponent,parser,read,asn1object,get,integer,big,integer,prime1,parser,read,asn1object,get,integer,big,integer,prime2,parser,read,asn1object,get,integer,big,integer,exponent1,parser,read,asn1object,get,integer,big,integer,exponent2,parser,read,asn1object,get,integer,big,integer,coefficient,parser,read,asn1object,get,integer,return,new,rsaprivate,crt,key,spec,modulus,public,exponent,private,exponent,prime1,prime2,exponent1,exponent2,coefficient
PemUtils -> private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1527622193;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an DSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link DSAPrivateKeySpec};private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (OPENSSL_DSA_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        DSAPrivateKeySpec spec = parseDsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("DSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,dsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,dsaprivate,key,spec;private,static,private,key,parse,open,ssl,dsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,dsaprivate,key,spec,spec,parse,dsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,dsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1531179852;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an DSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link DSAPrivateKeySpec};private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (OPENSSL_DSA_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        DSAPrivateKeySpec spec = parseDsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("DSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,dsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,dsaprivate,key,spec;private,static,private,key,parse,open,ssl,dsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,dsaprivate,key,spec,spec,parse,dsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,dsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1534434117;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an DSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link DSAPrivateKeySpec};private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (OPENSSL_DSA_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        DSAPrivateKeySpec spec = parseDsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("DSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,dsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,dsaprivate,key,spec;private,static,private,key,parse,open,ssl,dsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,dsaprivate,key,spec,spec,parse,dsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,dsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,         GeneralSecurityException;1535552903;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an DSA private key encoded in_OpenSSL traditional format.__@param bReader          the {@link BufferedReader} containing the key file contents_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link DSAPrivateKeySpec};private static PrivateKey parseOpenSslDsa(BufferedReader bReader, Supplier<char[]> passwordSupplier) throws IOException,_        GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        Map<String, String> pemHeaders = new HashMap<>()___        while (line != null) {_            if (OPENSSL_DSA_FOOTER.equals(line.trim())) {_                _                break__            }_            _            if (line.contains(":")) {_                String[] header = line.split(":")__                pemHeaders.put(header[0].trim(), header[1].trim())__            } else {_                sb.append(line.trim())__            }_            line = bReader.readLine()__        }_        if (null == line || OPENSSL_DSA_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier)__        DSAPrivateKeySpec spec = parseDsaDer(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance("DSA")__        return keyFactory.generatePrivate(spec)__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,dsa,private,key,encoded,in,open,ssl,traditional,format,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,dsaprivate,key,spec;private,static,private,key,parse,open,ssl,dsa,buffered,reader,b,reader,supplier,char,password,supplier,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,map,string,string,pem,headers,new,hash,map,while,line,null,if,equals,line,trim,break,if,line,contains,string,header,line,split,pem,headers,put,header,0,trim,header,1,trim,else,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,possibly,decrypt,pkcs1key,pem,headers,sb,to,string,password,supplier,dsaprivate,key,spec,spec,parse,dsa,der,key,bytes,key,factory,key,factory,key,factory,get,instance,dsa,return,key,factory,generate,private,spec
PemUtils -> private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException;1527622193;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an plaintext private key encoded in_PKCS#8__@param bReader the {@link BufferedReader} containing the key file contents_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())__        String keyAlgo = getKeyAlgorithmIdentifier(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes))__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,plaintext,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8,buffered,reader,b,reader,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,string,key,algo,get,key,algorithm,identifier,key,bytes,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,new,pkcs8encoded,key,spec,key,bytes
PemUtils -> private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException;1531179852;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an plaintext private key encoded in_PKCS#8__@param bReader the {@link BufferedReader} containing the key file contents_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())__        String keyAlgo = getKeyAlgorithmIdentifier(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes))__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,plaintext,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8,buffered,reader,b,reader,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,string,key,algo,get,key,algorithm,identifier,key,bytes,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,new,pkcs8encoded,key,spec,key,bytes
PemUtils -> private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException;1534434117;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an plaintext private key encoded in_PKCS#8__@param bReader the {@link BufferedReader} containing the key file contents_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())__        String keyAlgo = getKeyAlgorithmIdentifier(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes))__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,plaintext,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8,buffered,reader,b,reader,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,string,key,algo,get,key,algorithm,identifier,key,bytes,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,new,pkcs8encoded,key,spec,key,bytes
PemUtils -> private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException;1535552903;Creates a {@link PrivateKey} from the contents of {@code bReader} that contains an plaintext private key encoded in_PKCS#8__@param bReader the {@link BufferedReader} containing the key file contents_@return {@link PrivateKey}_@throws IOException              if the file can't be read_@throws GeneralSecurityException if the private key can't be generated from the {@link PKCS8EncodedKeySpec};private static PrivateKey parsePKCS8(BufferedReader bReader) throws IOException, GeneralSecurityException {_        StringBuilder sb = new StringBuilder()__        String line = bReader.readLine()__        while (line != null) {_            if (PKCS8_FOOTER.equals(line.trim())) {_                break__            }_            sb.append(line.trim())__            line = bReader.readLine()__        }_        if (null == line || PKCS8_FOOTER.equals(line.trim()) == false) {_            throw new IOException("Malformed PEM file, PEM footer is invalid or missing")__        }_        byte[] keyBytes = Base64.getDecoder().decode(sb.toString())__        String keyAlgo = getKeyAlgorithmIdentifier(keyBytes)__        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo)__        return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes))__    };creates,a,link,private,key,from,the,contents,of,code,b,reader,that,contains,an,plaintext,private,key,encoded,in,pkcs,8,param,b,reader,the,link,buffered,reader,containing,the,key,file,contents,return,link,private,key,throws,ioexception,if,the,file,can,t,be,read,throws,general,security,exception,if,the,private,key,can,t,be,generated,from,the,link,pkcs8encoded,key,spec;private,static,private,key,parse,pkcs8,buffered,reader,b,reader,throws,ioexception,general,security,exception,string,builder,sb,new,string,builder,string,line,b,reader,read,line,while,line,null,if,equals,line,trim,break,sb,append,line,trim,line,b,reader,read,line,if,null,line,equals,line,trim,false,throw,new,ioexception,malformed,pem,file,pem,footer,is,invalid,or,missing,byte,key,bytes,base64,get,decoder,decode,sb,to,string,string,key,algo,get,key,algorithm,identifier,key,bytes,key,factory,key,factory,key,factory,get,instance,key,algo,return,key,factory,generate,private,new,pkcs8encoded,key,spec,key,bytes
PemUtils -> private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)         throws GeneralSecurityException, IOException;1527622193;Decrypts the password protected contents using the algorithm and IV that is specified in the PEM Headers of the file__@param pemHeaders       The Proc-Type and DEK-Info PEM headers that have been extracted from the key file_@param keyContents      The key as a base64 encoded String_@param passwordSupplier A password supplier for the encrypted (password protected) key_@return the decrypted key bytes_@throws GeneralSecurityException if the key can't be decrypted_@throws IOException              if the PEM headers are missing or malformed;private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)_        throws GeneralSecurityException, IOException {_        byte[] keyBytes = Base64.getDecoder().decode(keyContents)__        String procType = pemHeaders.get("Proc-Type")__        if ("4,ENCRYPTED".equals(procType)) {_            _            String encryptionParameters = pemHeaders.get("DEK-Info")__            if (null == encryptionParameters) {_                _                throw new IOException("Malformed PEM File, DEK-Info header is missing")__            }_            char[] password = passwordSupplier.get()__            if (password == null) {_                throw new IOException("cannot read encrypted key without a password")__            }_            Cipher cipher = getCipherFromParameters(encryptionParameters, password)__            byte[] decryptedKeyBytes = cipher.doFinal(keyBytes)__            return decryptedKeyBytes__        }_        return keyBytes__    };decrypts,the,password,protected,contents,using,the,algorithm,and,iv,that,is,specified,in,the,pem,headers,of,the,file,param,pem,headers,the,proc,type,and,dek,info,pem,headers,that,have,been,extracted,from,the,key,file,param,key,contents,the,key,as,a,base64,encoded,string,param,password,supplier,a,password,supplier,for,the,encrypted,password,protected,key,return,the,decrypted,key,bytes,throws,general,security,exception,if,the,key,can,t,be,decrypted,throws,ioexception,if,the,pem,headers,are,missing,or,malformed;private,static,byte,possibly,decrypt,pkcs1key,map,string,string,pem,headers,string,key,contents,supplier,char,password,supplier,throws,general,security,exception,ioexception,byte,key,bytes,base64,get,decoder,decode,key,contents,string,proc,type,pem,headers,get,proc,type,if,4,encrypted,equals,proc,type,string,encryption,parameters,pem,headers,get,dek,info,if,null,encryption,parameters,throw,new,ioexception,malformed,pem,file,dek,info,header,is,missing,char,password,password,supplier,get,if,password,null,throw,new,ioexception,cannot,read,encrypted,key,without,a,password,cipher,cipher,get,cipher,from,parameters,encryption,parameters,password,byte,decrypted,key,bytes,cipher,do,final,key,bytes,return,decrypted,key,bytes,return,key,bytes
PemUtils -> private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)         throws GeneralSecurityException, IOException;1531179852;Decrypts the password protected contents using the algorithm and IV that is specified in the PEM Headers of the file__@param pemHeaders       The Proc-Type and DEK-Info PEM headers that have been extracted from the key file_@param keyContents      The key as a base64 encoded String_@param passwordSupplier A password supplier for the encrypted (password protected) key_@return the decrypted key bytes_@throws GeneralSecurityException if the key can't be decrypted_@throws IOException              if the PEM headers are missing or malformed;private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)_        throws GeneralSecurityException, IOException {_        byte[] keyBytes = Base64.getDecoder().decode(keyContents)__        String procType = pemHeaders.get("Proc-Type")__        if ("4,ENCRYPTED".equals(procType)) {_            _            String encryptionParameters = pemHeaders.get("DEK-Info")__            if (null == encryptionParameters) {_                _                throw new IOException("Malformed PEM File, DEK-Info header is missing")__            }_            char[] password = passwordSupplier.get()__            if (password == null) {_                throw new IOException("cannot read encrypted key without a password")__            }_            Cipher cipher = getCipherFromParameters(encryptionParameters, password)__            byte[] decryptedKeyBytes = cipher.doFinal(keyBytes)__            return decryptedKeyBytes__        }_        return keyBytes__    };decrypts,the,password,protected,contents,using,the,algorithm,and,iv,that,is,specified,in,the,pem,headers,of,the,file,param,pem,headers,the,proc,type,and,dek,info,pem,headers,that,have,been,extracted,from,the,key,file,param,key,contents,the,key,as,a,base64,encoded,string,param,password,supplier,a,password,supplier,for,the,encrypted,password,protected,key,return,the,decrypted,key,bytes,throws,general,security,exception,if,the,key,can,t,be,decrypted,throws,ioexception,if,the,pem,headers,are,missing,or,malformed;private,static,byte,possibly,decrypt,pkcs1key,map,string,string,pem,headers,string,key,contents,supplier,char,password,supplier,throws,general,security,exception,ioexception,byte,key,bytes,base64,get,decoder,decode,key,contents,string,proc,type,pem,headers,get,proc,type,if,4,encrypted,equals,proc,type,string,encryption,parameters,pem,headers,get,dek,info,if,null,encryption,parameters,throw,new,ioexception,malformed,pem,file,dek,info,header,is,missing,char,password,password,supplier,get,if,password,null,throw,new,ioexception,cannot,read,encrypted,key,without,a,password,cipher,cipher,get,cipher,from,parameters,encryption,parameters,password,byte,decrypted,key,bytes,cipher,do,final,key,bytes,return,decrypted,key,bytes,return,key,bytes
PemUtils -> private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)         throws GeneralSecurityException, IOException;1534434117;Decrypts the password protected contents using the algorithm and IV that is specified in the PEM Headers of the file__@param pemHeaders       The Proc-Type and DEK-Info PEM headers that have been extracted from the key file_@param keyContents      The key as a base64 encoded String_@param passwordSupplier A password supplier for the encrypted (password protected) key_@return the decrypted key bytes_@throws GeneralSecurityException if the key can't be decrypted_@throws IOException              if the PEM headers are missing or malformed;private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)_        throws GeneralSecurityException, IOException {_        byte[] keyBytes = Base64.getDecoder().decode(keyContents)__        String procType = pemHeaders.get("Proc-Type")__        if ("4,ENCRYPTED".equals(procType)) {_            _            String encryptionParameters = pemHeaders.get("DEK-Info")__            if (null == encryptionParameters) {_                _                throw new IOException("Malformed PEM File, DEK-Info header is missing")__            }_            char[] password = passwordSupplier.get()__            if (password == null) {_                throw new IOException("cannot read encrypted key without a password")__            }_            Cipher cipher = getCipherFromParameters(encryptionParameters, password)__            byte[] decryptedKeyBytes = cipher.doFinal(keyBytes)__            return decryptedKeyBytes__        }_        return keyBytes__    };decrypts,the,password,protected,contents,using,the,algorithm,and,iv,that,is,specified,in,the,pem,headers,of,the,file,param,pem,headers,the,proc,type,and,dek,info,pem,headers,that,have,been,extracted,from,the,key,file,param,key,contents,the,key,as,a,base64,encoded,string,param,password,supplier,a,password,supplier,for,the,encrypted,password,protected,key,return,the,decrypted,key,bytes,throws,general,security,exception,if,the,key,can,t,be,decrypted,throws,ioexception,if,the,pem,headers,are,missing,or,malformed;private,static,byte,possibly,decrypt,pkcs1key,map,string,string,pem,headers,string,key,contents,supplier,char,password,supplier,throws,general,security,exception,ioexception,byte,key,bytes,base64,get,decoder,decode,key,contents,string,proc,type,pem,headers,get,proc,type,if,4,encrypted,equals,proc,type,string,encryption,parameters,pem,headers,get,dek,info,if,null,encryption,parameters,throw,new,ioexception,malformed,pem,file,dek,info,header,is,missing,char,password,password,supplier,get,if,password,null,throw,new,ioexception,cannot,read,encrypted,key,without,a,password,cipher,cipher,get,cipher,from,parameters,encryption,parameters,password,byte,decrypted,key,bytes,cipher,do,final,key,bytes,return,decrypted,key,bytes,return,key,bytes
PemUtils -> private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)         throws GeneralSecurityException, IOException;1535552903;Decrypts the password protected contents using the algorithm and IV that is specified in the PEM Headers of the file__@param pemHeaders       The Proc-Type and DEK-Info PEM headers that have been extracted from the key file_@param keyContents      The key as a base64 encoded String_@param passwordSupplier A password supplier for the encrypted (password protected) key_@return the decrypted key bytes_@throws GeneralSecurityException if the key can't be decrypted_@throws IOException              if the PEM headers are missing or malformed;private static byte[] possiblyDecryptPKCS1Key(Map<String, String> pemHeaders, String keyContents, Supplier<char[]> passwordSupplier)_        throws GeneralSecurityException, IOException {_        byte[] keyBytes = Base64.getDecoder().decode(keyContents)__        String procType = pemHeaders.get("Proc-Type")__        if ("4,ENCRYPTED".equals(procType)) {_            _            String encryptionParameters = pemHeaders.get("DEK-Info")__            if (null == encryptionParameters) {_                _                throw new IOException("Malformed PEM File, DEK-Info header is missing")__            }_            char[] password = passwordSupplier.get()__            if (password == null) {_                throw new IOException("cannot read encrypted key without a password")__            }_            Cipher cipher = getCipherFromParameters(encryptionParameters, password)__            byte[] decryptedKeyBytes = cipher.doFinal(keyBytes)__            return decryptedKeyBytes__        }_        return keyBytes__    };decrypts,the,password,protected,contents,using,the,algorithm,and,iv,that,is,specified,in,the,pem,headers,of,the,file,param,pem,headers,the,proc,type,and,dek,info,pem,headers,that,have,been,extracted,from,the,key,file,param,key,contents,the,key,as,a,base64,encoded,string,param,password,supplier,a,password,supplier,for,the,encrypted,password,protected,key,return,the,decrypted,key,bytes,throws,general,security,exception,if,the,key,can,t,be,decrypted,throws,ioexception,if,the,pem,headers,are,missing,or,malformed;private,static,byte,possibly,decrypt,pkcs1key,map,string,string,pem,headers,string,key,contents,supplier,char,password,supplier,throws,general,security,exception,ioexception,byte,key,bytes,base64,get,decoder,decode,key,contents,string,proc,type,pem,headers,get,proc,type,if,4,encrypted,equals,proc,type,string,encryption,parameters,pem,headers,get,dek,info,if,null,encryption,parameters,throw,new,ioexception,malformed,pem,file,dek,info,header,is,missing,char,password,password,supplier,get,if,password,null,throw,new,ioexception,cannot,read,encrypted,key,without,a,password,cipher,cipher,get,cipher,from,parameters,encryption,parameters,password,byte,decrypted,key,bytes,cipher,do,final,key,bytes,return,decrypted,key,bytes,return,key,bytes
PemUtils -> private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws         GeneralSecurityException, IOException;1527622193;Creates a {@link Cipher} from the contents of the DEK-Info header of a PEM file. RFC 1421 indicates that supported algorithms are_defined in RFC 1423. RFC 1423 only defines DES-CBS and triple DES (EDE) in CBC mode. AES in CBC mode is also widely used though ( 3_different variants of 128, 192, 256 bit keys )__@param dekHeaderValue The value of the the DEK-Info PEM header_@param password       The password with which the key is encrypted_@return a cipher of the appropriate algorithm and parameters to be used for decryption_@throws GeneralSecurityException if the algorithm is not available in the used security provider, or if the key is inappropriate_for the cipher_@throws IOException if the DEK-Info PEM header is invalid;private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws_        GeneralSecurityException, IOException {_        String padding = "PKCS5Padding"__        SecretKey encryptionKey__        String[] valueTokens = dekHeaderValue.split(",")__        if (valueTokens.length != 2) {_            throw new IOException("Malformed PEM file, DEK-Info PEM header is invalid")__        }_        String algorithm = valueTokens[0]__        String ivString = valueTokens[1]__        byte[] iv = hexStringToByteArray(ivString)__        if ("DES-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 8)__            encryptionKey = new SecretKeySpec(key, "DES")__        } else if ("DES-EDE3-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "DESede")__        } else if ("AES-128-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 16)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-192-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-256-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 32)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else {_            throw new GeneralSecurityException("Private Key encrypted with unsupported algorithm: " + algorithm)__        }_        String transformation = encryptionKey.getAlgorithm() + "/" + "CBC" + "/" + padding__        Cipher cipher = Cipher.getInstance(transformation)__        cipher.init(Cipher.DECRYPT_MODE, encryptionKey, new IvParameterSpec(iv))__        return cipher__    };creates,a,link,cipher,from,the,contents,of,the,dek,info,header,of,a,pem,file,rfc,1421,indicates,that,supported,algorithms,are,defined,in,rfc,1423,rfc,1423,only,defines,des,cbs,and,triple,des,ede,in,cbc,mode,aes,in,cbc,mode,is,also,widely,used,though,3,different,variants,of,128,192,256,bit,keys,param,dek,header,value,the,value,of,the,the,dek,info,pem,header,param,password,the,password,with,which,the,key,is,encrypted,return,a,cipher,of,the,appropriate,algorithm,and,parameters,to,be,used,for,decryption,throws,general,security,exception,if,the,algorithm,is,not,available,in,the,used,security,provider,or,if,the,key,is,inappropriate,for,the,cipher,throws,ioexception,if,the,dek,info,pem,header,is,invalid;private,static,cipher,get,cipher,from,parameters,string,dek,header,value,char,password,throws,general,security,exception,ioexception,string,padding,pkcs5padding,secret,key,encryption,key,string,value,tokens,dek,header,value,split,if,value,tokens,length,2,throw,new,ioexception,malformed,pem,file,dek,info,pem,header,is,invalid,string,algorithm,value,tokens,0,string,iv,string,value,tokens,1,byte,iv,hex,string,to,byte,array,iv,string,if,des,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,8,encryption,key,new,secret,key,spec,key,des,else,if,des,ede3,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,desede,else,if,aes,128,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,16,encryption,key,new,secret,key,spec,key,aes,else,if,aes,192,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,aes,else,if,aes,256,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,32,encryption,key,new,secret,key,spec,key,aes,else,throw,new,general,security,exception,private,key,encrypted,with,unsupported,algorithm,algorithm,string,transformation,encryption,key,get,algorithm,cbc,padding,cipher,cipher,cipher,get,instance,transformation,cipher,init,cipher,encryption,key,new,iv,parameter,spec,iv,return,cipher
PemUtils -> private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws         GeneralSecurityException, IOException;1531179852;Creates a {@link Cipher} from the contents of the DEK-Info header of a PEM file. RFC 1421 indicates that supported algorithms are_defined in RFC 1423. RFC 1423 only defines DES-CBS and triple DES (EDE) in CBC mode. AES in CBC mode is also widely used though ( 3_different variants of 128, 192, 256 bit keys )__@param dekHeaderValue The value of the the DEK-Info PEM header_@param password       The password with which the key is encrypted_@return a cipher of the appropriate algorithm and parameters to be used for decryption_@throws GeneralSecurityException if the algorithm is not available in the used security provider, or if the key is inappropriate_for the cipher_@throws IOException if the DEK-Info PEM header is invalid;private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws_        GeneralSecurityException, IOException {_        String padding = "PKCS5Padding"__        SecretKey encryptionKey__        String[] valueTokens = dekHeaderValue.split(",")__        if (valueTokens.length != 2) {_            throw new IOException("Malformed PEM file, DEK-Info PEM header is invalid")__        }_        String algorithm = valueTokens[0]__        String ivString = valueTokens[1]__        byte[] iv = hexStringToByteArray(ivString)__        if ("DES-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 8)__            encryptionKey = new SecretKeySpec(key, "DES")__        } else if ("DES-EDE3-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "DESede")__        } else if ("AES-128-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 16)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-192-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-256-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 32)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else {_            throw new GeneralSecurityException("Private Key encrypted with unsupported algorithm: " + algorithm)__        }_        String transformation = encryptionKey.getAlgorithm() + "/" + "CBC" + "/" + padding__        Cipher cipher = Cipher.getInstance(transformation)__        cipher.init(Cipher.DECRYPT_MODE, encryptionKey, new IvParameterSpec(iv))__        return cipher__    };creates,a,link,cipher,from,the,contents,of,the,dek,info,header,of,a,pem,file,rfc,1421,indicates,that,supported,algorithms,are,defined,in,rfc,1423,rfc,1423,only,defines,des,cbs,and,triple,des,ede,in,cbc,mode,aes,in,cbc,mode,is,also,widely,used,though,3,different,variants,of,128,192,256,bit,keys,param,dek,header,value,the,value,of,the,the,dek,info,pem,header,param,password,the,password,with,which,the,key,is,encrypted,return,a,cipher,of,the,appropriate,algorithm,and,parameters,to,be,used,for,decryption,throws,general,security,exception,if,the,algorithm,is,not,available,in,the,used,security,provider,or,if,the,key,is,inappropriate,for,the,cipher,throws,ioexception,if,the,dek,info,pem,header,is,invalid;private,static,cipher,get,cipher,from,parameters,string,dek,header,value,char,password,throws,general,security,exception,ioexception,string,padding,pkcs5padding,secret,key,encryption,key,string,value,tokens,dek,header,value,split,if,value,tokens,length,2,throw,new,ioexception,malformed,pem,file,dek,info,pem,header,is,invalid,string,algorithm,value,tokens,0,string,iv,string,value,tokens,1,byte,iv,hex,string,to,byte,array,iv,string,if,des,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,8,encryption,key,new,secret,key,spec,key,des,else,if,des,ede3,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,desede,else,if,aes,128,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,16,encryption,key,new,secret,key,spec,key,aes,else,if,aes,192,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,aes,else,if,aes,256,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,32,encryption,key,new,secret,key,spec,key,aes,else,throw,new,general,security,exception,private,key,encrypted,with,unsupported,algorithm,algorithm,string,transformation,encryption,key,get,algorithm,cbc,padding,cipher,cipher,cipher,get,instance,transformation,cipher,init,cipher,encryption,key,new,iv,parameter,spec,iv,return,cipher
PemUtils -> private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws         GeneralSecurityException, IOException;1534434117;Creates a {@link Cipher} from the contents of the DEK-Info header of a PEM file. RFC 1421 indicates that supported algorithms are_defined in RFC 1423. RFC 1423 only defines DES-CBS and triple DES (EDE) in CBC mode. AES in CBC mode is also widely used though ( 3_different variants of 128, 192, 256 bit keys )__@param dekHeaderValue The value of the the DEK-Info PEM header_@param password       The password with which the key is encrypted_@return a cipher of the appropriate algorithm and parameters to be used for decryption_@throws GeneralSecurityException if the algorithm is not available in the used security provider, or if the key is inappropriate_for the cipher_@throws IOException if the DEK-Info PEM header is invalid;private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws_        GeneralSecurityException, IOException {_        String padding = "PKCS5Padding"__        SecretKey encryptionKey__        String[] valueTokens = dekHeaderValue.split(",")__        if (valueTokens.length != 2) {_            throw new IOException("Malformed PEM file, DEK-Info PEM header is invalid")__        }_        String algorithm = valueTokens[0]__        String ivString = valueTokens[1]__        byte[] iv = hexStringToByteArray(ivString)__        if ("DES-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 8)__            encryptionKey = new SecretKeySpec(key, "DES")__        } else if ("DES-EDE3-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "DESede")__        } else if ("AES-128-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 16)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-192-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-256-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 32)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else {_            throw new GeneralSecurityException("Private Key encrypted with unsupported algorithm: " + algorithm)__        }_        String transformation = encryptionKey.getAlgorithm() + "/" + "CBC" + "/" + padding__        Cipher cipher = Cipher.getInstance(transformation)__        cipher.init(Cipher.DECRYPT_MODE, encryptionKey, new IvParameterSpec(iv))__        return cipher__    };creates,a,link,cipher,from,the,contents,of,the,dek,info,header,of,a,pem,file,rfc,1421,indicates,that,supported,algorithms,are,defined,in,rfc,1423,rfc,1423,only,defines,des,cbs,and,triple,des,ede,in,cbc,mode,aes,in,cbc,mode,is,also,widely,used,though,3,different,variants,of,128,192,256,bit,keys,param,dek,header,value,the,value,of,the,the,dek,info,pem,header,param,password,the,password,with,which,the,key,is,encrypted,return,a,cipher,of,the,appropriate,algorithm,and,parameters,to,be,used,for,decryption,throws,general,security,exception,if,the,algorithm,is,not,available,in,the,used,security,provider,or,if,the,key,is,inappropriate,for,the,cipher,throws,ioexception,if,the,dek,info,pem,header,is,invalid;private,static,cipher,get,cipher,from,parameters,string,dek,header,value,char,password,throws,general,security,exception,ioexception,string,padding,pkcs5padding,secret,key,encryption,key,string,value,tokens,dek,header,value,split,if,value,tokens,length,2,throw,new,ioexception,malformed,pem,file,dek,info,pem,header,is,invalid,string,algorithm,value,tokens,0,string,iv,string,value,tokens,1,byte,iv,hex,string,to,byte,array,iv,string,if,des,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,8,encryption,key,new,secret,key,spec,key,des,else,if,des,ede3,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,desede,else,if,aes,128,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,16,encryption,key,new,secret,key,spec,key,aes,else,if,aes,192,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,aes,else,if,aes,256,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,32,encryption,key,new,secret,key,spec,key,aes,else,throw,new,general,security,exception,private,key,encrypted,with,unsupported,algorithm,algorithm,string,transformation,encryption,key,get,algorithm,cbc,padding,cipher,cipher,cipher,get,instance,transformation,cipher,init,cipher,encryption,key,new,iv,parameter,spec,iv,return,cipher
PemUtils -> private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws         GeneralSecurityException, IOException;1535552903;Creates a {@link Cipher} from the contents of the DEK-Info header of a PEM file. RFC 1421 indicates that supported algorithms are_defined in RFC 1423. RFC 1423 only defines DES-CBS and triple DES (EDE) in CBC mode. AES in CBC mode is also widely used though ( 3_different variants of 128, 192, 256 bit keys )__@param dekHeaderValue The value of the the DEK-Info PEM header_@param password       The password with which the key is encrypted_@return a cipher of the appropriate algorithm and parameters to be used for decryption_@throws GeneralSecurityException if the algorithm is not available in the used security provider, or if the key is inappropriate_for the cipher_@throws IOException if the DEK-Info PEM header is invalid;private static Cipher getCipherFromParameters(String dekHeaderValue, char[] password) throws_        GeneralSecurityException, IOException {_        String padding = "PKCS5Padding"__        SecretKey encryptionKey__        String[] valueTokens = dekHeaderValue.split(",")__        if (valueTokens.length != 2) {_            throw new IOException("Malformed PEM file, DEK-Info PEM header is invalid")__        }_        String algorithm = valueTokens[0]__        String ivString = valueTokens[1]__        byte[] iv = hexStringToByteArray(ivString)__        if ("DES-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 8)__            encryptionKey = new SecretKeySpec(key, "DES")__        } else if ("DES-EDE3-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "DESede")__        } else if ("AES-128-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 16)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-192-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 24)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else if ("AES-256-CBC".equals(algorithm)) {_            byte[] key = generateOpenSslKey(password, iv, 32)__            encryptionKey = new SecretKeySpec(key, "AES")__        } else {_            throw new GeneralSecurityException("Private Key encrypted with unsupported algorithm: " + algorithm)__        }_        String transformation = encryptionKey.getAlgorithm() + "/" + "CBC" + "/" + padding__        Cipher cipher = Cipher.getInstance(transformation)__        cipher.init(Cipher.DECRYPT_MODE, encryptionKey, new IvParameterSpec(iv))__        return cipher__    };creates,a,link,cipher,from,the,contents,of,the,dek,info,header,of,a,pem,file,rfc,1421,indicates,that,supported,algorithms,are,defined,in,rfc,1423,rfc,1423,only,defines,des,cbs,and,triple,des,ede,in,cbc,mode,aes,in,cbc,mode,is,also,widely,used,though,3,different,variants,of,128,192,256,bit,keys,param,dek,header,value,the,value,of,the,the,dek,info,pem,header,param,password,the,password,with,which,the,key,is,encrypted,return,a,cipher,of,the,appropriate,algorithm,and,parameters,to,be,used,for,decryption,throws,general,security,exception,if,the,algorithm,is,not,available,in,the,used,security,provider,or,if,the,key,is,inappropriate,for,the,cipher,throws,ioexception,if,the,dek,info,pem,header,is,invalid;private,static,cipher,get,cipher,from,parameters,string,dek,header,value,char,password,throws,general,security,exception,ioexception,string,padding,pkcs5padding,secret,key,encryption,key,string,value,tokens,dek,header,value,split,if,value,tokens,length,2,throw,new,ioexception,malformed,pem,file,dek,info,pem,header,is,invalid,string,algorithm,value,tokens,0,string,iv,string,value,tokens,1,byte,iv,hex,string,to,byte,array,iv,string,if,des,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,8,encryption,key,new,secret,key,spec,key,des,else,if,des,ede3,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,desede,else,if,aes,128,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,16,encryption,key,new,secret,key,spec,key,aes,else,if,aes,192,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,24,encryption,key,new,secret,key,spec,key,aes,else,if,aes,256,cbc,equals,algorithm,byte,key,generate,open,ssl,key,password,iv,32,encryption,key,new,secret,key,spec,key,aes,else,throw,new,general,security,exception,private,key,encrypted,with,unsupported,algorithm,algorithm,string,transformation,encryption,key,get,algorithm,cbc,padding,cipher,cipher,cipher,get,instance,transformation,cipher,init,cipher,encryption,key,new,iv,parameter,spec,iv,return,cipher
PemUtils -> private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength);1527622193;Performs key stretching in the same manner that OpenSSL does. This is basically a KDF_that uses n rounds of salted MD5 (as many times as needed to get the necessary number of key bytes)_<p>_https://www.openssl.org/docs/man1.1.0/crypto/PEM_write_bio_PrivateKey_traditional.html;private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength) {_        byte[] passwordBytes = CharArrays.toUtf8Bytes(password)__        MessageDigest md5 = MessageDigests.md5()__        byte[] key = new byte[keyLength]__        int copied = 0__        int remaining__        while (copied < keyLength) {_            remaining = keyLength - copied__            md5.update(passwordBytes, 0, passwordBytes.length)__            md5.update(salt, 0, 8)__            byte[] tempDigest = md5.digest()__            int bytesToCopy = (remaining > 16) ? 16 : remaining_ _            System.arraycopy(tempDigest, 0, key, copied, bytesToCopy)__            copied += bytesToCopy__            if (remaining == 0) {_                break__            }_            md5.update(tempDigest, 0, 16)_ _        }_        Arrays.fill(passwordBytes, (byte) 0)__        return key__    };performs,key,stretching,in,the,same,manner,that,open,ssl,does,this,is,basically,a,kdf,that,uses,n,rounds,of,salted,md5,as,many,times,as,needed,to,get,the,necessary,number,of,key,bytes,p,https,www,openssl,org,docs,man1,1,0,crypto,html;private,static,byte,generate,open,ssl,key,char,password,byte,salt,int,key,length,byte,password,bytes,char,arrays,to,utf8bytes,password,message,digest,md5,message,digests,md5,byte,key,new,byte,key,length,int,copied,0,int,remaining,while,copied,key,length,remaining,key,length,copied,md5,update,password,bytes,0,password,bytes,length,md5,update,salt,0,8,byte,temp,digest,md5,digest,int,bytes,to,copy,remaining,16,16,remaining,system,arraycopy,temp,digest,0,key,copied,bytes,to,copy,copied,bytes,to,copy,if,remaining,0,break,md5,update,temp,digest,0,16,arrays,fill,password,bytes,byte,0,return,key
PemUtils -> private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength);1531179852;Performs key stretching in the same manner that OpenSSL does. This is basically a KDF_that uses n rounds of salted MD5 (as many times as needed to get the necessary number of key bytes)_<p>_https://www.openssl.org/docs/man1.1.0/crypto/PEM_write_bio_PrivateKey_traditional.html;private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength) {_        byte[] passwordBytes = CharArrays.toUtf8Bytes(password)__        MessageDigest md5 = MessageDigests.md5()__        byte[] key = new byte[keyLength]__        int copied = 0__        int remaining__        while (copied < keyLength) {_            remaining = keyLength - copied__            md5.update(passwordBytes, 0, passwordBytes.length)__            md5.update(salt, 0, 8)__            byte[] tempDigest = md5.digest()__            int bytesToCopy = (remaining > 16) ? 16 : remaining_ _            System.arraycopy(tempDigest, 0, key, copied, bytesToCopy)__            copied += bytesToCopy__            if (remaining == 0) {_                break__            }_            md5.update(tempDigest, 0, 16)_ _        }_        Arrays.fill(passwordBytes, (byte) 0)__        return key__    };performs,key,stretching,in,the,same,manner,that,open,ssl,does,this,is,basically,a,kdf,that,uses,n,rounds,of,salted,md5,as,many,times,as,needed,to,get,the,necessary,number,of,key,bytes,p,https,www,openssl,org,docs,man1,1,0,crypto,html;private,static,byte,generate,open,ssl,key,char,password,byte,salt,int,key,length,byte,password,bytes,char,arrays,to,utf8bytes,password,message,digest,md5,message,digests,md5,byte,key,new,byte,key,length,int,copied,0,int,remaining,while,copied,key,length,remaining,key,length,copied,md5,update,password,bytes,0,password,bytes,length,md5,update,salt,0,8,byte,temp,digest,md5,digest,int,bytes,to,copy,remaining,16,16,remaining,system,arraycopy,temp,digest,0,key,copied,bytes,to,copy,copied,bytes,to,copy,if,remaining,0,break,md5,update,temp,digest,0,16,arrays,fill,password,bytes,byte,0,return,key
PemUtils -> private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength);1534434117;Performs key stretching in the same manner that OpenSSL does. This is basically a KDF_that uses n rounds of salted MD5 (as many times as needed to get the necessary number of key bytes)_<p>_https://www.openssl.org/docs/man1.1.0/crypto/PEM_write_bio_PrivateKey_traditional.html;private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength) {_        byte[] passwordBytes = CharArrays.toUtf8Bytes(password)__        MessageDigest md5 = MessageDigests.md5()__        byte[] key = new byte[keyLength]__        int copied = 0__        int remaining__        while (copied < keyLength) {_            remaining = keyLength - copied__            md5.update(passwordBytes, 0, passwordBytes.length)__            md5.update(salt, 0, 8)__            byte[] tempDigest = md5.digest()__            int bytesToCopy = (remaining > 16) ? 16 : remaining_ _            System.arraycopy(tempDigest, 0, key, copied, bytesToCopy)__            copied += bytesToCopy__            if (remaining == 0) {_                break__            }_            md5.update(tempDigest, 0, 16)_ _        }_        Arrays.fill(passwordBytes, (byte) 0)__        return key__    };performs,key,stretching,in,the,same,manner,that,open,ssl,does,this,is,basically,a,kdf,that,uses,n,rounds,of,salted,md5,as,many,times,as,needed,to,get,the,necessary,number,of,key,bytes,p,https,www,openssl,org,docs,man1,1,0,crypto,html;private,static,byte,generate,open,ssl,key,char,password,byte,salt,int,key,length,byte,password,bytes,char,arrays,to,utf8bytes,password,message,digest,md5,message,digests,md5,byte,key,new,byte,key,length,int,copied,0,int,remaining,while,copied,key,length,remaining,key,length,copied,md5,update,password,bytes,0,password,bytes,length,md5,update,salt,0,8,byte,temp,digest,md5,digest,int,bytes,to,copy,remaining,16,16,remaining,system,arraycopy,temp,digest,0,key,copied,bytes,to,copy,copied,bytes,to,copy,if,remaining,0,break,md5,update,temp,digest,0,16,arrays,fill,password,bytes,byte,0,return,key
PemUtils -> private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength);1535552903;Performs key stretching in the same manner that OpenSSL does. This is basically a KDF_that uses n rounds of salted MD5 (as many times as needed to get the necessary number of key bytes)_<p>_https://www.openssl.org/docs/man1.1.0/crypto/PEM_write_bio_PrivateKey_traditional.html;private static byte[] generateOpenSslKey(char[] password, byte[] salt, int keyLength) {_        byte[] passwordBytes = CharArrays.toUtf8Bytes(password)__        MessageDigest md5 = MessageDigests.md5()__        byte[] key = new byte[keyLength]__        int copied = 0__        int remaining__        while (copied < keyLength) {_            remaining = keyLength - copied__            md5.update(passwordBytes, 0, passwordBytes.length)__            md5.update(salt, 0, 8)__            byte[] tempDigest = md5.digest()__            int bytesToCopy = (remaining > 16) ? 16 : remaining_ _            System.arraycopy(tempDigest, 0, key, copied, bytesToCopy)__            copied += bytesToCopy__            if (remaining == 0) {_                break__            }_            md5.update(tempDigest, 0, 16)_ _        }_        Arrays.fill(passwordBytes, (byte) 0)__        return key__    };performs,key,stretching,in,the,same,manner,that,open,ssl,does,this,is,basically,a,kdf,that,uses,n,rounds,of,salted,md5,as,many,times,as,needed,to,get,the,necessary,number,of,key,bytes,p,https,www,openssl,org,docs,man1,1,0,crypto,html;private,static,byte,generate,open,ssl,key,char,password,byte,salt,int,key,length,byte,password,bytes,char,arrays,to,utf8bytes,password,message,digest,md5,message,digests,md5,byte,key,new,byte,key,length,int,copied,0,int,remaining,while,copied,key,length,remaining,key,length,copied,md5,update,password,bytes,0,password,bytes,length,md5,update,salt,0,8,byte,temp,digest,md5,digest,int,bytes,to,copy,remaining,16,16,remaining,system,arraycopy,temp,digest,0,key,copied,bytes,to,copy,copied,bytes,to,copy,if,remaining,0,break,md5,update,temp,digest,0,16,arrays,fill,password,bytes,byte,0,return,key
PemUtils -> private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException;1527622193;Parses a DER encoded private key and reads its algorithm identifier Object OID.__@param keyBytes the private key raw bytes_@return A string identifier for the key algorithm (RSA, DSA, or EC)_@throws GeneralSecurityException if the algorithm oid that is parsed from ASN.1 is unknown_@throws IOException if the DER encoded key can't be parsed;private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        DerParser.Asn1Object algSequence = parser.readAsn1Object()__        parser = algSequence.getParser()__        String oidString = parser.readAsn1Object().getOid()__        switch (oidString) {_            case "1.2.840.10040.4.1":_                return "DSA"__            case "1.2.840.113549.1.1.1":_                return "RSA"__            case "1.2.840.10045.2.1":_                return "EC"__        }_        throw new GeneralSecurityException("Error parsing key algorithm identifier. Algorithm with OID: "+oidString+ " is not " +_            "supported")__    };parses,a,der,encoded,private,key,and,reads,its,algorithm,identifier,object,oid,param,key,bytes,the,private,key,raw,bytes,return,a,string,identifier,for,the,key,algorithm,rsa,dsa,or,ec,throws,general,security,exception,if,the,algorithm,oid,that,is,parsed,from,asn,1,is,unknown,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,string,get,key,algorithm,identifier,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,der,parser,asn1object,alg,sequence,parser,read,asn1object,parser,alg,sequence,get,parser,string,oid,string,parser,read,asn1object,get,oid,switch,oid,string,case,1,2,840,10040,4,1,return,dsa,case,1,2,840,113549,1,1,1,return,rsa,case,1,2,840,10045,2,1,return,ec,throw,new,general,security,exception,error,parsing,key,algorithm,identifier,algorithm,with,oid,oid,string,is,not,supported
PemUtils -> private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException;1531179852;Parses a DER encoded private key and reads its algorithm identifier Object OID.__@param keyBytes the private key raw bytes_@return A string identifier for the key algorithm (RSA, DSA, or EC)_@throws GeneralSecurityException if the algorithm oid that is parsed from ASN.1 is unknown_@throws IOException if the DER encoded key can't be parsed;private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        DerParser.Asn1Object algSequence = parser.readAsn1Object()__        parser = algSequence.getParser()__        String oidString = parser.readAsn1Object().getOid()__        switch (oidString) {_            case "1.2.840.10040.4.1":_                return "DSA"__            case "1.2.840.113549.1.1.1":_                return "RSA"__            case "1.2.840.10045.2.1":_                return "EC"__        }_        throw new GeneralSecurityException("Error parsing key algorithm identifier. Algorithm with OID: "+oidString+ " is not " +_            "supported")__    };parses,a,der,encoded,private,key,and,reads,its,algorithm,identifier,object,oid,param,key,bytes,the,private,key,raw,bytes,return,a,string,identifier,for,the,key,algorithm,rsa,dsa,or,ec,throws,general,security,exception,if,the,algorithm,oid,that,is,parsed,from,asn,1,is,unknown,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,string,get,key,algorithm,identifier,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,der,parser,asn1object,alg,sequence,parser,read,asn1object,parser,alg,sequence,get,parser,string,oid,string,parser,read,asn1object,get,oid,switch,oid,string,case,1,2,840,10040,4,1,return,dsa,case,1,2,840,113549,1,1,1,return,rsa,case,1,2,840,10045,2,1,return,ec,throw,new,general,security,exception,error,parsing,key,algorithm,identifier,algorithm,with,oid,oid,string,is,not,supported
PemUtils -> private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException;1534434117;Parses a DER encoded private key and reads its algorithm identifier Object OID.__@param keyBytes the private key raw bytes_@return A string identifier for the key algorithm (RSA, DSA, or EC)_@throws GeneralSecurityException if the algorithm oid that is parsed from ASN.1 is unknown_@throws IOException if the DER encoded key can't be parsed;private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        DerParser.Asn1Object algSequence = parser.readAsn1Object()__        parser = algSequence.getParser()__        String oidString = parser.readAsn1Object().getOid()__        switch (oidString) {_            case "1.2.840.10040.4.1":_                return "DSA"__            case "1.2.840.113549.1.1.1":_                return "RSA"__            case "1.2.840.10045.2.1":_                return "EC"__        }_        throw new GeneralSecurityException("Error parsing key algorithm identifier. Algorithm with OID: "+oidString+ " is not " +_            "supported")__    };parses,a,der,encoded,private,key,and,reads,its,algorithm,identifier,object,oid,param,key,bytes,the,private,key,raw,bytes,return,a,string,identifier,for,the,key,algorithm,rsa,dsa,or,ec,throws,general,security,exception,if,the,algorithm,oid,that,is,parsed,from,asn,1,is,unknown,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,string,get,key,algorithm,identifier,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,der,parser,asn1object,alg,sequence,parser,read,asn1object,parser,alg,sequence,get,parser,string,oid,string,parser,read,asn1object,get,oid,switch,oid,string,case,1,2,840,10040,4,1,return,dsa,case,1,2,840,113549,1,1,1,return,rsa,case,1,2,840,10045,2,1,return,ec,throw,new,general,security,exception,error,parsing,key,algorithm,identifier,algorithm,with,oid,oid,string,is,not,supported
PemUtils -> private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException;1535552903;Parses a DER encoded private key and reads its algorithm identifier Object OID.__@param keyBytes the private key raw bytes_@return A string identifier for the key algorithm (RSA, DSA, or EC)_@throws GeneralSecurityException if the algorithm oid that is parsed from ASN.1 is unknown_@throws IOException if the DER encoded key can't be parsed;private static String getKeyAlgorithmIdentifier(byte[] keyBytes) throws IOException, GeneralSecurityException {_        DerParser parser = new DerParser(keyBytes)__        DerParser.Asn1Object sequence = parser.readAsn1Object()__        parser = sequence.getParser()__        parser.readAsn1Object().getInteger()_ _        DerParser.Asn1Object algSequence = parser.readAsn1Object()__        parser = algSequence.getParser()__        String oidString = parser.readAsn1Object().getOid()__        switch (oidString) {_            case "1.2.840.10040.4.1":_                return "DSA"__            case "1.2.840.113549.1.1.1":_                return "RSA"__            case "1.2.840.10045.2.1":_                return "EC"__        }_        throw new GeneralSecurityException("Error parsing key algorithm identifier. Algorithm with OID: "+oidString+ " is not " +_            "supported")__    };parses,a,der,encoded,private,key,and,reads,its,algorithm,identifier,object,oid,param,key,bytes,the,private,key,raw,bytes,return,a,string,identifier,for,the,key,algorithm,rsa,dsa,or,ec,throws,general,security,exception,if,the,algorithm,oid,that,is,parsed,from,asn,1,is,unknown,throws,ioexception,if,the,der,encoded,key,can,t,be,parsed;private,static,string,get,key,algorithm,identifier,byte,key,bytes,throws,ioexception,general,security,exception,der,parser,parser,new,der,parser,key,bytes,der,parser,asn1object,sequence,parser,read,asn1object,parser,sequence,get,parser,parser,read,asn1object,get,integer,der,parser,asn1object,alg,sequence,parser,read,asn1object,parser,alg,sequence,get,parser,string,oid,string,parser,read,asn1object,get,oid,switch,oid,string,case,1,2,840,10040,4,1,return,dsa,case,1,2,840,113549,1,1,1,return,rsa,case,1,2,840,10045,2,1,return,ec,throw,new,general,security,exception,error,parsing,key,algorithm,identifier,algorithm,with,oid,oid,string,is,not,supported
PemUtils -> public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier);1527622193;Creates a {@link PrivateKey} from the contents of a file. Supports PKCS#1, PKCS#8_encoded formats of encrypted and plaintext RSA, DSA and EC(secp256r1) keys__@param keyPath           the path for the key file_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return a private key from the contents of the file;public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier) {_        try (BufferedReader bReader = Files.newBufferedReader(keyPath, StandardCharsets.UTF_8)) {_            String line = bReader.readLine()__            if (null == line) {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File is empty")__            }_            if (PKCS8_ENCRYPTED_HEADER.equals(line.trim())) {_                char[] password = passwordSupplier.get()__                if (password == null) {_                    throw new IllegalArgumentException("cannot read encrypted key without a password")__                }_                return parsePKCS8Encrypted(bReader, password)__            } else if (PKCS8_HEADER.equals(line.trim())) {_                return parsePKCS8(bReader)__            } else if (PKCS1_HEADER.equals(line.trim())) {_                return parsePKCS1Rsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(removeDsaHeaders(bReader), passwordSupplier)__            } else if (OPENSSL_EC_HEADER.equals(line.trim())) {_                return parseOpenSslEC(bReader, passwordSupplier)__            } else if (OPENSSL_EC_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslEC(removeECHeaders(bReader), passwordSupplier)__            } else {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File did not contain a " +_                        "supported key format")__            }_        } catch (IOException | GeneralSecurityException e) {_            throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString(), e)__        }_    };creates,a,link,private,key,from,the,contents,of,a,file,supports,pkcs,1,pkcs,8,encoded,formats,of,encrypted,and,plaintext,rsa,dsa,and,ec,secp256r1,keys,param,key,path,the,path,for,the,key,file,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,a,private,key,from,the,contents,of,the,file;public,static,private,key,read,private,key,path,key,path,supplier,char,password,supplier,try,buffered,reader,b,reader,files,new,buffered,reader,key,path,standard,charsets,string,line,b,reader,read,line,if,null,line,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,is,empty,if,equals,line,trim,char,password,password,supplier,get,if,password,null,throw,new,illegal,argument,exception,cannot,read,encrypted,key,without,a,password,return,parse,pkcs8encrypted,b,reader,password,else,if,equals,line,trim,return,parse,pkcs8,b,reader,else,if,equals,line,trim,return,parse,pkcs1rsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,remove,dsa,headers,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,remove,echeaders,b,reader,password,supplier,else,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,did,not,contain,a,supported,key,format,catch,ioexception,general,security,exception,e,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,e
PemUtils -> public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier);1531179852;Creates a {@link PrivateKey} from the contents of a file. Supports PKCS#1, PKCS#8_encoded formats of encrypted and plaintext RSA, DSA and EC(secp256r1) keys__@param keyPath           the path for the key file_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return a private key from the contents of the file;public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier) {_        try (BufferedReader bReader = Files.newBufferedReader(keyPath, StandardCharsets.UTF_8)) {_            String line = bReader.readLine()__            if (null == line) {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File is empty")__            }_            if (PKCS8_ENCRYPTED_HEADER.equals(line.trim())) {_                char[] password = passwordSupplier.get()__                if (password == null) {_                    throw new IllegalArgumentException("cannot read encrypted key without a password")__                }_                return parsePKCS8Encrypted(bReader, password)__            } else if (PKCS8_HEADER.equals(line.trim())) {_                return parsePKCS8(bReader)__            } else if (PKCS1_HEADER.equals(line.trim())) {_                return parsePKCS1Rsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(removeDsaHeaders(bReader), passwordSupplier)__            } else if (OPENSSL_EC_HEADER.equals(line.trim())) {_                return parseOpenSslEC(bReader, passwordSupplier)__            } else if (OPENSSL_EC_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslEC(removeECHeaders(bReader), passwordSupplier)__            } else {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File did not contain a " +_                        "supported key format")__            }_        } catch (IOException | GeneralSecurityException e) {_            throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString(), e)__        }_    };creates,a,link,private,key,from,the,contents,of,a,file,supports,pkcs,1,pkcs,8,encoded,formats,of,encrypted,and,plaintext,rsa,dsa,and,ec,secp256r1,keys,param,key,path,the,path,for,the,key,file,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,a,private,key,from,the,contents,of,the,file;public,static,private,key,read,private,key,path,key,path,supplier,char,password,supplier,try,buffered,reader,b,reader,files,new,buffered,reader,key,path,standard,charsets,string,line,b,reader,read,line,if,null,line,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,is,empty,if,equals,line,trim,char,password,password,supplier,get,if,password,null,throw,new,illegal,argument,exception,cannot,read,encrypted,key,without,a,password,return,parse,pkcs8encrypted,b,reader,password,else,if,equals,line,trim,return,parse,pkcs8,b,reader,else,if,equals,line,trim,return,parse,pkcs1rsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,remove,dsa,headers,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,remove,echeaders,b,reader,password,supplier,else,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,did,not,contain,a,supported,key,format,catch,ioexception,general,security,exception,e,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,e
PemUtils -> public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier);1534434117;Creates a {@link PrivateKey} from the contents of a file. Supports PKCS#1, PKCS#8_encoded formats of encrypted and plaintext RSA, DSA and EC(secp256r1) keys__@param keyPath           the path for the key file_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return a private key from the contents of the file;public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier) {_        try (BufferedReader bReader = Files.newBufferedReader(keyPath, StandardCharsets.UTF_8)) {_            String line = bReader.readLine()__            if (null == line) {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File is empty")__            }_            if (PKCS8_ENCRYPTED_HEADER.equals(line.trim())) {_                char[] password = passwordSupplier.get()__                if (password == null) {_                    throw new IllegalArgumentException("cannot read encrypted key without a password")__                }_                return parsePKCS8Encrypted(bReader, password)__            } else if (PKCS8_HEADER.equals(line.trim())) {_                return parsePKCS8(bReader)__            } else if (PKCS1_HEADER.equals(line.trim())) {_                return parsePKCS1Rsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(removeDsaHeaders(bReader), passwordSupplier)__            } else if (OPENSSL_EC_HEADER.equals(line.trim())) {_                return parseOpenSslEC(bReader, passwordSupplier)__            } else if (OPENSSL_EC_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslEC(removeECHeaders(bReader), passwordSupplier)__            } else {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File did not contain a " +_                        "supported key format")__            }_        } catch (IOException | GeneralSecurityException e) {_            throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString(), e)__        }_    };creates,a,link,private,key,from,the,contents,of,a,file,supports,pkcs,1,pkcs,8,encoded,formats,of,encrypted,and,plaintext,rsa,dsa,and,ec,secp256r1,keys,param,key,path,the,path,for,the,key,file,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,a,private,key,from,the,contents,of,the,file;public,static,private,key,read,private,key,path,key,path,supplier,char,password,supplier,try,buffered,reader,b,reader,files,new,buffered,reader,key,path,standard,charsets,string,line,b,reader,read,line,if,null,line,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,is,empty,if,equals,line,trim,char,password,password,supplier,get,if,password,null,throw,new,illegal,argument,exception,cannot,read,encrypted,key,without,a,password,return,parse,pkcs8encrypted,b,reader,password,else,if,equals,line,trim,return,parse,pkcs8,b,reader,else,if,equals,line,trim,return,parse,pkcs1rsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,remove,dsa,headers,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,remove,echeaders,b,reader,password,supplier,else,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,did,not,contain,a,supported,key,format,catch,ioexception,general,security,exception,e,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,e
PemUtils -> public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier);1535552903;Creates a {@link PrivateKey} from the contents of a file. Supports PKCS#1, PKCS#8_encoded formats of encrypted and plaintext RSA, DSA and EC(secp256r1) keys__@param keyPath           the path for the key file_@param passwordSupplier A password supplier for the potentially encrypted (password protected) key_@return a private key from the contents of the file;public static PrivateKey readPrivateKey(Path keyPath, Supplier<char[]> passwordSupplier) {_        try (BufferedReader bReader = Files.newBufferedReader(keyPath, StandardCharsets.UTF_8)) {_            String line = bReader.readLine()__            while (null != line && line.startsWith(HEADER) == false){_                line = bReader.readLine()__            }_            if (null == line) {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File is empty")__            }_            if (PKCS8_ENCRYPTED_HEADER.equals(line.trim())) {_                char[] password = passwordSupplier.get()__                if (password == null) {_                    throw new IllegalArgumentException("cannot read encrypted key without a password")__                }_                return parsePKCS8Encrypted(bReader, password)__            } else if (PKCS8_HEADER.equals(line.trim())) {_                return parsePKCS8(bReader)__            } else if (PKCS1_HEADER.equals(line.trim())) {_                return parsePKCS1Rsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(bReader, passwordSupplier)__            } else if (OPENSSL_DSA_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslDsa(removeDsaHeaders(bReader), passwordSupplier)__            } else if (OPENSSL_EC_HEADER.equals(line.trim())) {_                return parseOpenSslEC(bReader, passwordSupplier)__            } else if (OPENSSL_EC_PARAMS_HEADER.equals(line.trim())) {_                return parseOpenSslEC(removeECHeaders(bReader), passwordSupplier)__            } else {_                throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString() + ". File did not contain a " +_                        "supported key format")__            }_        } catch (IOException | GeneralSecurityException e) {_            throw new IllegalStateException("Error parsing Private Key from: " + keyPath.toString(), e)__        }_    };creates,a,link,private,key,from,the,contents,of,a,file,supports,pkcs,1,pkcs,8,encoded,formats,of,encrypted,and,plaintext,rsa,dsa,and,ec,secp256r1,keys,param,key,path,the,path,for,the,key,file,param,password,supplier,a,password,supplier,for,the,potentially,encrypted,password,protected,key,return,a,private,key,from,the,contents,of,the,file;public,static,private,key,read,private,key,path,key,path,supplier,char,password,supplier,try,buffered,reader,b,reader,files,new,buffered,reader,key,path,standard,charsets,string,line,b,reader,read,line,while,null,line,line,starts,with,header,false,line,b,reader,read,line,if,null,line,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,is,empty,if,equals,line,trim,char,password,password,supplier,get,if,password,null,throw,new,illegal,argument,exception,cannot,read,encrypted,key,without,a,password,return,parse,pkcs8encrypted,b,reader,password,else,if,equals,line,trim,return,parse,pkcs8,b,reader,else,if,equals,line,trim,return,parse,pkcs1rsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,dsa,remove,dsa,headers,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,b,reader,password,supplier,else,if,equals,line,trim,return,parse,open,ssl,ec,remove,echeaders,b,reader,password,supplier,else,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,file,did,not,contain,a,supported,key,format,catch,ioexception,general,security,exception,e,throw,new,illegal,state,exception,error,parsing,private,key,from,key,path,to,string,e
