commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;3;5;;@Override protected void doExecute(Task task, FreezeRequest request, ActionListener<FreezeResponse> listener) {     destructiveOperations.failDestructive(request.indices()).     super.doExecute(task, request, listener). }
false;protected;0;4;;@Override protected FreezeResponse newResponse() {     return new FreezeResponse(). }
false;private;2;18;;private Index[] resolveIndices(FreezeRequest request, ClusterState state) {     List<Index> indices = new ArrayList<>().     for (Index index : indexNameExpressionResolver.concreteIndices(state, request)) {         IndexMetaData metaData = state.metaData().index(index).         Settings settings = metaData.getSettings().         // go through the cycles again.         if ((request.freeze() && FrozenEngine.INDEX_FROZEN.get(settings) == false) || (request.freeze() == false && FrozenEngine.INDEX_FROZEN.get(settings))) {             indices.add(index).         }     }     if (indices.isEmpty() && request.indicesOptions().allowNoIndices() == false) {         throw new ResourceNotFoundException("no index found to " + (request.freeze() ? "freeze" : "unfreeze")).     }     return indices.toArray(Index.EMPTY_ARRAY). }
false;protected;3;4;;@Override protected void masterOperation(FreezeRequest request, ClusterState state, ActionListener<FreezeResponse> listener) {     throw new UnsupportedOperationException("The task parameter is required"). }
false;public;1;9;;@Override public void onResponse(final CloseIndexResponse response) {     if (response.isAcknowledged()) {         toggleFrozenSettings(concreteIndices, request, listener).     } else {         // TODO improve FreezeResponse so that it also reports failures from the close index API         listener.onResponse(new FreezeResponse(false, false)).     } }
false;public;1;5;;@Override public void onFailure(final Exception t) {     logger.debug(() -> new ParameterizedMessage("failed to close indices [{}]", (Object) concreteIndices), t).     listener.onFailure(t). }
false;protected;4;32;;@Override protected void masterOperation(Task task, TransportFreezeIndexAction.FreezeRequest request, ClusterState state, ActionListener<TransportFreezeIndexAction.FreezeResponse> listener) throws Exception {     final Index[] concreteIndices = resolveIndices(request, state).     if (concreteIndices.length == 0) {         listener.onResponse(new FreezeResponse(true, true)).         return.     }     final CloseIndexClusterStateUpdateRequest closeRequest = new CloseIndexClusterStateUpdateRequest(task.getId()).ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()).indices(concreteIndices).     indexStateService.closeIndices(closeRequest, new ActionListener<CloseIndexResponse>() {          @Override         public void onResponse(final CloseIndexResponse response) {             if (response.isAcknowledged()) {                 toggleFrozenSettings(concreteIndices, request, listener).             } else {                 // TODO improve FreezeResponse so that it also reports failures from the close index API                 listener.onResponse(new FreezeResponse(false, false)).             }         }          @Override         public void onFailure(final Exception t) {             logger.debug(() -> new ParameterizedMessage("failed to close indices [{}]", (Object) concreteIndices), t).             listener.onFailure(t).         }     }). }
false;public;1;28;;@Override public ClusterState execute(ClusterState currentState) {     final MetaData.Builder builder = MetaData.builder(currentState.metaData()).     ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).     for (Index index : concreteIndices) {         IndexMetaData meta = currentState.metaData().getIndexSafe(index).         if (meta.getState() != IndexMetaData.State.CLOSE) {             throw new IllegalStateException("index [" + index.getName() + "] is not closed").         }         final IndexMetaData.Builder imdBuilder = IndexMetaData.builder(meta).         imdBuilder.settingsVersion(meta.getSettingsVersion() + 1).         final Settings.Builder settingsBuilder = Settings.builder().put(currentState.metaData().index(index).getSettings()).put(FrozenEngine.INDEX_FROZEN.getKey(), request.freeze()).put(IndexSettings.INDEX_SEARCH_THROTTLED.getKey(), request.freeze()).         if (request.freeze()) {             settingsBuilder.put("index.blocks.write", true).             blocks.addIndexBlock(index.getName(), IndexMetaData.INDEX_WRITE_BLOCK).         } else {             settingsBuilder.remove("index.blocks.write").             blocks.removeIndexBlock(index.getName(), IndexMetaData.INDEX_WRITE_BLOCK).         }         imdBuilder.settings(settingsBuilder).         builder.put(imdBuilder.build(), true).     }     return ClusterState.builder(currentState).blocks(blocks).metaData(builder).build(). }
false;protected;1;4;;@Override protected AcknowledgedResponse newResponse(boolean acknowledged) {     return new AcknowledgedResponse(acknowledged). }
false;public;1;5;;@Override public void onResponse(OpenIndexClusterStateUpdateResponse openIndexClusterStateUpdateResponse) {     listener.onResponse(new FreezeResponse(openIndexClusterStateUpdateResponse.isAcknowledged(), openIndexClusterStateUpdateResponse.isShardsAcknowledged())). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;1;18;;@Override public void onResponse(AcknowledgedResponse acknowledgedResponse) {     OpenIndexClusterStateUpdateRequest updateRequest = new OpenIndexClusterStateUpdateRequest().ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()).indices(concreteIndices).waitForActiveShards(request.waitForActiveShards()).     indexStateService.openIndex(updateRequest, new ActionListener<OpenIndexClusterStateUpdateResponse>() {          @Override         public void onResponse(OpenIndexClusterStateUpdateResponse openIndexClusterStateUpdateResponse) {             listener.onResponse(new FreezeResponse(openIndexClusterStateUpdateResponse.isAcknowledged(), openIndexClusterStateUpdateResponse.isShardsAcknowledged())).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;private;3;63;;private void toggleFrozenSettings(final Index[] concreteIndices, final FreezeRequest request, final ActionListener<FreezeResponse> listener) {     clusterService.submitStateUpdateTask("toggle-frozen-settings", new AckedClusterStateUpdateTask<AcknowledgedResponse>(Priority.URGENT, request, new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse acknowledgedResponse) {             OpenIndexClusterStateUpdateRequest updateRequest = new OpenIndexClusterStateUpdateRequest().ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()).indices(concreteIndices).waitForActiveShards(request.waitForActiveShards()).             indexStateService.openIndex(updateRequest, new ActionListener<OpenIndexClusterStateUpdateResponse>() {                  @Override                 public void onResponse(OpenIndexClusterStateUpdateResponse openIndexClusterStateUpdateResponse) {                     listener.onResponse(new FreezeResponse(openIndexClusterStateUpdateResponse.isAcknowledged(), openIndexClusterStateUpdateResponse.isShardsAcknowledged())).                 }                  @Override                 public void onFailure(Exception e) {                     listener.onFailure(e).                 }             }).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }) {          @Override         public ClusterState execute(ClusterState currentState) {             final MetaData.Builder builder = MetaData.builder(currentState.metaData()).             ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).             for (Index index : concreteIndices) {                 IndexMetaData meta = currentState.metaData().getIndexSafe(index).                 if (meta.getState() != IndexMetaData.State.CLOSE) {                     throw new IllegalStateException("index [" + index.getName() + "] is not closed").                 }                 final IndexMetaData.Builder imdBuilder = IndexMetaData.builder(meta).                 imdBuilder.settingsVersion(meta.getSettingsVersion() + 1).                 final Settings.Builder settingsBuilder = Settings.builder().put(currentState.metaData().index(index).getSettings()).put(FrozenEngine.INDEX_FROZEN.getKey(), request.freeze()).put(IndexSettings.INDEX_SEARCH_THROTTLED.getKey(), request.freeze()).                 if (request.freeze()) {                     settingsBuilder.put("index.blocks.write", true).                     blocks.addIndexBlock(index.getName(), IndexMetaData.INDEX_WRITE_BLOCK).                 } else {                     settingsBuilder.remove("index.blocks.write").                     blocks.removeIndexBlock(index.getName(), IndexMetaData.INDEX_WRITE_BLOCK).                 }                 imdBuilder.settings(settingsBuilder).                 builder.put(imdBuilder.build(), true).             }             return ClusterState.builder(currentState).blocks(blocks).metaData(builder).build().         }          @Override         protected AcknowledgedResponse newResponse(boolean acknowledged) {             return new AcknowledgedResponse(acknowledged).         }     }). }
false;protected;2;5;;@Override protected ClusterBlockException checkBlock(FreezeRequest request, ClusterState state) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, indexNameExpressionResolver.concreteIndexNames(state, request)). }
false;public;0;4;;@Override public FreezeResponse newResponse() {     return new FreezeResponse(). }
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (CollectionUtils.isEmpty(indices)) {         validationException = addValidationError("index is missing", validationException).     }     return validationException. }
false;public;1;4;;public FreezeRequest setFreeze(boolean freeze) {     this.freeze = freeze.     return this. }
false;public;0;3;;public boolean freeze() {     return freeze. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     indicesOptions = IndicesOptions.readIndicesOptions(in).     indices = in.readStringArray().     freeze = in.readBoolean().     waitForActiveShards = ActiveShardCount.readFrom(in). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     indicesOptions.writeIndicesOptions(out).     out.writeStringArray(indices).     out.writeBoolean(freeze).     waitForActiveShards.writeTo(out). }
true;public;0;4;/**  * @return the indices to be frozen or unfrozen  */ ;/**  * @return the indices to be frozen or unfrozen  */ @Override public String[] indices() {     return indices. }
true;public;0;4;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @return the current behaviour when it comes to index names and wildcard indices expressions  */ ;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @return the current behaviour when it comes to index names and wildcard indices expressions  */ @Override public IndicesOptions indicesOptions() {     return indicesOptions. }
true;public;1;4;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions  * @return the request itself  */ ;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions  * @return the request itself  */ public FreezeRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = indicesOptions.     return this. }
false;public;1;5;;@Override public IndicesRequest indices(String... indices) {     this.indices = indices.     return this. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return waitForActiveShards. }
true;public;1;4;/**  * Sets the number of shard copies that should be active for indices opening to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Indices opening will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link OpenIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ ;/**  * Sets the number of shard copies that should be active for indices opening to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Indices opening will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link OpenIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ public FreezeRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     this.waitForActiveShards = waitForActiveShards.     return this. }
