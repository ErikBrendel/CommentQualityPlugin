commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;4;/**  * Stashes the current context and sets the origin in the current context. The original context is returned as a stored context  * @deprecated use ThreadContext.stashWithOrigin  */ ;/**  * Stashes the current context and sets the origin in the current context. The original context is returned as a stored context  * @deprecated use ThreadContext.stashWithOrigin  */ @Deprecated public static ThreadContext.StoredContext stashWithOrigin(ThreadContext threadContext, String origin) {     return threadContext.stashWithOrigin(origin). }
true;public,static;2;4;/**  * Returns a client that will always set the appropriate origin and ensure the proper context is restored by listeners  * @deprecated use {@link OriginSettingClient} instead  */ ;/**  * Returns a client that will always set the appropriate origin and ensure the proper context is restored by listeners  * @deprecated use {@link OriginSettingClient} instead  */ @Deprecated public static Client clientWithOrigin(Client client, String origin) {     return new OriginSettingClient(client, origin). }
true;public,static;5;8;/**  * Executes a consumer after setting the origin and wrapping the listener so that the proper context is restored  */ ;/**  * Executes a consumer after setting the origin and wrapping the listener so that the proper context is restored  */ public static <Request extends ActionRequest, Response extends ActionResponse> void executeAsyncWithOrigin(ThreadContext threadContext, String origin, Request request, ActionListener<Response> listener, BiConsumer<Request, ActionListener<Response>> consumer) {     final Supplier<ThreadContext.StoredContext> supplier = threadContext.newRestorableContext(false).     try (ThreadContext.StoredContext ignore = stashWithOrigin(threadContext, origin)) {         consumer.accept(request, new ContextPreservingActionListener<>(supplier, listener)).     } }
true;public,static;5;10;/**  * Executes an asynchronous action using the provided client. The origin is set in the context and the listener  * is wrapped to ensure the proper context is restored  */ ;/**  * Executes an asynchronous action using the provided client. The origin is set in the context and the listener  * is wrapped to ensure the proper context is restored  */ public static <Request extends ActionRequest, Response extends ActionResponse, RequestBuilder extends ActionRequestBuilder<Request, Response>> void executeAsyncWithOrigin(Client client, String origin, Action<Response> action, Request request, ActionListener<Response> listener) {     final ThreadContext threadContext = client.threadPool().getThreadContext().     final Supplier<ThreadContext.StoredContext> supplier = threadContext.newRestorableContext(false).     try (ThreadContext.StoredContext ignore = stashWithOrigin(threadContext, origin)) {         client.execute(action, request, new ContextPreservingActionListener<>(supplier, listener)).     } }
true;public,static;4;18;/**  * Execute a client operation and return the response, try to run an action  * with least privileges, when headers exist  *  * @param headers  *            Request headers, ideally including security headers  * @param origin  *            The origin to fall back to if there are no security headers  * @param client  *            The client used to query  * @param supplier  *            The action to run  * @return An instance of the response class  */ ;/**  * Execute a client operation and return the response, try to run an action  * with least privileges, when headers exist  *  * @param headers  *            Request headers, ideally including security headers  * @param origin  *            The origin to fall back to if there are no security headers  * @param client  *            The client used to query  * @param supplier  *            The action to run  * @return An instance of the response class  */ public static <T extends ActionResponse> T executeWithHeaders(Map<String, String> headers, String origin, Client client, Supplier<T> supplier) {     Map<String, String> filteredHeaders = headers.entrySet().stream().filter(e -> SECURITY_HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     // our execution by specifying the origin     if (filteredHeaders.isEmpty()) {         try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), origin)) {             return supplier.get().         }     } else {         try (ThreadContext.StoredContext ignore = client.threadPool().getThreadContext().stashContext()) {             client.threadPool().getThreadContext().copyHeaders(filteredHeaders.entrySet()).             return supplier.get().         }     } }
true;public,static;6;20;/**  * Execute a client operation asynchronously, try to run an action with  * least privileges, when headers exist  *  * @param headers  *            Request headers, ideally including security headers  * @param origin  *            The origin to fall back to if there are no security headers  * @param action  *            The action to execute  * @param request  *            The request object for the action  * @param listener  *            The listener to call when the action is complete  */ ;/**  * Execute a client operation asynchronously, try to run an action with  * least privileges, when headers exist  *  * @param headers  *            Request headers, ideally including security headers  * @param origin  *            The origin to fall back to if there are no security headers  * @param action  *            The action to execute  * @param request  *            The request object for the action  * @param listener  *            The listener to call when the action is complete  */ public static <Request extends ActionRequest, Response extends ActionResponse> void executeWithHeadersAsync(Map<String, String> headers, String origin, Client client, Action<Response> action, Request request, ActionListener<Response> listener) {     Map<String, String> filteredHeaders = headers.entrySet().stream().filter(e -> SECURITY_HEADER_FILTERS.contains(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     final ThreadContext threadContext = client.threadPool().getThreadContext().     // No headers (e.g. security not installed/in use) so execute as origin     if (filteredHeaders.isEmpty()) {         ClientHelper.executeAsyncWithOrigin(client, origin, action, request, listener).     } else {         // Otherwise stash the context and copy in the saved headers before executing         final Supplier<ThreadContext.StoredContext> supplier = threadContext.newRestorableContext(false).         try (ThreadContext.StoredContext ignore = stashWithHeaders(threadContext, filteredHeaders)) {             client.execute(action, request, new ContextPreservingActionListener<>(supplier, listener)).         }     } }
false;private,static;2;5;;private static ThreadContext.StoredContext stashWithHeaders(ThreadContext threadContext, Map<String, String> headers) {     final ThreadContext.StoredContext storedContext = threadContext.stashContext().     threadContext.copyHeaders(headers.entrySet()).     return storedContext. }
