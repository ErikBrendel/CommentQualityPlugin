commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, SingleGroupSource<?>> getGroups() {     return groups. }
false;public;0;3;;public boolean isValid() {     return this.groups != null. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeMap(source).     out.writeMap(groups, StreamOutput::writeString, (stream, value) -> {         stream.writeByte(value.getType().getId()).         value.writeTo(stream).     }). }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.map(source). }
false;public;1;14;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     final GroupConfig that = (GroupConfig) other.     return Objects.equals(this.source, that.source) && Objects.equals(this.groups, that.groups). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(source, groups). }
false;public,static;2;26;;public static GroupConfig fromXContent(final XContentParser parser, boolean lenient) throws IOException {     NamedXContentRegistry registry = parser.getXContentRegistry().     Map<String, Object> source = parser.mapOrdered().     Map<String, SingleGroupSource<?>> groups = null.     if (source.isEmpty()) {         if (lenient) {             logger.warn(DataFrameMessages.DATA_FRAME_TRANSFORM_CONFIGURATION_PIVOT_NO_GROUP_BY).         } else {             throw new IllegalArgumentException(DataFrameMessages.DATA_FRAME_TRANSFORM_CONFIGURATION_PIVOT_NO_GROUP_BY).         }     } else {         try (XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().map(source).             XContentParser sourceParser = XContentType.JSON.xContent().createParser(registry, LoggingDeprecationHandler.INSTANCE, BytesReference.bytes(xContentBuilder).streamInput())) {             groups = parseGroupConfig(sourceParser, lenient).         } catch (Exception e) {             if (lenient) {                 logger.warn(DataFrameMessages.LOG_DATA_FRAME_TRANSFORM_CONFIGURATION_BAD_GROUP_BY, e).             } else {                 throw e.             }         }     }     return new GroupConfig(source, groups). }
false;private,static;2;48;;private static Map<String, SingleGroupSource<?>> parseGroupConfig(final XContentParser parser, boolean lenient) throws IOException {     LinkedHashMap<String, SingleGroupSource<?>> groups = new LinkedHashMap<>().     // be parsing friendly, whether the token needs to be advanced or not (similar to what ObjectParser does)     XContentParser.Token token.     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         token = parser.currentToken().     } else {         token = parser.nextToken().         if (token != XContentParser.Token.START_OBJECT) {             throw new ParsingException(parser.getTokenLocation(), "Failed to parse object: Expected START_OBJECT but was: " + token).         }     }     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).         String destinationFieldName = parser.currentName().         token = parser.nextToken().         ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).         token = parser.nextToken().         ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).         SingleGroupSource.Type groupType = SingleGroupSource.Type.valueOf(parser.currentName().toUpperCase(Locale.ROOT)).         token = parser.nextToken().         ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).         SingleGroupSource<?> groupSource.         switch(groupType) {             case TERMS:                 groupSource = TermsGroupSource.fromXContent(parser, lenient).                 break.             case HISTOGRAM:                 groupSource = HistogramGroupSource.fromXContent(parser, lenient).                 break.             case DATE_HISTOGRAM:                 groupSource = DateHistogramGroupSource.fromXContent(parser, lenient).                 break.             default:                 throw new ParsingException(parser.getTokenLocation(), "invalid grouping type: " + groupType).         }         parser.nextToken().         groups.put(destinationFieldName, groupSource).     }     return groups. }
