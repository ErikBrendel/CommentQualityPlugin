commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return the name of the field used in the metric configuration. Never {@code null}.  */ ;/**  * @return the name of the field used in the metric configuration. Never {@code null}.  */ public String getField() {     return field. }
true;public;0;3;/**  * @return the names of the metrics used in the metric configuration. Never {@code null}.  */ ;/**  * @return the names of the metrics used in the metric configuration. Never {@code null}.  */ public List<String> getMetrics() {     return metrics. }
false;public;2;27;;public void validateMappings(Map<String, Map<String, FieldCapabilities>> fieldCapsResponse, ActionRequestValidationException validationException) {     Map<String, FieldCapabilities> fieldCaps = fieldCapsResponse.get(field).     if (fieldCaps != null && fieldCaps.isEmpty() == false) {         fieldCaps.forEach((key, value) -> {             if (value.isAggregatable() == false) {                 validationException.addValidationError("The field [" + field + "] must be aggregatable across all indices, " + "but is not.").             }             if (RollupField.NUMERIC_FIELD_MAPPER_TYPES.contains(key)) {             // nothing to do as all metrics are supported by SUPPORTED_NUMERIC_METRICS currently             } else if (RollupField.DATE_FIELD_MAPPER_TYPE.equals(key)) {                 if (RollupField.SUPPORTED_DATE_METRICS.containsAll(metrics) == false) {                     validationException.addValidationError(buildSupportedMetricError("date", RollupField.SUPPORTED_DATE_METRICS)).                 }             } else {                 validationException.addValidationError("The field referenced by a metric group must be a [numeric] or [date] type, " + "but found " + fieldCaps.keySet().toString() + " for field [" + field + "]").             }         }).     } else {         validationException.addValidationError("Could not find a [numeric] or [date] field with name [" + field + "] in any of the " + "indices matching the index pattern.").     } }
false;public;2;9;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     builder.startObject().     {         builder.field(FIELD, field).         builder.field(METRICS, metrics).     }     return builder.endObject(). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(field).     out.writeStringCollection(metrics). }
false;public;1;12;;@Override public boolean equals(final Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     final MetricConfig that = (MetricConfig) other.     return Objects.equals(field, that.field) && Objects.equals(metrics, that.metrics). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(field, metrics). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
false;public,static;1;3;;public static MetricConfig fromXContent(final XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;private;2;6;;private String buildSupportedMetricError(String type, List<String> supportedMetrics) {     List<String> unsupportedMetrics = new ArrayList<>(metrics).     unsupportedMetrics.removeAll(supportedMetrics).     return "Only the metrics " + supportedMetrics + " are supported for [" + type + "] types," + " but unsupported metrics " + unsupportedMetrics + " supplied for field [" + field + "]". }
