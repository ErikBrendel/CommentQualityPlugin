commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;@Override public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {     delegate.checkClientTrusted(chain, authType, socket).     verifyTrust(chain). }
false;public;3;5;;@Override public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {     delegate.checkServerTrusted(chain, authType, socket).     verifyTrust(chain). }
false;public;3;5;;@Override public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {     delegate.checkClientTrusted(chain, authType, engine).     verifyTrust(chain). }
false;public;3;5;;@Override public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {     delegate.checkServerTrusted(chain, authType, engine).     verifyTrust(chain). }
false;public;2;5;;@Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {     delegate.checkClientTrusted(chain, authType).     verifyTrust(chain). }
false;public;2;5;;@Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {     delegate.checkServerTrusted(chain, authType).     verifyTrust(chain). }
false;public;0;4;;@Override public X509Certificate[] getAcceptedIssuers() {     return delegate.getAcceptedIssuers(). }
false;private;1;17;;private void verifyTrust(X509Certificate[] chain) throws CertificateException {     if (chain.length == 0) {         throw new CertificateException("No certificate presented").     }     final X509Certificate certificate = chain[0].     Set<String> names = readCommonNames(certificate).     if (verifyCertificateNames(names)) {         logger.debug(() -> new ParameterizedMessage("Trusting certificate [{}] [{}] with common-names [{}]", certificate.getSubjectDN(), certificate.getSerialNumber().toString(16), names)).     } else {         logger.info("Rejecting certificate [{}] [{}] with common-names [{}]", certificate.getSubjectDN(), certificate.getSerialNumber().toString(16), names).         throw new CertificateException("Certificate for " + certificate.getSubjectDN() + " with common-names " + names + " does not match the trusted names " + trustRestrictions.getTrustedNames()).     } }
false;private;1;10;;private boolean verifyCertificateNames(Set<String> names) {     for (Predicate<String> trust : trustRestrictions.getTrustedNames()) {         final Optional<String> match = names.stream().filter(trust).findFirst().         if (match.isPresent()) {             logger.debug("Name [{}] matches trusted pattern [{}]", match.get(), trust).             return true.         }     }     return false. }
false;private;1;8;;private Set<String> readCommonNames(X509Certificate certificate) throws CertificateParsingException {     return getSubjectAlternativeNames(certificate).stream().filter(pair -> ((Integer) pair.get(0)).intValue() == SAN_CODE_OTHERNAME).map(pair -> pair.get(1)).map(value -> decodeDerValue((byte[]) value, certificate)).filter(Objects::nonNull).collect(Collectors.toSet()). }
true;private;2;36;/**  * Decodes the otherName CN from the certificate  *  * @param value       The DER Encoded Subject Alternative Name  * @param certificate The certificate  * @return the CN or null if it could not be parsed  */ ;/**  * Decodes the otherName CN from the certificate  *  * @param value       The DER Encoded Subject Alternative Name  * @param certificate The certificate  * @return the CN or null if it could not be parsed  */ private String decodeDerValue(byte[] value, X509Certificate certificate) {     try {         DerParser parser = new DerParser(value).         DerParser.Asn1Object seq = parser.readAsn1Object().         parser = seq.getParser().         String id = parser.readAsn1Object().getOid().         if (CN_OID.equals(id)) {             // Get the DER object with explicit 0 tag             DerParser.Asn1Object cnObject = parser.readAsn1Object().             parser = cnObject.getParser().             // The JRE's handling of OtherNames is buggy.             // The internal sun classes go to a lot of trouble to parse the GeneralNames into real object             // And then java.security.cert.X509Certificate just turns them back into bytes             // But in doing so, it ends up wrapping the "other name" bytes with a second tag             // Specifically: sun.security.x509.OtherName(DerValue) never decodes the tagged "nameValue"             // But: sun.security.x509.OtherName.encode() wraps the nameValue in a DER Tag.             // So, there's a good chance that our tagged nameValue contains... a tagged name value.             DerParser.Asn1Object innerObject = parser.readAsn1Object().             if (innerObject.isConstructed()) {                 innerObject = innerObject.getParser().readAsn1Object().             }             logger.trace("Read innermost ASN.1 Object with type code [{}]", innerObject.getType()).             String cn = innerObject.getString().             logger.trace("Read cn [{}] from ASN1Sequence [{}]", cn, seq).             return cn.         } else {             logger.debug("Certificate [{}] has 'otherName' [{}] with unsupported object-id [{}]", certificate.getSubjectDN(), seq, id).             return null.         }     } catch (IOException e) {         logger.warn("Failed to read 'otherName' from certificate [{}]", certificate.getSubjectDN()).         return null.     } }
false;private;1;5;;private Collection<List<?>> getSubjectAlternativeNames(X509Certificate certificate) throws CertificateParsingException {     final Collection<List<?>> sans = certificate.getSubjectAlternativeNames().     logger.trace("Certificate [{}] has subject alternative names [{}]", certificate.getSubjectDN(), sans).     return sans == null ? Collections.emptyList() : sans. }
