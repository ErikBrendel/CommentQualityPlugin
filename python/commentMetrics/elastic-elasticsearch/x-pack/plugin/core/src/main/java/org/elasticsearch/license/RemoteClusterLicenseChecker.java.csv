commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The alias of the remote cluster.  *  * @return the cluster alias  */ ;/**  * The alias of the remote cluster.  *  * @return the cluster alias  */ public String clusterAlias() {     return clusterAlias. }
true;public;0;3;/**  * The license info of the remote cluster.  *  * @return the license info  */ ;/**  * The license info of the remote cluster.  *  * @return the license info  */ public XPackInfoResponse.LicenseInfo licenseInfo() {     return licenseInfo. }
true;public;0;4;/**  * The remote cluster license info. This method should only be invoked if this instance represents a failing license check.  *  * @return the remote cluster license info  */ ;/**  * The remote cluster license info. This method should only be invoked if this instance represents a failing license check.  *  * @return the remote cluster license info  */ public RemoteClusterLicenseInfo remoteClusterLicenseInfo() {     assert isSuccess() == false.     return remoteClusterLicenseInfo. }
true;public,static;0;3;/**  * A successful license check.  *  * @return a successful license check instance  */ ;/**  * A successful license check.  *  * @return a successful license check instance  */ public static LicenseCheck success() {     return SUCCESS. }
true;public;0;3;/**  * Test if this instance represents a successful license check.  *  * @return true if this instance represents a successful license check, otherwise false  */ ;/**  * Test if this instance represents a successful license check.  *  * @return true if this instance represents a successful license check, otherwise false  */ public boolean isSuccess() {     return this == SUCCESS. }
true;public,static;1;3;/**  * Creates a failing license check encapsulating the specified remote cluster license info.  *  * @param remoteClusterLicenseInfo the remote cluster license info  * @return a failing license check  */ ;/**  * Creates a failing license check encapsulating the specified remote cluster license info.  *  * @param remoteClusterLicenseInfo the remote cluster license info  * @return a failing license check  */ public static LicenseCheck failure(final RemoteClusterLicenseInfo remoteClusterLicenseInfo) {     return new LicenseCheck(remoteClusterLicenseInfo). }
false;public,static;1;4;;public static boolean isLicensePlatinumOrTrial(final XPackInfoResponse.LicenseInfo licenseInfo) {     final License.OperationMode mode = License.OperationMode.resolve(licenseInfo.getMode()).     return mode == License.OperationMode.PLATINUM || mode == License.OperationMode.TRIAL. }
false;public;1;21;;@Override public void onResponse(final XPackInfoResponse xPackInfoResponse) {     final XPackInfoResponse.LicenseInfo licenseInfo = xPackInfoResponse.getLicenseInfo().     if (licenseInfo == null) {         listener.onFailure(new ResourceNotFoundException("license info is missing for cluster [" + clusterAlias.get() + "]")).         return.     }     if ((licenseInfo.getStatus() == LicenseStatus.ACTIVE) == false || predicate.test(License.OperationMode.resolve(licenseInfo.getMode())) == false) {         listener.onResponse(LicenseCheck.failure(new RemoteClusterLicenseInfo(clusterAlias.get(), licenseInfo))).         return.     }     if (clusterAliasesIterator.hasNext()) {         clusterAlias.set(clusterAliasesIterator.next()).         // recurse to the next cluster         remoteClusterLicense(clusterAlias.get(), this).     } else {         listener.onResponse(LicenseCheck.success()).     } }
false;public;1;5;;@Override public void onFailure(final Exception e) {     final String message = "could not determine the license type for cluster [" + clusterAlias.get() + "]".     listener.onFailure(new ElasticsearchException(message, e)). }
true;public;2;45;/**  * Checks the specified clusters for license compatibility. The specified callback will be invoked once if all clusters are  * license-compatible, otherwise the specified callback will be invoked once on the first cluster that is not license-compatible.  *  * @param clusterAliases the cluster aliases to check  * @param listener       a callback  */ ;/**  * Checks the specified clusters for license compatibility. The specified callback will be invoked once if all clusters are  * license-compatible, otherwise the specified callback will be invoked once on the first cluster that is not license-compatible.  *  * @param clusterAliases the cluster aliases to check  * @param listener       a callback  */ public void checkRemoteClusterLicenses(final List<String> clusterAliases, final ActionListener<LicenseCheck> listener) {     final Iterator<String> clusterAliasesIterator = clusterAliases.iterator().     if (clusterAliasesIterator.hasNext() == false) {         listener.onResponse(LicenseCheck.success()).         return.     }     final AtomicReference<String> clusterAlias = new AtomicReference<>().     final ActionListener<XPackInfoResponse> infoListener = new ActionListener<XPackInfoResponse>() {          @Override         public void onResponse(final XPackInfoResponse xPackInfoResponse) {             final XPackInfoResponse.LicenseInfo licenseInfo = xPackInfoResponse.getLicenseInfo().             if (licenseInfo == null) {                 listener.onFailure(new ResourceNotFoundException("license info is missing for cluster [" + clusterAlias.get() + "]")).                 return.             }             if ((licenseInfo.getStatus() == LicenseStatus.ACTIVE) == false || predicate.test(License.OperationMode.resolve(licenseInfo.getMode())) == false) {                 listener.onResponse(LicenseCheck.failure(new RemoteClusterLicenseInfo(clusterAlias.get(), licenseInfo))).                 return.             }             if (clusterAliasesIterator.hasNext()) {                 clusterAlias.set(clusterAliasesIterator.next()).                 // recurse to the next cluster                 remoteClusterLicense(clusterAlias.get(), this).             } else {                 listener.onResponse(LicenseCheck.success()).             }         }          @Override         public void onFailure(final Exception e) {             final String message = "could not determine the license type for cluster [" + clusterAlias.get() + "]".             listener.onFailure(new ElasticsearchException(message, e)).         }     }.     // check the license on the first cluster, and then we recursively check licenses on the remaining clusters     clusterAlias.set(clusterAliasesIterator.next()).     remoteClusterLicense(clusterAlias.get(), infoListener). }
false;private;2;17;;private void remoteClusterLicense(final String clusterAlias, final ActionListener<XPackInfoResponse> listener) {     final ThreadContext threadContext = client.threadPool().getThreadContext().     final ContextPreservingActionListener<XPackInfoResponse> contextPreservingActionListener = new ContextPreservingActionListener<>(threadContext.newRestorableContext(false), listener).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         // we stash any context here since this is an internal execution and should not leak any existing context information         threadContext.markAsSystemContext().         final XPackInfoRequest request = new XPackInfoRequest().         request.setCategories(EnumSet.of(XPackInfoRequest.Category.LICENSE)).         try {             client.getRemoteClusterClient(clusterAlias).execute(XPackInfoAction.INSTANCE, request, contextPreservingActionListener).         } catch (final Exception e) {             contextPreservingActionListener.onFailure(e).         }     } }
true;public,static;1;3;/**  * Predicate to test if the index name represents the name of a remote index.  *  * @param index the index name  * @return true if the collection of indices contains a remote index, otherwise false  */ ;/**  * Predicate to test if the index name represents the name of a remote index.  *  * @param index the index name  * @return true if the collection of indices contains a remote index, otherwise false  */ public static boolean isRemoteIndex(final String index) {     return index.indexOf(RemoteClusterAware.REMOTE_CLUSTER_INDEX_SEPARATOR) != -1. }
true;public,static;1;3;/**  * Predicate to test if the collection of index names contains any that represent the name of a remote index.  *  * @param indices the collection of index names  * @return true if the collection of index names contains a name that represents a remote index, otherwise false  */ ;/**  * Predicate to test if the collection of index names contains any that represent the name of a remote index.  *  * @param indices the collection of index names  * @return true if the collection of index names contains a name that represents a remote index, otherwise false  */ public static boolean containsRemoteIndex(final List<String> indices) {     return indices.stream().anyMatch(RemoteClusterLicenseChecker::isRemoteIndex). }
true;public,static;1;3;/**  * Filters the collection of index names for names that represent a remote index. Remote index names are of the form  * {@code cluster_name:index_name}.  *  * @param indices the collection of index names  * @return list of index names that represent remote index names  */ ;/**  * Filters the collection of index names for names that represent a remote index. Remote index names are of the form  * {@code cluster_name:index_name}.  *  * @param indices the collection of index names  * @return list of index names that represent remote index names  */ public static List<String> remoteIndices(final List<String> indices) {     return indices.stream().filter(RemoteClusterLicenseChecker::isRemoteIndex).collect(Collectors.toList()). }
true;public,static;2;9;/**  * Extract the list of remote cluster aliases from the list of index names. Remote index names are of the form  * {@code cluster_alias:index_name} and the cluster_alias is extracted (and expanded if it is a wildcard) for  * each index name that represents a remote index.  *  * @param remoteClusters the aliases for remote clusters  * @param indices        the collection of index names  * @return the remote cluster names  */ ;/**  * Extract the list of remote cluster aliases from the list of index names. Remote index names are of the form  * {@code cluster_alias:index_name} and the cluster_alias is extracted (and expanded if it is a wildcard) for  * each index name that represents a remote index.  *  * @param remoteClusters the aliases for remote clusters  * @param indices        the collection of index names  * @return the remote cluster names  */ public static List<String> remoteClusterAliases(final Set<String> remoteClusters, final List<String> indices) {     return indices.stream().filter(RemoteClusterLicenseChecker::isRemoteIndex).map(index -> index.substring(0, index.indexOf(RemoteClusterAware.REMOTE_CLUSTER_INDEX_SEPARATOR))).distinct().flatMap(clusterExpression -> clusterNameExpressionResolver.resolveClusterNames(remoteClusters, clusterExpression).stream()).distinct().collect(Collectors.toList()). }
true;public,static;3;20;/**  * Constructs an error message for license incompatibility.  *  * @param feature                  the name of the feature that initiated the remote cluster license check.  * @param remoteClusterLicenseInfo the remote cluster license info of the cluster that failed the license check  * @return an error message representing license incompatibility  */ ;/**  * Constructs an error message for license incompatibility.  *  * @param feature                  the name of the feature that initiated the remote cluster license check.  * @param remoteClusterLicenseInfo the remote cluster license info of the cluster that failed the license check  * @return an error message representing license incompatibility  */ public static String buildErrorMessage(final String feature, final RemoteClusterLicenseInfo remoteClusterLicenseInfo, final Predicate<XPackInfoResponse.LicenseInfo> predicate) {     final StringBuilder error = new StringBuilder().     if (remoteClusterLicenseInfo.licenseInfo().getStatus() != LicenseStatus.ACTIVE) {         error.append(String.format(Locale.ROOT, "the license on cluster [%s] is not active", remoteClusterLicenseInfo.clusterAlias())).     } else {         assert predicate.test(remoteClusterLicenseInfo.licenseInfo()) == false : "license must be incompatible to build error message".         final String message = String.format(Locale.ROOT, "the license mode [%s] on cluster [%s] does not enable [%s]", License.OperationMode.resolve(remoteClusterLicenseInfo.licenseInfo().getMode()), remoteClusterLicenseInfo.clusterAlias(), feature).         error.append(message).     }     return error.toString(). }
