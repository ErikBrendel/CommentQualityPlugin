commented;modifiers;parameterAmount;loc;comment;code
false;public;0;30;;public void testIteration() {     final int numberOfItems = scaledRandomIntBetween(1, 32).     final int numberOfIterations = scaledRandomIntBetween(1, numberOfItems).     List<Object> items = new ArrayList<>(numberOfItems).     for (int i = 0. i < numberOfItems. i++) {         items.add(new Object()).     }     final AtomicInteger iterations = new AtomicInteger(0).     final BiConsumer<Object, ActionListener<Object>> consumer = (listValue, listener) -> {         final int current = iterations.incrementAndGet().         if (current == numberOfIterations) {             listener.onResponse(items.get(current - 1)).         } else {             listener.onResponse(null).         }     }.     IteratingActionListener<Object, Object> iteratingListener = new IteratingActionListener<>(ActionListener.wrap((object) -> {         assertNotNull(object).         assertThat(object, sameInstance(items.get(numberOfIterations - 1))).     }, (e) -> {         logger.error("unexpected exception", e).         fail("exception should not have been thrown").     }), consumer, items, new ThreadContext(Settings.EMPTY)).     iteratingListener.run().     // we never really went async, its all chained together so verify this for sanity     assertEquals(numberOfIterations, iterations.get()). }
false;public;0;38;;public void testIterationDoesntAllowThreadContextLeak() {     final ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     final int numberOfItems = scaledRandomIntBetween(1, 32).     final int numberOfIterations = scaledRandomIntBetween(1, numberOfItems).     List<Object> items = new ArrayList<>(numberOfItems).     for (int i = 0. i < numberOfItems. i++) {         items.add(new Object()).     }     threadContext.putHeader("outside", "listener").     final AtomicInteger iterations = new AtomicInteger(0).     final BiConsumer<Object, ActionListener<Object>> consumer = (listValue, listener) -> {         final int current = iterations.incrementAndGet().         assertEquals("listener", threadContext.getHeader("outside")).         if (current == numberOfIterations) {             threadContext.putHeader("foo", "bar").             listener.onResponse(items.get(current - 1)).         } else {             listener.onResponse(null).         }     }.     IteratingActionListener<Object, Object> iteratingListener = new IteratingActionListener<>(ActionListener.wrap((object) -> {         assertNotNull(object).         assertThat(object, sameInstance(items.get(numberOfIterations - 1))).         assertEquals("bar", threadContext.getHeader("foo")).         assertEquals("listener", threadContext.getHeader("outside")).     }, (e) -> {         logger.error("unexpected exception", e).         fail("exception should not have been thrown").     }), consumer, items, threadContext).     iteratingListener.run().     // we never really went async, its all chained together so verify this for sanity     assertEquals(numberOfIterations, iterations.get()).     assertNull(threadContext.getHeader("foo")).     assertEquals("listener", threadContext.getHeader("outside")). }
false;public;0;10;;public void testIterationEmptyList() {     IteratingActionListener<Object, Object> listener = new IteratingActionListener<>(ActionListener.wrap(Assert::assertNull, (e) -> {         logger.error("unexpected exception", e).         fail("exception should not have been thrown").     }), (listValue, iteratingListener) -> {         fail("consumer should not have been called!!!").     }, Collections.emptyList(), new ThreadContext(Settings.EMPTY)).     listener.run(). }
false;public;0;31;;public void testFailure() {     final int numberOfItems = scaledRandomIntBetween(1, 32).     final int numberOfIterations = scaledRandomIntBetween(1, numberOfItems).     List<Object> items = new ArrayList<>(numberOfItems).     for (int i = 0. i < numberOfItems. i++) {         items.add(new Object()).     }     final AtomicInteger iterations = new AtomicInteger(0).     final BiConsumer<Object, ActionListener<Object>> consumer = (listValue, listener) -> {         final int current = iterations.incrementAndGet().         if (current == numberOfIterations) {             listener.onFailure(new ElasticsearchException("expected exception")).         } else {             listener.onResponse(null).         }     }.     final AtomicBoolean onFailureCalled = new AtomicBoolean(false).     IteratingActionListener<Object, Object> iteratingListener = new IteratingActionListener<>(ActionListener.wrap((object) -> {         fail("onResponse should not have been called, but was called with: " + object).     }, (e) -> {         assertEquals("expected exception", e.getMessage()).         assertTrue(onFailureCalled.compareAndSet(false, true)).     }), consumer, items, new ThreadContext(Settings.EMPTY)).     iteratingListener.run().     // we never really went async, its all chained together so verify this for sanity     assertEquals(numberOfIterations, iterations.get()).     assertTrue(onFailureCalled.get()). }
false;public;0;44;;public void testFunctionApplied() {     final int numberOfItems = scaledRandomIntBetween(2, 32).     final int numberOfIterations = scaledRandomIntBetween(1, numberOfItems).     List<Object> items = new ArrayList<>(numberOfItems).     for (int i = 0. i < numberOfItems. i++) {         items.add(new Object()).     }     final AtomicInteger iterations = new AtomicInteger(0).     final Predicate<Object> iterationPredicate = object -> {         final int current = iterations.incrementAndGet().         return current != numberOfIterations.     }.     final BiConsumer<Object, ActionListener<Object>> consumer = (listValue, listener) -> {         listener.onResponse(items.get(iterations.get())).     }.     final AtomicReference<Object> originalObject = new AtomicReference<>().     final AtomicReference<Object> result = new AtomicReference<>().     final Function<Object, Object> responseFunction = object -> {         originalObject.set(object).         Object randomResult.         do {             randomResult = randomFrom(items).         } while (randomResult == object).         result.set(randomResult).         return randomResult.     }.     IteratingActionListener<Object, Object> iteratingListener = new IteratingActionListener<>(ActionListener.wrap((object) -> {         assertNotNull(object).         assertNotNull(originalObject.get()).         assertThat(object, sameInstance(result.get())).         assertThat(object, not(sameInstance(originalObject.get()))).         assertThat(originalObject.get(), sameInstance(items.get(iterations.get() - 1))).     }, (e) -> {         logger.error("unexpected exception", e).         fail("exception should not have been thrown").     }), consumer, items, new ThreadContext(Settings.EMPTY), responseFunction, iterationPredicate).     iteratingListener.run().     // we never really went async, its all chained together so verify this for sanity     assertEquals(numberOfIterations, iterations.get()). }
