commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static String dateMathString(String time, final long now) {     return formatDateTimeFormatter.format(dateMathParser.parse(time, () -> now).atZone(ZoneOffset.UTC)). }
false;public,static;2;3;;public static long dateMath(String time, final long now) {     return dateMathParser.parse(time, () -> now).toEpochMilli(). }
false;public,static;1;28;;public static LicenseSpec generateRandomLicenseSpec(int version) {     boolean datesInMillis = randomBoolean().     long now = System.currentTimeMillis().     String uid = UUID.randomUUID().toString().     String feature = "feature__" + randomInt().     String issuer = "issuer__" + randomInt().     String issuedTo = "issuedTo__" + randomInt().     final String type.     final String subscriptionType.     if (version < License.VERSION_NO_FEATURE_TYPE) {         subscriptionType = randomFrom("gold", "silver", "platinum").         // randomFrom("subscription", "internal", "development").         type = "subscription".     } else {         subscriptionType = null.         type = randomFrom("basic", "dev", "gold", "silver", "platinum").     }     int maxNodes = RandomizedTest.randomIntBetween(5, 100).     if (datesInMillis) {         long issueDateInMillis = dateMath("now", now).         long expiryDateInMillis = dateMath("now+10d/d", now).         return new LicenseSpec(version, uid, feature, issueDateInMillis, expiryDateInMillis, type, subscriptionType, issuedTo, issuer, maxNodes).     } else {         String issueDate = dateMathString("now", now).         String expiryDate = dateMathString("now+10d/d", now).         return new LicenseSpec(version, uid, feature, issueDate, expiryDate, type, subscriptionType, issuedTo, issuer, maxNodes).     } }
false;public,static;1;29;;public static String generateLicenseSpecString(LicenseSpec licenseSpec) throws IOException {     XContentBuilder licenses = jsonBuilder().     licenses.startObject().     licenses.startArray("licenses").     licenses.startObject().field("uid", licenseSpec.uid).field("type", licenseSpec.type).field("subscription_type", licenseSpec.subscriptionType).field("issued_to", licenseSpec.issuedTo).field("issuer", licenseSpec.issuer).field("feature", licenseSpec.feature).field("max_nodes", licenseSpec.maxNodes).     if (licenseSpec.issueDate != null) {         licenses.field("issue_date", licenseSpec.issueDate).     } else {         licenses.field("issue_date_in_millis", licenseSpec.issueDateInMillis).     }     if (licenseSpec.expiryDate != null) {         licenses.field("expiry_date", licenseSpec.expiryDate).     } else {         licenses.field("expiry_date_in_millis", licenseSpec.expiryDateInMillis).     }     licenses.field("version", licenseSpec.version).     licenses.endObject().     licenses.endArray().     licenses.endObject().     return Strings.toString(licenses). }
false;public,static;1;22;;public static License generateLicenses(LicenseSpec spec) {     License.Builder builder = License.builder().uid(spec.uid).feature(spec.feature).type(spec.type).subscriptionType(spec.subscriptionType).issuedTo(spec.issuedTo).issuer(spec.issuer).maxNodes(spec.maxNodes).     if (spec.expiryDate != null) {         builder.expiryDate(DateUtils.endOfTheDay(spec.expiryDate)).     } else {         builder.expiryDate(spec.expiryDateInMillis).     }     if (spec.issueDate != null) {         builder.issueDate(DateUtils.beginningOfTheDay(spec.issueDate)).     } else {         builder.issueDate(spec.issueDateInMillis).     }     return builder.build(). }
false;public,static;2;17;;public static void assertLicenseSpec(LicenseSpec spec, License license) {     MatcherAssert.assertThat(license.uid(), equalTo(spec.uid)).     MatcherAssert.assertThat(license.issuedTo(), equalTo(spec.issuedTo)).     MatcherAssert.assertThat(license.issuer(), equalTo(spec.issuer)).     MatcherAssert.assertThat(license.type(), equalTo(spec.type)).     MatcherAssert.assertThat(license.maxNodes(), equalTo(spec.maxNodes)).     if (spec.issueDate != null) {         MatcherAssert.assertThat(license.issueDate(), equalTo(DateUtils.beginningOfTheDay(spec.issueDate))).     } else {         MatcherAssert.assertThat(license.issueDate(), equalTo(spec.issueDateInMillis)).     }     if (spec.expiryDate != null) {         MatcherAssert.assertThat(license.expiryDate(), equalTo(DateUtils.endOfTheDay(spec.expiryDate))).     } else {         MatcherAssert.assertThat(license.expiryDate(), equalTo(spec.expiryDateInMillis)).     } }
false;private,static;0;3;;private static Path getTestPriKeyPath() throws Exception {     return getResourcePath("/private.key"). }
false;private,static;0;3;;private static Path getTestPubKeyPath() throws Exception {     return getResourcePath("/public.key"). }
false;public,static;1;9;;public static String dumpLicense(License license) throws Exception {     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     builder.startObject().     builder.startObject("license").     license.toInnerXContent(builder, ToXContent.EMPTY_PARAMS).     builder.endObject().     builder.endObject().     return Strings.toString(builder). }
false;public,static;1;3;;public static License generateSignedLicense(TimeValue expiryDuration) throws Exception {     return generateSignedLicense(null, -1, expiryDuration). }
false;public,static;2;3;;public static License generateSignedLicense(String type, TimeValue expiryDuration) throws Exception {     return generateSignedLicense(type, -1, expiryDuration). }
false;public,static;2;3;;public static License generateSignedLicense(long issueDate, TimeValue expiryDuration) throws Exception {     return generateSignedLicense(null, issueDate, expiryDuration). }
false;public,static;3;3;;public static License generateSignedLicense(String type, long issueDate, TimeValue expiryDuration) throws Exception {     return generateSignedLicense(type, randomIntBetween(License.VERSION_START, License.VERSION_CURRENT), issueDate, expiryDuration). }
false;public,static;0;12;;public static License generateSignedLicenseOldSignature() {     long issueDate = System.currentTimeMillis().     License.Builder specBuilder = License.builder().uid(UUID.randomUUID().toString()).version(License.VERSION_START_DATE).issuedTo("customer").maxNodes(5).type("trial").issueDate(issueDate).expiryDate(issueDate + TimeValue.timeValueHours(24).getMillis()).     return SelfGeneratedLicense.create(specBuilder, License.VERSION_START_DATE). }
true;public,static;4;24;/**  * This method which chooses the license type randomly if the type is null. However, it will not randomly  * choose trial or basic types as those types can only be self-generated.  */ ;/**  * This method which chooses the license type randomly if the type is null. However, it will not randomly  * choose trial or basic types as those types can only be self-generated.  */ public static License generateSignedLicense(String type, int version, long issueDate, TimeValue expiryDuration) throws Exception {     long issue = (issueDate != -1L) ? issueDate : System.currentTimeMillis() - TimeValue.timeValueHours(2).getMillis().     final String licenseType.     if (version < License.VERSION_NO_FEATURE_TYPE) {         licenseType = randomFrom("subscription", "internal", "development").     } else {         licenseType = (type != null) ? type : randomFrom("silver", "dev", "gold", "platinum").     }     final License.Builder builder = License.builder().uid(UUID.randomUUID().toString()).version(version).expiryDate(System.currentTimeMillis() + expiryDuration.getMillis()).issueDate(issue).type(licenseType).issuedTo("customer").issuer("elasticsearch").maxNodes(5).     if (version == License.VERSION_START) {         builder.subscriptionType((type != null) ? type : randomFrom("dev", "gold", "platinum", "silver")).         builder.feature(randomAlphaOfLength(10)).     }     final LicenseSigner signer = new LicenseSigner(getTestPriKeyPath(), getTestPubKeyPath()).     return signer.sign(builder.build()). }
false;public,static;1;4;;public static License generateSignedLicense(License.Builder builder) throws Exception {     LicenseSigner signer = new LicenseSigner(getTestPriKeyPath(), getTestPubKeyPath()).     return signer.sign(builder.build()). }
false;public,static;1;3;;public static License generateExpiredNonBasicLicense(long expiryDate) throws Exception {     return generateExpiredNonBasicLicense(randomFrom("silver", "dev", "gold", "platinum"), expiryDate). }
false;public,static;0;3;;public static License generateExpiredNonBasicLicense() throws Exception {     return generateExpiredNonBasicLicense(randomFrom("silver", "dev", "gold", "platinum")). }
false;public,static;1;4;;public static License generateExpiredNonBasicLicense(String type) throws Exception {     return generateExpiredNonBasicLicense(type, System.currentTimeMillis() - TimeValue.timeValueHours(randomIntBetween(1, 10)).getMillis()). }
false;public,static;2;13;;public static License generateExpiredNonBasicLicense(String type, long expiryDate) throws Exception {     final License.Builder builder = License.builder().uid(UUID.randomUUID().toString()).version(License.VERSION_CURRENT).expiryDate(expiryDate).issueDate(expiryDate - TimeValue.timeValueMinutes(10).getMillis()).type(type).issuedTo("customer").issuer("elasticsearch").maxNodes(5).     LicenseSigner signer = new LicenseSigner(getTestPriKeyPath(), getTestPubKeyPath()).     return signer.sign(builder.build()). }
false;private,static;1;7;;private static Path getResourcePath(String resource) throws Exception {     Path resourceFile = createTempFile().     try (InputStream resourceInput = TestUtils.class.getResourceAsStream(resource)) {         Files.copy(resourceInput, resourceFile, StandardCopyOption.REPLACE_EXISTING).     }     return resourceFile. }
false;public;1;5;;@Override public void onResponse(PutLicenseResponse licensesUpdateResponse) {     status.set(licensesUpdateResponse.status()).     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     latch.countDown(). }
false;public,static;3;24;;public static void registerAndAckSignedLicenses(final LicenseService licenseService, License license, final LicensesStatus expectedStatus) {     PutLicenseRequest putLicenseRequest = new PutLicenseRequest().license(license).acknowledge(true).     final CountDownLatch latch = new CountDownLatch(1).     final AtomicReference<LicensesStatus> status = new AtomicReference<>().     licenseService.registerLicense(putLicenseRequest, new ActionListener<PutLicenseResponse>() {          @Override         public void onResponse(PutLicenseResponse licensesUpdateResponse) {             status.set(licensesUpdateResponse.status()).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             latch.countDown().         }     }).     try {         latch.await().     } catch (InterruptedException e) {         Assert.fail(e.getMessage()).     }     assertThat(status.get(), equalTo(expectedStatus)). }
false;;3;6;;@Override void update(License.OperationMode mode, boolean active, Version mostRecentTrialVersion) {     modeUpdates.add(mode).     activeUpdates.add(active).     trialVersionUpdates.add(mostRecentTrialVersion). }
false;public;3;4;;@Override public void update(License.OperationMode mode, boolean active, Version mostRecentTrialVersion) {     super.update(mode, active, mostRecentTrialVersion). }
false;public,static;2;3;;public static void putLicense(MetaData.Builder builder, License license) {     builder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(license, null)). }
