commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;public void testXPackInstalledAttrClash() throws Exception {     Settings.Builder builder = Settings.builder().     builder.put("node.attr." + XPackPlugin.XPACK_INSTALLED_NODE_ATTR, randomBoolean()).     if (randomBoolean()) {         builder.put(Client.CLIENT_TYPE_SETTING_S.getKey(), "transport").     }     XPackPlugin xpackPlugin = createXPackPlugin(builder.put("path.home", createTempDir()).build()).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, xpackPlugin::additionalSettings).     assertThat(e.getMessage(), containsString("Directly setting [node.attr." + XPackPlugin.XPACK_INSTALLED_NODE_ATTR + "] is not permitted")). }
false;public;0;4;;public void testXPackInstalledAttrExists() throws Exception {     XPackPlugin xpackPlugin = createXPackPlugin(Settings.builder().put("path.home", createTempDir()).build()).     assertEquals("true", xpackPlugin.additionalSettings().get("node.attr." + XPackPlugin.XPACK_INSTALLED_NODE_ATTR)). }
false;public;0;38;;public void testNodesNotReadyForXPackCustomMetadata() {     boolean compatible.     boolean nodesCompatible = true.     DiscoveryNodes.Builder discoveryNodes = DiscoveryNodes.builder().     for (int i = 0. i < randomInt(3). i++) {         final Version version = VersionUtils.randomVersion(random()).         final Map<String, String> attributes.         if (randomBoolean() && version.onOrAfter(Version.V_6_3_0)) {             attributes = Collections.singletonMap(XPackPlugin.XPACK_INSTALLED_NODE_ATTR, "true").         } else {             nodesCompatible = false.             attributes = Collections.emptyMap().         }         discoveryNodes.add(new DiscoveryNode("node_" + i, buildNewFakeTransportAddress(), attributes, Collections.emptySet(), Version.CURRENT)).     }     ClusterState.Builder clusterStateBuilder = ClusterState.builder(ClusterName.DEFAULT).     if (randomBoolean()) {         clusterStateBuilder.putCustom(TokenMetaData.TYPE, new TokenMetaData(Collections.emptyList(), new byte[0])).         compatible = true.     } else {         compatible = nodesCompatible.     }     ClusterState clusterState = clusterStateBuilder.nodes(discoveryNodes.build()).build().     assertEquals(XPackPlugin.nodesNotReadyForXPackCustomMetadata(clusterState).isEmpty(), nodesCompatible).     assertEquals(XPackPlugin.isReadyForXPackCustomMetadata(clusterState), compatible).     if (compatible == false) {         IllegalStateException e = expectThrows(IllegalStateException.class, () -> XPackPlugin.checkReadyForXPackCustomMetadata(clusterState)).         assertThat(e.getMessage(), containsString("The following nodes are not ready yet for enabling x-pack custom metadata:")).     } }
false;protected;1;4;;@Override protected void setSslService(SSLService sslService) { // disable }
false;protected;1;4;;@Override protected void setLicenseState(XPackLicenseState licenseState) { // disable }
false;private;1;14;;private XPackPlugin createXPackPlugin(Settings settings) throws Exception {     return new XPackPlugin(settings, null) {          @Override         protected void setSslService(SSLService sslService) {         // disable         }          @Override         protected void setLicenseState(XPackLicenseState licenseState) {         // disable         }     }. }
