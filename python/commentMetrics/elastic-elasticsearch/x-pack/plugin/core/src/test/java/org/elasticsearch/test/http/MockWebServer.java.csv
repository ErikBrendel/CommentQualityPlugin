commented;modifiers;parameterAmount;loc;comment;code
true;public;0;52;/**  * Starts the webserver and binds it to an arbitrary ephemeral port  * The webserver will be able to serve requests once this method returns  *  * @throws IOException in case of a binding or other I/O errors  */ ;/**  * Starts the webserver and binds it to an arbitrary ephemeral port  * The webserver will be able to serve requests once this method returns  *  * @throws IOException in case of a binding or other I/O errors  */ public void start() throws IOException {     InetSocketAddress address = new InetSocketAddress(InetAddress.getLoopbackAddress().getHostAddress(), 0).     if (sslContext != null) {         HttpsServer httpsServer = MockHttpServer.createHttps(address, 0).         httpsServer.setHttpsConfigurator(new CustomHttpsConfigurator(sslContext, needClientAuth)).         server = httpsServer.     } else {         server = MockHttpServer.createHttp(address, 0).     }     server.start().     // Uses #InetSocketAddress.getHostString() to prevent reverse dns lookups, eager binding, so we can find out host/port regardless     // if the webserver was already shut down     this.hostname = server.getAddress().getHostString().     this.port = server.getAddress().getPort().     server.createContext("/", s -> {         try {             MockResponse response = responses.poll().             MockRequest request = createRequest(s).             requests.add(request).             if (logger.isDebugEnabled()) {                 logger.debug("[{}:{}] incoming HTTP request [{} {}], returning status [{}] body [{}]", getHostName(), getPort(), s.getRequestMethod(), s.getRequestURI(), response.getStatusCode(), getStartOfBody(response)).             }             sleepIfNeeded(response.getBeforeReplyDelay()).             s.getResponseHeaders().putAll(response.getHeaders().headers).             if (Strings.isEmpty(response.getBody())) {                 s.sendResponseHeaders(response.getStatusCode(), 0).             } else {                 byte[] responseAsBytes = response.getBody().getBytes(StandardCharsets.UTF_8).                 s.sendResponseHeaders(response.getStatusCode(), responseAsBytes.length).                 sleepIfNeeded(response.getBodyDelay()).                 if ("HEAD".equals(request.getMethod()) == false) {                     try (OutputStream responseBody = s.getResponseBody()) {                         responseBody.write(responseAsBytes).                     }                 }             }         } catch (Exception e) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to respond to request [{} {}]", s.getRequestMethod(), s.getRequestURI()), e).         } finally {             s.close().         }     }).     logger.info("bound HTTP mock server to [{}:{}]", getHostName(), getPort()). }
false;public;1;4;;@Override public void configure(HttpsParameters params) {     params.setNeedClientAuth(needClientAuth). }
true;private;1;13;/**  * Sleep the specified amount of time, if the time value is not null  */ ;/**  * Sleep the specified amount of time, if the time value is not null  */ private void sleepIfNeeded(TimeValue timeValue) throws InterruptedException {     if (timeValue == null) {         return.     }     CountDownLatch latch = new CountDownLatch(1).     latches.add(latch).     try {         latch.await(timeValue.millis(), TimeUnit.MILLISECONDS).     } finally {         latches.remove(latch).     } }
true;private;1;10;/**  * Creates a MockRequest from an incoming HTTP request, that can later be checked in your test assertions  */ ;/**  * Creates a MockRequest from an incoming HTTP request, that can later be checked in your test assertions  */ private MockRequest createRequest(HttpExchange exchange) throws IOException {     MockRequest request = new MockRequest(exchange.getRequestMethod(), exchange.getRequestURI(), exchange.getRequestHeaders()).     if (exchange.getRequestBody() != null) {         String body = Streams.copyToString(new InputStreamReader(exchange.getRequestBody(), StandardCharsets.UTF_8)).         if (Strings.isEmpty(body) == false) {             request.setBody(body).         }     }     return request. }
true;public;0;3;/**  * @return The hostname the server is bound to.  */ ;/**  * @return The hostname the server is bound to.  */ public String getHostName() {     return hostname. }
true;public;0;3;/**  * @return The tcp port that the server is bound to  */ ;/**  * @return The tcp port that the server is bound to  */ public int getPort() {     return port. }
true;public;1;7;/**  * Adds a response to the response queue that is used when a request comes in  * Note: Every response is only processed once  * @param response The created mock response  */ ;/**  * Adds a response to the response queue that is used when a request comes in  * Note: Every response is only processed once  * @param response The created mock response  */ public void enqueue(MockResponse response) {     if (logger.isTraceEnabled()) {         logger.trace("[{}:{}] Enqueueing response [{}], status [{}] body [{}]", getHostName(), getPort(), responses.size(), response.getStatusCode(), getStartOfBody(response)).     }     responses.add(response). }
true;public;0;3;/**  * @return The requests that have been made to this mock web server  */ ;/**  * @return The requests that have been made to this mock web server  */ public List<MockRequest> requests() {     return new ArrayList<>(requests). }
true;public;0;3;/**  * Removes the first request in the list of requests and returns it to the caller.  * This can be used as a queue if you are sure the order of your requests.  */ ;/**  * Removes the first request in the list of requests and returns it to the caller.  * This can be used as a queue if you are sure the order of your requests.  */ public MockRequest takeRequest() {     return requests.poll(). }
true;public;0;3;/**  * A utility method to peek into the requests and find out if #MockWebServer.takeRequests will not throw an out of bound exception  * @return true if more requests are available, false otherwise  */ ;/**  * A utility method to peek into the requests and find out if #MockWebServer.takeRequests will not throw an out of bound exception  * @return true if more requests are available, false otherwise  */ public boolean hasMoreRequests() {     return requests.isEmpty() == false. }
true;public;0;10;/**  * Closes down the webserver. Also tries to stop all the currently sleeping requests first by counting down their respective  * latches.  */ ;/**  * Closes down the webserver. Also tries to stop all the currently sleeping requests first by counting down their respective  * latches.  */ @Override public void close() {     logger.debug("[{}:{}] Counting down all latches before terminating executor", getHostName(), getPort()).     latches.forEach(CountDownLatch::countDown).     if (server.getExecutor() instanceof ExecutorService) {         terminate((ExecutorService) server.getExecutor()).     }     server.stop(0). }
true;private;1;7;/**  * Helper method to return the first 20 chars of a request's body  * @param response The MockResponse to inspect  * @return Returns the first 20 chars or an empty string if the response body is not configured  */ ;/**  * Helper method to return the first 20 chars of a request's body  * @param response The MockResponse to inspect  * @return Returns the first 20 chars or an empty string if the response body is not configured  */ private String getStartOfBody(MockResponse response) {     if (Strings.isEmpty(response.getBody())) {         return "".     }     int length = Math.min(20, response.getBody().length()).     return response.getBody().substring(0, length).replaceAll("\n", ""). }
