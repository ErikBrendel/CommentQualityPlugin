commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Info createTestInstance() {     return new Info(randomNonNegativeLong(), randomNonNegativeLong(), randomBoolean()). }
false;protected;1;4;;@Override protected Info doParseInstance(XContentParser parser) throws IOException {     return Info.PARSER.apply(parser, null). }
false;protected;0;4;;@Override protected boolean supportsUnknownFields() {     return false. }
false;public,final;0;5;;public final void testEqualsAndHashcode() {     for (int runs = 0. runs < NUMBER_OF_TEST_RUNS. runs++) {         EqualsHashCodeTestUtils.checkEqualsAndHashCode(createTestInstance(), this::copyInstance, this::mutateInstance).     } }
false;protected,final;1;3;;protected final Info copyInstance(Info instance) throws IOException {     return new Info(instance.getActualReplicas(), instance.getNumberShardsLeftToAllocate(), instance.allShardsActive()). }
false;protected;1;19;;protected Info mutateInstance(Info instance) throws IOException {     long actualReplicas = instance.getActualReplicas().     long shardsToAllocate = instance.getNumberShardsLeftToAllocate().     boolean allShardsActive = instance.allShardsActive().     switch(between(0, 2)) {         case 0:             shardsToAllocate += between(1, 20).             break.         case 1:             allShardsActive = allShardsActive == false.             break.         case 2:             actualReplicas += between(1, 20).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new Info(actualReplicas, shardsToAllocate, allShardsActive). }
