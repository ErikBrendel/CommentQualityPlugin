commented;modifiers;parameterAmount;loc;comment;code
false;public;0;24;;public void testEqualsAndHashCode() {     final int numKeyAndTimestamps = scaledRandomIntBetween(1, 8).     final List<KeyAndTimestamp> keyAndTimestampList = generateKeyAndTimestampListOfSize(numKeyAndTimestamps).     final byte[] currentKeyHash = randomByteArrayOfLength(8).     final TokenMetaData original = new TokenMetaData(keyAndTimestampList, currentKeyHash).     EqualsHashCodeTestUtils.checkEqualsAndHashCode(original, tokenMetaData -> {         final List<KeyAndTimestamp> copiedList = new ArrayList<>(keyAndTimestampList).         final byte[] copyKeyHash = Arrays.copyOf(currentKeyHash, currentKeyHash.length).         return new TokenMetaData(copiedList, copyKeyHash).     }, tokenMetaData -> {         final List<KeyAndTimestamp> modifiedList = generateKeyAndTimestampListOfSize(numKeyAndTimestamps).         return new TokenMetaData(modifiedList, currentKeyHash).     }).     EqualsHashCodeTestUtils.checkEqualsAndHashCode(original, tokenMetaData -> {         BytesStreamOutput out = new BytesStreamOutput().         tokenMetaData.writeTo(out).         return new TokenMetaData(out.bytes().streamInput()).     }, tokenMetaData -> {         final byte[] modifiedKeyHash = randomByteArrayOfLength(8).         return new TokenMetaData(keyAndTimestampList, modifiedKeyHash).     }). }
false;private;1;8;;private List<KeyAndTimestamp> generateKeyAndTimestampListOfSize(int size) {     final List<KeyAndTimestamp> keyAndTimestampList = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         keyAndTimestampList.add(new KeyAndTimestamp(new SecureString(randomAlphaOfLengthBetween(1, 12).toCharArray()), randomNonNegativeLong())).     }     return keyAndTimestampList. }
