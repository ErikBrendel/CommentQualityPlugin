# id;timestamp;commentText;codeText;commentWords;codeWords
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1524684173;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.truststore.path", trustStorePath)_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final X509ExtendedTrustManager trustManager = sslService.sslContextHolder(config).trustManager().getTrustManager()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).trustManager().getTrustManager(), sameInstance(trustManager))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,x509extended,trust,manager,trust,manager,ssl,service,ssl,context,holder,config,trust,manager,get,trust,manager,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,trust,manager,get,trust,manager,same,instance,trust,manager
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1526449283;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.truststore.path", trustStorePath)_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1527622193;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.truststore.path", trustStorePath)_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1531179852;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.truststore.path", trustStorePath)_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1531729807;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.truststore.path", trustStorePath)_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1531910483;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1532434432;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1535666657;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1536964057;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1538509426;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1541092382;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1547152045;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1547499982;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1549035251;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1549080058;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1549316077;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,xpack,security,transport,ssl,tlsv1,2,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1549986214;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [truststore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,truststore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,trust,store,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testTrustStoreReloadException() throws Exception;1551280664;Tests the reloading of a truststore when there is an exception during reloading. An exception is caused by truncating the truststore_that is being monitored;public void testTrustStoreReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        final AtomicReference<Exception> exceptionRef = new AtomicReference<>()__        final CountDownLatch latch = new CountDownLatch(1)__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                try {_                    super.reloadSSLContext(configuration)__                } catch (Exception e) {_                    exceptionRef.set(e)__                    throw e__                } finally {_                    latch.countDown()__                }_            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream ignore = Files.newOutputStream(trustStorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        latch.await()__        assertNotNull(exceptionRef.get())__        assertThat(exceptionRef.get().getMessage(), containsString("failed to initialize a TrustManagerFactory"))__        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,truststore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,truststore,that,is,being,monitored;public,void,test,trust,store,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,final,atomic,reference,exception,exception,ref,new,atomic,reference,final,count,down,latch,latch,new,count,down,latch,1,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,try,super,reload,sslcontext,configuration,catch,exception,e,exception,ref,set,e,throw,e,finally,latch,count,down,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,ignore,files,new,output,stream,trust,store,path,standard,open,option,latch,await,assert,not,null,exception,ref,get,assert,that,exception,ref,get,get,message,contains,string,failed,to,initialize,a,trust,manager,factory,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1531910483;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1532434432;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1535666657;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1536964057;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().useProtocol("TLSv1.2").loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,use,protocol,tlsv1,2,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1538509426;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1541092382;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1547152045;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1547499982;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(trustStore, null).build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1549035251;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder()_            .loadTrustMaterial(trustStore, null)_            .setProtocol("TLSv1.2")_            .build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,set,protocol,tlsv1,2,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1549080058;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder()_            .loadTrustMaterial(trustStore, null)_            .setProtocol("TLSv1.2")_            .build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,set,protocol,tlsv1,2,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1549316077;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder()_            .loadTrustMaterial(trustStore, null)_            .setProtocol("TLSv1.2")_            .build()__        return HttpClients.custom().setSSLContext(sslContext).build()__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,set,protocol,tlsv1,2,build,return,http,clients,custom,set,sslcontext,ssl,context,build
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1549986214;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder()_            .loadTrustMaterial(trustStore, null)_            .build()__        return createHttpClient(sslContext)__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,create,http,client,ssl,context
SSLConfigurationReloaderTests -> private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,         NoSuchAlgorithmException,         KeyManagementException, IOException, CertificateException;1551280664;Creates a {@link CloseableHttpClient} that only trusts the given certificate(s)__@param trustedCertificatePaths The certificates this client trusts;private static CloseableHttpClient getSSLClient(List<Path> trustedCertificatePaths) throws KeyStoreException,_        NoSuchAlgorithmException,_        KeyManagementException, IOException, CertificateException {_        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType())__        trustStore.load(null, null)__        for (Certificate cert : CertParsingUtils.readCertificates(trustedCertificatePaths)) {_            trustStore.setCertificateEntry(cert.toString(), cert)__        }_        final SSLContext sslContext = new SSLContextBuilder()_            .loadTrustMaterial(trustStore, null)_            .build()__        return createHttpClient(sslContext)__    };creates,a,link,closeable,http,client,that,only,trusts,the,given,certificate,s,param,trusted,certificate,paths,the,certificates,this,client,trusts;private,static,closeable,http,client,get,sslclient,list,path,trusted,certificate,paths,throws,key,store,exception,no,such,algorithm,exception,key,management,exception,ioexception,certificate,exception,key,store,trust,store,key,store,get,instance,key,store,get,default,type,trust,store,load,null,null,for,certificate,cert,cert,parsing,utils,read,certificates,trusted,certificate,paths,trust,store,set,certificate,entry,cert,to,string,cert,final,sslcontext,ssl,context,new,sslcontext,builder,load,trust,material,trust,store,null,build,return,create,http,client,ssl,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1524684173;Tests reloading a keystore. The contents of the keystore is used for both keystore and truststore material, so both key_config and trust config is checked.;public void testReloadingKeyStore() throws Exception {_        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_                .put("path.home", createTempDir())_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)___        final BiConsumer<X509ExtendedKeyManager, SSLConfiguration> keyManagerPreChecks = (keyManager, config) -> {_            _            String[] aliases = keyManager.getServerAliases("RSA", null)__            assertNotNull(aliases)__            assertThat(aliases.length, is(1))__            assertThat(aliases[0], is("testnode"))__        }___        final SetOnce<Integer> trustedCount = new SetOnce<>()__        final BiConsumer<X509ExtendedTrustManager, SSLConfiguration> trustManagerPreChecks = (trustManager, config) -> {_            _            Certificate[] certificates = trustManager.getAcceptedIssuers()__            trustedCount.set(certificates.length)__        }___        final Runnable modifier = () -> {_            try {_                _                KeyStore keyStore = KeyStore.getInstance("jks")__                keyStore.load(null, null)__                final KeyPair keyPair = CertUtils.generateKeyPair(512)__                X509Certificate cert = CertUtils.generateSignedCertificate(new X500Principal("CN=testReloadingKeyStore"), null, keyPair,_                        null, null, 365)__                keyStore.setKeyEntry("key", keyPair.getPrivate(), "testnode".toCharArray(), new X509Certificate[] { cert })__                Path updated = tempDir.resolve("updated.jks")__                try (OutputStream out = Files.newOutputStream(updated)) {_                    keyStore.store(out, "testnode".toCharArray())__                }_                atomicMoveIfPossible(updated, keystorePath)__            } catch (Exception e) {_                throw new RuntimeException("modification failed", e)__            }_        }___        final BiConsumer<X509ExtendedKeyManager, SSLConfiguration> keyManagerPostChecks = (updatedKeyManager, config) -> {_            String[] aliases = updatedKeyManager.getServerAliases("RSA", null)__            assertNotNull(aliases)__            assertThat(aliases.length, is(1))__            assertThat(aliases[0], is("key"))__        }__        final BiConsumer<X509ExtendedTrustManager, SSLConfiguration> trustManagerPostChecks = (updatedTrustManager, config) -> {_            assertThat(trustedCount.get() - updatedTrustManager.getAcceptedIssuers().length, is(5))__        }__        validateSSLConfigurationIsReloaded(settings, env, keyManagerPreChecks, trustManagerPreChecks, modifier, keyManagerPostChecks,_                trustManagerPostChecks)__    };tests,reloading,a,keystore,the,contents,of,the,keystore,is,used,for,both,keystore,and,truststore,material,so,both,key,config,and,trust,config,is,checked;public,void,test,reloading,key,store,throws,exception,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,final,bi,consumer,x509extended,key,manager,sslconfiguration,key,manager,pre,checks,key,manager,config,string,aliases,key,manager,get,server,aliases,rsa,null,assert,not,null,aliases,assert,that,aliases,length,is,1,assert,that,aliases,0,is,testnode,final,set,once,integer,trusted,count,new,set,once,final,bi,consumer,x509extended,trust,manager,sslconfiguration,trust,manager,pre,checks,trust,manager,config,certificate,certificates,trust,manager,get,accepted,issuers,trusted,count,set,certificates,length,final,runnable,modifier,try,key,store,key,store,key,store,get,instance,jks,key,store,load,null,null,final,key,pair,key,pair,cert,utils,generate,key,pair,512,x509certificate,cert,cert,utils,generate,signed,certificate,new,x500principal,cn,test,reloading,key,store,null,key,pair,null,null,365,key,store,set,key,entry,key,key,pair,get,private,testnode,to,char,array,new,x509certificate,cert,path,updated,temp,dir,resolve,updated,jks,try,output,stream,out,files,new,output,stream,updated,key,store,store,out,testnode,to,char,array,atomic,move,if,possible,updated,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,bi,consumer,x509extended,key,manager,sslconfiguration,key,manager,post,checks,updated,key,manager,config,string,aliases,updated,key,manager,get,server,aliases,rsa,null,assert,not,null,aliases,assert,that,aliases,length,is,1,assert,that,aliases,0,is,key,final,bi,consumer,x509extended,trust,manager,sslconfiguration,trust,manager,post,checks,updated,trust,manager,config,assert,that,trusted,count,get,updated,trust,manager,get,accepted,issuers,length,is,5,validate,sslconfiguration,is,reloaded,settings,env,key,manager,pre,checks,trust,manager,pre,checks,modifier,key,manager,post,checks,trust,manager,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1526449283;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_                .put("path.home", createTempDir())_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    _                    KeyStore keyStore = KeyStore.getInstance("jks")__                    keyStore.load(null, null)__                    final KeyPair keyPair = CertUtils.generateKeyPair(512)__                    X509Certificate cert = CertUtils.generateSignedCertificate(new X500Principal("CN=localhost"), null, keyPair,_                        null, null, 365)__                    keyStore.setKeyEntry("key", keyPair.getPrivate(), "testnode".toCharArray(), new X509Certificate[]{cert})__                    Path updated = tempDir.resolve("updated.jks")__                    try (OutputStream out = Files.newOutputStream(updated)) {_                        keyStore.store(out, "testnode".toCharArray())__                    }_                    atomicMoveIfPossible(updated, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }__            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,key,store,key,store,key,store,get,instance,jks,key,store,load,null,null,final,key,pair,key,pair,cert,utils,generate,key,pair,512,x509certificate,cert,cert,utils,generate,signed,certificate,new,x500principal,cn,localhost,null,key,pair,null,null,365,key,store,set,key,entry,key,key,pair,get,private,testnode,to,char,array,new,x509certificate,cert,path,updated,temp,dir,resolve,updated,jks,try,output,stream,out,files,new,output,stream,updated,key,store,store,out,testnode,to,char,array,atomic,move,if,possible,updated,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1527622193;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1531179852;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1531729807;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1531910483;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1535666657;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1536964057;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1538509426;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1541092382;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1547152045;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1547499982;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1549035251;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1549080058;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1549316077;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,keystore,path,keystore,path,put,xpack,security,transport,ssl,tlsv1,2,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1549986214;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStore() throws Exception;1551280664;Tests reloading a keystore that is used in the KeyManager of SSLContext;public void testReloadingKeyStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        final Path tempDir = createTempDir()__        final Path keystorePath = tempDir.resolve("testnode.jks")__        final Path updatedKeystorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedKeystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (CloseableHttpClient client = getSSLClient(keystorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeystorePath, keystorePath)__                } catch (Exception e) {_                    throw new RuntimeException("modification failed", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, true)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,reloading,a,keystore,that,is,used,in,the,key,manager,of,sslcontext;public,void,test,reloading,key,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,final,path,temp,dir,create,temp,dir,final,path,keystore,path,temp,dir,resolve,testnode,jks,final,path,updated,keystore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,try,closeable,http,client,client,get,sslclient,keystore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,keystore,path,keystore,path,catch,exception,e,throw,new,runtime,exception,modification,failed,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,true,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1524684173;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        _        final X509ExtendedKeyManager keyManager = sslService.sslContextHolder(config).keyManager().getKeyManager()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).keyManager().getKeyManager(), sameInstance(keyManager))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,x509extended,key,manager,key,manager,ssl,service,ssl,context,holder,config,key,manager,get,key,manager,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,key,manager,get,key,manager,same,instance,key,manager
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1526449283;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1527622193;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1531179852;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1531729807;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.keystore.path", keystorePath)_                .setSecureSettings(secureSettings)_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1531910483;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1532434432;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1535666657;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1536964057;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1538509426;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1541092382;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1547152045;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1547499982;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1549035251;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1549080058;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1549316077;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,keystore,path,keystore,path,put,xpack,security,transport,ssl,tlsv1,2,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1549986214;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [keystore reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream out = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,keystore,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,out,files,new,output,stream,keystore,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingKeyStoreException() throws Exception;1551280664;Tests the reloading of a keystore when there is an exception during reloading. An exception is caused by truncating the keystore_that is being monitored;public void testReloadingKeyStoreException() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path keystorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keystorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.keystore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.keystore.path", keystorePath)_            .setSecureSettings(secureSettings)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        final AtomicReference<Exception> exceptionRef = new AtomicReference<>()__        final CountDownLatch latch = new CountDownLatch(1)__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                try {_                    super.reloadSSLContext(configuration)__                } catch (Exception e) {_                    exceptionRef.set(e)__                    throw e__                } finally {_                    latch.countDown()__                }_            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream ignore = Files.newOutputStream(keystorePath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        latch.await()__        assertNotNull(exceptionRef.get())__        assertThat(exceptionRef.get().getMessage(), containsString("failed to initialize a KeyManagerFactory"))__        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,keystore,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,keystore,that,is,being,monitored;public,void,test,reloading,key,store,exception,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,keystore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,keystore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,keystore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,keystore,path,keystore,path,set,secure,settings,secure,settings,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,final,atomic,reference,exception,exception,ref,new,atomic,reference,final,count,down,latch,latch,new,count,down,latch,1,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,try,super,reload,sslcontext,configuration,catch,exception,e,exception,ref,set,e,throw,e,finally,latch,count,down,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,ignore,files,new,output,stream,keystore,path,standard,open,option,latch,await,assert,not,null,exception,ref,get,assert,that,exception,ref,get,get,message,contains,string,failed,to,initialize,a,key,manager,factory,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> private static HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> getHttpClientConnectionFactory();1549986214;Creates our own HttpConnectionFactory that changes how the connection is closed to prevent issues with_the MockWebServer going into an endless loop based on the way that HttpClient closes its connection.;private static HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> getHttpClientConnectionFactory() {_        return (route, config) -> {_            ManagedHttpClientConnection delegate = ManagedHttpClientConnectionFactory.INSTANCE.create(route, config)__            return new ManagedHttpClientConnection() {_                @Override_                public String getId() {_                    return delegate.getId()__                }__                @Override_                public void bind(Socket socket) throws IOException {_                    delegate.bind(socket)__                }__                @Override_                public Socket getSocket() {_                    return delegate.getSocket()__                }__                @Override_                public SSLSession getSSLSession() {_                    return delegate.getSSLSession()__                }__                @Override_                public boolean isResponseAvailable(int timeout) throws IOException {_                    return delegate.isResponseAvailable(timeout)__                }__                @Override_                public void sendRequestHeader(HttpRequest request) throws HttpException, IOException {_                    delegate.sendRequestHeader(request)__                }__                @Override_                public void sendRequestEntity(HttpEntityEnclosingRequest request) throws HttpException, IOException {_                    delegate.sendRequestEntity(request)__                }__                @Override_                public HttpResponse receiveResponseHeader() throws HttpException, IOException {_                    return delegate.receiveResponseHeader()__                }__                @Override_                public void receiveResponseEntity(HttpResponse response) throws HttpException, IOException {_                    delegate.receiveResponseEntity(response)__                }__                @Override_                public void flush() throws IOException {_                    delegate.flush()__                }__                @Override_                public InetAddress getLocalAddress() {_                    return delegate.getLocalAddress()__                }__                @Override_                public int getLocalPort() {_                    return delegate.getLocalPort()__                }__                @Override_                public InetAddress getRemoteAddress() {_                    return delegate.getRemoteAddress()__                }__                @Override_                public int getRemotePort() {_                    return delegate.getRemotePort()__                }__                @Override_                public void close() throws IOException {_                    if (delegate.getSocket() instanceof SSLSocket) {_                        try (SSLSocket socket = (SSLSocket) delegate.getSocket()) {_                        }_                    }_                    delegate.close()__                }__                @Override_                public boolean isOpen() {_                    return delegate.isOpen()__                }__                @Override_                public boolean isStale() {_                    return delegate.isStale()__                }__                @Override_                public void setSocketTimeout(int timeout) {_                    delegate.setSocketTimeout(timeout)__                }__                @Override_                public int getSocketTimeout() {_                    return delegate.getSocketTimeout()__                }__                @Override_                public void shutdown() throws IOException {_                    delegate.shutdown()__                }__                @Override_                public HttpConnectionMetrics getMetrics() {_                    return delegate.getMetrics()__                }_            }__        }__    };creates,our,own,http,connection,factory,that,changes,how,the,connection,is,closed,to,prevent,issues,with,the,mock,web,server,going,into,an,endless,loop,based,on,the,way,that,http,client,closes,its,connection;private,static,http,connection,factory,http,route,managed,http,client,connection,get,http,client,connection,factory,return,route,config,managed,http,client,connection,delegate,managed,http,client,connection,factory,instance,create,route,config,return,new,managed,http,client,connection,override,public,string,get,id,return,delegate,get,id,override,public,void,bind,socket,socket,throws,ioexception,delegate,bind,socket,override,public,socket,get,socket,return,delegate,get,socket,override,public,sslsession,get,sslsession,return,delegate,get,sslsession,override,public,boolean,is,response,available,int,timeout,throws,ioexception,return,delegate,is,response,available,timeout,override,public,void,send,request,header,http,request,request,throws,http,exception,ioexception,delegate,send,request,header,request,override,public,void,send,request,entity,http,entity,enclosing,request,request,throws,http,exception,ioexception,delegate,send,request,entity,request,override,public,http,response,receive,response,header,throws,http,exception,ioexception,return,delegate,receive,response,header,override,public,void,receive,response,entity,http,response,response,throws,http,exception,ioexception,delegate,receive,response,entity,response,override,public,void,flush,throws,ioexception,delegate,flush,override,public,inet,address,get,local,address,return,delegate,get,local,address,override,public,int,get,local,port,return,delegate,get,local,port,override,public,inet,address,get,remote,address,return,delegate,get,remote,address,override,public,int,get,remote,port,return,delegate,get,remote,port,override,public,void,close,throws,ioexception,if,delegate,get,socket,instanceof,sslsocket,try,sslsocket,socket,sslsocket,delegate,get,socket,delegate,close,override,public,boolean,is,open,return,delegate,is,open,override,public,boolean,is,stale,return,delegate,is,stale,override,public,void,set,socket,timeout,int,timeout,delegate,set,socket,timeout,timeout,override,public,int,get,socket,timeout,return,delegate,get,socket,timeout,override,public,void,shutdown,throws,ioexception,delegate,shutdown,override,public,http,connection,metrics,get,metrics,return,delegate,get,metrics
SSLConfigurationReloaderTests -> private static HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> getHttpClientConnectionFactory();1551280664;Creates our own HttpConnectionFactory that changes how the connection is closed to prevent issues with_the MockWebServer going into an endless loop based on the way that HttpClient closes its connection.;private static HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> getHttpClientConnectionFactory() {_        return (route, config) -> {_            ManagedHttpClientConnection delegate = ManagedHttpClientConnectionFactory.INSTANCE.create(route, config)__            return new ManagedHttpClientConnection() {_                @Override_                public String getId() {_                    return delegate.getId()__                }__                @Override_                public void bind(Socket socket) throws IOException {_                    delegate.bind(socket)__                }__                @Override_                public Socket getSocket() {_                    return delegate.getSocket()__                }__                @Override_                public SSLSession getSSLSession() {_                    return delegate.getSSLSession()__                }__                @Override_                public boolean isResponseAvailable(int timeout) throws IOException {_                    return delegate.isResponseAvailable(timeout)__                }__                @Override_                public void sendRequestHeader(HttpRequest request) throws HttpException, IOException {_                    delegate.sendRequestHeader(request)__                }__                @Override_                public void sendRequestEntity(HttpEntityEnclosingRequest request) throws HttpException, IOException {_                    delegate.sendRequestEntity(request)__                }__                @Override_                public HttpResponse receiveResponseHeader() throws HttpException, IOException {_                    return delegate.receiveResponseHeader()__                }__                @Override_                public void receiveResponseEntity(HttpResponse response) throws HttpException, IOException {_                    delegate.receiveResponseEntity(response)__                }__                @Override_                public void flush() throws IOException {_                    delegate.flush()__                }__                @Override_                public InetAddress getLocalAddress() {_                    return delegate.getLocalAddress()__                }__                @Override_                public int getLocalPort() {_                    return delegate.getLocalPort()__                }__                @Override_                public InetAddress getRemoteAddress() {_                    return delegate.getRemoteAddress()__                }__                @Override_                public int getRemotePort() {_                    return delegate.getRemotePort()__                }__                @Override_                public void close() throws IOException {_                    if (delegate.getSocket() instanceof SSLSocket) {_                        try (SSLSocket socket = (SSLSocket) delegate.getSocket()) {_                        }_                    }_                    delegate.close()__                }__                @Override_                public boolean isOpen() {_                    return delegate.isOpen()__                }__                @Override_                public boolean isStale() {_                    return delegate.isStale()__                }__                @Override_                public void setSocketTimeout(int timeout) {_                    delegate.setSocketTimeout(timeout)__                }__                @Override_                public int getSocketTimeout() {_                    return delegate.getSocketTimeout()__                }__                @Override_                public void shutdown() throws IOException {_                    delegate.shutdown()__                }__                @Override_                public HttpConnectionMetrics getMetrics() {_                    return delegate.getMetrics()__                }_            }__        }__    };creates,our,own,http,connection,factory,that,changes,how,the,connection,is,closed,to,prevent,issues,with,the,mock,web,server,going,into,an,endless,loop,based,on,the,way,that,http,client,closes,its,connection;private,static,http,connection,factory,http,route,managed,http,client,connection,get,http,client,connection,factory,return,route,config,managed,http,client,connection,delegate,managed,http,client,connection,factory,instance,create,route,config,return,new,managed,http,client,connection,override,public,string,get,id,return,delegate,get,id,override,public,void,bind,socket,socket,throws,ioexception,delegate,bind,socket,override,public,socket,get,socket,return,delegate,get,socket,override,public,sslsession,get,sslsession,return,delegate,get,sslsession,override,public,boolean,is,response,available,int,timeout,throws,ioexception,return,delegate,is,response,available,timeout,override,public,void,send,request,header,http,request,request,throws,http,exception,ioexception,delegate,send,request,header,request,override,public,void,send,request,entity,http,entity,enclosing,request,request,throws,http,exception,ioexception,delegate,send,request,entity,request,override,public,http,response,receive,response,header,throws,http,exception,ioexception,return,delegate,receive,response,header,override,public,void,receive,response,entity,http,response,response,throws,http,exception,ioexception,delegate,receive,response,entity,response,override,public,void,flush,throws,ioexception,delegate,flush,override,public,inet,address,get,local,address,return,delegate,get,local,address,override,public,int,get,local,port,return,delegate,get,local,port,override,public,inet,address,get,remote,address,return,delegate,get,remote,address,override,public,int,get,remote,port,return,delegate,get,remote,port,override,public,void,close,throws,ioexception,if,delegate,get,socket,instanceof,sslsocket,try,sslsocket,socket,sslsocket,delegate,get,socket,delegate,close,override,public,boolean,is,open,return,delegate,is,open,override,public,boolean,is,stale,return,delegate,is,stale,override,public,void,set,socket,timeout,int,timeout,delegate,set,socket,timeout,timeout,override,public,int,get,socket,timeout,return,delegate,get,socket,timeout,override,public,void,shutdown,throws,ioexception,delegate,shutdown,override,public,http,connection,metrics,get,metrics,return,delegate,get,metrics
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1524684173;Tests the reloading of a PEM key config when the key is overwritten. The trust portion is not tested as it is not modified by this_test.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_                .put("path.home", createTempDir())_                .put("xpack.ssl.key", keyPath)_                .put("xpack.ssl.certificate", certPath)_                .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_                .setSecureSettings(secureSettings)_                .build()__        final Environment env = randomBoolean() ? null :_                TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())___        final SetOnce<PrivateKey> privateKey = new SetOnce<>()__        final BiConsumer<X509ExtendedKeyManager, SSLConfiguration> keyManagerPreChecks = (keyManager, config) -> {_            String[] aliases = keyManager.getServerAliases("RSA", null)__            assertNotNull(aliases)__            assertThat(aliases.length, is(1))__            assertThat(aliases[0], is("key"))__            privateKey.set(keyManager.getPrivateKey("key"))__            assertNotNull(privateKey.get())__        }___        final KeyPair keyPair = CertUtils.generateKeyPair(randomFrom(1024, 2048))__        final Runnable modifier = () -> {_            try {_                _                _                assertTrue(awaitBusy(() -> {_                    try {_                        BasicFileAttributes attributes = Files.readAttributes(keyPath, BasicFileAttributes.class)__                        return System.currentTimeMillis() - attributes.lastModifiedTime().toMillis() >= 1000L__                    } catch (IOException e) {_                        throw new RuntimeException("io exception while checking time", e)__                    }_                }))__                Path updatedKeyPath = tempDir.resolve("updated.pem")__                try (OutputStream os = Files.newOutputStream(updatedKeyPath)__                     OutputStreamWriter osWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8)__                     JcaPEMWriter writer = new JcaPEMWriter(osWriter)) {_                    writer.writeObject(keyPair,_                            new JcePEMEncryptorBuilder("DES-EDE3-CBC").setProvider(CertUtils.BC_PROV).build("testnode".toCharArray()))__                }_                atomicMoveIfPossible(updatedKeyPath, keyPath)__            } catch (Exception e) {_                throw new RuntimeException("failed to modify file", e)__            }_        }___        final BiConsumer<X509ExtendedKeyManager, SSLConfiguration> keyManagerPostChecks = (keyManager, config) -> {_            String[] aliases = keyManager.getServerAliases("RSA", null)__            assertNotNull(aliases)__            assertThat(aliases.length, is(1))__            assertThat(aliases[0], is("key"))__            assertThat(keyManager.getPrivateKey(aliases[0]), not(equalTo(privateKey)))__            assertThat(keyManager.getPrivateKey(aliases[0]), is(equalTo(keyPair.getPrivate())))__        }__        validateKeyConfigurationIsReloaded(settings, env, keyManagerPreChecks, modifier, keyManagerPostChecks)__    };tests,the,reloading,of,a,pem,key,config,when,the,key,is,overwritten,the,trust,portion,is,not,tested,as,it,is,not,modified,by,this,test;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,final,set,once,private,key,private,key,new,set,once,final,bi,consumer,x509extended,key,manager,sslconfiguration,key,manager,pre,checks,key,manager,config,string,aliases,key,manager,get,server,aliases,rsa,null,assert,not,null,aliases,assert,that,aliases,length,is,1,assert,that,aliases,0,is,key,private,key,set,key,manager,get,private,key,key,assert,not,null,private,key,get,final,key,pair,key,pair,cert,utils,generate,key,pair,random,from,1024,2048,final,runnable,modifier,try,assert,true,await,busy,try,basic,file,attributes,attributes,files,read,attributes,key,path,basic,file,attributes,class,return,system,current,time,millis,attributes,last,modified,time,to,millis,1000l,catch,ioexception,e,throw,new,runtime,exception,io,exception,while,checking,time,e,path,updated,key,path,temp,dir,resolve,updated,pem,try,output,stream,os,files,new,output,stream,updated,key,path,output,stream,writer,os,writer,new,output,stream,writer,os,standard,charsets,jca,pemwriter,writer,new,jca,pemwriter,os,writer,writer,write,object,key,pair,new,jce,pemencryptor,builder,des,ede3,cbc,set,provider,cert,utils,build,testnode,to,char,array,atomic,move,if,possible,updated,key,path,key,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,bi,consumer,x509extended,key,manager,sslconfiguration,key,manager,post,checks,key,manager,config,string,aliases,key,manager,get,server,aliases,rsa,null,assert,not,null,aliases,assert,that,aliases,length,is,1,assert,that,aliases,0,is,key,assert,that,key,manager,get,private,key,aliases,0,not,equal,to,private,key,assert,that,key,manager,get,private,key,aliases,0,is,equal,to,key,pair,get,private,validate,key,configuration,is,reloaded,settings,env,key,manager,pre,checks,modifier,key,manager,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1527622193;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        final Path clientTruststorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), clientTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(clientTruststorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,final,path,client,truststore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,client,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,client,truststore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1531179852;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        final Path clientTruststorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), clientTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(clientTruststorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,final,path,client,truststore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,client,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,client,truststore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1531729807;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        final Path clientTruststorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), clientTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(clientTruststorePath, "testnode")) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,final,path,client,truststore,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,client,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,client,truststore,path,testnode,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1531910483;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1532434432;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1535666657;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1536964057;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1538509426;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1541092382;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1547152045;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1547499982;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString())_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1549035251;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString())_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1549080058;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString())_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1549316077;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString())_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,put,xpack,security,transport,ssl,tlsv1,2,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1549986214;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString())_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testPEMKeyConfigReloading() throws Exception;1551280664;Tests the reloading of SSLContext when a PEM key and certificate are used.;public void testPEMKeyConfigReloading() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path updatedKeyPath = tempDir.resolve("testnode_updated.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path updatedCertPath = tempDir.resolve("testnode_updated.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.pem"), updatedKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        final Settings settings = Settings.builder()_            .put("path.home", createTempDir())_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString())_            .setSecureSettings(secureSettings)_            .build()__        final Environment env = randomBoolean() ? null :_            TestEnvironment.newEnvironment(Settings.builder().put("path.home", createTempDir()).build())__        _        try (CloseableHttpClient client = getSSLClient(Collections.singletonList(certPath))) {_            final Consumer<SSLContext> keyMaterialPreChecks = (context) -> {_                try (MockWebServer server = new MockWebServer(context, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedKeyPath, keyPath)__                    atomicMoveIfPossible(updatedCertPath, certPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> keyMaterialPostChecks = (updatedContext) -> {_                try (MockWebServer server = new MockWebServer(updatedContext, false)) {_                    server.enqueue(new MockResponse().setResponseCode(200).setBody("body"))__                    server.start()__                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Exception starting or connecting to the mock server", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, keyMaterialPreChecks, modifier, keyMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,a,pem,key,and,certificate,are,used;public,void,test,pemkey,config,reloading,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,updated,key,path,temp,dir,resolve,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,updated,cert,path,temp,dir,resolve,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,pem,updated,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,final,settings,settings,settings,builder,put,path,home,create,temp,dir,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,set,secure,settings,secure,settings,build,final,environment,env,random,boolean,null,test,environment,new,environment,settings,builder,put,path,home,create,temp,dir,build,try,closeable,http,client,client,get,sslclient,collections,singleton,list,cert,path,final,consumer,sslcontext,key,material,pre,checks,context,try,mock,web,server,server,new,mock,web,server,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,key,path,key,path,atomic,move,if,possible,updated,cert,path,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,key,material,post,checks,updated,context,try,mock,web,server,server,new,mock,web,server,updated,context,false,server,enqueue,new,mock,response,set,response,code,200,set,body,body,server,start,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,exception,starting,or,connecting,to,the,mock,server,e,validate,sslconfiguration,is,reloaded,settings,env,key,material,pre,checks,modifier,key,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1524684173;Test the reloading of a trust config that is backed by PEM certificate files. The key config is not tested as we only care about the_trust config in this test.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_                .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)___        final BiConsumer<X509ExtendedTrustManager, SSLConfiguration> trustManagerPreChecks = (trustManager, config) -> {_            _            Certificate[] certificates = trustManager.getAcceptedIssuers()__            assertThat(certificates.length, is(1))__            assertThat(((X509Certificate)certificates[0]).getSubjectX500Principal().getName(), containsString("Test Client"))__        }___        final Runnable modifier = () -> {_            try {_                Path updatedCert = tempDir.resolve("updated.crt")__                Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), updatedCert,_                        StandardCopyOption.REPLACE_EXISTING)__                atomicMoveIfPossible(updatedCert, clientCertPath)__            } catch (Exception e) {_                throw new RuntimeException("failed to modify file", e)__            }_        }___        final BiConsumer<X509ExtendedTrustManager, SSLConfiguration> trustManagerPostChecks = (updatedTrustManager, config) -> {_            Certificate[] updatedCerts = updatedTrustManager.getAcceptedIssuers()__            assertThat(updatedCerts.length, is(1))__            assertThat(((X509Certificate)updatedCerts[0]).getSubjectX500Principal().getName(), containsString("Test Node"))__        }___        validateTrustConfigurationIsReloaded(settings, env, trustManagerPreChecks, modifier, trustManagerPostChecks)__    };test,the,reloading,of,a,trust,config,that,is,backed,by,pem,certificate,files,the,key,config,is,not,tested,as,we,only,care,about,the,trust,config,in,this,test;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,bi,consumer,x509extended,trust,manager,sslconfiguration,trust,manager,pre,checks,trust,manager,config,certificate,certificates,trust,manager,get,accepted,issuers,assert,that,certificates,length,is,1,assert,that,x509certificate,certificates,0,get,subject,x500principal,get,name,contains,string,test,client,final,runnable,modifier,try,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,updated,cert,standard,copy,option,atomic,move,if,possible,updated,cert,client,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,bi,consumer,x509extended,trust,manager,sslconfiguration,trust,manager,post,checks,updated,trust,manager,config,certificate,updated,certs,updated,trust,manager,get,accepted,issuers,assert,that,updated,certs,length,is,1,assert,that,x509certificate,updated,certs,0,get,subject,x500principal,get,name,contains,string,test,node,validate,trust,configuration,is,reloaded,settings,env,trust,manager,pre,checks,modifier,trust,manager,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1526449283;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testnode.crt")__        Path keyStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keyStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), clientCertPath)__        Settings settings = Settings.builder()_                .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try(MockWebServer server = getSslServer(keyStorePath, "testnode")){_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()){_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    final KeyPair keyPair = CertUtils.generateKeyPair(512)__                    X509Certificate cert = CertUtils.generateSignedCertificate(new X500Principal("CN=localhost"), null, keyPair,_                        null, null, 365)__                    Path updatedCertPath = tempDir.resolve("updated.crt")__                    try (BufferedWriter out = Files.newBufferedWriter(updatedCertPath)__                         JcaPEMWriter pemWriter = new JcaPEMWriter(out)) {_                        pemWriter.writeObject(cert)__                    }_                    atomicMoveIfPossible(updatedCertPath, clientCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }__            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()){_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }___            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testnode,crt,path,key,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,key,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,key,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,final,key,pair,key,pair,cert,utils,generate,key,pair,512,x509certificate,cert,cert,utils,generate,signed,certificate,new,x500principal,cn,localhost,null,key,pair,null,null,365,path,updated,cert,path,temp,dir,resolve,updated,crt,try,buffered,writer,out,files,new,buffered,writer,updated,cert,path,jca,pemwriter,pem,writer,new,jca,pemwriter,out,pem,writer,write,object,cert,atomic,move,if,possible,updated,cert,path,client,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1527622193;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testnode.crt")__        Path keyStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keyStorePath)__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_ec.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(keyStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    Path updatedCert = tempDir.resolve("updated.crt")__                    Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"),_                        updatedCert, StandardCopyOption.REPLACE_EXISTING)__                    atomicMoveIfPossible(updatedCert, clientCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testnode,crt,path,key,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,key,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,key,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,standard,copy,option,atomic,move,if,possible,updated,cert,client,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1531179852;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testnode.crt")__        Path keyStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keyStorePath)__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_ec.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(keyStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    Path updatedCert = tempDir.resolve("updated.crt")__                    Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"),_                        updatedCert, StandardCopyOption.REPLACE_EXISTING)__                    atomicMoveIfPossible(updatedCert, clientCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testnode,crt,path,key,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,key,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,key,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,standard,copy,option,atomic,move,if,possible,updated,cert,client,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1531729807;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testnode.crt")__        Path keyStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), keyStorePath)__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_ec.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(keyStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    Path updatedCert = tempDir.resolve("updated.crt")__                    Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"),_                        updatedCert, StandardCopyOption.REPLACE_EXISTING)__                    atomicMoveIfPossible(updatedCert, clientCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testnode,crt,path,key,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,key,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,key,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,standard,copy,option,atomic,move,if,possible,updated,cert,client,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1531910483;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1532434432;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1535666657;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1536964057;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1538509426;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1541092382;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1547152045;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .put("xpack.ssl.certificate_authorities", serverCertPath)_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,xpack,ssl,server,cert,path,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1547499982;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", serverCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,server,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1549035251;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", serverCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())))__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,server,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1549316077;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", serverCertPath.toString())_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())))__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,server,cert,path,to,string,put,xpack,security,transport,ssl,tlsv1,2,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1549986214;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", serverCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = createHttpClient(context)) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())))__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = createHttpClient(updatedContext)) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,server,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,create,http,client,context,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,create,http,client,updated,context,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMTrustConfig() throws Exception;1551280664;Test the reloading of SSLContext whose trust config is backed by PEM certificate files.;public void testReloadingPEMTrustConfig() throws Exception {_        Path tempDir = createTempDir()__        Path serverCertPath = tempDir.resolve("testnode.crt")__        Path serverKeyPath = tempDir.resolve("testnode.pem")__        Path updatedCert = tempDir.resolve("updated.crt")__        _        _        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), serverCertPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), serverKeyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.crt"), updatedCert)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", serverCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(serverKeyPath, serverCertPath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = createHttpClient(context)) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())))__                } catch (Exception e) {_                    throw new RuntimeException("Exception connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedCert, serverCertPath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = createHttpClient(updatedContext)) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path validation failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };test,the,reloading,of,sslcontext,whose,trust,config,is,backed,by,pem,certificate,files;public,void,test,reloading,pemtrust,config,throws,exception,path,temp,dir,create,temp,dir,path,server,cert,path,temp,dir,resolve,testnode,crt,path,server,key,path,temp,dir,resolve,testnode,pem,path,updated,cert,temp,dir,resolve,updated,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,server,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,server,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,crt,updated,cert,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,server,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,server,key,path,server,cert,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,create,http,client,context,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,catch,exception,e,throw,new,runtime,exception,exception,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,cert,server,cert,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,create,http,client,updated,context,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,validation,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1524684173;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.key", keyPath)_                .put("xpack.ssl.certificate", certPath)_                .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final X509ExtendedKeyManager keyManager = sslService.sslContextHolder(config).keyManager().getKeyManager()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).keyManager().getKeyManager(), sameInstance(keyManager))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,x509extended,key,manager,key,manager,ssl,service,ssl,context,holder,config,key,manager,get,key,manager,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,key,manager,get,key,manager,same,instance,key,manager
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1526449283;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.key", keyPath)_                .put("xpack.ssl.certificate", certPath)_                .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1527622193;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.key", keyPath)_                .put("xpack.ssl.certificate", certPath)_                .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1531179852;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.key", keyPath)_                .put("xpack.ssl.certificate", certPath)_                .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1531729807;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.key", keyPath)_                .put("xpack.ssl.certificate", certPath)_                .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1531910483;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1532434432;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1535666657;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1536964057;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1538509426;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1541092382;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1547152045;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.key", keyPath)_            .put("xpack.ssl.certificate", certPath)_            .putList("xpack.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,testnode,settings,settings,settings,builder,put,xpack,ssl,key,key,path,put,xpack,ssl,certificate,cert,path,put,list,xpack,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1547499982;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1549035251;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1549080058;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1549316077;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,client,cert,path,to,string,put,xpack,security,transport,ssl,tlsv1,2,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1549986214;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem key reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream os = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,key,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,os,files,new,output,stream,key,path,standard,open,option,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingPEMKeyConfigException() throws Exception;1551280664;Tests the reloading of a key config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the key file that is being monitored;public void testReloadingPEMKeyConfigException() throws Exception {_        Path tempDir = createTempDir()__        Path keyPath = tempDir.resolve("testnode.pem")__        Path certPath = tempDir.resolve("testnode.crt")__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem"), keyPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), certPath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.secure_key_passphrase", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.key", keyPath)_            .put("xpack.security.transport.ssl.certificate", certPath)_            .putList("xpack.security.transport.ssl.certificate_authorities", certPath.toString(), clientCertPath.toString())_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.security.transport.ssl.")__        final AtomicReference<Exception> exceptionRef = new AtomicReference<>()__        final CountDownLatch latch = new CountDownLatch(1)__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                try {_                    super.reloadSSLContext(configuration)__                } catch (Exception e) {_                    exceptionRef.set(e)__                    throw e__                } finally {_                    latch.countDown()__                }_            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        try (OutputStream ignore = Files.newOutputStream(keyPath, StandardOpenOption.TRUNCATE_EXISTING)) {_        }__        latch.await()__        assertNotNull(exceptionRef.get())__        assertThat(exceptionRef.get().getMessage(), containsString("Error parsing Private Key"))__        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,key,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,key,file,that,is,being,monitored;public,void,test,reloading,pemkey,config,exception,throws,exception,path,temp,dir,create,temp,dir,path,key,path,temp,dir,resolve,testnode,pem,path,cert,path,temp,dir,resolve,testnode,crt,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,pem,key,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,crt,cert,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,key,key,path,put,xpack,security,transport,ssl,certificate,cert,path,put,list,xpack,security,transport,ssl,cert,path,to,string,client,cert,path,to,string,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,security,transport,ssl,final,atomic,reference,exception,exception,ref,new,atomic,reference,final,count,down,latch,latch,new,count,down,latch,1,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,try,super,reload,sslcontext,configuration,catch,exception,e,exception,ref,set,e,throw,e,finally,latch,count,down,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,try,output,stream,ignore,files,new,output,stream,key,path,standard,open,option,latch,await,assert,not,null,exception,ref,get,assert,that,exception,ref,get,get,message,contains,string,error,parsing,private,key,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1524684173;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_                .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final X509ExtendedTrustManager trustManager = sslService.sslContextHolder(config).trustManager().getTrustManager()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).trustManager().getTrustManager(), sameInstance(trustManager))__    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,x509extended,trust,manager,trust,manager,ssl,service,ssl,context,holder,config,trust,manager,get,trust,manager,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,trust,manager,get,trust,manager,same,instance,trust,manager
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1526449283;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_                .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_                .put("path.home", createTempDir())_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1527622193;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1531179852;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(Settings.EMPTY)__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,empty,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1531729807;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1531910483;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1532434432;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1535666657;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1536964057;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1538509426;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(settings, env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,settings,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1541092382;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1547152045;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.getSSLConfiguration("xpack.ssl")__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,get,sslconfiguration,xpack,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1547499982;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(settings.getByPrefix("xpack.security.transport.ssl."))__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,get,by,prefix,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1549035251;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(settings.getByPrefix("xpack.security.transport.ssl."))__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,get,by,prefix,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1549080058;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(settings.getByPrefix("xpack.security.transport.ssl."))__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,get,by,prefix,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1549316077;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", clientCertPath.toString())_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(settings.getByPrefix("xpack.security.transport.ssl."))__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,client,cert,path,to,string,put,xpack,security,transport,ssl,tlsv1,2,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,get,by,prefix,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1549986214;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(settings.getByPrefix("xpack.security.transport.ssl."))__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                fail("reload should not be called! [pem trust reload exception]")__            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        _        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))___    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,get,by,prefix,xpack,security,transport,ssl,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,fail,reload,should,not,be,called,pem,trust,reload,exception,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testPEMTrustReloadException() throws Exception;1551280664;Tests the reloading of a trust config backed by pem files when there is an exception during reloading. An exception is caused by_truncating the certificate file that is being monitored;public void testPEMTrustReloadException() throws Exception {_        Path tempDir = createTempDir()__        Path clientCertPath = tempDir.resolve("testclient.crt")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), clientCertPath)__        Settings settings = Settings.builder()_            .putList("xpack.security.transport.ssl.certificate_authorities", clientCertPath.toString())_            .put("path.home", createTempDir())_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        final SSLService sslService = new SSLService(settings, env)__        final SSLConfiguration config = sslService.sslConfiguration(settings.getByPrefix("xpack.security.transport.ssl."))__        final AtomicReference<Exception> exceptionRef = new AtomicReference<>()__        final CountDownLatch latch = new CountDownLatch(1)__        new SSLConfigurationReloader(env, sslService, resourceWatcherService) {_            @Override_            void reloadSSLContext(SSLConfiguration configuration) {_                try {_                    super.reloadSSLContext(configuration)__                } catch (Exception e) {_                    exceptionRef.set(e)__                    throw e__                } finally {_                    latch.countDown()__                }_            }_        }___        final SSLContext context = sslService.sslContextHolder(config).sslContext()___        _        Path updatedCert = tempDir.resolve("updated.crt")__        try (OutputStream os = Files.newOutputStream(updatedCert)) {_            os.write(randomByte())__        }_        atomicMoveIfPossible(updatedCert, clientCertPath)___        latch.await()__        assertNotNull(exceptionRef.get())__        assertThat(exceptionRef.get().getMessage(), containsString("failed to initialize a TrustManagerFactory"))__        assertThat(sslService.sslContextHolder(config).sslContext(), sameInstance(context))__    };tests,the,reloading,of,a,trust,config,backed,by,pem,files,when,there,is,an,exception,during,reloading,an,exception,is,caused,by,truncating,the,certificate,file,that,is,being,monitored;public,void,test,pemtrust,reload,exception,throws,exception,path,temp,dir,create,temp,dir,path,client,cert,path,temp,dir,resolve,testclient,crt,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testclient,crt,client,cert,path,settings,settings,settings,builder,put,list,xpack,security,transport,ssl,client,cert,path,to,string,put,path,home,create,temp,dir,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,sslservice,ssl,service,new,sslservice,settings,env,final,sslconfiguration,config,ssl,service,ssl,configuration,settings,get,by,prefix,xpack,security,transport,ssl,final,atomic,reference,exception,exception,ref,new,atomic,reference,final,count,down,latch,latch,new,count,down,latch,1,new,sslconfiguration,reloader,env,ssl,service,resource,watcher,service,override,void,reload,sslcontext,sslconfiguration,configuration,try,super,reload,sslcontext,configuration,catch,exception,e,exception,ref,set,e,throw,e,finally,latch,count,down,final,sslcontext,context,ssl,service,ssl,context,holder,config,ssl,context,path,updated,cert,temp,dir,resolve,updated,crt,try,output,stream,os,files,new,output,stream,updated,cert,os,write,random,byte,atomic,move,if,possible,updated,cert,client,cert,path,latch,await,assert,not,null,exception,ref,get,assert,that,exception,ref,get,get,message,contains,string,failed,to,initialize,a,trust,manager,factory,assert,that,ssl,service,ssl,context,holder,config,ssl,context,same,instance,context
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1524684173;Tests the reloading of the trust config when the trust store is modified. The key config is not tested as part of this test.;public void testReloadingTrustStore() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_                .put("xpack.ssl.truststore.path", trustStorePath)_                .put("path.home", createTempDir())_                .setSecureSettings(secureSettings)_                .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)___        final SetOnce<Integer> trustedCount = new SetOnce<>()__        final BiConsumer<X509ExtendedTrustManager, SSLConfiguration> trustManagerPreChecks = (trustManager, config) -> {_            _            Certificate[] certificates = trustManager.getAcceptedIssuers()__            trustedCount.set(certificates.length)__        }____        final Runnable modifier = () -> {_            try {_                Path updatedTruststore = tempDir.resolve("updated.jks")__                KeyStore keyStore = KeyStore.getInstance("jks")__                keyStore.load(null, null)__                try (OutputStream out = Files.newOutputStream(updatedTruststore)) {_                    keyStore.store(out, "testnode".toCharArray())__                }_                atomicMoveIfPossible(updatedTruststore, trustStorePath)__            } catch (Exception e) {_                throw new RuntimeException("failed to modify file", e)__            }_        }___        final BiConsumer<X509ExtendedTrustManager, SSLConfiguration> trustManagerPostChecks = (updatedTrustManager, config) -> {_            assertThat(trustedCount.get() - updatedTrustManager.getAcceptedIssuers().length, is(6))__        }___        validateTrustConfigurationIsReloaded(settings, env, trustManagerPreChecks, modifier, trustManagerPostChecks)__    };tests,the,reloading,of,the,trust,config,when,the,trust,store,is,modified,the,key,config,is,not,tested,as,part,of,this,test;public,void,test,reloading,trust,store,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,final,set,once,integer,trusted,count,new,set,once,final,bi,consumer,x509extended,trust,manager,sslconfiguration,trust,manager,pre,checks,trust,manager,config,certificate,certificates,trust,manager,get,accepted,issuers,trusted,count,set,certificates,length,final,runnable,modifier,try,path,updated,truststore,temp,dir,resolve,updated,jks,key,store,key,store,key,store,get,instance,jks,key,store,load,null,null,try,output,stream,out,files,new,output,stream,updated,truststore,key,store,store,out,testnode,to,char,array,atomic,move,if,possible,updated,truststore,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,bi,consumer,x509extended,trust,manager,sslconfiguration,trust,manager,post,checks,updated,trust,manager,config,assert,that,trusted,count,get,updated,trust,manager,get,accepted,issuers,length,is,6,validate,trust,configuration,is,reloaded,settings,env,trust,manager,pre,checks,modifier,trust,manager,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1526449283;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try(MockWebServer server = getSslServer(trustStorePath, "testnode")){_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()){_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    Path updatedTrustStore = tempDir.resolve("updated.jks")__                    KeyStore keyStore = KeyStore.getInstance("jks")__                    keyStore.load(null, null)__                    final KeyPair keyPair = CertUtils.generateKeyPair(512)__                    X509Certificate cert = CertUtils.generateSignedCertificate(new X500Principal("CN=localhost"), null, keyPair,_                        null, null, 365)__                    keyStore.setKeyEntry("newKey", keyPair.getPrivate(), "testnode".toCharArray(), new Certificate[]{cert})__                    try (OutputStream out = Files.newOutputStream(updatedTrustStore)) {_                        keyStore.store(out, "testnode".toCharArray())__                    }_                    atomicMoveIfPossible(updatedTrustStore, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()){_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }___            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,path,updated,trust,store,temp,dir,resolve,updated,jks,key,store,key,store,key,store,get,instance,jks,key,store,load,null,null,final,key,pair,key,pair,cert,utils,generate,key,pair,512,x509certificate,cert,cert,utils,generate,signed,certificate,new,x500principal,cn,localhost,null,key,pair,null,null,365,key,store,set,key,entry,new,key,key,pair,get,private,testnode,to,char,array,new,certificate,cert,try,output,stream,out,files,new,output,stream,updated,trust,store,key,store,store,out,testnode,to,char,array,atomic,move,if,possible,updated,trust,store,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1527622193;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"), updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1531179852;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1531729807;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1531910483;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1535666657;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1536964057;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1538509426;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1541092382;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1547152045;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1547499982;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1549035251;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1549316077;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("xpack.security.transport.ssl.supported_protocols", "TLSv1.2")_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = HttpClients.custom().setSSLContext(updatedContext).build()) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,xpack,security,transport,ssl,tlsv1,2,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,context,build,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,http,clients,custom,set,sslcontext,updated,context,build,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1549986214;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = createHttpClient(context)) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = createHttpClient(updatedContext)) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,create,http,client,context,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,create,http,client,updated,context,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
SSLConfigurationReloaderTests -> public void testReloadingTrustStore() throws Exception;1551280664;Tests the reloading of SSLContext when the trust store is modified. The same store is used as a TrustStore (for the_reloadable SSLContext used in the HTTPClient) and as a KeyStore for the MockWebServer;public void testReloadingTrustStore() throws Exception {_        assumeFalse("Can't run in a FIPS JVM", inFipsJvm())__        Path tempDir = createTempDir()__        Path trustStorePath = tempDir.resolve("testnode.jks")__        Path updatedTruststorePath = tempDir.resolve("testnode_updated.jks")__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks"), trustStorePath)__        Files.copy(getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks"),_            updatedTruststorePath)__        MockSecureSettings secureSettings = new MockSecureSettings()__        secureSettings.setString("xpack.security.transport.ssl.truststore.secure_password", "testnode")__        Settings settings = Settings.builder()_            .put("xpack.security.transport.ssl.truststore.path", trustStorePath)_            .put("path.home", createTempDir())_            .setSecureSettings(secureSettings)_            .build()__        Environment env = randomBoolean() ? null : TestEnvironment.newEnvironment(settings)__        _        try (MockWebServer server = getSslServer(trustStorePath, "testnode")) {_            final Consumer<SSLContext> trustMaterialPreChecks = (context) -> {_                try (CloseableHttpClient client = createHttpClient(context)) {_                    privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close())__                } catch (Exception e) {_                    throw new RuntimeException("Error connecting to the mock server", e)__                }_            }___            final Runnable modifier = () -> {_                try {_                    atomicMoveIfPossible(updatedTruststorePath, trustStorePath)__                } catch (Exception e) {_                    throw new RuntimeException("failed to modify file", e)__                }_            }___            _            final Consumer<SSLContext> trustMaterialPostChecks = (updatedContext) -> {_                try (CloseableHttpClient client = createHttpClient(updatedContext)) {_                    SSLHandshakeException sslException = expectThrows(SSLHandshakeException.class, () ->_                        privilegedConnect(() -> client.execute(new HttpGet("https://localhost:" + server.getPort())).close()))__                    assertThat(sslException.getCause().getMessage(), containsString("PKIX path building failed"))__                } catch (Exception e) {_                    throw new RuntimeException("Error closing CloseableHttpClient", e)__                }_            }__            validateSSLConfigurationIsReloaded(settings, env, trustMaterialPreChecks, modifier, trustMaterialPostChecks)__        }_    };tests,the,reloading,of,sslcontext,when,the,trust,store,is,modified,the,same,store,is,used,as,a,trust,store,for,the,reloadable,sslcontext,used,in,the,httpclient,and,as,a,key,store,for,the,mock,web,server;public,void,test,reloading,trust,store,throws,exception,assume,false,can,t,run,in,a,fips,jvm,in,fips,jvm,path,temp,dir,create,temp,dir,path,trust,store,path,temp,dir,resolve,testnode,jks,path,updated,truststore,path,temp,dir,resolve,jks,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,testnode,jks,trust,store,path,files,copy,get,data,path,org,elasticsearch,xpack,security,transport,ssl,certs,simple,jks,updated,truststore,path,mock,secure,settings,secure,settings,new,mock,secure,settings,secure,settings,set,string,xpack,security,transport,ssl,truststore,testnode,settings,settings,settings,builder,put,xpack,security,transport,ssl,truststore,path,trust,store,path,put,path,home,create,temp,dir,set,secure,settings,secure,settings,build,environment,env,random,boolean,null,test,environment,new,environment,settings,try,mock,web,server,server,get,ssl,server,trust,store,path,testnode,final,consumer,sslcontext,trust,material,pre,checks,context,try,closeable,http,client,client,create,http,client,context,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,catch,exception,e,throw,new,runtime,exception,error,connecting,to,the,mock,server,e,final,runnable,modifier,try,atomic,move,if,possible,updated,truststore,path,trust,store,path,catch,exception,e,throw,new,runtime,exception,failed,to,modify,file,e,final,consumer,sslcontext,trust,material,post,checks,updated,context,try,closeable,http,client,client,create,http,client,updated,context,sslhandshake,exception,ssl,exception,expect,throws,sslhandshake,exception,class,privileged,connect,client,execute,new,http,get,https,localhost,server,get,port,close,assert,that,ssl,exception,get,cause,get,message,contains,string,pkix,path,building,failed,catch,exception,e,throw,new,runtime,exception,error,closing,closeable,http,client,e,validate,sslconfiguration,is,reloaded,settings,env,trust,material,pre,checks,modifier,trust,material,post,checks
