commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Info createTestInstance() {     return new Info(randomBoolean(), randomIntBetween(0, 10000), randomBoolean()). }
false;protected;1;4;;@Override protected Info doParseInstance(XContentParser parser) throws IOException {     return Info.PARSER.apply(parser, null). }
false;protected;0;4;;@Override protected boolean supportsUnknownFields() {     return false. }
false;public,final;0;5;;public final void testEqualsAndHashcode() {     for (int runs = 0. runs < NUMBER_OF_TEST_RUNS. runs++) {         EqualsHashCodeTestUtils.checkEqualsAndHashCode(createTestInstance(), this::copyInstance, this::mutateInstance).     } }
false;protected,final;1;3;;protected final Info copyInstance(Info instance) throws IOException {     return new Info(instance.shrunkIndexExists(), instance.getActualShards(), instance.allShardsActive()). }
false;protected;1;19;;protected Info mutateInstance(Info instance) throws IOException {     boolean shrunkIndexExists = instance.shrunkIndexExists().     int actualShards = instance.getActualShards().     boolean allShardsActive = instance.allShardsActive().     switch(between(0, 2)) {         case 0:             shrunkIndexExists = shrunkIndexExists == false.             break.         case 1:             actualShards += between(1, 20).             break.         case 2:             allShardsActive = allShardsActive == false.             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new Info(shrunkIndexExists, actualShards, allShardsActive). }
