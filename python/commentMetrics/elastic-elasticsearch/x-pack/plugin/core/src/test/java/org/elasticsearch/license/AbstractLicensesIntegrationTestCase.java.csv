commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(XPackSettings.SECURITY_ENABLED.getKey(), false).build(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(LocalStateCompositeXPackPlugin.class, CommonAnalysisPlugin.class). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return Arrays.asList(XPackClientPlugin.class, CommonAnalysisPlugin.class). }
false;protected;0;5;;@Override protected Settings transportClientSettings() {     // Plugin should be loaded on the transport client as well     return nodeSettings(0). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     latch.countDown(). }
false;public;1;6;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).     mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(license, null)).     return ClusterState.builder(currentState).metaData(mdBuilder).build(). }
false;public;2;4;;@Override public void onFailure(String source, @Nullable Exception e) {     logger.error("error on metaData cleanup after test", e). }
false;protected;1;23;;protected void putLicense(final License license) throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(1).     ClusterService clusterService = internalCluster().getInstance(ClusterService.class, internalCluster().getMasterName()).     clusterService.submitStateUpdateTask("putting license", new ClusterStateUpdateTask() {          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             latch.countDown().         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).             mdBuilder.putCustom(LicensesMetaData.TYPE, new LicensesMetaData(license, null)).             return ClusterState.builder(currentState).metaData(mdBuilder).build().         }          @Override         public void onFailure(String source, @Nullable Exception e) {             logger.error("error on metaData cleanup after test", e).         }     }).     latch.await(). }
false;protected;0;3;;protected void putLicenseTombstone() throws InterruptedException {     putLicense(LicensesMetaData.LICENSE_TOMBSTONE). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     latch.countDown(). }
false;public;1;6;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).     mdBuilder.removeCustom(LicensesMetaData.TYPE).     return ClusterState.builder(currentState).metaData(mdBuilder).build(). }
false;public;2;4;;@Override public void onFailure(String source, @Nullable Exception e) {     logger.error("error on metaData cleanup after test", e). }
false;protected;0;23;;protected void wipeAllLicenses() throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(1).     ClusterService clusterService = internalCluster().getInstance(ClusterService.class, internalCluster().getMasterName()).     clusterService.submitStateUpdateTask("delete licensing metadata", new ClusterStateUpdateTask() {          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             latch.countDown().         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).             mdBuilder.removeCustom(LicensesMetaData.TYPE).             return ClusterState.builder(currentState).metaData(mdBuilder).build().         }          @Override         public void onFailure(String source, @Nullable Exception e) {             logger.error("error on metaData cleanup after test", e).         }     }).     latch.await(). }
false;protected;1;11;;protected void assertLicenseActive(boolean active) throws InterruptedException {     boolean success = awaitBusy(() -> {         for (XPackLicenseState licenseState : internalCluster().getDataNodeInstances(XPackLicenseState.class)) {             if (licenseState.isActive() == active) {                 return true.             }         }         return false.     }).     assertTrue(success). }
