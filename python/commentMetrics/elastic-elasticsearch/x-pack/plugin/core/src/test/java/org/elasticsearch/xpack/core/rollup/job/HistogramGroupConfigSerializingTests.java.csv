commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected HistogramGroupConfig doParseInstance(XContentParser parser) throws IOException {     return HistogramGroupConfig.fromXContent(parser). }
false;protected;0;4;;@Override protected Writeable.Reader<HistogramGroupConfig> instanceReader() {     return HistogramGroupConfig::new. }
false;protected;0;4;;@Override protected HistogramGroupConfig createTestInstance() {     return randomHistogramGroupConfig(random()). }
false;public;0;9;;public void testValidateNoMapping() throws IOException {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     HistogramGroupConfig config = new HistogramGroupConfig(132, "my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("Could not find a [numeric] field with name [my_field] in any of the " + "indices matching the index pattern.")). }
false;public;0;14;;public void testValidateNomatchingField() throws IOException {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     responseMap.put("some_other_field", Collections.singletonMap("long", fieldCaps)).     HistogramGroupConfig config = new HistogramGroupConfig(132, "my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("Could not find a [numeric] field with name [my_field] in any of the " + "indices matching the index pattern.")). }
false;public;0;14;;public void testValidateFieldWrongType() throws IOException {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     responseMap.put("my_field", Collections.singletonMap("keyword", fieldCaps)).     HistogramGroupConfig config = new HistogramGroupConfig(132, "my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field referenced by a histo group must be a [numeric] type, but " + "found [keyword] for field [my_field]")). }
false;public;0;14;;public void testValidateFieldMatchingNotAggregatable() throws IOException {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(false).     responseMap.put("my_field", Collections.singletonMap("long", fieldCaps)).     HistogramGroupConfig config = new HistogramGroupConfig(132, "my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field [my_field] must be aggregatable across all indices, but is not.")). }
false;public;0;14;;public void testValidateMatchingField() throws IOException {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(true).     String mappingType = randomFrom(RollupField.NUMERIC_FIELD_MAPPER_TYPES).     responseMap.put("my_field", Collections.singletonMap(mappingType, fieldCaps)).     HistogramGroupConfig config = new HistogramGroupConfig(132, "my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().size(), equalTo(0)). }
