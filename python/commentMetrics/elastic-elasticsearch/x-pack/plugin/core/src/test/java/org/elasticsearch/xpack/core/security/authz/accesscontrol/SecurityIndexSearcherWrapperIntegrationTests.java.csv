commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;@Override public void onCache(ShardId shardId, Accountable accountable) { }
false;public;2;4;;@Override public void onRemoval(ShardId shardId, Accountable accountable) { }
false;protected;0;4;;@Override protected IndicesAccessControl getIndicesAccessControl() {     return new IndicesAccessControl(true, singletonMap("_index", indexAccessControl)). }
false;public;0;107;;public void testDLS() throws Exception {     ShardId shardId = new ShardId("_index", "_na_", 0).     MapperService mapperService = mock(MapperService.class).     ScriptService scriptService = mock(ScriptService.class).     when(mapperService.documentMapper()).thenReturn(null).     when(mapperService.simpleMatchToFullName(anyString())).then(invocationOnMock -> Collections.singletonList((String) invocationOnMock.getArguments()[0])).     ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     final Authentication authentication = mock(Authentication.class).     when(authentication.getUser()).thenReturn(mock(User.class)).     threadContext.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication).     IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.filteredBy(singleton(new BytesArray("{\"match_all\" : {}}")))).     IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(shardId.getIndex(), Settings.EMPTY).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     final long nowInMillis = randomNonNegativeLong().     QueryShardContext realQueryShardContext = new QueryShardContext(shardId.id(), indexSettings, null, null, mapperService, null, null, xContentRegistry(), writableRegistry(), client, null, () -> nowInMillis, null).     QueryShardContext queryShardContext = spy(realQueryShardContext).     IndexSettings settings = IndexSettingsModule.newIndexSettings("_index", Settings.EMPTY).     BitsetFilterCache bitsetFilterCache = new BitsetFilterCache(settings, new BitsetFilterCache.Listener() {          @Override         public void onCache(ShardId shardId, Accountable accountable) {         }          @Override         public void onRemoval(ShardId shardId, Accountable accountable) {         }     }).     XPackLicenseState licenseState = mock(XPackLicenseState.class).     when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(true).     SecurityIndexSearcherWrapper wrapper = new SecurityIndexSearcherWrapper(s -> queryShardContext, bitsetFilterCache, threadContext, licenseState, scriptService) {          @Override         protected IndicesAccessControl getIndicesAccessControl() {             return new IndicesAccessControl(true, singletonMap("_index", indexAccessControl)).         }     }.     Directory directory = newDirectory().     IndexWriter iw = new IndexWriter(directory, new IndexWriterConfig(new StandardAnalyzer()).setMergePolicy(NoMergePolicy.INSTANCE)).     int numValues = scaledRandomIntBetween(2, 16).     String[] values = new String[numValues].     for (int i = 0. i < numValues. i++) {         values[i] = "value" + i.     }     int[] valuesHitCount = new int[numValues].     int numDocs = scaledRandomIntBetween(32, 128).     int commitAfter = scaledRandomIntBetween(1, numDocs).     logger.info("Going to index [{}] documents with [{}] unique values and commit after [{}] documents have been indexed", numDocs, numValues, commitAfter).     for (int doc = 1. doc <= numDocs. doc++) {         int valueIndex = (numValues - 1) % doc.         Document document = new Document().         String id = String.valueOf(doc).         document.add(new StringField("id", id, Field.Store.NO)).         String value = values[valueIndex].         document.add(new StringField("field", value, Field.Store.NO)).         iw.addDocument(document).         if (doc % 11 == 0) {             iw.deleteDocuments(new Term("id", id)).         } else {             if (commitAfter % commitAfter == 0) {                 iw.commit().             }             valuesHitCount[valueIndex]++.         }     }     iw.close().     StringBuilder valueToHitCountOutput = new StringBuilder().     for (int i = 0. i < numValues. i++) {         valueToHitCountOutput.append(values[i]).append('\t').append(valuesHitCount[i]).append('\n').     }     logger.info("Value count matrix:\n{}", valueToHitCountOutput).     DirectoryReader directoryReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), shardId).     for (int i = 0. i < numValues. i++) {         ParsedQuery parsedQuery = new ParsedQuery(new TermQuery(new Term("field", values[i]))).         doReturn(new TermQueryBuilder("field", values[i])).when(queryShardContext).parseInnerQueryBuilder(any(XContentParser.class)).         when(queryShardContext.toQuery(new TermsQueryBuilder("field", values[i]))).thenReturn(parsedQuery).         DirectoryReader wrappedDirectoryReader = wrapper.wrap(directoryReader).         IndexSearcher indexSearcher = wrapper.wrap(new IndexSearcher(wrappedDirectoryReader)).         int expectedHitCount = valuesHitCount[i].         logger.info("Going to verify hit count with query [{}] with expected total hits [{}]", parsedQuery.query(), expectedHitCount).         TotalHitCountCollector countCollector = new TotalHitCountCollector().         indexSearcher.search(new MatchAllDocsQuery(), countCollector).         assertThat(countCollector.getTotalHits(), equalTo(expectedHitCount)).         assertThat(wrappedDirectoryReader.numDocs(), equalTo(expectedHitCount)).     }     bitsetFilterCache.close().     directoryReader.close().     directory.close(). }
false;public;2;3;;@Override public void onCache(ShardId shardId, Accountable accountable) { }
false;public;2;3;;@Override public void onRemoval(ShardId shardId, Accountable accountable) { }
false;protected;0;10;;@Override protected IndicesAccessControl getIndicesAccessControl() {     IndicesAccessControl indicesAccessControl = new IndicesAccessControl(true, singletonMap("_index", indexAccessControl)).     if (noFilteredIndexPermissions) {         return indicesAccessControl.     }     IndicesAccessControl limitedByIndicesAccessControl = new IndicesAccessControl(true, singletonMap("_index", limitedIndexAccessControl)).     return indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl). }
false;public;0;110;;public void testDLSWithLimitedPermissions() throws Exception {     ShardId shardId = new ShardId("_index", "_na_", 0).     MapperService mapperService = mock(MapperService.class).     ScriptService scriptService = mock(ScriptService.class).     when(mapperService.documentMapper()).thenReturn(null).     when(mapperService.simpleMatchToFullName(anyString())).then(invocationOnMock -> Collections.singletonList((String) invocationOnMock.getArguments()[0])).     ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     final Authentication authentication = mock(Authentication.class).     when(authentication.getUser()).thenReturn(mock(User.class)).     threadContext.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication).     final boolean noFilteredIndexPermissions = randomBoolean().     boolean restrictiveLimitedIndexPermissions = false.     if (noFilteredIndexPermissions == false) {         restrictiveLimitedIndexPermissions = randomBoolean().     }     Set<BytesReference> queries = new HashSet<>().     queries.add(new BytesArray("{\"terms\" : { \"f2\" : [\"fv22\"] } }")).     queries.add(new BytesArray("{\"terms\" : { \"f2\" : [\"fv32\"] } }")).     IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.filteredBy(queries)).     queries = singleton(new BytesArray("{\"terms\" : { \"f1\" : [\"fv11\", \"fv21\", \"fv31\"] } }")).     if (restrictiveLimitedIndexPermissions) {         queries = singleton(new BytesArray("{\"terms\" : { \"f1\" : [\"fv11\", \"fv31\"] } }")).     }     IndicesAccessControl.IndexAccessControl limitedIndexAccessControl = new IndicesAccessControl.IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.filteredBy(queries)).     IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(shardId.getIndex(), Settings.EMPTY).     Client client = mock(Client.class).     when(client.settings()).thenReturn(Settings.EMPTY).     final long nowInMillis = randomNonNegativeLong().     QueryShardContext realQueryShardContext = new QueryShardContext(shardId.id(), indexSettings, null, null, mapperService, null, null, xContentRegistry(), writableRegistry(), client, null, () -> nowInMillis, null).     QueryShardContext queryShardContext = spy(realQueryShardContext).     IndexSettings settings = IndexSettingsModule.newIndexSettings("_index", Settings.EMPTY).     BitsetFilterCache bitsetFilterCache = new BitsetFilterCache(settings, new BitsetFilterCache.Listener() {          @Override         public void onCache(ShardId shardId, Accountable accountable) {         }          @Override         public void onRemoval(ShardId shardId, Accountable accountable) {         }     }).     XPackLicenseState licenseState = mock(XPackLicenseState.class).     when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(true).     SecurityIndexSearcherWrapper wrapper = new SecurityIndexSearcherWrapper(s -> queryShardContext, bitsetFilterCache, threadContext, licenseState, scriptService) {          @Override         protected IndicesAccessControl getIndicesAccessControl() {             IndicesAccessControl indicesAccessControl = new IndicesAccessControl(true, singletonMap("_index", indexAccessControl)).             if (noFilteredIndexPermissions) {                 return indicesAccessControl.             }             IndicesAccessControl limitedByIndicesAccessControl = new IndicesAccessControl(true, singletonMap("_index", limitedIndexAccessControl)).             return indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl).         }     }.     Directory directory = newDirectory().     IndexWriter iw = new IndexWriter(directory, new IndexWriterConfig(new StandardAnalyzer()).setMergePolicy(NoMergePolicy.INSTANCE)).     Document doc1 = new Document().     doc1.add(new StringField("f1", "fv11", Store.NO)).     doc1.add(new StringField("f2", "fv12", Store.NO)).     iw.addDocument(doc1).     Document doc2 = new Document().     doc2.add(new StringField("f1", "fv21", Store.NO)).     doc2.add(new StringField("f2", "fv22", Store.NO)).     iw.addDocument(doc2).     Document doc3 = new Document().     doc3.add(new StringField("f1", "fv31", Store.NO)).     doc3.add(new StringField("f2", "fv32", Store.NO)).     iw.addDocument(doc3).     iw.commit().     iw.close().     DirectoryReader directoryReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), shardId).     DirectoryReader wrappedDirectoryReader = wrapper.wrap(directoryReader).     IndexSearcher indexSearcher = wrapper.wrap(new IndexSearcher(wrappedDirectoryReader)).     ScoreDoc[] hits = indexSearcher.search(new MatchAllDocsQuery(), 1000).scoreDocs.     Set<Integer> actualDocIds = new HashSet<>().     for (ScoreDoc doc : hits) {         actualDocIds.add(doc.doc).     }     if (noFilteredIndexPermissions) {         assertThat(actualDocIds, containsInAnyOrder(1, 2)).     } else {         if (restrictiveLimitedIndexPermissions) {             assertThat(actualDocIds, containsInAnyOrder(2)).         } else {             assertThat(actualDocIds, containsInAnyOrder(1, 2)).         }     }     bitsetFilterCache.close().     directoryReader.close().     directory.close(). }
