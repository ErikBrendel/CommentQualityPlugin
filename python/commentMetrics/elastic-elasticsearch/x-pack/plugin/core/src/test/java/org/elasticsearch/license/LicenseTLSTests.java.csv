commented;modifiers;parameterAmount;loc;comment;code
false;public;0;27;;public void testApplyLicenseInDevMode() throws Exception {     License newLicense = TestUtils.generateSignedLicense(randomFrom("gold", "platinum"), TimeValue.timeValueHours(24L)).     PutLicenseRequest request = new PutLicenseRequest().     request.acknowledge(true).     request.license(newLicense).     Settings settings = Settings.builder().put("xpack.security.enabled", true).build().     XPackLicenseState licenseState = new XPackLicenseState(settings).     inetAddress = InetAddress.getLoopbackAddress().     setInitialState(null, licenseState, settings).     licenseService.start().     PlainActionFuture<PutLicenseResponse> responseFuture = new PlainActionFuture<>().     licenseService.registerLicense(request, responseFuture).     verify(clusterService).submitStateUpdateTask(any(String.class), any(ClusterStateUpdateTask.class)).     inetAddress = TransportAddress.META_ADDRESS.     settings = Settings.builder().put("xpack.security.enabled", true).put("discovery.type", "single-node").build().     licenseService.stop().     licenseState = new XPackLicenseState(settings).     setInitialState(null, licenseState, settings).     licenseService.start().     licenseService.registerLicense(request, responseFuture).     verify(clusterService, times(2)).submitStateUpdateTask(any(String.class), any(ClusterStateUpdateTask.class)). }
false;public;0;36;;public void testApplyLicenseInProdMode() throws Exception {     final String licenseType = randomFrom("GOLD", "PLATINUM").     License newLicense = TestUtils.generateSignedLicense(licenseType, TimeValue.timeValueHours(24L)).     PutLicenseRequest request = new PutLicenseRequest().     request.acknowledge(true).     request.license(newLicense).     Settings settings = Settings.builder().put("xpack.security.enabled", true).build().     XPackLicenseState licenseState = new XPackLicenseState(settings).     inetAddress = TransportAddress.META_ADDRESS.     setInitialState(null, licenseState, settings).     licenseService.start().     PlainActionFuture<PutLicenseResponse> responseFuture = new PlainActionFuture<>().     IllegalStateException e = expectThrows(IllegalStateException.class, () -> licenseService.registerLicense(request, responseFuture)).     assertThat(e.getMessage(), containsString("Cannot install a [" + licenseType + "] license unless TLS is configured or security is disabled")).     settings = Settings.builder().put("xpack.security.enabled", false).build().     licenseService.stop().     licenseState = new XPackLicenseState(settings).     setInitialState(null, licenseState, settings).     licenseService.start().     licenseService.registerLicense(request, responseFuture).     verify(clusterService).submitStateUpdateTask(any(String.class), any(ClusterStateUpdateTask.class)).     settings = Settings.builder().put("xpack.security.enabled", true).put("xpack.security.transport.ssl.enabled", true).build().     licenseService.stop().     licenseState = new XPackLicenseState(settings).     setInitialState(null, licenseState, settings).     licenseService.start().     licenseService.registerLicense(request, responseFuture).     verify(clusterService, times(2)).submitStateUpdateTask(any(String.class), any(ClusterStateUpdateTask.class)). }
false;protected;0;5;;@Override protected DiscoveryNode getLocalNode() {     return new DiscoveryNode("localnode", new TransportAddress(inetAddress, randomIntBetween(9300, 9399)), emptyMap(), emptySet(), Version.CURRENT). }
