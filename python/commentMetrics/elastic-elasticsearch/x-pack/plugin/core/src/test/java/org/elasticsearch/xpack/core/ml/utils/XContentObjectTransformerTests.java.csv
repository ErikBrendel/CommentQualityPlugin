commented;modifiers;parameterAmount;loc;comment;code
false;public;0;28;;public void testFromMap() throws IOException {     Map<String, Object> aggMap = Collections.singletonMap("fieldName", Collections.singletonMap("max", Collections.singletonMap("field", "fieldName"))).     XContentObjectTransformer<AggregatorFactories.Builder> aggTransformer = XContentObjectTransformer.aggregatorTransformer().     assertXContentAreEqual(aggTransformer.fromMap(aggMap), aggMap).     assertXContentAreEqual(aggTransformer.fromMap(aggMap), aggTransformer.toMap(aggTransformer.fromMap(aggMap))).     Map<String, Object> queryMap = Collections.singletonMap("match", Collections.singletonMap("fieldName", new HashMap<String, Object>() {          {             // Add all the default fields so they are not added dynamically when the object is parsed             put("query", "fieldValue").             put("operator", "OR").             put("prefix_length", 0).             put("max_expansions", 50).             put("fuzzy_transpositions", true).             put("lenient", false).             put("zero_terms_query", "NONE").             put("auto_generate_synonyms_phrase_query", true).             put("boost", 1.0).         }     })).     XContentObjectTransformer<QueryBuilder> queryBuilderTransformer = XContentObjectTransformer.queryBuilderTransformer().     assertXContentAreEqual(queryBuilderTransformer.fromMap(queryMap), queryMap).     assertXContentAreEqual(queryBuilderTransformer.fromMap(queryMap), queryBuilderTransformer.toMap(queryBuilderTransformer.fromMap(queryMap))). }
false;public;0;23;;public void testFromMapWithBadMaps() {     Map<String, Object> queryMap = Collections.singletonMap("match", Collections.singletonMap("airline", new HashMap<String, Object>() {          {             put("query", "notSupported").             // phrase stopped being supported for match in 6.x             put("type", "phrase").         }     })).     XContentObjectTransformer<QueryBuilder> queryBuilderTransformer = XContentObjectTransformer.queryBuilderTransformer().     ParsingException exception = expectThrows(ParsingException.class, () -> queryBuilderTransformer.fromMap(queryMap)).     assertThat(exception.getMessage(), equalTo("[match] query does not support [type]")).     Map<String, Object> aggMap = Collections.singletonMap("badTerms", Collections.singletonMap("terms", new HashMap<String, Object>() {          {             // size being 0 in terms agg stopped being supported in 6.x             put("size", 0).             put("field", "myField").         }     })).     XContentObjectTransformer<AggregatorFactories.Builder> aggTransformer = XContentObjectTransformer.aggregatorTransformer().     XContentParseException xContentParseException = expectThrows(XContentParseException.class, () -> aggTransformer.fromMap(aggMap)).     assertThat(xContentParseException.getMessage(), containsString("[terms] failed to parse field [size]")). }
false;public;0;19;;public void testToMap() throws IOException {     XContentObjectTransformer<AggregatorFactories.Builder> aggTransformer = XContentObjectTransformer.aggregatorTransformer().     XContentObjectTransformer<QueryBuilder> queryBuilderTransformer = XContentObjectTransformer.queryBuilderTransformer().     AggregatorFactories.Builder aggs = new AggregatorFactories.Builder().     long aggHistogramInterval = randomNonNegativeLong().     MaxAggregationBuilder maxTime = AggregationBuilders.max("time").field("time").     aggs.addAggregator(AggregationBuilders.dateHistogram("buckets").interval(aggHistogramInterval).subAggregation(maxTime).field("time")).     assertXContentAreEqual(aggs, aggTransformer.toMap(aggs)).     assertXContentAreEqual(aggTransformer.fromMap(aggTransformer.toMap(aggs)), aggTransformer.toMap(aggs)).     QueryBuilder queryBuilder = QueryBuilders.termQuery(randomAlphaOfLength(10), randomAlphaOfLength(10)).     assertXContentAreEqual(queryBuilder, queryBuilderTransformer.toMap(queryBuilder)).     assertXContentAreEqual(queryBuilderTransformer.fromMap(queryBuilderTransformer.toMap(queryBuilder)), queryBuilderTransformer.toMap(queryBuilder)). }
false;public;0;14;;public void testDeprecationWarnings() throws IOException {     XContentObjectTransformer<QueryBuilder> queryBuilderTransformer = new XContentObjectTransformer<>(NamedXContentRegistry.EMPTY, (p) -> {         p.getDeprecationHandler().usedDeprecatedField("oldField", "newField").         p.getDeprecationHandler().usedDeprecatedName("oldName", "modernName").         return new BoolQueryBuilder().     }).     List<String> deprecations = new ArrayList<>().     queryBuilderTransformer.fromMap(Collections.singletonMap("bool", "match"), deprecations).     assertThat(deprecations, hasSize(2)).     assertThat(deprecations, hasItem("Deprecated field [oldField] used, replaced by [newField]")).     assertThat(deprecations, hasItem("Deprecated field [oldName] used, expected [modernName] instead")). }
false;protected;0;4;;@Override protected boolean enableWarningsCheck() {     return false. }
false;private;2;6;;private void assertXContentAreEqual(ToXContentObject object, Map<String, Object> map) throws IOException {     XContentType xContentType = XContentType.JSON.     BytesReference objectReference = XContentHelper.toXContent(object, xContentType, EMPTY_PARAMS, false).     BytesReference mapReference = BytesReference.bytes(XContentFactory.jsonBuilder().map(map)).     assertToXContentEquivalent(objectReference, mapReference, xContentType). }
