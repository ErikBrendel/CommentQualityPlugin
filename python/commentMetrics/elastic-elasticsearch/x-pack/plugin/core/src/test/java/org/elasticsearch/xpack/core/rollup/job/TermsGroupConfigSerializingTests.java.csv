commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected TermsGroupConfig doParseInstance(XContentParser parser) throws IOException {     return TermsGroupConfig.fromXContent(parser). }
false;protected;0;4;;@Override protected Writeable.Reader<TermsGroupConfig> instanceReader() {     return TermsGroupConfig::new. }
false;protected;0;4;;@Override protected TermsGroupConfig createTestInstance() {     return randomTermsGroupConfig(random()). }
false;public;0;9;;public void testValidateNoMapping() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     TermsGroupConfig config = new TermsGroupConfig("my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("Could not find a [numeric] or [keyword/text] field with name " + "[my_field] in any of the indices matching the index pattern.")). }
false;public;0;13;;public void testValidateNomatchingField() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     responseMap.put("some_other_field", Collections.singletonMap("keyword", fieldCaps)).     TermsGroupConfig config = new TermsGroupConfig("my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("Could not find a [numeric] or [keyword/text] field with name " + "[my_field] in any of the indices matching the index pattern.")). }
false;public;0;13;;public void testValidateFieldWrongType() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     responseMap.put("my_field", Collections.singletonMap("geo_point", fieldCaps)).     TermsGroupConfig config = new TermsGroupConfig("my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field referenced by a terms group must be a [numeric] or " + "[keyword/text] type, but found [geo_point] for field [my_field]")). }
false;public;0;13;;public void testValidateFieldMatchingNotAggregatable() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(false).     responseMap.put("my_field", Collections.singletonMap(getRandomType(), fieldCaps)).     TermsGroupConfig config = new TermsGroupConfig("my_field").     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field [my_field] must be aggregatable across all indices, but is not.")). }
false;public;0;16;;public void testValidateMatchingField() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     String type = getRandomType().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(true).     responseMap.put("my_field", Collections.singletonMap(type, fieldCaps)).     TermsGroupConfig config = new TermsGroupConfig("my_field").     config.validateMappings(responseMap, e).     if (e.validationErrors().size() != 0) {         fail(e.getMessage()).     } }
false;private;0;23;;private String getRandomType() {     int n = randomIntBetween(0, 8).     if (n == 0) {         return "keyword".     } else if (n == 1) {         return "text".     } else if (n == 2) {         return "long".     } else if (n == 3) {         return "integer".     } else if (n == 4) {         return "short".     } else if (n == 5) {         return "float".     } else if (n == 6) {         return "double".     } else if (n == 7) {         return "scaled_float".     } else if (n == 8) {         return "half_float".     }     return "long". }
