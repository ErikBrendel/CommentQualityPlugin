# id;timestamp;commentText;codeText;commentWords;codeWords
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1537312077;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1540394099;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1541783486;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1544081506;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1546556440;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                case FreezeAction.NAME:_                    return new FreezeAction()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,case,freeze,action,name,return,new,freeze,action,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1547740536;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                case FreezeAction.NAME:_                    return new FreezeAction()__                case SetPriorityAction.NAME:_                    return SetPriorityActionTests.randomInstance()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,case,freeze,action,name,return,new,freeze,action,case,set,priority,action,name,return,set,priority,action,tests,random,instance,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
LifecyclePolicyTests -> public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName);1547841903;The same as {@link #randomTimeseriesLifecyclePolicy(String)} but ensures_that the resulting policy has all valid phases and all valid actions.;public static LifecyclePolicy randomTimeseriesLifecyclePolicyWithAllPhases(@Nullable String lifecycleName) {_        List<String> phaseNames = TimeseriesLifecycleType.VALID_PHASES__        Map<String, Phase> phases = new HashMap<>(phaseNames.size())__        Function<String, Set<String>> validActions = (phase) ->  {_            switch (phase) {_                case "hot":_                    return TimeseriesLifecycleType.VALID_HOT_ACTIONS__                case "warm":_                    return TimeseriesLifecycleType.VALID_WARM_ACTIONS__                case "cold":_                    return TimeseriesLifecycleType.VALID_COLD_ACTIONS__                case "delete":_                    return TimeseriesLifecycleType.VALID_DELETE_ACTIONS__                default:_                    throw new IllegalArgumentException("invalid phase [" + phase + "]")__            }}__        Function<String, LifecycleAction> randomAction = (action) ->  {_            switch (action) {_                case AllocateAction.NAME:_                    return AllocateActionTests.randomInstance()__                case DeleteAction.NAME:_                    return new DeleteAction()__                case ForceMergeAction.NAME:_                    return ForceMergeActionTests.randomInstance()__                case ReadOnlyAction.NAME:_                    return new ReadOnlyAction()__                case RolloverAction.NAME:_                    return RolloverActionTests.randomInstance()__                case ShrinkAction.NAME:_                    return ShrinkActionTests.randomInstance()__                case FreezeAction.NAME:_                    return new FreezeAction()__                case SetPriorityAction.NAME:_                    return SetPriorityActionTests.randomInstance()__                case UnfollowAction.NAME:_                    return new UnfollowAction()__                default:_                    throw new IllegalArgumentException("invalid action [" + action + "]")__            }}__        for (String phase : phaseNames) {_            TimeValue after = TimeValue.parseTimeValue(randomTimeValue(0, 1000000000, "s", "m", "h", "d"), "test_after")__            Map<String, LifecycleAction> actions = new HashMap<>()__            Set<String> actionNames = validActions.apply(phase)__            for (String action : actionNames) {_                actions.put(action, randomAction.apply(action))__            }_            phases.put(phase, new Phase(phase, after, actions))__        }_        return new LifecyclePolicy(TimeseriesLifecycleType.INSTANCE, lifecycleName, phases)__    };the,same,as,link,random,timeseries,lifecycle,policy,string,but,ensures,that,the,resulting,policy,has,all,valid,phases,and,all,valid,actions;public,static,lifecycle,policy,random,timeseries,lifecycle,policy,with,all,phases,nullable,string,lifecycle,name,list,string,phase,names,timeseries,lifecycle,type,map,string,phase,phases,new,hash,map,phase,names,size,function,string,set,string,valid,actions,phase,switch,phase,case,hot,return,timeseries,lifecycle,type,case,warm,return,timeseries,lifecycle,type,case,cold,return,timeseries,lifecycle,type,case,delete,return,timeseries,lifecycle,type,default,throw,new,illegal,argument,exception,invalid,phase,phase,function,string,lifecycle,action,random,action,action,switch,action,case,allocate,action,name,return,allocate,action,tests,random,instance,case,delete,action,name,return,new,delete,action,case,force,merge,action,name,return,force,merge,action,tests,random,instance,case,read,only,action,name,return,new,read,only,action,case,rollover,action,name,return,rollover,action,tests,random,instance,case,shrink,action,name,return,shrink,action,tests,random,instance,case,freeze,action,name,return,new,freeze,action,case,set,priority,action,name,return,set,priority,action,tests,random,instance,case,unfollow,action,name,return,new,unfollow,action,default,throw,new,illegal,argument,exception,invalid,action,action,for,string,phase,phase,names,time,value,after,time,value,parse,time,value,random,time,value,0,1000000000,s,m,h,d,map,string,lifecycle,action,actions,new,hash,map,set,string,action,names,valid,actions,apply,phase,for,string,action,action,names,actions,put,action,random,action,apply,action,phases,put,phase,new,phase,phase,after,actions,return,new,lifecycle,policy,timeseries,lifecycle,type,instance,lifecycle,name,phases
