commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected DateHistogramGroupConfig doParseInstance(final XContentParser parser) throws IOException {     return DateHistogramGroupConfig.fromXContent(parser). }
false;protected;0;4;;@Override protected Writeable.Reader<DateHistogramGroupConfig> instanceReader() {     return DateHistogramGroupConfig::new. }
false;protected;0;4;;@Override protected DateHistogramGroupConfig createTestInstance() {     return randomDateHistogramGroupConfig(random()). }
false;public;0;9;;public void testValidateNoMapping() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1d"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("Could not find a [date] field with name [my_field] in any of the " + "indices matching the index pattern.")). }
false;public;0;13;;public void testValidateNomatchingField() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     responseMap.put("some_other_field", Collections.singletonMap("date", fieldCaps)).     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1d"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("Could not find a [date] field with name [my_field] in any of the " + "indices matching the index pattern.")). }
false;public;0;13;;public void testValidateFieldWrongType() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     responseMap.put("my_field", Collections.singletonMap("keyword", fieldCaps)).     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1d"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field referenced by a date_histo group must be a [date] type across all " + "indices in the index pattern.  Found: [keyword] for field [my_field]")). }
false;public;0;16;;public void testValidateFieldMixtureTypes() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     Map<String, FieldCapabilities> types = new HashMap<>(2).     types.put("date", fieldCaps).     types.put("keyword", fieldCaps).     responseMap.put("my_field", types).     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1d"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field referenced by a date_histo group must be a [date] type across all " + "indices in the index pattern.  Found: [date, keyword] for field [my_field]")). }
false;public;0;13;;public void testValidateFieldMatchingNotAggregatable() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(false).     responseMap.put("my_field", Collections.singletonMap("date", fieldCaps)).     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1d"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().get(0), equalTo("The field [my_field] must be aggregatable across all indices, but is not.")). }
false;public;0;13;;public void testValidateMatchingField() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(true).     responseMap.put("my_field", Collections.singletonMap("date", fieldCaps)).     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1d"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().size(), equalTo(0)). }
false;public;0;13;;public void testValidateWeek() {     ActionRequestValidationException e = new ActionRequestValidationException().     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     // Have to mock fieldcaps because the ctor's aren't public...     FieldCapabilities fieldCaps = mock(FieldCapabilities.class).     when(fieldCaps.isAggregatable()).thenReturn(true).     responseMap.put("my_field", Collections.singletonMap("date", fieldCaps)).     DateHistogramGroupConfig config = new DateHistogramGroupConfig("my_field", new DateHistogramInterval("1w"), null, null).     config.validateMappings(responseMap, e).     assertThat(e.validationErrors().size(), equalTo(0)). }
true;public;0;36;/**  * Tests that a DateHistogramGroupConfig can be serialized/deserialized correctly after  * the timezone was changed from DateTimeZone to String.  */ ;/**  * Tests that a DateHistogramGroupConfig can be serialized/deserialized correctly after  * the timezone was changed from DateTimeZone to String.  */ public void testBwcSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TEST_RUNS. runs++) {         final DateHistogramGroupConfig reference = ConfigTestHelpers.randomDateHistogramGroupConfig(random()).         final BytesStreamOutput out = new BytesStreamOutput().         reference.writeTo(out).         // previous way to deserialize a DateHistogramGroupConfig         final StreamInput in = out.bytes().streamInput().         DateHistogramInterval interval = new DateHistogramInterval(in).         String field = in.readString().         DateHistogramInterval delay = in.readOptionalWriteable(DateHistogramInterval::new).         ZoneId timeZone = in.readZoneId().         assertEqualInstances(reference, new DateHistogramGroupConfig(field, interval, delay, timeZone.getId())).     }     for (int runs = 0. runs < NUMBER_OF_TEST_RUNS. runs++) {         final String field = ConfigTestHelpers.randomField(random()).         final DateHistogramInterval interval = ConfigTestHelpers.randomInterval().         final DateHistogramInterval delay = randomBoolean() ? ConfigTestHelpers.randomInterval() : null.         final ZoneId timezone = randomZone().         // previous way to serialize a DateHistogramGroupConfig         final BytesStreamOutput out = new BytesStreamOutput().         interval.writeTo(out).         out.writeString(field).         out.writeOptionalWriteable(delay).         out.writeZoneId(timezone).         final StreamInput in = out.bytes().streamInput().         DateHistogramGroupConfig deserialized = new DateHistogramGroupConfig(in).         assertEqualInstances(new DateHistogramGroupConfig(field, interval, delay, timezone.getId()), deserialized).     } }
