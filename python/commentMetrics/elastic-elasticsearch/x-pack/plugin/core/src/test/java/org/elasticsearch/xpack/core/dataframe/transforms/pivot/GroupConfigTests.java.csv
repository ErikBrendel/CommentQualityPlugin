commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;30;;public static GroupConfig randomGroupConfig() {     Map<String, Object> source = new LinkedHashMap<>().     Map<String, SingleGroupSource<?>> groups = new LinkedHashMap<>().     // ensure that the unlikely does not happen: 2 group_by's share the same name     Set<String> names = new HashSet<>().     for (int i = 0. i < randomIntBetween(1, 20). ++i) {         String targetFieldName = randomAlphaOfLengthBetween(1, 20).         if (names.add(targetFieldName)) {             SingleGroupSource<?> groupBy.             Type type = randomFrom(SingleGroupSource.Type.values()).             switch(type) {                 case TERMS:                     groupBy = TermsGroupSourceTests.randomTermsGroupSource().                     break.                 case HISTOGRAM:                     groupBy = HistogramGroupSourceTests.randomHistogramGroupSource().                     break.                 case DATE_HISTOGRAM:                 default:                     groupBy = DateHistogramGroupSourceTests.randomDateHistogramGroupSource().             }             source.put(targetFieldName, Collections.singletonMap(type.value(), getSource(groupBy))).             groups.put(targetFieldName, groupBy).         }     }     return new GroupConfig(source, groups). }
false;protected;1;4;;@Override protected GroupConfig doParseInstance(XContentParser parser) throws IOException {     return GroupConfig.fromXContent(parser, false). }
false;protected;0;4;;@Override protected GroupConfig createTestInstance() {     return randomGroupConfig(). }
false;protected;0;4;;@Override protected Reader<GroupConfig> instanceReader() {     return GroupConfig::new. }
false;public;0;14;;public void testEmptyGroupBy() throws IOException {     String source = "{}".     // lenient, passes but reports invalid     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         GroupConfig groupConfig = GroupConfig.fromXContent(parser, true).         assertFalse(groupConfig.isValid()).     }     // strict throws     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         expectThrows(IllegalArgumentException.class, () -> GroupConfig.fromXContent(parser, false)).     } }
false;private,static;1;10;;private static Map<String, Object> getSource(SingleGroupSource<?> groupSource) {     try (XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()) {         XContentBuilder content = groupSource.toXContent(xContentBuilder, ToXContent.EMPTY_PARAMS).         return XContentHelper.convertToMap(BytesReference.bytes(content), true, XContentType.JSON).v2().     } catch (IOException e) {         // should not happen         fail("failed to create random single group source").     }     return null. }
