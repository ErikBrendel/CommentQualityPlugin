commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Before public void init() throws Exception {     threadPool = new TestThreadPool("ldap realm tests").     resourceWatcherService = new ResourceWatcherService(Settings.EMPTY, threadPool).     defaultGlobalSettings = Settings.builder().put("path.home", createTempDir()).build().     sslService = new SSLService(defaultGlobalSettings, TestEnvironment.newEnvironment(defaultGlobalSettings)).     licenseState = mock(XPackLicenseState.class).     when(licenseState.isAuthorizationRealmAllowed()).thenReturn(true). }
false;public;0;5;;@After public void shutdown() throws InterruptedException {     resourceWatcherService.stop().     terminate(threadPool). }
false;public;0;25;;public void testAuthenticateSubTreeGroupSearch() throws Exception {     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     LdapRealm ldap = new LdapRealm(config, ldapFactory, buildGroupAsRoleMapper(resourceWatcherService), threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     final AuthenticationResult result = future.actionGet().     assertThat(result.getStatus(), is(AuthenticationResult.Status.SUCCESS)).     User user = result.getUser().     assertThat(user, notNullValue()).     assertThat(user.roles(), arrayContaining("HMS Victory")).     assertThat(user.metadata(), notNullValue()).     assertThat(user.metadata().get("ldap_dn"), equalTo("cn=" + VALID_USERNAME + ",ou=people,o=sevenSeas")).     assertThat(user.metadata().get("ldap_groups"), instanceOf(List.class)).     assertThat((List<?>) user.metadata().get("ldap_groups"), contains("cn=HMS Victory,ou=crews,ou=groups,o=sevenSeas")). }
false;private;2;4;;private RealmConfig getRealmConfig(RealmConfig.RealmIdentifier identifier, Settings settings) {     final Environment env = TestEnvironment.newEnvironment(settings).     return new RealmConfig(identifier, settings, env, new ThreadContext(settings)). }
false;public;0;26;;public void testAuthenticateOneLevelGroupSearch() throws Exception {     String groupSearchBase = "ou=crews,ou=groups,o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.ONE_LEVEL)).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     LdapRealm ldap = new LdapRealm(config, ldapFactory, buildGroupAsRoleMapper(resourceWatcherService), threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     final AuthenticationResult result = future.actionGet().     assertThat(result.getStatus(), is(AuthenticationResult.Status.SUCCESS)).     User user = result.getUser().     assertThat(user, notNullValue()).     assertThat("For roles " + Arrays.toString(user.roles()), user.roles(), arrayContaining("HMS Victory")).     assertThat(user.metadata(), notNullValue()).     assertThat(user.metadata().get("ldap_dn"), equalTo("cn=" + VALID_USERNAME + ",ou=people,o=sevenSeas")).     assertThat(user.metadata().get("ldap_groups"), instanceOf(List.class)).     assertThat((List<?>) user.metadata().get("ldap_groups"), contains("cn=HMS Victory,ou=crews,ou=groups,o=sevenSeas")). }
false;public;0;26;;public void testAuthenticateCaching() throws Exception {     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     ldapFactory = spy(ldapFactory).     LdapRealm ldap = new LdapRealm(config, ldapFactory, buildGroupAsRoleMapper(resourceWatcherService), threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     assertThat(future.actionGet().getStatus(), is(AuthenticationResult.Status.SUCCESS)).     future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     assertThat(future.actionGet().getStatus(), is(AuthenticationResult.Status.SUCCESS)).     // verify one and only one session -> caching is working     verify(ldapFactory, times(1)).session(anyString(), any(SecureString.class), any(ActionListener.class)). }
false;public;0;34;;public void testAuthenticateCachingRefresh() throws Exception {     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).put(defaultGlobalSettings).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     DnRoleMapper roleMapper = buildGroupAsRoleMapper(resourceWatcherService).     ldapFactory = spy(ldapFactory).     LdapRealm ldap = new LdapRealm(config, ldapFactory, roleMapper, threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     future.actionGet().     future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     future.actionGet().     // verify one and only one session -> caching is working     verify(ldapFactory, times(1)).session(anyString(), any(SecureString.class), any(ActionListener.class)).     roleMapper.notifyRefresh().     future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     future.actionGet().     // we need to session again     verify(ldapFactory, times(2)).session(anyString(), any(SecureString.class), any(ActionListener.class)). }
false;public;0;26;;public void testAuthenticateNoncaching() throws Exception {     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).put(getFullSettingKey(REALM_IDENTIFIER, CachingUsernamePasswordRealmSettings.CACHE_TTL_SETTING), -1).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     ldapFactory = spy(ldapFactory).     LdapRealm ldap = new LdapRealm(config, ldapFactory, buildGroupAsRoleMapper(resourceWatcherService), threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     future.actionGet().     future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     future.actionGet().     // verify two and only two binds -> caching is disabled     verify(ldapFactory, times(2)).session(anyString(), any(SecureString.class), any(ActionListener.class)). }
false;public;0;41;;public void testDelegatedAuthorization() throws Exception {     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     final Settings.Builder builder = Settings.builder().put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).putList(getFullSettingKey(REALM_IDENTIFIER, DelegatedAuthorizationSettings.AUTHZ_REALMS), "mock_lookup").     if (randomBoolean()) {         // maybe disable caching         builder.put(getFullSettingKey(REALM_IDENTIFIER, CachingUsernamePasswordRealmSettings.CACHE_TTL_SETTING), -1).     }     final Settings realmSettings = builder.build().     final Environment env = TestEnvironment.newEnvironment(defaultGlobalSettings).     RealmConfig config = new RealmConfig(REALM_IDENTIFIER, realmSettings, env, threadPool.getThreadContext()).     final LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     final DnRoleMapper roleMapper = buildGroupAsRoleMapper(resourceWatcherService).     final LdapRealm ldap = new LdapRealm(config, ldapFactory, roleMapper, threadPool).     final MockLookupRealm mockLookup = new MockLookupRealm(new RealmConfig(new RealmConfig.RealmIdentifier("mock", "mock_lookup"), defaultGlobalSettings, env, threadPool.getThreadContext())).     ldap.initialize(Arrays.asList(ldap, mockLookup), licenseState).     mockLookup.initialize(Arrays.asList(ldap, mockLookup), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     final AuthenticationResult result1 = future.actionGet().     assertThat(result1.getStatus(), equalTo(AuthenticationResult.Status.CONTINUE)).     assertThat(result1.getMessage(), equalTo("the principal [" + VALID_USERNAME + "] was authenticated, but no user could be found in realms [mock/mock_lookup]")).     future = new PlainActionFuture<>().     final User fakeUser = new User(VALID_USERNAME, "fake_role").     mockLookup.registerUser(fakeUser).     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     final AuthenticationResult result2 = future.actionGet().     assertThat(result2.getStatus(), equalTo(AuthenticationResult.Status.SUCCESS)).     assertThat(result2.getUser(), sameInstance(fakeUser)). }
false;public;0;16;;public void testLdapRealmSelectsLdapSessionFactory() throws Exception {     final RealmConfig.RealmIdentifier identifier = new RealmConfig.RealmIdentifier(LdapRealmSettings.LDAP_TYPE, "test-ldap-realm").     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).putList(getFullSettingKey(identifier, URLS_SETTING), ldapUrls()).putList(getFullSettingKey(identifier.getName(), LdapSessionFactorySettings.USER_DN_TEMPLATES_SETTING), userTemplate).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.BASE_DN), groupSearchBase).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.SCOPE), LdapSearchScope.SUB_TREE).put(getFullSettingKey(identifier, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM), VerificationMode.CERTIFICATE).build().     RealmConfig config = getRealmConfig(identifier, settings).     SessionFactory sessionFactory = LdapRealm.sessionFactory(config, new SSLService(settings, config.env()), threadPool).     assertThat(sessionFactory, is(instanceOf(LdapSessionFactory.class))). }
false;public;0;23;;public void testLdapRealmSelectsLdapUserSearchSessionFactory() throws Exception {     final RealmConfig.RealmIdentifier identifier = new RealmConfig.RealmIdentifier(LdapRealmSettings.LDAP_TYPE, "test-ldap-realm-user-search").     String groupSearchBase = "o=sevenSeas".     Settings settings = Settings.builder().put(defaultGlobalSettings).putList(getFullSettingKey(identifier, URLS_SETTING), ldapUrls()).put(getFullSettingKey(identifier.getName(), LdapUserSearchSessionFactorySettings.SEARCH_BASE_DN), "").put(getFullSettingKey(identifier, PoolingSessionFactorySettings.BIND_DN), "cn=Thomas Masterman Hardy,ou=people,o=sevenSeas").setSecureSettings(secureSettings(PoolingSessionFactorySettings.SECURE_BIND_PASSWORD, identifier, PASSWORD)).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.BASE_DN), groupSearchBase).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.SCOPE), LdapSearchScope.SUB_TREE).put(getFullSettingKey(identifier, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM), VerificationMode.CERTIFICATE).build().     final RealmConfig config = getRealmConfig(identifier, settings).     SessionFactory sessionFactory = LdapRealm.sessionFactory(config, new SSLService(config.settings(), config.env()), threadPool).     try {         assertThat(sessionFactory, is(instanceOf(LdapUserSearchSessionFactory.class))).     } finally {         ((LdapUserSearchSessionFactory) sessionFactory).close().     } }
false;public;0;20;;public void testLdapRealmThrowsExceptionForUserTemplateAndSearchSettings() throws Exception {     final RealmConfig.RealmIdentifier identifier = new RealmConfig.RealmIdentifier(LdapRealmSettings.LDAP_TYPE, "test-ldap-realm-user-search").     Settings settings = Settings.builder().put(defaultGlobalSettings).putList(getFullSettingKey(identifier, URLS_SETTING), ldapUrls()).putList(getFullSettingKey(identifier.getName(), LdapSessionFactorySettings.USER_DN_TEMPLATES_SETTING), "cn=foo").put(getFullSettingKey(identifier.getName(), LdapUserSearchSessionFactorySettings.SEARCH_BASE_DN), "cn=bar").put(getFullSettingKey(identifier, SearchGroupsResolverSettings.BASE_DN), "").put(getFullSettingKey(identifier, SearchGroupsResolverSettings.SCOPE), LdapSearchScope.SUB_TREE).put(getFullSettingKey(identifier, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM), VerificationMode.CERTIFICATE).build().     RealmConfig config = getRealmConfig(identifier, settings).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> LdapRealm.sessionFactory(config, null, threadPool)).     assertThat(e.getMessage(), containsString("settings were found for both" + " user search [xpack.security.authc.realms.ldap.test-ldap-realm-user-search.user_search.base_dn] and" + " user template [xpack.security.authc.realms.ldap.test-ldap-realm-user-search.user_dn_templates]")). }
false;public;0;18;;public void testLdapRealmThrowsExceptionWhenNeitherUserTemplateNorSearchSettingsProvided() throws Exception {     final RealmConfig.RealmIdentifier identifier = new RealmConfig.RealmIdentifier(LdapRealmSettings.LDAP_TYPE, "test-ldap-realm-user-search").     Settings settings = Settings.builder().put(defaultGlobalSettings).putList(getFullSettingKey(identifier, URLS_SETTING), ldapUrls()).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.BASE_DN), "").put(getFullSettingKey(identifier, SearchGroupsResolverSettings.SCOPE), LdapSearchScope.SUB_TREE).put(getFullSettingKey(identifier, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM), VerificationMode.CERTIFICATE).build().     RealmConfig config = getRealmConfig(identifier, settings).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> LdapRealm.sessionFactory(config, null, threadPool)).     assertThat(e.getMessage(), containsString("settings were not found for either" + " user search [xpack.security.authc.realms.ldap.test-ldap-realm-user-search.user_search.base_dn] or" + " user template [xpack.security.authc.realms.ldap.test-ldap-realm-user-search.user_dn_templates]")). }
false;public;0;24;;public void testLdapRealmMapsUserDNToRole() throws Exception {     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).put(buildLdapSettings(ldapUrls(), userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).put(getFullSettingKey(REALM_IDENTIFIER, DnRoleMapperSettings.ROLE_MAPPING_FILE_SETTING), getDataPath("/org/elasticsearch/xpack/security/authc/support/role_mapping.yml")).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     LdapRealm ldap = new LdapRealm(config, ldapFactory, new DnRoleMapper(config, resourceWatcherService), threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken("Horatio Hornblower", new SecureString(PASSWORD)), future).     final AuthenticationResult result = future.actionGet().     assertThat(result.getStatus(), is(AuthenticationResult.Status.SUCCESS)).     User user = result.getUser().     assertThat(user, notNullValue()).     assertThat(user.roles(), arrayContaining("avenger")). }
true;public;0;23;/**  * The contract for {@link Realm} implementations is that they should log-and-return-null (and  * not call {@link ActionListener#onFailure(Exception)}) if there is an internal exception that prevented them from performing an  * authentication.  * This method tests that when an LDAP server is unavailable (invalid hostname), there is a <code>null</code> result  * rather than an exception.  */ ;/**  * The contract for {@link Realm} implementations is that they should log-and-return-null (and  * not call {@link ActionListener#onFailure(Exception)}) if there is an internal exception that prevented them from performing an  * authentication.  * This method tests that when an LDAP server is unavailable (invalid hostname), there is a <code>null</code> result  * rather than an exception.  */ public void testLdapConnectionFailureIsTreatedAsAuthenticationFailure() throws Exception {     LDAPURL url = new LDAPURL("ldap", "..", 12345, null, null, null, null).     String groupSearchBase = "o=sevenSeas".     String userTemplate = VALID_USER_TEMPLATE.     Settings settings = Settings.builder().put(defaultGlobalSettings).put(buildLdapSettings(new String[] { url.toString() }, userTemplate, groupSearchBase, LdapSearchScope.SUB_TREE)).build().     RealmConfig config = getRealmConfig(REALM_IDENTIFIER, settings).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, sslService, threadPool).     LdapRealm ldap = new LdapRealm(config, ldapFactory, buildGroupAsRoleMapper(resourceWatcherService), threadPool).     ldap.initialize(Collections.singleton(ldap), licenseState).     PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     ldap.authenticate(new UsernamePasswordToken(VALID_USERNAME, new SecureString(PASSWORD)), future).     final AuthenticationResult result = future.actionGet().     assertThat(result.getStatus(), is(AuthenticationResult.Status.CONTINUE)).     assertThat(result.getUser(), nullValue()).     assertThat(result.getMessage(), is("authenticate failed")).     assertThat(result.getException(), notNullValue()).     assertThat(result.getException().getMessage(), containsString("UnknownHostException")). }
false;public;0;38;;public void testUsageStats() throws Exception {     final RealmConfig.RealmIdentifier identifier = new RealmConfig.RealmIdentifier(LdapRealmSettings.LDAP_TYPE, "ldap-realm").     String groupSearchBase = "o=sevenSeas".     Settings.Builder settings = Settings.builder().put(defaultGlobalSettings).putList(getFullSettingKey(identifier, URLS_SETTING), ldapUrls()).put(getFullSettingKey(identifier, PoolingSessionFactorySettings.BIND_DN), "cn=Thomas Masterman Hardy,ou=people,o=sevenSeas").put(getFullSettingKey(identifier, PoolingSessionFactorySettings.LEGACY_BIND_PASSWORD), PASSWORD).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.BASE_DN), groupSearchBase).put(getFullSettingKey(identifier, SearchGroupsResolverSettings.SCOPE), LdapSearchScope.SUB_TREE).put(getFullSettingKey(identifier.getName(), LdapSessionFactorySettings.USER_DN_TEMPLATES_SETTING), "--").put(getFullSettingKey(identifier, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM), VerificationMode.CERTIFICATE).     int order = randomIntBetween(0, 10).     settings.put(getFullSettingKey(identifier, RealmSettings.ORDER_SETTING), order).     boolean userSearch = randomBoolean().     if (userSearch) {         settings.put(getFullSettingKey(identifier.getName(), LdapUserSearchSessionFactorySettings.SEARCH_BASE_DN), "").     }     RealmConfig config = getRealmConfig(identifier, settings.build()).     LdapSessionFactory ldapFactory = new LdapSessionFactory(config, new SSLService(config.settings(), config.env()), threadPool).     LdapRealm realm = new LdapRealm(config, ldapFactory, new DnRoleMapper(config, resourceWatcherService), threadPool).     realm.initialize(Collections.singleton(realm), licenseState).     PlainActionFuture<Map<String, Object>> future = new PlainActionFuture<>().     realm.usageStats(future).     Map<String, Object> stats = future.get().     assertThat(stats, is(notNullValue())).     assertThat(stats, hasEntry("name", identifier.getName())).     assertThat(stats, hasEntry("order", realm.order())).     assertThat(stats, hasEntry("size", 0)).     assertThat(stats, hasEntry("ssl", false)).     assertThat(stats, hasEntry("user_search", userSearch)). }
false;private;3;6;;private SecureSettings secureSettings(Function<String, Setting.AffixSetting<SecureString>> settingFactory, RealmConfig.RealmIdentifier identifier, String value) {     final MockSecureSettings secureSettings = new MockSecureSettings().     secureSettings.setString(getFullSettingKey(identifier, settingFactory), value).     return secureSettings. }
