commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Map<String, Realm.Factory> getRealms(ResourceWatcherService resourceWatcherService) {     return Collections.singletonMap(realmType, config -> null). }
false;protected;0;4;;@Override protected XPackLicenseState getLicenseState() {     return licenseState. }
false;protected;0;4;;@Override protected SSLService getSslService() {     return sslService. }
false;private;2;37;;private Collection<Object> createComponents(Settings testSettings, SecurityExtension... extensions) throws Exception {     if (security != null) {         throw new IllegalStateException("Security object already exists (" + security + ")").     }     Settings settings = Settings.builder().put("xpack.security.enabled", true).put(testSettings).put("path.home", createTempDir()).build().     Environment env = TestEnvironment.newEnvironment(settings).     licenseState = new TestUtils.UpdatableLicenseState(settings).     SSLService sslService = new SSLService(settings, env).     security = new Security(settings, null, Arrays.asList(extensions)) {          @Override         protected XPackLicenseState getLicenseState() {             return licenseState.         }          @Override         protected SSLService getSslService() {             return sslService.         }     }.     ThreadPool threadPool = mock(ThreadPool.class).     ClusterService clusterService = mock(ClusterService.class).     settings = Security.additionalSettings(settings, true, false).     Set<Setting<?>> allowedSettings = new HashSet<>(Security.getSettings(false, null)).     allowedSettings.addAll(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS).     ClusterSettings clusterSettings = new ClusterSettings(settings, allowedSettings).     when(clusterService.getClusterSettings()).thenReturn(clusterSettings).     when(threadPool.relativeTimeInMillis()).thenReturn(1L).     threadContext = new ThreadContext(Settings.EMPTY).     when(threadPool.getThreadContext()).thenReturn(threadContext).     Client client = mock(Client.class).     when(client.threadPool()).thenReturn(threadPool).     when(client.settings()).thenReturn(settings).     return security.createComponents(client, threadPool, clusterService, mock(ResourceWatcherService.class)). }
false;private,static;2;8;;private static <T> T findComponent(Class<T> type, Collection<Object> components) {     for (Object obj : components) {         if (type.isInstance(obj)) {             return type.cast(obj).         }     }     return null. }
false;public;0;8;;@Before public void cleanup() throws IOException {     if (threadContext != null) {         threadContext.stashContext().         threadContext.close().         threadContext = null.     } }
false;public;0;6;;public void testCustomRealmExtension() throws Exception {     Collection<Object> components = createComponents(Settings.EMPTY, new DummyExtension("myrealm")).     Realms realms = findComponent(Realms.class, components).     assertNotNull(realms).     assertNotNull(realms.realmFactory("myrealm")). }
false;public;0;5;;public void testCustomRealmExtensionConflict() throws Exception {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> createComponents(Settings.EMPTY, new DummyExtension(FileRealmSettings.TYPE))).     assertEquals("Realm type [" + FileRealmSettings.TYPE + "] is already registered", e.getMessage()). }
false;public;0;8;;public void testAuditEnabled() throws Exception {     Settings settings = Settings.builder().put(XPackSettings.AUDIT_ENABLED.getKey(), true).build().     Collection<Object> components = createComponents(settings).     AuditTrailService service = findComponent(AuditTrailService.class, components).     assertNotNull(service).     assertEquals(1, service.getAuditTrails().size()).     assertEquals(LoggingAuditTrail.NAME, service.getAuditTrails().get(0).name()). }
false;public;0;5;;public void testDisabledByDefault() throws Exception {     Collection<Object> components = createComponents(Settings.EMPTY).     AuditTrailService auditTrailService = findComponent(AuditTrailService.class, components).     assertEquals(0, auditTrailService.getAuditTrails().size()). }
false;public;0;5;;public void testHttpSettingDefaults() throws Exception {     final Settings defaultSettings = Security.additionalSettings(Settings.EMPTY, true, false).     assertThat(SecurityField.NAME4, equalTo(NetworkModule.TRANSPORT_TYPE_SETTING.get(defaultSettings))).     assertThat(SecurityField.NAME4, equalTo(NetworkModule.HTTP_TYPE_SETTING.get(defaultSettings))). }
false;public;0;8;;public void testTransportSettingNetty4Both() {     Settings both4 = Security.additionalSettings(Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, SecurityField.NAME4).put(NetworkModule.HTTP_TYPE_KEY, SecurityField.NAME4).build(), true, false).     assertFalse(NetworkModule.TRANSPORT_TYPE_SETTING.exists(both4)).     assertFalse(NetworkModule.HTTP_TYPE_SETTING.exists(both4)). }
false;public;0;14;;public void testTransportSettingValidation() {     final String badType = randomFrom("netty4", "other", "security1").     Settings settingsTransport = Settings.builder().put(NetworkModule.TRANSPORT_TYPE_KEY, badType).build().     IllegalArgumentException badTransport = expectThrows(IllegalArgumentException.class, () -> Security.additionalSettings(settingsTransport, true, false)).     assertThat(badTransport.getMessage(), containsString(SecurityField.NAME4)).     assertThat(badTransport.getMessage(), containsString(NetworkModule.TRANSPORT_TYPE_KEY)).     Settings settingsHttp = Settings.builder().put(NetworkModule.HTTP_TYPE_KEY, badType).build().     IllegalArgumentException badHttp = expectThrows(IllegalArgumentException.class, () -> Security.additionalSettings(settingsHttp, true, false)).     assertThat(badHttp.getMessage(), containsString(SecurityField.NAME4)).     assertThat(badHttp.getMessage(), containsString(NetworkModule.HTTP_TYPE_KEY)). }
false;public;0;5;;public void testSettingFilter() throws Exception {     createComponents(Settings.EMPTY).     final List<String> filter = security.getSettingsFilter().     assertThat(filter, hasItem("transport.profiles.*.xpack.security.*")). }
false;public;0;20;;public void testFilteredSettings() throws Exception {     createComponents(Settings.EMPTY).     final List<Setting<?>> realmSettings = security.getSettings().stream().filter(s -> s.getKey().startsWith("xpack.security.authc.realms")).collect(Collectors.toList()).     Arrays.asList("bind_dn", "bind_password", "hostname_verification", "truststore.password", "truststore.path", "truststore.algorithm", "keystore.key_password").forEach(suffix -> {         final List<Setting<?>> matching = realmSettings.stream().filter(s -> s.getKey().endsWith("." + suffix)).collect(Collectors.toList()).         assertThat("For suffix " + suffix, matching, Matchers.not(empty())).         matching.forEach(setting -> assertThat("For setting " + setting, setting.getProperties(), Matchers.hasItem(Setting.Property.Filtered))).     }). }
false;public;0;6;;public void testJoinValidatorOnDisabledSecurity() throws Exception {     Settings disabledSettings = Settings.builder().put("xpack.security.enabled", false).build().     createComponents(disabledSettings).     BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator().     assertNull(joinValidator). }
false;public;0;26;;public void testTLSJoinValidator() throws Exception {     createComponents(Settings.EMPTY).     BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator().     assertNotNull(joinValidator).     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT).     joinValidator.accept(node, ClusterState.builder(ClusterName.DEFAULT).build()).     int numIters = randomIntBetween(1, 10).     for (int i = 0. i < numIters. i++) {         boolean tlsOn = randomBoolean().         String discoveryType = randomFrom("single-node", ZEN_DISCOVERY_TYPE, ZEN2_DISCOVERY_TYPE, randomAlphaOfLength(4)).         Security.ValidateTLSOnJoin validator = new Security.ValidateTLSOnJoin(tlsOn, discoveryType).         MetaData.Builder builder = MetaData.builder().         License license = TestUtils.generateSignedLicense(TimeValue.timeValueHours(24)).         TestUtils.putLicense(builder, license).         ClusterState state = ClusterState.builder(ClusterName.DEFAULT).metaData(builder.build()).build().         EnumSet<License.OperationMode> productionModes = EnumSet.of(License.OperationMode.GOLD, License.OperationMode.PLATINUM, License.OperationMode.STANDARD).         if (productionModes.contains(license.operationMode()) && tlsOn == false && "single-node".equals(discoveryType) == false) {             IllegalStateException ise = expectThrows(IllegalStateException.class, () -> validator.accept(node, state)).             assertEquals("TLS setup is required for license type [" + license.operationMode().name() + "]", ise.getMessage()).         } else {             validator.accept(node, state).         }         validator.accept(node, ClusterState.builder(ClusterName.DEFAULT).metaData(MetaData.builder().build()).build()).     } }
false;public;0;12;;public void testJoinValidatorForLicenseDeserialization() throws Exception {     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), VersionUtils.randomVersionBetween(random(), null, Version.V_6_3_0)).     MetaData.Builder builder = MetaData.builder().     License license = TestUtils.generateSignedLicense(null, randomIntBetween(License.VERSION_CRYPTO_ALGORITHMS, License.VERSION_CURRENT), -1, TimeValue.timeValueHours(24)).     TestUtils.putLicense(builder, license).     ClusterState state = ClusterState.builder(ClusterName.DEFAULT).metaData(builder.build()).build().     IllegalStateException e = expectThrows(IllegalStateException.class, () -> new Security.ValidateLicenseCanBeDeserialized().accept(node, state)).     assertThat(e.getMessage(), containsString("cannot deserialize the license format")). }
false;public;0;19;;public void testJoinValidatorForFIPSLicense() throws Exception {     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), VersionUtils.randomVersionBetween(random(), null, Version.CURRENT)).     MetaData.Builder builder = MetaData.builder().     License license = TestUtils.generateSignedLicense(TimeValue.timeValueHours(24)).     TestUtils.putLicense(builder, license).     ClusterState state = ClusterState.builder(ClusterName.DEFAULT).metaData(builder.build()).build().     new Security.ValidateLicenseForFIPS(false).accept(node, state).     final boolean isLicenseValidForFips = FIPS140LicenseBootstrapCheck.ALLOWED_LICENSE_OPERATION_MODES.contains(license.operationMode()).     if (isLicenseValidForFips) {         new Security.ValidateLicenseForFIPS(true).accept(node, state).     } else {         IllegalStateException e = expectThrows(IllegalStateException.class, () -> new Security.ValidateLicenseForFIPS(true).accept(node, state)).         assertThat(e.getMessage(), containsString("FIPS mode cannot be used")).     } }
false;public;0;19;;public void testIndexJoinValidator_Old_And_Rolling() throws Exception {     createComponents(Settings.EMPTY).     BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator().     assertNotNull(joinValidator).     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT).     IndexMetaData indexMetaData = IndexMetaData.builder(SECURITY_INDEX_NAME).settings(settings(Version.V_6_1_0).put(INDEX_FORMAT_SETTING.getKey(), INTERNAL_INDEX_FORMAT - 1)).numberOfShards(1).numberOfReplicas(0).build().     DiscoveryNode existingOtherNode = new DiscoveryNode("bar", buildNewFakeTransportAddress(), Version.V_6_1_0).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(existingOtherNode).build().     ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT).nodes(discoveryNodes).metaData(MetaData.builder().put(indexMetaData, true).build()).build().     IllegalStateException e = expectThrows(IllegalStateException.class, () -> joinValidator.accept(node, clusterState)).     assertThat(e.getMessage(), equalTo("Security index is not on the current version [6] - " + "The Upgrade API must be run for 7.x nodes to join the cluster")). }
false;public;0;17;;public void testIndexJoinValidator_FullyCurrentCluster() throws Exception {     createComponents(Settings.EMPTY).     BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator().     assertNotNull(joinValidator).     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT).     int indexFormat = randomBoolean() ? INTERNAL_INDEX_FORMAT : INTERNAL_INDEX_FORMAT - 1.     IndexMetaData indexMetaData = IndexMetaData.builder(SECURITY_INDEX_NAME).settings(settings(Version.V_6_1_0).put(INDEX_FORMAT_SETTING.getKey(), indexFormat)).numberOfShards(1).numberOfReplicas(0).build().     DiscoveryNode existingOtherNode = new DiscoveryNode("bar", buildNewFakeTransportAddress(), Version.CURRENT).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(existingOtherNode).build().     ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT).nodes(discoveryNodes).metaData(MetaData.builder().put(indexMetaData, true).build()).build().     joinValidator.accept(node, clusterState). }
false;public;0;17;;public void testIndexUpgradeValidatorWithUpToDateIndex() throws Exception {     createComponents(Settings.EMPTY).     BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator().     assertNotNull(joinValidator).     Version version = randomBoolean() ? Version.CURRENT : Version.V_6_1_0.     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT).     IndexMetaData indexMetaData = IndexMetaData.builder(SECURITY_INDEX_NAME).settings(settings(version).put(INDEX_FORMAT_SETTING.getKey(), INTERNAL_INDEX_FORMAT)).numberOfShards(1).numberOfReplicas(0).build().     DiscoveryNode existingOtherNode = new DiscoveryNode("bar", buildNewFakeTransportAddress(), version).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(existingOtherNode).build().     ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT).nodes(discoveryNodes).metaData(MetaData.builder().put(indexMetaData, true).build()).build().     joinValidator.accept(node, clusterState). }
false;public;0;11;;public void testIndexUpgradeValidatorWithMissingIndex() throws Exception {     createComponents(Settings.EMPTY).     BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator().     assertNotNull(joinValidator).     DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT).     DiscoveryNode existingOtherNode = new DiscoveryNode("bar", buildNewFakeTransportAddress(), Version.V_6_1_0).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(existingOtherNode).build().     ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT).nodes(discoveryNodes).build().     joinValidator.accept(node, clusterState). }
false;public;0;29;;public void testGetFieldFilterSecurityEnabled() throws Exception {     createComponents(Settings.EMPTY).     Function<String, Predicate<String>> fieldFilter = security.getFieldFilter().     assertNotSame(MapperPlugin.NOOP_FIELD_FILTER, fieldFilter).     Map<String, IndicesAccessControl.IndexAccessControl> permissionsMap = new HashMap<>().     FieldPermissions permissions = new FieldPermissions(new FieldPermissionsDefinition(new String[] { "field_granted" }, Strings.EMPTY_ARRAY)).     IndicesAccessControl.IndexAccessControl indexGrantedAccessControl = new IndicesAccessControl.IndexAccessControl(true, permissions, DocumentPermissions.allowAll()).     permissionsMap.put("index_granted", indexGrantedAccessControl).     IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(false, FieldPermissions.DEFAULT, DocumentPermissions.allowAll()).     permissionsMap.put("index_not_granted", indexAccessControl).     IndicesAccessControl.IndexAccessControl nullFieldPermissions = new IndicesAccessControl.IndexAccessControl(true, null, DocumentPermissions.allowAll()).     permissionsMap.put("index_null", nullFieldPermissions).     IndicesAccessControl index = new IndicesAccessControl(true, permissionsMap).     threadContext.putTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, index).     assertTrue(fieldFilter.apply("index_granted").test("field_granted")).     assertFalse(fieldFilter.apply("index_granted").test(randomAlphaOfLengthBetween(3, 10))).     assertTrue(fieldFilter.apply(randomAlphaOfLengthBetween(3, 6)).test("field_granted")).     assertTrue(fieldFilter.apply(randomAlphaOfLengthBetween(3, 6)).test(randomAlphaOfLengthBetween(3, 10))).     assertEquals(MapperPlugin.NOOP_FIELD_PREDICATE, fieldFilter.apply(randomAlphaOfLengthBetween(3, 10))).     expectThrows(IllegalStateException.class, () -> fieldFilter.apply("index_not_granted")).     assertTrue(fieldFilter.apply("index_null").test(randomAlphaOfLengthBetween(3, 6))).     assertEquals(MapperPlugin.NOOP_FIELD_PREDICATE, fieldFilter.apply("index_null")). }
false;public;0;4;;public void testGetFieldFilterSecurityDisabled() throws Exception {     createComponents(Settings.builder().put(XPackSettings.SECURITY_ENABLED.getKey(), false).build()).     assertSame(MapperPlugin.NOOP_FIELD_FILTER, security.getFieldFilter()). }
false;public;0;9;;public void testGetFieldFilterSecurityEnabledLicenseNoFLS() throws Exception {     createComponents(Settings.EMPTY).     Function<String, Predicate<String>> fieldFilter = security.getFieldFilter().     assertNotSame(MapperPlugin.NOOP_FIELD_FILTER, fieldFilter).     licenseState.update(randomFrom(License.OperationMode.BASIC, License.OperationMode.STANDARD, License.OperationMode.GOLD), true, null).     assertNotSame(MapperPlugin.NOOP_FIELD_FILTER, fieldFilter).     assertSame(MapperPlugin.NOOP_FIELD_PREDICATE, fieldFilter.apply(randomAlphaOfLengthBetween(3, 6))). }
false;public;0;11;;public void testValidateRealmsWhenSettingsAreInvalid() {     final Settings settings = Settings.builder().put(RealmSettings.PREFIX + "my_pki.type", "pki").put(RealmSettings.PREFIX + "ldap1.type", "ldap").build().     final IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () -> Security.validateRealmSettings(settings)).     assertThat(iae.getMessage(), containsString("Incorrect realm settings")).     assertThat(iae.getMessage(), containsString("breaking changes doc")).     assertThat(iae.getMessage(), containsString(RealmSettings.PREFIX + "my_pki.type")).     assertThat(iae.getMessage(), containsString(RealmSettings.PREFIX + "ldap1.type")). }
false;public;0;8;;public void testValidateRealmsWhenSettingsAreCorrect() {     final Settings settings = Settings.builder().put(RealmSettings.PREFIX + "pki.my_pki.order", 0).put(RealmSettings.PREFIX + "ldap.ldap1.order", 1).build().     Security.validateRealmSettings(settings). // no-exception }
