commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;0;16;;@Override protected Settings nodeSettings() {     SSLClientAuth sslClientAuth = randomBoolean() ? SSLClientAuth.REQUIRED : SSLClientAuth.OPTIONAL.     Settings.Builder builder = Settings.builder().put(super.nodeSettings()).     addSSLSettingsForNodePEMFiles(builder, "xpack.security.http.", true).     builder.put("xpack.security.http.ssl.enabled", true).put("xpack.security.http.ssl.client_authentication", sslClientAuth).put("xpack.security.authc.realms.file.file.order", "0").put("xpack.security.authc.realms.pki.pki1.order", "1").put("xpack.security.authc.realms.pki.pki1.certificate_authorities", getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt")).put("xpack.security.authc.realms.pki.pki1.files.role_mapping", getDataPath("role_mapping.yml")).     return builder.build(). }
false;protected;0;4;;@Override protected boolean transportSSLEnabled() {     return true. }
false;protected;0;6;;@Override protected boolean enableWarningsCheck() {     // secure settings for the transport client     return false. }
false;public;0;15;;public void testTransportClientCanAuthenticateViaPki() {     Settings.Builder builder = Settings.builder().     addSSLSettingsForPEMFiles(builder, "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem", "testnode", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt", Arrays.asList("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt")).     try (TransportClient client = createTransportClient(builder.build())) {         client.addTransportAddress(randomFrom(node().injector().getInstance(Transport.class).boundAddress().boundAddresses())).         IndexResponse response = client.prepareIndex("foo", "bar").setSource("pki", "auth").get().         assertEquals(DocWriteResponse.Result.CREATED, response.getResult()).     } }
true;public;0;9;/**  * Test uses the testclient cert which is trusted by the SSL layer BUT it is not trusted by the PKI authentication  * realm  */ ;/**  * Test uses the testclient cert which is trusted by the SSL layer BUT it is not trusted by the PKI authentication  * realm  */ public void testTransportClientAuthenticationFailure() {     try (TransportClient client = createTransportClient(Settings.EMPTY)) {         client.addTransportAddress(randomFrom(node().injector().getInstance(Transport.class).boundAddress().boundAddresses())).         client.prepareIndex("foo", "bar").setSource("pki", "auth").get().         fail("transport client should not have been able to authenticate").     } catch (NoNodeAvailableException e) {         assertThat(e.getMessage(), containsString("None of the configured nodes are available: [{#transport#")).     } }
false;public;0;14;;public void testRestAuthenticationViaPki() throws Exception {     SSLContext context = getRestSSLContext("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem", "testnode", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt", Arrays.asList("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt")).     try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {         HttpPut put = new HttpPut(getNodeUrl() + "foo").         try (CloseableHttpResponse response = SocketAccess.doPrivileged(() -> client.execute(put))) {             String body = EntityUtils.toString(response.getEntity()).             assertThat(body, containsString("\"acknowledged\":true")).         }     } }
false;public;0;14;;public void testRestAuthenticationFailure() throws Exception {     SSLContext context = getRestSSLContext("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.pem", "testclient", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt", Arrays.asList("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt")).     try (CloseableHttpClient client = HttpClients.custom().setSSLContext(context).build()) {         HttpPut put = new HttpPut(getNodeUrl() + "foo").         try (CloseableHttpResponse response = SocketAccess.doPrivileged(() -> client.execute(put))) {             assertThat(response.getStatusLine().getStatusCode(), is(401)).             String body = EntityUtils.toString(response.getEntity()).             assertThat(body, containsString("unable to authenticate user [Elasticsearch Test Client]")).         }     } }
false;private;4;9;;private SSLContext getRestSSLContext(String keyPath, String password, String certPath, List<String> trustedCertPaths) throws Exception {     SSLContext context = SSLContext.getInstance("TLS").     TrustManager tm = CertParsingUtils.trustManager(CertParsingUtils.readCertificates(trustedCertPaths.stream().map(p -> getDataPath(p)).collect(Collectors.toList()))).     KeyManager km = CertParsingUtils.keyManager(CertParsingUtils.readCertificates(Collections.singletonList(getDataPath(certPath))), PemUtils.readPrivateKey(getDataPath(keyPath), password::toCharArray), password.toCharArray()).     context.init(new KeyManager[] { km }, new TrustManager[] { tm }, new SecureRandom()).     return context. }
false;private;1;15;;private TransportClient createTransportClient(Settings additionalSettings) {     Settings clientSettings = transportClientSettings().     if (additionalSettings.getByPrefix("xpack.security.transport.ssl.").isEmpty() == false) {         clientSettings = clientSettings.filter(k -> k.startsWith("xpack.security.transport.ssl.") == false).     }     Settings.Builder builder = Settings.builder().put("xpack.security.transport.ssl.enabled", true).put(clientSettings, false).put(additionalSettings).put("cluster.name", node().settings().get("cluster.name")).     builder.remove(SecurityField.USER_SETTING.getKey()).     builder.remove("request.headers.Authorization").     return new TestXPackTransportClient(builder.build(), LocalStateSecurity.class). }
false;private;0;6;;private String getNodeUrl() {     TransportAddress transportAddress = randomFrom(node().injector().getInstance(HttpServerTransport.class).boundAddress().boundAddresses()).     final InetSocketAddress inetSocketAddress = transportAddress.address().     return String.format(Locale.ROOT, "https://%s/", NetworkAddress.format(inetSocketAddress)). }
