commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void loadMappings(ActionListener<List<ExpressionRoleMapping>> listener) {     final List<ExpressionRoleMapping> mappings = Arrays.asList(mapping1, mapping2, mapping3, mapping4).     logger.info("Role mappings are: [{}]", mappings).     listener.onResponse(mappings). }
false;public;0;53;;public void testResolveRoles() throws Exception {     // Does match DN     final ExpressionRoleMapping mapping1 = new ExpressionRoleMapping("dept_h", new FieldExpression("dn", Collections.singletonList(new FieldValue("*,ou=dept_h,o=forces,dc=gc,dc=ca"))), Arrays.asList("dept_h", "defence"), Collections.emptyMap(), true).     // Does not match - user is not in this group     final ExpressionRoleMapping mapping2 = new ExpressionRoleMapping("admin", new FieldExpression("groups", Collections.singletonList(new FieldValue(randomiseDn("cn=esadmin,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca")))), Arrays.asList("admin"), Collections.emptyMap(), true).     // Does match - user is one of these groups     final ExpressionRoleMapping mapping3 = new ExpressionRoleMapping("flight", new FieldExpression("groups", Arrays.asList(new FieldValue(randomiseDn("cn=alphaflight,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca")), new FieldValue(randomiseDn("cn=betaflight,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca")), new FieldValue(randomiseDn("cn=gammaflight,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca")))), Arrays.asList("flight"), Collections.emptyMap(), true).     // Does not match - mapping is not enabled     final ExpressionRoleMapping mapping4 = new ExpressionRoleMapping("mutants", new FieldExpression("groups", Collections.singletonList(new FieldValue(randomiseDn("cn=mutants,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca")))), Arrays.asList("mutants"), Collections.emptyMap(), false).     final Client client = mock(Client.class).     SecurityIndexManager securityIndex = mock(SecurityIndexManager.class).     when(securityIndex.isAvailable()).thenReturn(true).     final NativeRoleMappingStore store = new NativeRoleMappingStore(Settings.EMPTY, client, securityIndex) {          @Override         protected void loadMappings(ActionListener<List<ExpressionRoleMapping>> listener) {             final List<ExpressionRoleMapping> mappings = Arrays.asList(mapping1, mapping2, mapping3, mapping4).             logger.info("Role mappings are: [{}]", mappings).             listener.onResponse(mappings).         }     }.     final RealmConfig realm = new RealmConfig(new RealmConfig.RealmIdentifier("ldap", "ldap1"), Settings.EMPTY, mock(Environment.class), new ThreadContext(Settings.EMPTY)).     final PlainActionFuture<Set<String>> future = new PlainActionFuture<>().     final UserRoleMapper.UserData user = new UserRoleMapper.UserData("sasquatch", randomiseDn("cn=walter.langowski,ou=people,ou=dept_h,o=forces,dc=gc,dc=ca"), Arrays.asList(randomiseDn("cn=alphaflight,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca"), randomiseDn("cn=mutants,ou=groups,ou=dept_h,o=forces,dc=gc,dc=ca")), Collections.emptyMap(), realm).     logger.info("UserData is [{}]", user).     store.resolveRoles(user, future).     final Set<String> roles = future.get().     assertThat(roles, Matchers.containsInAnyOrder("dept_h", "defence", "flight")). }
false;private;1;21;;private String randomiseDn(String dn) {     // but (potentially) textually different     switch(randomIntBetween(0, 3)) {         case 0:             // do nothing             return dn.         case 1:             return dn.toUpperCase(Locale.ROOT).         case 2:             // Upper case just the attribute name for each RDN             return Arrays.stream(dn.split(",")).map(s -> {                 final String[] arr = s.split("=").                 arr[0] = arr[0].toUpperCase(Locale.ROOT).                 return String.join("=", arr).             }).collect(Collectors.joining(",")).         case 3:             return dn.replaceAll(",", ", ").     }     return dn. }
false;private;1;3;;private SecurityIndexManager.State dummyState(ClusterHealthStatus indexStatus) {     return new SecurityIndexManager.State(true, true, true, true, null, concreteSecurityIndexName, indexStatus). }
false;public;0;36;;public void testCacheClearOnIndexHealthChange() {     final AtomicInteger numInvalidation = new AtomicInteger(0).     final NativeRoleMappingStore store = buildRoleMappingStoreForInvalidationTesting(numInvalidation).     int expectedInvalidation = 0.     // existing to no longer present     SecurityIndexManager.State previousState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     SecurityIndexManager.State currentState = dummyState(null).     store.onSecurityIndexStateChange(previousState, currentState).     assertEquals(++expectedInvalidation, numInvalidation.get()).     // doesn't exist to exists     previousState = dummyState(null).     currentState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     store.onSecurityIndexStateChange(previousState, currentState).     assertEquals(++expectedInvalidation, numInvalidation.get()).     // green or yellow to red     previousState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     currentState = dummyState(ClusterHealthStatus.RED).     store.onSecurityIndexStateChange(previousState, currentState).     assertEquals(expectedInvalidation, numInvalidation.get()).     // red to non red     previousState = dummyState(ClusterHealthStatus.RED).     currentState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     store.onSecurityIndexStateChange(previousState, currentState).     assertEquals(++expectedInvalidation, numInvalidation.get()).     // green to yellow or yellow to green     previousState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     currentState = dummyState(previousState.indexStatus == ClusterHealthStatus.GREEN ? ClusterHealthStatus.YELLOW : ClusterHealthStatus.GREEN).     store.onSecurityIndexStateChange(previousState, currentState).     assertEquals(expectedInvalidation, numInvalidation.get()). }
false;public;0;14;;public void testCacheClearOnIndexOutOfDateChange() {     final AtomicInteger numInvalidation = new AtomicInteger(0).     final NativeRoleMappingStore store = buildRoleMappingStoreForInvalidationTesting(numInvalidation).     store.onSecurityIndexStateChange(new SecurityIndexManager.State(true, false, true, true, null, concreteSecurityIndexName, null), new SecurityIndexManager.State(true, true, true, true, null, concreteSecurityIndexName, null)).     assertEquals(1, numInvalidation.get()).     store.onSecurityIndexStateChange(new SecurityIndexManager.State(true, true, true, true, null, concreteSecurityIndexName, null), new SecurityIndexManager.State(true, false, true, true, null, concreteSecurityIndexName, null)).     assertEquals(2, numInvalidation.get()). }
false;protected;2;4;;@Override protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {     listener.onResponse(AuthenticationResult.notHandled()). }
false;protected;2;4;;@Override protected void doLookupUser(String username, ActionListener<User> listener) {     listener.onResponse(null). }
false;private;1;35;;private NativeRoleMappingStore buildRoleMappingStoreForInvalidationTesting(AtomicInteger invalidationCounter) {     final Settings settings = Settings.builder().put("path.home", createTempDir()).build().     final ThreadPool threadPool = mock(ThreadPool.class).     final ThreadContext threadContext = new ThreadContext(settings).     when(threadPool.getThreadContext()).thenReturn(threadContext).     final Client client = mock(Client.class).     when(client.threadPool()).thenReturn(threadPool).     when(client.settings()).thenReturn(settings).     doAnswer(invocationOnMock -> {         ActionListener<ClearRealmCacheResponse> listener = (ActionListener<ClearRealmCacheResponse>) invocationOnMock.getArguments()[2].         invalidationCounter.incrementAndGet().         listener.onResponse(new ClearRealmCacheResponse(new ClusterName("cluster"), Collections.emptyList(), Collections.emptyList())).         return null.     }).when(client).execute(eq(ClearRealmCacheAction.INSTANCE), any(ClearRealmCacheRequest.class), any(ActionListener.class)).     final Environment env = TestEnvironment.newEnvironment(settings).     final RealmConfig realmConfig = new RealmConfig(new RealmConfig.RealmIdentifier("ldap", getTestName()), settings, env, threadContext).     final CachingUsernamePasswordRealm mockRealm = new CachingUsernamePasswordRealm(realmConfig, threadPool) {          @Override         protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {             listener.onResponse(AuthenticationResult.notHandled()).         }          @Override         protected void doLookupUser(String username, ActionListener<User> listener) {             listener.onResponse(null).         }     }.     final NativeRoleMappingStore store = new NativeRoleMappingStore(Settings.EMPTY, client, mock(SecurityIndexManager.class)).     store.refreshRealmOnChange(mockRealm).     return store. }
