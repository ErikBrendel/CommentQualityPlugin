commented;modifiers;parameterAmount;loc;comment;code
false;public;0;58;;public void testInterceptorThrowsWhenFLSDLSEnabled() {     XPackLicenseState licenseState = mock(XPackLicenseState.class).     when(licenseState.copyCurrentLicenseState()).thenReturn(licenseState).     when(licenseState.isAuthAllowed()).thenReturn(true).     when(licenseState.isAuditingAllowed()).thenReturn(true).     when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(true).     ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     AuditTrailService auditTrailService = new AuditTrailService(Collections.emptyList(), licenseState).     Authentication authentication = new Authentication(new User("john", "role"), new RealmRef(null, null, null), new RealmRef(null, null, null)).     final FieldPermissions fieldPermissions.     final boolean useFls = randomBoolean().     if (useFls) {         fieldPermissions = new FieldPermissions(new FieldPermissionsDefinition(new String[] { "foo" }, null)).     } else {         fieldPermissions = new FieldPermissions().     }     final boolean useDls = (useFls == false) || randomBoolean().     final Set<BytesReference> queries.     if (useDls) {         queries = Collections.singleton(new BytesArray(randomAlphaOfLengthBetween(2, 8))).     } else {         queries = null.     }     final String action = IndicesAliasesAction.NAME.     IndicesAccessControl accessControl = new IndicesAccessControl(true, Collections.singletonMap("foo", new IndicesAccessControl.IndexAccessControl(true, fieldPermissions, (useDls) ? DocumentPermissions.filteredBy(queries) : DocumentPermissions.allowAll()))).     threadContext.putTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, accessControl).     IndicesAliasesRequestInterceptor interceptor = new IndicesAliasesRequestInterceptor(threadContext, licenseState, auditTrailService).     IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest().     if (randomBoolean()) {         indicesAliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.remove().index("bar").alias(randomAlphaOfLength(4))).     }     indicesAliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add().index("foo").alias(randomAlphaOfLength(4))).     if (randomBoolean()) {         indicesAliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index("foofoo")).     }     PlainActionFuture<Void> plainActionFuture = new PlainActionFuture<>().     RequestInfo requestInfo = new RequestInfo(authentication, indicesAliasesRequest, action).     AuthorizationEngine mockEngine = mock(AuthorizationEngine.class).     doAnswer(invocationOnMock -> {         ActionListener<AuthorizationResult> listener = (ActionListener<AuthorizationResult>) invocationOnMock.getArguments()[3].         listener.onResponse(AuthorizationResult.deny()).         return null.     }).when(mockEngine).validateIndexPermissionsAreSubset(eq(requestInfo), eq(EmptyAuthorizationInfo.INSTANCE), any(Map.class), any(ActionListener.class)).     ElasticsearchSecurityException securityException = expectThrows(ElasticsearchSecurityException.class, () -> {         interceptor.intercept(requestInfo, mockEngine, EmptyAuthorizationInfo.INSTANCE, plainActionFuture).         plainActionFuture.actionGet().     }).     assertEquals("Alias requests are not allowed for users who have field or document level security enabled on one of the indices", securityException.getMessage()). }
false;public;0;67;;public void testInterceptorThrowsWhenTargetHasGreaterPermissions() throws Exception {     XPackLicenseState licenseState = mock(XPackLicenseState.class).     when(licenseState.copyCurrentLicenseState()).thenReturn(licenseState).     when(licenseState.isAuthAllowed()).thenReturn(true).     when(licenseState.isAuditingAllowed()).thenReturn(true).     when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(randomBoolean()).     ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     AuditTrailService auditTrailService = new AuditTrailService(Collections.emptyList(), licenseState).     Authentication authentication = new Authentication(new User("john", "role"), new RealmRef(null, null, null), new RealmRef(null, null, null)).     final String action = IndicesAliasesAction.NAME.     IndicesAccessControl accessControl = new IndicesAccessControl(true, Collections.emptyMap()).     threadContext.putTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, accessControl).     IndicesAliasesRequestInterceptor interceptor = new IndicesAliasesRequestInterceptor(threadContext, licenseState, auditTrailService).     final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest().     if (randomBoolean()) {         indicesAliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.remove().index("bar").alias(randomAlphaOfLength(4))).     }     indicesAliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add().index("index").alias("alias")).     if (randomBoolean()) {         indicesAliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index("foofoo")).     }     AuthorizationEngine mockEngine = mock(AuthorizationEngine.class).     {         PlainActionFuture<Void> plainActionFuture = new PlainActionFuture<>().         RequestInfo requestInfo = new RequestInfo(authentication, indicesAliasesRequest, action).         doAnswer(invocationOnMock -> {             ActionListener<AuthorizationResult> listener = (ActionListener<AuthorizationResult>) invocationOnMock.getArguments()[3].             listener.onResponse(AuthorizationResult.deny()).             return null.         }).when(mockEngine).validateIndexPermissionsAreSubset(eq(requestInfo), eq(EmptyAuthorizationInfo.INSTANCE), any(Map.class), any(ActionListener.class)).         ElasticsearchSecurityException securityException = expectThrows(ElasticsearchSecurityException.class, () -> {             interceptor.intercept(requestInfo, mockEngine, EmptyAuthorizationInfo.INSTANCE, plainActionFuture).             plainActionFuture.actionGet().         }).         assertEquals("Adding an alias is not allowed when the alias has more permissions than any of the indices", securityException.getMessage()).     }     // swap target and source for success     final IndicesAliasesRequest successRequest = new IndicesAliasesRequest().     if (randomBoolean()) {         successRequest.addAliasAction(IndicesAliasesRequest.AliasActions.remove().index("bar").alias(randomAlphaOfLength(4))).     }     successRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add().index("alias").alias("index")).     if (randomBoolean()) {         successRequest.addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index("foofoo")).     }     {         PlainActionFuture<Void> plainActionFuture = new PlainActionFuture<>().         RequestInfo requestInfo = new RequestInfo(authentication, successRequest, action).         doAnswer(invocationOnMock -> {             ActionListener<AuthorizationResult> listener = (ActionListener<AuthorizationResult>) invocationOnMock.getArguments()[3].             listener.onResponse(AuthorizationResult.granted()).             return null.         }).when(mockEngine).validateIndexPermissionsAreSubset(eq(requestInfo), eq(EmptyAuthorizationInfo.INSTANCE), any(Map.class), any(ActionListener.class)).         interceptor.intercept(requestInfo, mockEngine, EmptyAuthorizationInfo.INSTANCE, plainActionFuture).         plainActionFuture.actionGet().     } }
