commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void configureRunAsHasSuperUserRole() {     runAsHasSuperUserRole = randomBoolean(). }
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;public;0;4;;@Override public String configRoles() {     return ROLES + super.configRoles(). }
false;public;0;6;;@Override public String configUsers() {     return super.configUsers() + RUN_AS_USER + ":" + SecuritySettingsSource.TEST_PASSWORD_HASHED + "\n" + TRANSPORT_CLIENT_USER + ":" + SecuritySettingsSource.TEST_PASSWORD_HASHED + "\n". }
false;public;0;11;;@Override public String configUsersRoles() {     String roles = super.configUsersRoles() + "run_as_role:" + RUN_AS_USER + "\n" + "transport_client:" + TRANSPORT_CLIENT_USER.     if (runAsHasSuperUserRole) {         roles = roles + "\n" + "superuser:" + RUN_AS_USER.     }     return roles. }
false;protected;0;4;;@Override protected boolean transportSSLEnabled() {     return false. }
false;public;0;36;;public void testUserImpersonation() throws Exception {     try (TransportClient client = getTransportClient(Settings.builder().put(SecurityField.USER_SETTING.getKey(), TRANSPORT_CLIENT_USER + ":" + SecuritySettingsSourceField.TEST_PASSWORD).build())) {         // ensure the client can connect         assertBusy(() -> assertThat(client.connectedNodes().size(), greaterThan(0))).         // make sure the client can't get health         try {             client.admin().cluster().prepareHealth().get().             fail("the client user should not have privileges to get the health").         } catch (ElasticsearchSecurityException e) {             assertThat(e.getMessage(), containsString("unauthorized")).         }         // let's run as without authorization         try {             Map<String, String> headers = Collections.singletonMap(AuthenticationServiceField.RUN_AS_USER_HEADER, SecuritySettingsSource.TEST_USER_NAME).             client.filterWithHeader(headers).admin().cluster().prepareHealth().get().             fail("run as should be unauthorized for the transport client user").         } catch (ElasticsearchSecurityException e) {             assertThat(e.getMessage(), containsString("unauthorized")).             assertThat(e.getMessage(), containsString("run as")).         }         Map<String, String> headers = new HashMap<>().         headers.put("Authorization", UsernamePasswordToken.basicAuthHeaderValue(RUN_AS_USER, new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()))).         headers.put(AuthenticationServiceField.RUN_AS_USER_HEADER, SecuritySettingsSource.TEST_USER_NAME).         // lets set the user         ClusterHealthResponse response = client.filterWithHeader(headers).admin().cluster().prepareHealth().get().         assertThat(response.isTimedOut(), is(false)).     } }
false;public;0;32;;public void testUserImpersonationUsingHttp() throws Exception {     // use the transport client user and try to run as     try {         Request request = new Request("GET", "/_nodes").         RequestOptions.Builder options = request.getOptions().toBuilder().         options.addHeader("Authorization", UsernamePasswordToken.basicAuthHeaderValue(TRANSPORT_CLIENT_USER, TEST_PASSWORD_SECURE_STRING)).         options.addHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, SecuritySettingsSource.TEST_USER_NAME).         request.setOptions(options).         getRestClient().performRequest(request).         fail("request should have failed").     } catch (ResponseException e) {         assertThat(e.getResponse().getStatusLine().getStatusCode(), is(403)).     }     if (runAsHasSuperUserRole == false) {         try {             // the run as user shouldn't have access to the nodes api             Request request = new Request("GET", "/_nodes").             RequestOptions.Builder options = request.getOptions().toBuilder().             options.addHeader("Authorization", UsernamePasswordToken.basicAuthHeaderValue(RUN_AS_USER, TEST_PASSWORD_SECURE_STRING)).             request.setOptions(options).             getRestClient().performRequest(request).             fail("request should have failed").         } catch (ResponseException e) {             assertThat(e.getResponse().getStatusLine().getStatusCode(), is(403)).         }     }     // but when running as a different user it should work     getRestClient().performRequest(requestForUserRunAsUser(SecuritySettingsSource.TEST_USER_NAME)). }
false;public;0;22;;public void testEmptyUserImpersonationHeader() throws Exception {     try (TransportClient client = getTransportClient(Settings.builder().put(SecurityField.USER_SETTING.getKey(), TRANSPORT_CLIENT_USER + ":" + SecuritySettingsSourceField.TEST_PASSWORD).build())) {         // ensure the client can connect         awaitBusy(() -> {             return client.connectedNodes().size() > 0.         }).         try {             Map<String, String> headers = new HashMap<>().             headers.put("Authorization", UsernamePasswordToken.basicAuthHeaderValue(RUN_AS_USER, new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()))).             headers.put(AuthenticationServiceField.RUN_AS_USER_HEADER, "").             client.filterWithHeader(headers).admin().cluster().prepareHealth().get().             fail("run as header should not be allowed to be empty").         } catch (ElasticsearchSecurityException e) {             assertThat(e.getMessage(), containsString("unable to authenticate")).         }     } }
false;public;0;8;;public void testEmptyHeaderUsingHttp() throws Exception {     try {         getRestClient().performRequest(requestForUserRunAsUser("")).         fail("request should have failed").     } catch (ResponseException e) {         assertThat(e.getResponse().getStatusLine().getStatusCode(), is(401)).     } }
false;public;0;22;;public void testNonExistentRunAsUser() throws Exception {     try (TransportClient client = getTransportClient(Settings.builder().put(SecurityField.USER_SETTING.getKey(), TRANSPORT_CLIENT_USER + ":" + SecuritySettingsSourceField.TEST_PASSWORD).build())) {         // ensure the client can connect         awaitBusy(() -> {             return client.connectedNodes().size() > 0.         }).         try {             Map<String, String> headers = new HashMap<>().             headers.put("Authorization", UsernamePasswordToken.basicAuthHeaderValue(RUN_AS_USER, new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()))).             headers.put(AuthenticationServiceField.RUN_AS_USER_HEADER, "idontexist").             client.filterWithHeader(headers).admin().cluster().prepareHealth().get().             fail("run as header should not accept non-existent users").         } catch (ElasticsearchSecurityException e) {             assertThat(e.getMessage(), containsString("unauthorized")).         }     } }
false;public;0;8;;public void testNonExistentRunAsUserUsingHttp() throws Exception {     try {         getRestClient().performRequest(requestForUserRunAsUser("idontexist")).         fail("request should have failed").     } catch (ResponseException e) {         assertThat(e.getResponse().getStatusLine().getStatusCode(), is(403)).     } }
false;private,static;1;8;;private static Request requestForUserRunAsUser(String user) {     Request request = new Request("GET", "/_nodes").     RequestOptions.Builder options = request.getOptions().toBuilder().     options.addHeader("Authorization", UsernamePasswordToken.basicAuthHeaderValue(RUN_AS_USER, TEST_PASSWORD_SECURE_STRING)).     options.addHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, user).     request.setOptions(options).     return request. }
true;;1;15;// build our own here to better mimic an actual client... ;// build our own here to better mimic an actual client... TransportClient getTransportClient(Settings extraSettings) {     NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().get().     List<NodeInfo> nodes = nodeInfos.getNodes().     assertTrue(nodes.isEmpty() == false).     TransportAddress publishAddress = randomFrom(nodes).getTransport().address().publishAddress().     String clusterName = nodeInfos.getClusterName().value().     Settings settings = Settings.builder().put(extraSettings).put("cluster.name", clusterName).build().     return new TestXPackTransportClient(settings, LocalStateSecurity.class).addTransportAddress(publishAddress). }
