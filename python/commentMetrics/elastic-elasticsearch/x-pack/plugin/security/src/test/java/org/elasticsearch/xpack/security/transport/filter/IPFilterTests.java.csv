commented;modifiers;parameterAmount;loc;comment;code
false;public;0;30;;@Before public void init() {     licenseState = mock(XPackLicenseState.class).     when(licenseState.isIpFilteringAllowed()).thenReturn(true).     auditTrail = mock(AuditTrailService.class).     clusterSettings = new ClusterSettings(Settings.EMPTY, new HashSet<>(Arrays.asList(IPFilter.HTTP_FILTER_ALLOW_SETTING, IPFilter.HTTP_FILTER_DENY_SETTING, IPFilter.IP_FILTER_ENABLED_HTTP_SETTING, IPFilter.IP_FILTER_ENABLED_SETTING, IPFilter.TRANSPORT_FILTER_ALLOW_SETTING, IPFilter.TRANSPORT_FILTER_DENY_SETTING, IPFilter.PROFILE_FILTER_ALLOW_SETTING, IPFilter.PROFILE_FILTER_DENY_SETTING))).     httpTransport = mock(HttpServerTransport.class).     TransportAddress httpAddress = new TransportAddress(InetAddress.getLoopbackAddress(), 9200).     when(httpTransport.boundAddress()).thenReturn(new BoundTransportAddress(new TransportAddress[] { httpAddress }, httpAddress)).     when(httpTransport.lifecycleState()).thenReturn(Lifecycle.State.STARTED).     transport = mock(Transport.class).     TransportAddress address = new TransportAddress(InetAddress.getLoopbackAddress(), 9300).     when(transport.boundAddress()).thenReturn(new BoundTransportAddress(new TransportAddress[] { address }, address)).     when(transport.lifecycleState()).thenReturn(Lifecycle.State.STARTED).     Map<String, BoundTransportAddress> profileBoundAddresses = Collections.singletonMap("client", new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9500) }, address)).     when(transport.profileBoundAddresses()).thenReturn(profileBoundAddresses). }
false;public;0;10;;public void testThatIpV4AddressesCanBeProcessed() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "127.0.0.1").put("xpack.security.transport.filter.deny", "10.0.0.0/8").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("127.0.0.1").     assertAddressIsDenied("10.2.3.4"). }
false;public;0;14;;public void testThatIpV6AddressesCanBeProcessed() throws Exception {     // you have to use the shortest possible notation in order to match, so     // 1234:0db8:85a3:0000:0000:8a2e:0370:7334 becomes 1234:db8:85a3:0:0:8a2e:370:7334     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "2001:0db8:1234::/48").putList("xpack.security.transport.filter.deny", "1234:db8:85a3:0:0:8a2e:370:7334", "4321:db8:1234::/48").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("2001:0db8:1234:0000:0000:8a2e:0370:7334").     assertAddressIsDenied("1234:0db8:85a3:0000:0000:8a2e:0370:7334").     assertAddressIsDenied("4321:0db8:1234:0000:0000:8a2e:0370:7334"). }
false;public;0;13;;// requires network for name resolution @Network public void testThatHostnamesCanBeProcessed() throws Exception {     Settings settings = Settings.builder().put("xpack.ml.autodetect_process", false).put("xpack.security.transport.filter.allow", "127.0.0.1").put("xpack.security.transport.filter.deny", "*.google.com").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("127.0.0.1").     assertAddressIsDenied("8.8.8.8"). }
false;public;0;9;;public void testThatAnAllowAllAuthenticatorWorks() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "_all").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("127.0.0.1").     assertAddressIsAllowed("173.194.70.100"). }
false;public;0;14;;public void testThatProfilesAreSupported() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "localhost").put("xpack.security.transport.filter.deny", "_all").put("transport.profiles.client.xpack.security.filter.allow", "192.168.0.1").put("transport.profiles.client.xpack.security.filter.deny", "_all").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("127.0.0.1").     assertAddressIsDenied("192.168.0.1").     assertAddressIsAllowedForProfile("client", "192.168.0.1").     assertAddressIsDeniedForProfile("client", "192.168.0.2"). }
false;public;0;20;;public void testThatProfilesAreUpdateable() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "localhost").put("xpack.security.transport.filter.deny", "_all").put("transport.profiles.client.xpack.security.filter.allow", "192.168.0.1").put("transport.profiles.client.xpack.security.filter.deny", "_all").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     Settings newSettings = Settings.builder().putList("transport.profiles.client.xpack.security.filter.allow", "192.168.0.1", "192.168.0.2").put("transport.profiles.client.xpack.security.filter.deny", "192.168.0.3").build().     Settings.Builder updatedSettingsBuilder = Settings.builder().     clusterSettings.updateDynamicSettings(newSettings, updatedSettingsBuilder, Settings.builder(), "test").     clusterSettings.applySettings(updatedSettingsBuilder.build()).     assertAddressIsAllowed("127.0.0.1").     assertAddressIsDenied("192.168.0.1").     assertAddressIsAllowedForProfile("client", "192.168.0.1", "192.168.0.2").     assertAddressIsDeniedForProfile("client", "192.168.0.3"). }
false;public;0;10;;public void testThatAllowWinsOverDeny() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "10.0.0.1").put("xpack.security.transport.filter.deny", "10.0.0.0/8").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("10.0.0.1").     assertAddressIsDenied("10.0.0.2"). }
false;public;0;7;;public void testDefaultAllow() throws Exception {     Settings settings = Settings.builder().build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowed("10.0.0.1").     assertAddressIsAllowed("10.0.0.2"). }
false;public;0;13;;public void testThatHttpWorks() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "127.0.0.1").put("xpack.security.transport.filter.deny", "10.0.0.0/8").put("xpack.security.http.filter.allow", "10.0.0.0/8").put("xpack.security.http.filter.deny", "192.168.0.1").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundHttpTransportAddress(httpTransport.boundAddress()).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowedForProfile(IPFilter.HTTP_PROFILE_NAME, "10.2.3.4").     assertAddressIsDeniedForProfile(IPFilter.HTTP_PROFILE_NAME, "192.168.0.1"). }
false;public;0;12;;public void testThatHttpFallsbackToDefault() throws Exception {     Settings settings = Settings.builder().put("xpack.security.transport.filter.allow", "127.0.0.1").put("xpack.security.transport.filter.deny", "10.0.0.0/8").build().     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundHttpTransportAddress(httpTransport.boundAddress()).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsAllowedForProfile(IPFilter.HTTP_PROFILE_NAME, "127.0.0.1").     assertAddressIsDeniedForProfile(IPFilter.HTTP_PROFILE_NAME, "10.2.3.4"). }
false;public;0;22;;public void testThatBoundAddressIsNeverRejected() throws Exception {     List<String> addressStrings = new ArrayList<>().     for (TransportAddress address : transport.boundAddress().boundAddresses()) {         addressStrings.add(NetworkAddress.format(address.address().getAddress())).     }     Settings settings.     if (randomBoolean()) {         settings = Settings.builder().putList("xpack.security.transport.filter.deny", addressStrings.toArray(new String[addressStrings.size()])).build().     } else {         settings = Settings.builder().put("xpack.security.transport.filter.deny", "_all").build().     }     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     ipFilter.setBoundHttpTransportAddress(httpTransport.boundAddress()).     for (String addressString : addressStrings) {         assertAddressIsAllowedForProfile(IPFilter.HTTP_PROFILE_NAME, addressString).         assertAddressIsAllowedForProfile("default", addressString).     } }
false;public;0;21;;public void testThatAllAddressesAreAllowedWhenLicenseDisablesSecurity() {     Settings settings = Settings.builder().put("xpack.security.transport.filter.deny", "_all").build().     when(licenseState.isIpFilteringAllowed()).thenReturn(false).     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     // don't use the assert helper because we don't want the audit trail to be invoked here     String message = String.format(Locale.ROOT, "Expected address %s to be allowed", "8.8.8.8").     InetAddress address = InetAddresses.forString("8.8.8.8").     assertThat(message, ipFilter.accept("default", new InetSocketAddress(address, 0)), is(true)).     verifyZeroInteractions(auditTrail).     // for sanity enable license and check that it is denied     when(licenseState.isIpFilteringAllowed()).thenReturn(true).     ipFilter = new IPFilter(settings, auditTrail, clusterSettings, licenseState).     ipFilter.setBoundTransportAddress(transport.boundAddress(), transport.profileBoundAddresses()).     assertAddressIsDeniedForProfile("default", "8.8.8.8"). }
false;public;0;10;;public void testThatNodeStartsWithIPFilterDisabled() throws Exception {     Settings settings = Settings.builder().put("path.home", createTempDir()).put("xpack.security.transport.filter.enabled", randomBoolean()).put("xpack.security.http.filter.enabled", randomBoolean()).build().     try (Node node = new MockNode(settings, Arrays.asList(LocalStateSecurity.class))) {         assertNotNull(node).     } }
false;private;2;10;;private void assertAddressIsAllowedForProfile(String profile, String... inetAddresses) {     for (String inetAddress : inetAddresses) {         String message = String.format(Locale.ROOT, "Expected address %s to be allowed", inetAddress).         InetAddress address = InetAddresses.forString(inetAddress).         assertTrue(message, ipFilter.accept(profile, new InetSocketAddress(address, 0))).         ArgumentCaptor<SecurityIpFilterRule> ruleCaptor = ArgumentCaptor.forClass(SecurityIpFilterRule.class).         verify(auditTrail).connectionGranted(eq(address), eq(profile), ruleCaptor.capture()).         assertNotNull(ruleCaptor.getValue()).     } }
false;private;1;3;;private void assertAddressIsAllowed(String... inetAddresses) {     assertAddressIsAllowedForProfile("default", inetAddresses). }
false;private;2;10;;private void assertAddressIsDeniedForProfile(String profile, String... inetAddresses) {     for (String inetAddress : inetAddresses) {         String message = String.format(Locale.ROOT, "Expected address %s to be denied", inetAddress).         InetAddress address = InetAddresses.forString(inetAddress).         assertFalse(message, ipFilter.accept(profile, new InetSocketAddress(address, 0))).         ArgumentCaptor<SecurityIpFilterRule> ruleCaptor = ArgumentCaptor.forClass(SecurityIpFilterRule.class).         verify(auditTrail).connectionDenied(eq(address), eq(profile), ruleCaptor.capture()).         assertNotNull(ruleCaptor.getValue()).     } }
false;private;1;3;;private void assertAddressIsDenied(String... inetAddresses) {     assertAddressIsDeniedForProfile("default", inetAddresses). }
