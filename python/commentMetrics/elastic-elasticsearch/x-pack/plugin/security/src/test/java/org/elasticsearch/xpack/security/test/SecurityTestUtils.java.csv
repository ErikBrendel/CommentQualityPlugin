commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;22;;public static String writeFile(Path folder, String name, byte[] content) {     final Path path = folder.resolve(name).     Path tempFile = null.     try {         tempFile = Files.createTempFile(path.getParent(), path.getFileName().toString(), "tmp").         try (OutputStream os = Files.newOutputStream(tempFile, CREATE, TRUNCATE_EXISTING, WRITE)) {             Streams.copy(content, os).         }         try {             Files.move(tempFile, path, REPLACE_EXISTING, ATOMIC_MOVE).         } catch (final AtomicMoveNotSupportedException e) {             Files.move(tempFile, path, REPLACE_EXISTING).         }     } catch (final IOException e) {         throw new UncheckedIOException(String.format(Locale.ROOT, "could not write file [%s]", path.toAbsolutePath()), e).     } finally {         // we are ignoring exceptions here, so we do not need handle whether or not tempFile was initialized nor if the file exists         IOUtils.deleteFilesIgnoringExceptions(tempFile).     }     return path.toAbsolutePath().toString(). }
false;public,static;3;3;;public static String writeFile(Path folder, String name, String content) {     return writeFile(folder, name, content.getBytes(StandardCharsets.UTF_8)). }
false;public,static;1;12;;public static RoutingTable buildIndexRoutingTable(String indexName) {     Index index = new Index(indexName, UUID.randomUUID().toString()).     ShardRouting shardRouting = ShardRouting.newUnassigned(new ShardId(index, 0), true, ExistingStoreRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "")).     String nodeId = ESTestCase.randomAlphaOfLength(8).     IndexShardRoutingTable table = new IndexShardRoutingTable.Builder(new ShardId(index, 0)).addShard(shardRouting.initialize(nodeId, null, shardRouting.getExpectedShardSize()).moveToStarted()).build().     return RoutingTable.builder().add(IndexRoutingTable.builder(index).addIndexShard(table).build()).build(). }
true;public,static;2;7;/**  * Adds the index alias {@code .security} to the underlying concrete index.  */ ;/**  * Adds the index alias {@code .security} to the underlying concrete index.  */ public static MetaData addAliasToMetaData(MetaData metaData, String indexName) {     AliasMetaData aliasMetaData = AliasMetaData.newAliasMetaDataBuilder(SECURITY_INDEX_NAME).build().     MetaData.Builder metaDataBuilder = new MetaData.Builder(metaData).     IndexMetaData indexMetaData = metaData.index(indexName).     metaDataBuilder.put(IndexMetaData.builder(indexMetaData).putAlias(aliasMetaData)).     return metaDataBuilder.build(). }
