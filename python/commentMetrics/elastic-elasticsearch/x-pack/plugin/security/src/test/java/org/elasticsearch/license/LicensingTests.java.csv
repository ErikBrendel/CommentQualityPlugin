commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String configRoles() {     return ROLES. }
false;protected;0;6;;@Override protected String configUsers() {     return SecuritySettingsSource.CONFIG_STANDARD_USER + "user_a:{plain}passwd\n" + "user_b:{plain}passwd\n". }
false;protected;0;4;;@Override protected String configUsersRoles() {     return USERS_ROLES. }
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;0;6;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     ArrayList<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins()).     // for http     plugins.add(Netty4Plugin.class).     return plugins. }
false;protected;0;4;;@Override protected int maxNumberOfNodes() {     return super.maxNumberOfNodes() + 1. }
false;public;0;4;;@Before public void resetLicensing() throws InterruptedException {     enableLicensing(OperationMode.BASIC). }
false;public;0;4;;@After public void cleanupSecurityIndex() {     deleteSecurityIndex(). }
false;public;0;41;;public void testEnableDisableBehaviour() throws Exception {     IndexResponse indexResponse = index("test", "type", jsonBuilder().startObject().field("name", "value").endObject()).     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()).     indexResponse = index("test1", "type", jsonBuilder().startObject().field("name", "value1").endObject()).     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()).     refresh().     final Client client = internalCluster().transportClient().     disableLicensing().     assertElasticsearchSecurityException(() -> client.admin().indices().prepareStats().get()).     assertElasticsearchSecurityException(() -> client.admin().cluster().prepareClusterStats().get()).     assertElasticsearchSecurityException(() -> client.admin().cluster().prepareHealth().get()).     assertElasticsearchSecurityException(() -> client.admin().cluster().prepareNodesStats().get()).     enableLicensing(randomFrom(License.OperationMode.values())).     IndicesStatsResponse indicesStatsResponse = client.admin().indices().prepareStats().get().     assertNoFailures(indicesStatsResponse).     ClusterStatsResponse clusterStatsNodeResponse = client.admin().cluster().prepareClusterStats().get().     assertThat(clusterStatsNodeResponse, notNullValue()).     ClusterStatsIndices indices = clusterStatsNodeResponse.getIndicesStats().     assertThat(indices, notNullValue()).     assertThat(indices.getIndexCount(), greaterThanOrEqualTo(2)).     ClusterHealthResponse clusterIndexHealth = client.admin().cluster().prepareHealth().get().     assertThat(clusterIndexHealth, notNullValue()).     NodesStatsResponse nodeStats = client.admin().cluster().prepareNodesStats().get().     assertThat(nodeStats, notNullValue()). }
false;public;0;32;;public void testRestAuthenticationByLicenseType() throws Exception {     Response unauthorizedRootResponse = getRestClient().performRequest(new Request("GET", "/")).     // the default of the licensing tests is basic     assertThat(unauthorizedRootResponse.getStatusLine().getStatusCode(), is(200)).     ResponseException e = expectThrows(ResponseException.class, () -> getRestClient().performRequest(new Request("GET", "/_security/_authenticate"))).     assertThat(e.getResponse().getStatusLine().getStatusCode(), is(403)).     // generate a new license with a mode that enables auth     License.OperationMode mode = randomFrom(License.OperationMode.GOLD, License.OperationMode.TRIAL, License.OperationMode.PLATINUM, License.OperationMode.STANDARD).     enableLicensing(mode).     e = expectThrows(ResponseException.class, () -> getRestClient().performRequest(new Request("GET", "/"))).     assertThat(e.getResponse().getStatusLine().getStatusCode(), is(401)).     e = expectThrows(ResponseException.class, () -> getRestClient().performRequest(new Request("GET", "/_security/_authenticate"))).     assertThat(e.getResponse().getStatusLine().getStatusCode(), is(401)).     RequestOptions.Builder optionsBuilder = RequestOptions.DEFAULT.toBuilder().     optionsBuilder.addHeader("Authorization", UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_USER_NAME, new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()))).     RequestOptions options = optionsBuilder.build().     Request rootRequest = new Request("GET", "/").     rootRequest.setOptions(options).     Response authorizedRootResponse = getRestClient().performRequest(rootRequest).     assertThat(authorizedRootResponse.getStatusLine().getStatusCode(), is(200)).     Request authenticateRequest = new Request("GET", "/_security/_authenticate").     authenticateRequest.setOptions(options).     Response authorizedAuthenticateResponse = getRestClient().performRequest(authenticateRequest).     assertThat(authorizedAuthenticateResponse.getStatusLine().getStatusCode(), is(200)). }
false;public;0;23;;public void testSecurityActionsByLicenseType() throws Exception {     // security actions should not work!     Settings settings = internalCluster().transportClient().settings().     try (TransportClient client = new TestXPackTransportClient(settings, LocalStateSecurity.class)) {         client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress()).         new SecurityClient(client).preparePutUser("john", "password".toCharArray(), Hasher.BCRYPT).get().         fail("security actions should not be enabled!").     } catch (ElasticsearchSecurityException e) {         assertThat(e.status(), is(RestStatus.FORBIDDEN)).         assertThat(e.getMessage(), containsString("non-compliant")).     }     // enable a license that enables security     License.OperationMode mode = randomFrom(License.OperationMode.GOLD, License.OperationMode.TRIAL, License.OperationMode.PLATINUM, License.OperationMode.STANDARD).     enableLicensing(mode).     // security actions should work!     try (TransportClient client = new TestXPackTransportClient(settings, LocalStateSecurity.class)) {         client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress()).         PutUserResponse response = new SecurityClient(client).preparePutUser("john", "password".toCharArray(), Hasher.BCRYPT).get().         assertNotNull(response).     } }
false;public;0;26;;public void testTransportClientAuthenticationByLicenseType() throws Exception {     Settings.Builder builder = Settings.builder().put(internalCluster().transportClient().settings()).     // remove user info     builder.remove(SecurityField.USER_SETTING.getKey()).     builder.remove(ThreadContext.PREFIX + "." + UsernamePasswordToken.BASIC_AUTH_HEADER).     // basic has no auth     try (TransportClient client = new TestXPackTransportClient(builder.build(), LocalStateSecurity.class)) {         client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress()).         assertGreenClusterState(client).     }     // enable a license that enables security     License.OperationMode mode = randomFrom(License.OperationMode.GOLD, License.OperationMode.TRIAL, License.OperationMode.PLATINUM, License.OperationMode.STANDARD).     enableLicensing(mode).     try (TransportClient client = new TestXPackTransportClient(builder.build(), LocalStateSecurity.class)) {         client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress()).         client.admin().cluster().prepareHealth().get().         fail("should not have been able to connect to a node!").     } catch (NoNodeAvailableException e) {     // expected     } }
false;public;0;26;;public void testNodeJoinWithoutSecurityExplicitlyEnabled() throws Exception {     License.OperationMode mode = randomFrom(License.OperationMode.GOLD, License.OperationMode.PLATINUM, License.OperationMode.STANDARD).     enableLicensing(mode).     final List<String> seedHosts = internalCluster().masterClient().admin().cluster().nodesInfo(new NodesInfoRequest()).get().getNodes().stream().map(n -> n.getTransport().getAddress().publishAddress().toString()).distinct().collect(Collectors.toList()).     Path home = createTempDir().     Path conf = home.resolve("config").     Files.createDirectories(conf).     Settings.Builder nodeSettings = Settings.builder().put(nodeSettings(maxNumberOfNodes() - 1).filter(s -> "xpack.security.enabled".equals(s) == false)).put("node.name", "my-test-node").put("network.host", "localhost").put("cluster.name", internalCluster().getClusterName()).put("path.home", home).putList(DiscoveryModule.DISCOVERY_SEED_PROVIDERS_SETTING.getKey()).putList(DISCOVERY_SEED_HOSTS_SETTING.getKey(), seedHosts).     Collection<Class<? extends Plugin>> mockPlugins = Arrays.asList(LocalStateSecurity.class, MockHttpTransport.TestPlugin.class).     try (Node node = new MockNode(nodeSettings.build(), mockPlugins)) {         node.start().         ensureStableCluster(cluster().size() + 1).     } }
false;private,static;1;5;;private static void assertElasticsearchSecurityException(ThrowingRunnable runnable) {     ElasticsearchSecurityException ee = expectThrows(ElasticsearchSecurityException.class, runnable).     assertThat(ee.getMetadata(LicenseUtils.EXPIRED_FEATURE_METADATA), hasItem(XPackField.SECURITY)).     assertThat(ee.status(), is(RestStatus.FORBIDDEN)). }
false;private;0;31;;private void disableLicensing() throws InterruptedException {     // This method first makes sure licensing is enabled everywhere so that we can execute     // monitoring actions to ensure we have a stable cluster and only then do we disable.     // This is done in an await busy since there is a chance that the enabling of the license     // is overwritten by some other cluster activity and the node throws an exception while we     // wait for things to stabilize!     final boolean success = awaitBusy(() -> {         try {             for (XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {                 if (licenseState.isAuthAllowed() == false) {                     enableLicensing(OperationMode.BASIC).                     break.                 }             }             ensureGreen().             ensureClusterSizeConsistency().             ensureClusterStateConsistency().             // apply the disabling of the license once the cluster is stable             for (XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {                 licenseState.update(OperationMode.BASIC, false, null).             }         } catch (Exception e) {             logger.error("Caught exception while disabling license", e).             return false.         }         return true.     }, 30L, TimeUnit.SECONDS).     assertTrue(success). }
false;private;1;28;;private void enableLicensing(License.OperationMode operationMode) throws InterruptedException {     // do this in an await busy since there is a chance that the enabling of the license is     // overwritten by some other cluster activity and the node throws an exception while we     // wait for things to stabilize!     final boolean success = awaitBusy(() -> {         try {             // first update the license so we can execute monitoring actions             for (XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {                 licenseState.update(operationMode, true, null).             }             ensureGreen().             ensureClusterSizeConsistency().             ensureClusterStateConsistency().             // to change             for (XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {                 licenseState.update(operationMode, true, null).             }         } catch (Exception e) {             logger.error("Caught exception while enabling license", e).             return false.         }         return true.     }, 30L, TimeUnit.SECONDS).     assertTrue(success). }
