commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void generateBootstrapPassword() {     BOOTSTRAP_PASSWORD = TEST_PASSWORD_SECURE_STRING.clone(). }
false;public,static;0;7;;@BeforeClass public static void initDefaultSettings() {     if (SECURITY_DEFAULT_SETTINGS == null) {         SECURITY_DEFAULT_SETTINGS = new SecuritySettingsSource(randomBoolean(), createTempDir(), ESIntegTestCase.Scope.SUITE).     } }
true;public,static;0;10;/**  * Set the static default settings to null to prevent a memory leak. The test framework also checks for memory leaks  * and computes the size, this can cause issues when running with the security manager as it tries to do reflection  * into protected sun packages.  */ ;/**  * Set the static default settings to null to prevent a memory leak. The test framework also checks for memory leaks  * and computes the size, this can cause issues when running with the security manager as it tries to do reflection  * into protected sun packages.  */ @AfterClass public static void destroyDefaultSettings() {     SECURITY_DEFAULT_SETTINGS = null.     customSecuritySettingsSource = null.     if (BOOTSTRAP_PASSWORD != null) {         BOOTSTRAP_PASSWORD.close().         BOOTSTRAP_PASSWORD = null.     }     tearDownRestClient(). }
false;public;0;7;;@Override public void tearDown() throws Exception {     super.tearDown().     if (resetNodeAfterTest()) {         tearDownRestClient().     } }
false;private,static;0;6;;private static void tearDownRestClient() {     if (restClient != null) {         IOUtils.closeWhileHandlingException(restClient).         restClient = null.     } }
false;protected;0;7;;@Override protected void before() {     if (customSecuritySettingsSource == null) {         customSecuritySettingsSource = new CustomSecuritySettingsSource(transportSSLEnabled(), createTempDir(), ESIntegTestCase.Scope.SUITE).     } }
false;protected;0;19;;@Override protected void after() {     try {         GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } catch (IllegalStateException e) {         if (e.getMessage().equals("thread was not started") == false) {             throw e.         }     // ignore since the thread was never started     }     try {         ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
false;public;0;5;;@Before public // before methods from the superclass are run before this, which means that the current cluster is ready to go void assertXPackIsInstalled() {     doAssertXPackIsInstalled(). }
false;private;0;11;;private void doAssertXPackIsInstalled() {     NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().clear().setPlugins(true).get().     for (NodeInfo nodeInfo : nodeInfos.getNodes()) {         // TODO: disable this assertion for now, due to random runs with mock plugins. perhaps run without mock plugins?         // assertThat(nodeInfo.getPlugins().getInfos(), hasSize(2)).         Collection<String> pluginNames = nodeInfo.getPlugins().getPluginInfos().stream().map(PluginInfo::getClassname).collect(Collectors.toList()).         assertThat("plugin [" + LocalStateSecurity.class.getName() + "] not found in [" + pluginNames + "]", pluginNames, hasItem(LocalStateSecurity.class.getName())).     } }
false;protected;0;19;;@Override protected Settings nodeSettings() {     Settings.Builder builder = Settings.builder().put(super.nodeSettings()).     Settings customSettings = customSecuritySettingsSource.nodeSettings(0).     // handle secure settings separately     builder.put(customSettings, false).     builder.put(LicenseService.SELF_GENERATED_LICENSE_TYPE.getKey(), "trial").     builder.put("transport.type", "security4").     builder.put("path.home", customSecuritySettingsSource.nodePath(0)).     Settings.Builder customBuilder = Settings.builder().put(customSettings).     if (customBuilder.getSecureSettings() != null) {         SecuritySettingsSource.addSecureSettings(builder, secureSettings -> secureSettings.merge((MockSecureSettings) customBuilder.getSecureSettings())).     }     if (builder.getSecureSettings() == null) {         builder.setSecureSettings(new MockSecureSettings()).     }     ((MockSecureSettings) builder.getSecureSettings()).setString("bootstrap.password", BOOTSTRAP_PASSWORD.toString()).     return builder.build(). }
false;protected;0;5;;protected Settings transportClientSettings() {     return Settings.builder().put(customSecuritySettingsSource.transportClientSettings()).build(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return customSecuritySettingsSource.nodePlugins(). }
true;protected;0;3;/**  * Allows to override the users config file  */ ;/**  * Allows to override the users config file  */ protected String configUsers() {     return SECURITY_DEFAULT_SETTINGS.configUsers(). }
true;protected;0;3;/**  * Allows to override the users_roles config file  */ ;/**  * Allows to override the users_roles config file  */ protected String configUsersRoles() {     return SECURITY_DEFAULT_SETTINGS.configUsersRoles(). }
true;protected;0;3;/**  * Allows to override the roles config file  */ ;/**  * Allows to override the roles config file  */ protected String configRoles() {     return SECURITY_DEFAULT_SETTINGS.configRoles(). }
true;protected;0;3;/**  * Allows to override the node client username  */ ;/**  * Allows to override the node client username  */ protected String nodeClientUsername() {     return SECURITY_DEFAULT_SETTINGS.nodeClientUsername(). }
true;protected;0;3;/**  * Allows to override the node client password (used while sending requests to the test node)  */ ;/**  * Allows to override the node client password (used while sending requests to the test node)  */ protected SecureString nodeClientPassword() {     return SECURITY_DEFAULT_SETTINGS.nodeClientPassword(). }
true;protected;0;3;/**  * Allows to control whether ssl key information is auto generated or not on the transport layer  */ ;/**  * Allows to control whether ssl key information is auto generated or not on the transport layer  */ protected boolean transportSSLEnabled() {     return randomBoolean(). }
false;protected;0;4;;@Override protected String configUsers() {     return SecuritySingleNodeTestCase.this.configUsers(). }
false;protected;0;4;;@Override protected String configUsersRoles() {     return SecuritySingleNodeTestCase.this.configUsersRoles(). }
false;protected;0;4;;@Override protected String configRoles() {     return SecuritySingleNodeTestCase.this.configRoles(). }
false;protected;0;4;;@Override protected String nodeClientUsername() {     return SecuritySingleNodeTestCase.this.nodeClientUsername(). }
false;protected;0;4;;@Override protected SecureString nodeClientPassword() {     return SecuritySingleNodeTestCase.this.nodeClientPassword(). }
false;public;1;10;;@Override public Client wrapClient(final Client client) {     Map<String, String> headers = Collections.singletonMap("Authorization", basicAuthHeaderValue(nodeClientUsername(), nodeClientPassword())).     // are all using a node client     return client.filterWithHeader(headers). }
false;protected;0;3;;protected boolean isTransportSSLEnabled() {     return customSecuritySettingsSource.isSslEnabled(). }
true;protected;0;3;/**  * Returns an instance of {@link RestClient} pointing to the current node.  * Creates a new client if the method is invoked for the first time in the context of the current test scope.  * The returned client gets automatically closed when needed, it shouldn't be closed as part of tests otherwise  * it cannot be reused by other tests anymore.  */ ;/**  * Returns an instance of {@link RestClient} pointing to the current node.  * Creates a new client if the method is invoked for the first time in the context of the current test scope.  * The returned client gets automatically closed when needed, it shouldn't be closed as part of tests otherwise  * it cannot be reused by other tests anymore.  */ protected RestClient getRestClient() {     return getRestClient(client()). }
false;protected;2;3;;protected RestClient createRestClient(RestClientBuilder.HttpClientConfigCallback httpClientConfigCallback, String protocol) {     return createRestClient(client(), httpClientConfigCallback, protocol). }
false;private,static,synchronized;1;6;;private static synchronized RestClient getRestClient(Client client) {     if (restClient == null) {         restClient = createRestClient(client, null, "http").     }     return restClient. }
false;private,static;3;16;;private static RestClient createRestClient(Client client, RestClientBuilder.HttpClientConfigCallback httpClientConfigCallback, String protocol) {     NodesInfoResponse nodesInfoResponse = client.admin().cluster().prepareNodesInfo().get().     assertFalse(nodesInfoResponse.hasFailures()).     assertEquals(nodesInfoResponse.getNodes().size(), 1).     NodeInfo node = nodesInfoResponse.getNodes().get(0).     assertNotNull(node.getHttp()).     TransportAddress publishAddress = node.getHttp().address().publishAddress().     InetSocketAddress address = publishAddress.address().     final HttpHost host = new HttpHost(NetworkAddress.format(address.getAddress()), address.getPort(), protocol).     RestClientBuilder builder = RestClient.builder(host).     if (httpClientConfigCallback != null) {         builder.setHttpClientConfigCallback(httpClientConfigCallback).     }     return builder.build(). }
