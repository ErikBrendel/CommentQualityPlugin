commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public void testTimingOutARunnable() {     AtomicReference<Exception> exceptionAtomicReference = new AtomicReference<>().     final CancellableLdapRunnable runnable = new CancellableLdapRunnable(ActionListener.wrap(user -> {         throw new AssertionError("onResponse should not be called").     }, exceptionAtomicReference::set), e -> null, () -> {         throw new AssertionError("runnable should not be executed").     }, logger).     runnable.maybeTimeout().     runnable.run().     assertNotNull(exceptionAtomicReference.get()).     assertThat(exceptionAtomicReference.get(), instanceOf(ElasticsearchTimeoutException.class)).     assertThat(exceptionAtomicReference.get().getMessage(), containsString("timed out waiting for execution")). }
false;public;0;20;;public void testCallTimeOutAfterRunning() {     final AtomicBoolean ran = new AtomicBoolean(false).     final AtomicBoolean listenerCalled = new AtomicBoolean(false).     final CancellableLdapRunnable runnable = new CancellableLdapRunnable(ActionListener.wrap(user -> {         listenerCalled.set(true).         throw new AssertionError("onResponse should not be called").     }, e -> {         listenerCalled.set(true).         throw new AssertionError("onFailure should not be called").     }), e -> null, () -> ran.set(ran.get() == false), logger).     runnable.run().     assertTrue(ran.get()).     runnable.maybeTimeout().     assertTrue(ran.get()).     // the listener shouldn't have ever been called. If it was, then either something called     // onResponse or onFailure was called as part of the timeout     assertFalse(listenerCalled.get()). }
false;public;0;15;;public void testRejectingExecution() {     AtomicReference<Exception> exceptionAtomicReference = new AtomicReference<>().     final CancellableLdapRunnable runnable = new CancellableLdapRunnable(ActionListener.wrap(user -> {         throw new AssertionError("onResponse should not be called").     }, exceptionAtomicReference::set), e -> null, () -> {         throw new AssertionError("runnable should not be executed").     }, logger).     final Exception e = new RuntimeException("foo").     runnable.onRejection(e).     assertNotNull(exceptionAtomicReference.get()).     assertThat(exceptionAtomicReference.get(), sameInstance(e)). }
false;public;0;27;;public void testTimeoutDuringExecution() throws InterruptedException {     final CountDownLatch listenerCalledLatch = new CountDownLatch(1).     final CountDownLatch timeoutCalledLatch = new CountDownLatch(1).     final CountDownLatch runningLatch = new CountDownLatch(1).     final ActionListener<User> listener = ActionListener.wrap(user -> {         listenerCalledLatch.countDown().     }, e -> {         throw new AssertionError("onFailure should not be executed").     }).     final CancellableLdapRunnable runnable = new CancellableLdapRunnable(listener, e -> null, () -> {         runningLatch.countDown().         try {             timeoutCalledLatch.await().             listener.onResponse(null).         } catch (InterruptedException e) {             throw new AssertionError("don't interrupt me", e).         }     }, logger).     Thread t = new Thread(runnable).     t.start().     runningLatch.await().     runnable.maybeTimeout().     timeoutCalledLatch.countDown().     listenerCalledLatch.await().     t.join(). }
false;public;0;14;;public void testExceptionInRunnable() {     AtomicReference<String> resultRef = new AtomicReference<>().     final ActionListener<String> listener = ActionListener.wrap(resultRef::set, e -> {         throw new AssertionError("onFailure should not be executed").     }).     String defaultValue = randomAlphaOfLengthBetween(2, 10).     final CancellableLdapRunnable<String> runnable = new CancellableLdapRunnable<>(listener, e -> defaultValue, () -> {         throw new RuntimeException("runnable intentionally failed").     }, logger).     runnable.run().     assertThat(resultRef.get(), equalTo(defaultValue)). }
