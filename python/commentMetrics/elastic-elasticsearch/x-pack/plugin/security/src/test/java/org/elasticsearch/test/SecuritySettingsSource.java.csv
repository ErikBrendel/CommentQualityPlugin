commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;Path nodePath(final int nodeOrdinal) {     return parentFolder.resolve(subfolderPrefix + "-" + nodeOrdinal). }
false;public;1;31;;@Override public Settings nodeSettings(int nodeOrdinal) {     final Path home = nodePath(nodeOrdinal).     final Path xpackConf = home.resolve("config").     try {         Files.createDirectories(xpackConf).     } catch (IOException e) {         throw new UncheckedIOException(e).     }     writeFile(xpackConf, "roles.yml", configRoles()).     writeFile(xpackConf, "users", configUsers()).     writeFile(xpackConf, "users_roles", configUsersRoles()).     Settings.Builder builder = Settings.builder().put(XPackSettings.SECURITY_ENABLED.getKey(), true).put(NetworkModule.TRANSPORT_TYPE_KEY, randomBoolean() ? SecurityField.NAME4 : SecurityField.NIO).put(NetworkModule.HTTP_TYPE_KEY, randomBoolean() ? SecurityField.NAME4 : SecurityField.NIO).put(XPackSettings.WATCHER_ENABLED.getKey(), false).put(XPackSettings.MONITORING_ENABLED.getKey(), false).put(XPackSettings.AUDIT_ENABLED.getKey(), randomBoolean()).put(LoggingAuditTrail.EMIT_HOST_ADDRESS_SETTING.getKey(), randomBoolean()).put(LoggingAuditTrail.EMIT_HOST_NAME_SETTING.getKey(), randomBoolean()).put(LoggingAuditTrail.EMIT_NODE_NAME_SETTING.getKey(), randomBoolean()).put(LoggingAuditTrail.EMIT_NODE_ID_SETTING.getKey(), randomBoolean()).put("xpack.security.authc.realms." + FileRealmSettings.TYPE + ".file.order", 0).put("xpack.security.authc.realms." + NativeRealmSettings.TYPE + ".index.order", "1").put("xpack.license.self_generated.type", "trial").     addNodeSSLSettings(builder).     return builder.build(). }
false;public;1;4;;@Override public Path nodeConfigPath(int nodeOrdinal) {     return nodePath(nodeOrdinal).resolve("config"). }
false;public;0;15;;@Override public Settings transportClientSettings() {     Settings.Builder builder = Settings.builder().     addClientSSLSettings(builder, "xpack.security.transport.").     addDefaultSecurityTransportType(builder, Settings.EMPTY).     if (randomBoolean()) {         builder.put(SecurityField.USER_SETTING.getKey(), transportClientUsername() + ":" + new String(transportClientPassword().getChars())).     } else {         builder.put(ThreadContext.PREFIX + ".Authorization", basicAuthHeaderValue(transportClientUsername(), transportClientPassword())).     }     return builder.build(). }
false;protected;2;5;;protected void addDefaultSecurityTransportType(Settings.Builder builder, Settings settings) {     if (NetworkModule.TRANSPORT_TYPE_SETTING.exists(settings) == false) {         builder.put(NetworkModule.TRANSPORT_TYPE_SETTING.getKey(), SecurityField.NAME4).     } }
false;public;0;5;;@Override public Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(LocalStateSecurity.class, Netty4Plugin.class, ReindexPlugin.class, CommonAnalysisPlugin.class, InternalSettingsPlugin.class). }
false;public;0;4;;@Override public Collection<Class<? extends Plugin>> transportClientPlugins() {     return Arrays.asList(XPackClientPlugin.class, Netty4Plugin.class, ReindexPlugin.class, CommonAnalysisPlugin.class). }
false;protected;0;3;;protected String configUsers() {     return CONFIG_STANDARD_USER. }
false;protected;0;3;;protected String configUsersRoles() {     return CONFIG_STANDARD_USER_ROLES. }
false;protected;0;3;;protected String configRoles() {     return CONFIG_ROLE_ALLOW_ALL. }
false;protected;0;3;;protected String nodeClientUsername() {     return TEST_USER_NAME. }
false;protected;0;3;;protected SecureString nodeClientPassword() {     return new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()). }
false;protected;0;3;;protected String transportClientUsername() {     return DEFAULT_TRANSPORT_CLIENT_USER_NAME. }
false;protected;0;3;;protected SecureString transportClientPassword() {     return new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()). }
false;public,static;3;11;;public static void addSSLSettingsForNodePEMFiles(Settings.Builder builder, String prefix, boolean hostnameVerificationEnabled) {     addSSLSettingsForPEMFiles(builder, prefix, "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.pem", "testnode", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt", Arrays.asList("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode-client-profile.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/active-directory-ca.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/openldap.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt"), hostnameVerificationEnabled, false). }
false;private;1;14;;private void addNodeSSLSettings(Settings.Builder builder) {     if (sslEnabled) {         builder.put("xpack.security.transport.ssl.enabled", true).         if (usePEM) {             addSSLSettingsForNodePEMFiles(builder, "xpack.security.transport.", hostnameVerificationEnabled).         } else {             addSSLSettingsForStore(builder, "xpack.security.transport.", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks", "testnode", hostnameVerificationEnabled, false).         }     } else if (randomBoolean()) {         builder.put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), false).     } }
false;public;2;14;;public void addClientSSLSettings(Settings.Builder builder, String prefix) {     builder.put("xpack.security.transport.ssl.enabled", sslEnabled).     if (usePEM) {         addSSLSettingsForPEMFiles(builder, prefix, "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.pem", "testclient", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt", Arrays.asList("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt"), hostnameVerificationEnabled, true).     } else {         addSSLSettingsForStore(builder, prefix, "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.jks", "testclient", hostnameVerificationEnabled, true).     } }
true;public,static;4;3;/**  * Returns the configuration settings given the location of a certificate and its password  *  * @param resourcePathToStore the location of the keystore or truststore  * @param password the password  */ ;/**  * Returns the configuration settings given the location of a certificate and its password  *  * @param resourcePathToStore the location of the keystore or truststore  * @param password the password  */ public static void addSSLSettingsForStore(Settings.Builder builder, String resourcePathToStore, String password, String prefix) {     addSSLSettingsForStore(builder, prefix, resourcePathToStore, password, true, true). }
false;private,static;6;26;;private static void addSSLSettingsForStore(Settings.Builder builder, String prefix, String resourcePathToStore, String password, boolean hostnameVerificationEnabled, boolean transportClient) {     Path store = resolveResourcePath(resourcePathToStore).     builder.put(prefix + "ssl.verification_mode", hostnameVerificationEnabled ? "full" : "certificate").     builder.put(prefix + "ssl.keystore.path", store).     if (transportClient) {         // continue using insecure settings for clients until we figure out what to do there...         builder.put(prefix + "ssl.keystore.password", password).     } else {         final String finalPrefix = prefix.         addSecureSettings(builder, secureSettings -> secureSettings.setString(finalPrefix + "ssl.keystore.secure_password", password)).     }     if (randomBoolean()) {         builder.put(prefix + "ssl.truststore.path", store).         if (transportClient) {             // continue using insecure settings for clients until we figure out what to do there...             builder.put(prefix + "ssl.truststore.password", password).         } else {             final String finalPrefix = prefix.             addSecureSettings(builder, secureSettings -> secureSettings.setString(finalPrefix + "ssl.truststore.secure_password", password)).         }     } }
true;public,static;5;4;/**  * Returns the SSL related configuration settings given the location of a key and certificate and the location  * of the PEM certificates to be trusted  *  * @param keyPath             The path to the Private key to be used for SSL  * @param password            The password with which the private key is protected  * @param certificatePath     The path to the PEM formatted Certificate encapsulating the public key that corresponds  *                            to the Private Key specified in {@code keyPath}. Will be presented to incoming  *                            SSL connections.  * @param trustedCertificates A list of PEM formatted certificates that will be trusted.  */ ;/**  * Returns the SSL related configuration settings given the location of a key and certificate and the location  * of the PEM certificates to be trusted  *  * @param keyPath             The path to the Private key to be used for SSL  * @param password            The password with which the private key is protected  * @param certificatePath     The path to the PEM formatted Certificate encapsulating the public key that corresponds  *                            to the Private Key specified in {@code keyPath}. Will be presented to incoming  *                            SSL connections.  * @param trustedCertificates A list of PEM formatted certificates that will be trusted.  */ public static void addSSLSettingsForPEMFiles(Settings.Builder builder, String keyPath, String password, String certificatePath, List<String> trustedCertificates) {     addSSLSettingsForPEMFiles(builder, "", keyPath, password, certificatePath, trustedCertificates, true, true). }
true;public,static;6;4;/**  * Returns the SSL related configuration settings given the location of a key and certificate and the location  * of the PEM certificates to be trusted  *  * @param keyPath             The path to the Private key to be used for SSL  * @param password            The password with which the private key is protected  * @param certificatePath     The path to the PEM formatted Certificate encapsulating the public key that corresponds  *                            to the Private Key specified in {@code keyPath}. Will be presented to incoming  *                            SSL connections.  * @param prefix              The settings prefix to use before ssl setting names  * @param trustedCertificates A list of PEM formatted certificates that will be trusted.  */ ;/**  * Returns the SSL related configuration settings given the location of a key and certificate and the location  * of the PEM certificates to be trusted  *  * @param keyPath             The path to the Private key to be used for SSL  * @param password            The password with which the private key is protected  * @param certificatePath     The path to the PEM formatted Certificate encapsulating the public key that corresponds  *                            to the Private Key specified in {@code keyPath}. Will be presented to incoming  *                            SSL connections.  * @param prefix              The settings prefix to use before ssl setting names  * @param trustedCertificates A list of PEM formatted certificates that will be trusted.  */ public static void addSSLSettingsForPEMFiles(Settings.Builder builder, String keyPath, String password, String certificatePath, String prefix, List<String> trustedCertificates) {     addSSLSettingsForPEMFiles(builder, prefix, keyPath, password, certificatePath, trustedCertificates, true, true). }
false;private,static;8;23;;private static void addSSLSettingsForPEMFiles(Settings.Builder builder, String prefix, String keyPath, String password, String certificatePath, List<String> trustedCertificates, boolean hostnameVerificationEnabled, boolean transportClient) {     if (prefix.equals("")) {         prefix = "xpack.security.transport.".     }     builder.put(prefix + "ssl.verification_mode", hostnameVerificationEnabled ? "full" : "certificate").     builder.put(prefix + "ssl.key", resolveResourcePath(keyPath)).put(prefix + "ssl.certificate", resolveResourcePath(certificatePath)).     if (transportClient) {         // continue using insecure settings for clients until we figure out what to do there...         builder.put(prefix + "ssl.key_passphrase", password).     } else {         final String finalPrefix = prefix.         addSecureSettings(builder, secureSettings -> secureSettings.setString(finalPrefix + "ssl.secure_key_passphrase", password)).     }     if (trustedCertificates.isEmpty() == false) {         builder.put(prefix + "ssl.certificate_authorities", Strings.arrayToCommaDelimitedString(resolvePathsToString(trustedCertificates))).     } }
false;public,static;2;13;;public static void addSecureSettings(Settings.Builder builder, Consumer<MockSecureSettings> settingsSetter) {     SecureSettings secureSettings = builder.getSecureSettings().     if (secureSettings instanceof MockSecureSettings) {         settingsSetter.accept((MockSecureSettings) secureSettings).     } else if (secureSettings == null) {         MockSecureSettings mockSecureSettings = new MockSecureSettings().         settingsSetter.accept(mockSecureSettings).         builder.setSecureSettings(mockSecureSettings).     } else {         throw new AssertionError("Test settings builder must contain MockSecureSettings, " + "but has [" + secureSettings.getClass().getName() + "]").     } }
false;private,static;1;7;;private static String[] resolvePathsToString(List<String> resourcePaths) {     List<String> resolvedPaths = new ArrayList<>(resourcePaths.size()).     for (String resource : resourcePaths) {         resolvedPaths.add(resolveResourcePath(resource).toString()).     }     return resolvedPaths.toArray(new String[resolvedPaths.size()]). }
false;private,static;1;11;;private static Path resolveResourcePath(String resourcePathToStore) {     try {         Path path = createTempFile().         try (InputStream resourceInput = SecuritySettingsSource.class.getResourceAsStream(resourcePathToStore)) {             Files.copy(resourceInput, path, StandardCopyOption.REPLACE_EXISTING).         }         return path.     } catch (IOException e) {         throw new ElasticsearchException("Failed to resolve resource (Path=[{}])", e, resourcePathToStore).     } }
false;public;0;3;;public boolean isSslEnabled() {     return sslEnabled. }
