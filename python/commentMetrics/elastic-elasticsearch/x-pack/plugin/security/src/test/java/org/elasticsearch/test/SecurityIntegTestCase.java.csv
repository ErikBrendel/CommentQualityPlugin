commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void generateBootstrapPassword() {     BOOTSTRAP_PASSWORD = TEST_PASSWORD_SECURE_STRING.clone(). }
true;protected,static;0;29;// and configure them all in unicast.hosts ;// UnicastZen requires the number of nodes in a cluster to generate the unicast configuration. // The number of nodes is randomized though, but we can predict what the maximum number of nodes will be // and configure them all in unicast.hosts protected static int defaultMaxNumberOfNodes() {     ClusterScope clusterScope = SecurityIntegTestCase.class.getAnnotation(ClusterScope.class).     if (clusterScope == null) {         return InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES + InternalTestCluster.DEFAULT_MAX_NUM_DATA_NODES + InternalTestCluster.DEFAULT_MAX_NUM_CLIENT_NODES.     } else {         int clientNodes = clusterScope.numClientNodes().         if (clientNodes < 0) {             clientNodes = InternalTestCluster.DEFAULT_MAX_NUM_CLIENT_NODES.         }         int masterNodes = 0.         if (clusterScope.supportsDedicatedMasters()) {             masterNodes = InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES.         }         int dataNodes = 0.         if (clusterScope.numDataNodes() < 0) {             if (clusterScope.maxNumDataNodes() < 0) {                 dataNodes = InternalTestCluster.DEFAULT_MAX_NUM_DATA_NODES.             } else {                 dataNodes = clusterScope.maxNumDataNodes().             }         } else {             dataNodes = clusterScope.numDataNodes().         }         return masterNodes + dataNodes + clientNodes.     } }
false;private,static;1;10;;private static ClusterScope getAnnotation(Class<?> clazz) {     if (clazz == Object.class || clazz == SecurityIntegTestCase.class) {         return null.     }     ClusterScope annotation = clazz.getAnnotation(ClusterScope.class).     if (annotation != null) {         return annotation.     }     return getAnnotation(clazz.getSuperclass()). }
false;;0;3;;Scope getCurrentClusterScope() {     return getCurrentClusterScope(this.getClass()). }
false;private,static;1;4;;private static Scope getCurrentClusterScope(Class<?> clazz) {     ClusterScope annotation = getAnnotation(clazz).     return annotation == null ? Scope.SUITE : annotation.scope(). }
false;public,static;0;7;;@BeforeClass public static void initDefaultSettings() {     if (SECURITY_DEFAULT_SETTINGS == null) {         SECURITY_DEFAULT_SETTINGS = new SecuritySettingsSource(randomBoolean(), createTempDir(), Scope.SUITE).     } }
true;public,static;0;5;/**  * Set the static default settings to null to prevent a memory leak. The test framework also checks for memory leaks  * and computes the size, this can cause issues when running with the security manager as it tries to do reflection  * into protected sun packages.  */ ;/**  * Set the static default settings to null to prevent a memory leak. The test framework also checks for memory leaks  * and computes the size, this can cause issues when running with the security manager as it tries to do reflection  * into protected sun packages.  */ @AfterClass public static void destroyDefaultSettings() {     SECURITY_DEFAULT_SETTINGS = null.     customSecuritySettingsSource = null. }
false;protected;0;16;;@Override protected void before() throws Throwable {     Scope currentClusterScope = getCurrentClusterScope().     switch(currentClusterScope) {         case SUITE:             if (customSecuritySettingsSource == null) {                 customSecuritySettingsSource = new CustomSecuritySettingsSource(transportSSLEnabled(), createTempDir(), currentClusterScope).             }             break.         case TEST:             customSecuritySettingsSource = new CustomSecuritySettingsSource(transportSSLEnabled(), createTempDir(), currentClusterScope).             break.     } }
false;protected;0;19;;@Override protected void after() {     try {         GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } catch (IllegalStateException e) {         if (e.getMessage().equals("thread was not started") == false) {             throw e.         }     // ignore since the thread was never started     }     try {         ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
false;public;0;5;;@Before public // before methods from the superclass are run before this, which means that the current cluster is ready to go void assertXPackIsInstalled() {     doAssertXPackIsInstalled(). }
false;protected;0;11;;protected void doAssertXPackIsInstalled() {     NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().clear().setPlugins(true).get().     for (NodeInfo nodeInfo : nodeInfos.getNodes()) {         // TODO: disable this assertion for now, due to random runs with mock plugins. perhaps run without mock plugins?         // assertThat(nodeInfo.getPlugins().getInfos(), hasSize(2)).         Collection<String> pluginNames = nodeInfo.getPlugins().getPluginInfos().stream().map(p -> p.getClassname()).collect(Collectors.toList()).         assertThat("plugin [" + LocalStateSecurity.class.getName() + "] not found in [" + pluginNames + "]", pluginNames, hasItem(LocalStateSecurity.class.getName())).     } }
false;protected;1;21;;@Override protected Settings nodeSettings(int nodeOrdinal) {     Settings.Builder builder = Settings.builder().put(super.nodeSettings(nodeOrdinal)).     // Disable native ML autodetect_process as the c++ controller won't be available     // builder.put(MachineLearningField.AUTODETECT_PROCESS.getKey(), false).     Settings customSettings = customSecuritySettingsSource.nodeSettings(nodeOrdinal).     // handle secure settings separately     builder.put(customSettings, false).     builder.put(LicenseService.SELF_GENERATED_LICENSE_TYPE.getKey(), "trial").     builder.put(NetworkModule.TRANSPORT_TYPE_KEY, randomBoolean() ? SecurityField.NAME4 : SecurityField.NIO).     builder.put(NetworkModule.HTTP_TYPE_KEY, randomBoolean() ? SecurityField.NAME4 : SecurityField.NIO).     Settings.Builder customBuilder = Settings.builder().put(customSettings).     if (customBuilder.getSecureSettings() != null) {         SecuritySettingsSource.addSecureSettings(builder, secureSettings -> secureSettings.merge((MockSecureSettings) customBuilder.getSecureSettings())).     }     if (builder.getSecureSettings() == null) {         builder.setSecureSettings(new MockSecureSettings()).     }     ((MockSecureSettings) builder.getSecureSettings()).setString("bootstrap.password", BOOTSTRAP_PASSWORD.toString()).     return builder.build(). }
false;protected;1;4;;@Override protected Path nodeConfigPath(int nodeOrdinal) {     return customSecuritySettingsSource.nodeConfigPath(nodeOrdinal). }
false;protected;0;7;;@Override protected Settings transportClientSettings() {     return Settings.builder().put(super.transportClientSettings()).put(NetworkModule.TRANSPORT_TYPE_KEY, SecurityField.NIO).put(customSecuritySettingsSource.transportClientSettings()).build(). }
false;protected;0;4;;@Override protected boolean addMockTransportService() {     // security has its own transport service     return false. }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return customSecuritySettingsSource.nodePlugins(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return customSecuritySettingsSource.transportClientPlugins(). }
false;protected;0;7;;@Override protected Settings externalClusterClientSettings() {     return Settings.builder().put(SecurityField.USER_SETTING.getKey(), SecuritySettingsSource.TEST_USER_NAME + ":" + SecuritySettingsSourceField.TEST_PASSWORD).build(). }
true;protected;0;3;/**  * Allows to override the users config file when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the users config file when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected String configUsers() {     return SECURITY_DEFAULT_SETTINGS.configUsers(). }
true;protected;0;3;/**  * Allows to override the users_roles config file when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the users_roles config file when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected String configUsersRoles() {     return SECURITY_DEFAULT_SETTINGS.configUsersRoles(). }
true;protected;0;3;/**  * Allows to override the roles config file when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the roles config file when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected String configRoles() {     return SECURITY_DEFAULT_SETTINGS.configRoles(). }
true;protected;0;3;/**  * Allows to override the node client username (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the node client username (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected String nodeClientUsername() {     return SECURITY_DEFAULT_SETTINGS.nodeClientUsername(). }
true;protected;0;3;/**  * Allows to override the node client password (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the node client password (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected SecureString nodeClientPassword() {     return SECURITY_DEFAULT_SETTINGS.nodeClientPassword(). }
true;protected;0;3;/**  * Allows to override the transport client username (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the transport client username (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected String transportClientUsername() {     return SECURITY_DEFAULT_SETTINGS.transportClientUsername(). }
true;protected;0;3;/**  * Allows to override the transport client password (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ ;/**  * Allows to override the transport client password (used while sending requests to the test cluster) when the  * {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to  * {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}  */ protected SecureString transportClientPassword() {     return SECURITY_DEFAULT_SETTINGS.transportClientPassword(). }
true;protected;0;3;/**  * Allows to control whether ssl key information is auto generated or not on the transport layer  */ ;/**  * Allows to control whether ssl key information is auto generated or not on the transport layer  */ protected boolean transportSSLEnabled() {     return randomBoolean(). }
false;protected;0;3;;protected int maxNumberOfNodes() {     return defaultMaxNumberOfNodes(). }
false;protected;0;4;;@Override protected String configUsers() {     return SecurityIntegTestCase.this.configUsers(). }
false;protected;0;4;;@Override protected String configUsersRoles() {     return SecurityIntegTestCase.this.configUsersRoles(). }
false;protected;0;4;;@Override protected String configRoles() {     return SecurityIntegTestCase.this.configRoles(). }
false;protected;0;4;;@Override protected String nodeClientUsername() {     return SecurityIntegTestCase.this.nodeClientUsername(). }
false;protected;0;4;;@Override protected SecureString nodeClientPassword() {     return SecurityIntegTestCase.this.nodeClientPassword(). }
false;protected;0;4;;@Override protected String transportClientUsername() {     return SecurityIntegTestCase.this.transportClientUsername(). }
false;protected;0;4;;@Override protected SecureString transportClientPassword() {     return SecurityIntegTestCase.this.transportClientPassword(). }
false;protected,static;1;5;;protected static void assertGreenClusterState(Client client) {     ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().get().     assertNoTimeout(clusterHealthResponse).     assertThat(clusterHealthResponse.getStatus(), is(ClusterHealthStatus.GREEN)). }
true;protected;1;29;/**  * Creates the indices provided as argument, randomly associating them with aliases, indexes one dummy document per index  * and refreshes the new indices  */ ;/**  * Creates the indices provided as argument, randomly associating them with aliases, indexes one dummy document per index  * and refreshes the new indices  */ protected void createIndicesWithRandomAliases(String... indices) {     createIndex(indices).     if (frequently()) {         boolean aliasAdded = false.         IndicesAliasesRequestBuilder builder = client().admin().indices().prepareAliases().         for (String index : indices) {             if (frequently()) {                 // one alias per index with prefix "alias-"                 builder.addAlias(index, "alias-" + index).                 aliasAdded = true.             }         }         // or the request will fail so use noAliasAdded to force adding the alias in this case         if (aliasAdded == false || randomBoolean()) {             // one alias pointing to all indices             for (String index : indices) {                 builder.addAlias(index, "alias").             }         }         assertAcked(builder).     }     for (String index : indices) {         client().prepareIndex(index, "type").setSource("field", "value").get().     }     refresh(indices). }
false;protected;0;13;;@Override protected Function<Client, Client> getClientWrapper() {     Map<String, String> headers = Collections.singletonMap("Authorization", basicAuthHeaderValue(nodeClientUsername(), nodeClientPassword())).     // to connect     return client -> (client instanceof NodeClient) ? client.filterWithHeader(headers) : client. }
false;protected;0;3;;protected SecurityClient securityClient() {     return securityClient(client()). }
false;public,static;1;3;;public static SecurityClient securityClient(Client client) {     return randomBoolean() ? new XPackClient(client).security() : new SecurityClient(client). }
false;protected;0;10;;protected String getHttpURL() {     final NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().get().     final List<NodeInfo> nodes = nodeInfos.getNodes().     assertTrue("there is at least one node", nodes.size() > 0).     NodeInfo ni = randomFrom(nodes).     boolean useSSL = XPackSettings.HTTP_SSL_ENABLED.get(ni.getSettings()).     TransportAddress publishAddress = ni.getHttp().address().publishAddress().     InetSocketAddress address = publishAddress.address().     return (useSSL ? "https://" : "http://") + NetworkAddress.format(address.getAddress()) + ":" + address.getPort(). }
false;public;0;3;;public void assertSecurityIndexActive() throws Exception {     assertSecurityIndexActive(cluster()). }
false;public;1;20;;public void assertSecurityIndexActive(TestCluster testCluster) throws Exception {     for (Client client : testCluster.getClients()) {         assertBusy(() -> {             ClusterState clusterState = client.admin().cluster().prepareState().setLocal(true).get().getState().             assertFalse(clusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)).             XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint().startObject().             assertTrue("security index mapping not sufficient to read:\n" + Strings.toString(clusterState.toXContent(builder, ToXContent.EMPTY_PARAMS).endObject()), SecurityIndexManager.checkIndexMappingVersionMatches(SECURITY_INDEX_NAME, clusterState, logger, Version.CURRENT.minimumIndexCompatibilityVersion()::onOrBefore)).             Index securityIndex = resolveSecurityIndex(clusterState.metaData()).             if (securityIndex != null) {                 IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(securityIndex).                 if (indexRoutingTable != null) {                     assertTrue(indexRoutingTable.allPrimaryShardsActive()).                 }             }         }, 30L, TimeUnit.SECONDS).     } }
false;protected;0;14;;protected void deleteSecurityIndex() {     final Client client = client().filterWithHeader(Collections.singletonMap("Authorization", UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING))).     GetIndexRequest getIndexRequest = new GetIndexRequest().     getIndexRequest.indices(SECURITY_INDEX_NAME).     getIndexRequest.indicesOptions(IndicesOptions.lenientExpandOpen()).     GetIndexResponse getIndexResponse = client.admin().indices().getIndex(getIndexRequest).actionGet().     if (getIndexResponse.getIndices().length > 0) {         // this is a hack to clean up the .security index since only a superuser can delete it         DeleteIndexRequest deleteIndexRequest = new DeleteIndexRequest(getIndexResponse.getIndices()).         client.admin().indices().delete(deleteIndexRequest).actionGet().     } }
false;private,static;1;7;;private static Index resolveSecurityIndex(MetaData metaData) {     final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(SECURITY_INDEX_NAME).     if (aliasOrIndex != null) {         return aliasOrIndex.getIndices().get(0).getIndex().     }     return null. }
false;protected;0;3;;protected boolean isTransportSSLEnabled() {     return customSecuritySettingsSource.isSslEnabled(). }
false;protected,static;0;3;;protected static Hasher getFastStoredHashAlgoForTests() {     return Hasher.resolve(randomFrom("pbkdf2", "pbkdf2_1000", "bcrypt", "bcrypt9")). }
