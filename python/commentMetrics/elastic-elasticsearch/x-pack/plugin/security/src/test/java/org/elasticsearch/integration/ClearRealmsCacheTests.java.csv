commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@BeforeClass public static void init() throws Exception {     usernames = new String[randomIntBetween(5, 10)].     for (int i = 0. i < usernames.length. i++) {         usernames[i] = randomAlphaOfLength(6) + "_" + i.     } }
false;public;2;4;;@Override public void assertEviction(User prevUser, User newUser) {     assertThat(prevUser, not(sameInstance(newUser))). }
false;public;0;4;;@Override public void executeRequest() throws Exception {     executeTransportRequest(new ClearRealmCacheRequest()). }
false;public;2;8;;@Override public void assertEviction(User prevUser, User newUser) {     if (Arrays.stream(evicted_usernames).anyMatch(prevUser.principal()::equals)) {         assertThat(prevUser, not(sameInstance(newUser))).     } else {         assertThat(prevUser, sameInstance(newUser)).     } }
false;public;0;4;;@Override public void executeRequest() throws Exception {     executeTransportRequest(new ClearRealmCacheRequest().usernames(evicted_usernames)). }
false;public;2;4;;@Override public void assertEviction(User prevUser, User newUser) {     assertThat(prevUser, not(sameInstance(newUser))). }
false;public;0;5;;@Override public void executeRequest() throws Exception {     executeHttpRequest("/_security/realm/" + (randomBoolean() ? "*" : "_all") + "/_clear_cache", Collections.<String, String>emptyMap()). }
false;public;2;8;;@Override public void assertEviction(User prevUser, User newUser) {     if (Arrays.stream(evicted_usernames).anyMatch(prevUser.principal()::equals)) {         assertThat(prevUser, not(sameInstance(newUser))).     } else {         assertThat(prevUser, sameInstance(newUser)).     } }
false;public;0;6;;@Override public void executeRequest() throws Exception {     String path = "/_security/realm/" + (randomBoolean() ? "*" : "_all") + "/_clear_cache".     Map<String, String> params = Collections.singletonMap("usernames", String.join(",", evicted_usernames)).     executeHttpRequest(path, params). }
false;public,abstract;2;1;;public abstract void assertEviction(User prevUser, User newUser).
false;public,abstract;0;1;;public abstract void executeRequest() throws Exception.
false;public;1;5;;@Override public void onResponse(ClearRealmCacheResponse response) {     assertThat(response.getNodes().size(), equalTo(internalCluster().getNodeNames().length)).     latch.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     error.set(e).     latch.countDown(). }
false;static;1;27;;static void executeTransportRequest(ClearRealmCacheRequest request) throws Exception {     SecurityClient securityClient = securityClient(client()).     final CountDownLatch latch = new CountDownLatch(1).     final AtomicReference<Throwable> error = new AtomicReference<>().     securityClient.clearRealmCache(request, new ActionListener<ClearRealmCacheResponse>() {          @Override         public void onResponse(ClearRealmCacheResponse response) {             assertThat(response.getNodes().size(), equalTo(internalCluster().getNodeNames().length)).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             error.set(e).             latch.countDown().         }     }).     if (!latch.await(5, TimeUnit.SECONDS)) {         fail("waiting for clear realms cache request too long").     }     if (error.get() != null) {         fail("failed to clear realm caches" + error.get().getMessage()).     } }
false;static;2;13;;static void executeHttpRequest(String path, Map<String, String> params) throws Exception {     Request request = new Request("POST", path).     for (Map.Entry<String, String> param : params.entrySet()) {         request.addParameter(param.getKey(), param.getValue()).     }     RequestOptions.Builder options = request.getOptions().toBuilder().     options.addHeader("Authorization", UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_USER_NAME, new SecureString(SecuritySettingsSourceField.TEST_PASSWORD.toCharArray()))).     request.setOptions(options).     Response response = getRestClient().performRequest(request).     assertNotNull(response.getEntity()).     assertTrue(EntityUtils.toString(response.getEntity()).contains("cluster_name")). }
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;0;6;;@Override protected String configRoles() {     return SecuritySettingsSource.CONFIG_ROLE_ALLOW_ALL + "\n" + "r1:\n" + "  cluster: all\n". }
false;protected;0;10;;@Override protected String configUsers() {     StringBuilder builder = new StringBuilder(SecuritySettingsSource.CONFIG_STANDARD_USER).     final String usersPasswdHashed = new String(getFastStoredHashAlgoForTests().hash(new SecureString("passwd".toCharArray()))).     for (String username : usernames) {         builder.append(username).append(":").append(usersPasswdHashed).append("\n").     }     return builder.toString(). }
false;protected;0;5;;@Override protected String configUsersRoles() {     return SecuritySettingsSource.CONFIG_STANDARD_USER_ROLES + "r1:" + Strings.arrayToCommaDelimitedString(usernames). }
false;public;0;3;;public void testEvictAll() throws Exception {     testScenario(Scenario.EVICT_ALL). }
false;public;0;3;;public void testEvictSome() throws Exception {     testScenario(Scenario.EVICT_SOME). }
false;public;0;3;;public void testEvictAllHttp() throws Exception {     testScenario(Scenario.EVICT_ALL_HTTP). }
false;public;0;3;;public void testEvictSomeHttp() throws Exception {     testScenario(Scenario.EVICT_SOME_HTTP). }
false;private;1;53;;private void testScenario(Scenario scenario) throws Exception {     Map<String, UsernamePasswordToken> tokens = new HashMap<>().     for (String user : usernames) {         tokens.put(user, new UsernamePasswordToken(user, new SecureString("passwd"))).     }     List<Realm> realms = new ArrayList<>().     for (Realms nodeRealms : internalCluster().getInstances(Realms.class)) {         realms.add(nodeRealms.realm("file")).     }     // we authenticate each user on each of the realms to make sure they're all cached     Map<String, Map<Realm, User>> users = new HashMap<>().     for (Realm realm : realms) {         for (String username : usernames) {             PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().             realm.authenticate(tokens.get(username), future).             User user = future.actionGet().getUser().             assertThat(user, notNullValue()).             Map<Realm, User> realmToUser = users.get(username).             if (realmToUser == null) {                 realmToUser = new HashMap<>().                 users.put(username, realmToUser).             }             realmToUser.put(realm, user).         }     }     for (String username : usernames) {         for (Realm realm : realms) {             PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().             realm.authenticate(tokens.get(username), future).             User user = future.actionGet().getUser().             assertThat(user, sameInstance(users.get(username).get(realm))).         }     }     // now, lets run the scenario     scenario.executeRequest().     // now, user_a should have been evicted, but user_b should still be cached     for (String username : usernames) {         for (Realm realm : realms) {             PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().             realm.authenticate(tokens.get(username), future).             User user = future.actionGet().getUser().             assertThat(user, notNullValue()).             scenario.assertEviction(users.get(username).get(realm), user).         }     } }
true;private,static;1;12;// selects a random sub-set of the give values ;// selects a random sub-set of the give values private static String[] randomSelection(String[] values) {     List<String> list = new ArrayList<>().     while (list.isEmpty()) {         double base = randomDouble().         for (String value : values) {             if (randomDouble() < base) {                 list.add(value).             }         }     }     return list.toArray(new String[list.size()]). }
