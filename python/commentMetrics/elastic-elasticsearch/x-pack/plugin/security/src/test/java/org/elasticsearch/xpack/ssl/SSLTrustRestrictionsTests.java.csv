commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected int maxNumberOfNodes() {     // (That's not _quite_ true, because the base setup code checks the cluster using transport client, but it's the best we can do)     return 1. }
false;public,static;0;36;;@BeforeClass public static void setupCertificates() throws Exception {     assumeFalse("Can't run in a FIPS JVM, custom TrustManager implementations cannot be used.", inFipsJvm()).     configPath = createTempDir().     Path caCertPath = PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/ca.crt").toURI()).     X509Certificate caCert = CertParsingUtils.readX509Certificates(Collections.singletonList(caCertPath))[0].     Path caKeyPath = PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/ca.key").toURI()).     PrivateKey caKey = PemUtils.readPrivateKey(caKeyPath, ""::toCharArray).     ca = new CertificateInfo(caKey, caKeyPath, caCert, caCertPath).     Path trustedCertPath = PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/trusted.crt").toURI()).     X509Certificate trustedX509Certificate = CertParsingUtils.readX509Certificates(Collections.singletonList(trustedCertPath))[0].     Path trustedKeyPath = PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/trusted.key").toURI()).     PrivateKey trustedKey = PemUtils.readPrivateKey(trustedKeyPath, ""::toCharArray).     trustedCert = new CertificateInfo(trustedKey, trustedKeyPath, trustedX509Certificate, trustedCertPath).     Path untrustedCertPath = PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/untrusted.crt").toURI()).     X509Certificate untrustedX509Certificate = CertParsingUtils.readX509Certificates(Collections.singletonList(untrustedCertPath))[0].     Path untrustedKeyPath = PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/untrusted.key").toURI()).     PrivateKey untrustedKey = PemUtils.readPrivateKey(untrustedKeyPath, ""::toCharArray).     untrustedCert = new CertificateInfo(untrustedKey, untrustedKeyPath, untrustedX509Certificate, untrustedCertPath).     nodeSSL = Settings.builder().put("xpack.security.transport.ssl.enabled", true).put("xpack.security.transport.ssl.verification_mode", "certificate").putList("xpack.security.transport.ssl.certificate_authorities", ca.getCertPath().toString()).put("xpack.security.transport.ssl.key", trustedCert.getKeyPath()).put("xpack.security.transport.ssl.certificate", trustedCert.getCertPath()).build(). }
false;public,static;0;8;;@AfterClass public static void cleanup() {     configPath = null.     nodeSSL = null.     ca = null.     trustedCert = null.     untrustedCert = null. }
false;public;1;16;;@Override public Settings nodeSettings(int nodeOrdinal) {     Settings parentSettings = super.nodeSettings(nodeOrdinal).     Settings.Builder builder = Settings.builder().put(parentSettings.filter((s) -> s.startsWith("xpack.security.transport.ssl.") == false)).put(nodeSSL).     restrictionsPath = configPath.resolve("trust_restrictions.yml").     restrictionsTmpPath = configPath.resolve("trust_restrictions.tmp").     writeRestrictions("*.trusted").     builder.put("xpack.security.transport.ssl.trust_restrictions.path", restrictionsPath).     return builder.build(). }
false;private;1;13;;private void writeRestrictions(String trustedPattern) {     try {         Files.write(restrictionsTmpPath, Collections.singleton("trust.subject_name: \"" + trustedPattern + "\"")).         try {             Files.move(restrictionsTmpPath, restrictionsPath, REPLACE_EXISTING, ATOMIC_MOVE).         } catch (final AtomicMoveNotSupportedException e) {             Files.move(restrictionsTmpPath, restrictionsPath, REPLACE_EXISTING).         }     } catch (IOException e) {         throw new ElasticsearchException("failed to write restrictions", e).     }     runResourceWatcher(). }
false;protected;0;8;;@Override protected Settings transportClientSettings() {     Settings parentSettings = super.transportClientSettings().     Settings.Builder builder = Settings.builder().put(parentSettings.filter((s) -> s.startsWith("xpack.security.transport.ssl.") == false)).put(nodeSSL).     return builder.build(). }
false;protected;0;4;;@Override protected boolean transportSSLEnabled() {     return true. }
false;public;0;10;;public void testCertificateWithTrustedNameIsAccepted() throws Exception {     writeRestrictions("*.trusted").     try {         tryConnect(trustedCert).     } catch (SSLException | SocketException ex) {         logger.warn(new ParameterizedMessage("unexpected handshake failure with certificate [{}] [{}]", trustedCert.certificate.getSubjectDN(), trustedCert.certificate.getSubjectAlternativeNames()), ex).         fail("handshake should have been successful, but failed with " + ex).     } }
false;public;0;9;;public void testCertificateWithUntrustedNameFails() throws Exception {     writeRestrictions("*.trusted").     try {         tryConnect(untrustedCert).         fail("handshake should have failed, but was successful").     } catch (SSLException | SocketException ex) {     // expected     } }
false;public;0;20;;public void testRestrictionsAreReloaded() throws Exception {     writeRestrictions("*").     assertBusy(() -> {         try {             tryConnect(untrustedCert).         } catch (SSLException | SocketException ex) {             fail("handshake should have been successful, but failed with " + ex).         }     }, MAX_WAIT_RELOAD.millis(), TimeUnit.MILLISECONDS).     writeRestrictions("*.trusted").     assertBusy(() -> {         try {             tryConnect(untrustedCert).             fail("handshake should have failed, but was successful").         } catch (SSLException | SocketException ex) {         // expected         }     }, MAX_WAIT_RELOAD.millis(), TimeUnit.MILLISECONDS). }
true;private;0;8;/**  * Force the file watch to be updated.  * Ideally we'd just left the service do its thing, but that means waiting for 5sec  * We can drop the 5s down, but then we run into resource contention issues.  * This method just tells the {@link ResourceWatcherService} to run its check at a time that suits the tests. In all other respects  * it works just like normal - the usual file checks apply for detecting it as "changed", and only the previously configured files  * are checked.  */ ;/**  * Force the file watch to be updated.  * Ideally we'd just left the service do its thing, but that means waiting for 5sec  * We can drop the 5s down, but then we run into resource contention issues.  * This method just tells the {@link ResourceWatcherService} to run its check at a time that suits the tests. In all other respects  * it works just like normal - the usual file checks apply for detecting it as "changed", and only the previously configured files  * are checked.  */ private void runResourceWatcher() {     final InternalTestCluster cluster = internalCluster().     if (cluster.size() > 0) {         final ResourceWatcherService service = cluster.getInstance(ResourceWatcherService.class).         logger.info("Triggering a reload of watched resources").         service.notifyNow(ResourceWatcherService.Frequency.HIGH).     } }
false;private;1;20;;private void tryConnect(CertificateInfo certificate) throws Exception {     Settings settings = Settings.builder().put("path.home", createTempDir()).put("xpack.security.transport.ssl.key", certificate.getKeyPath()).put("xpack.security.transport.ssl.certificate", certificate.getCertPath()).putList("xpack.security.transport.ssl.certificate_authorities", ca.getCertPath().toString()).put("xpack.security.transport.ssl.verification_mode", "certificate").build().     String node = randomFrom(internalCluster().getNodeNames()).     SSLService sslService = new SSLService(settings, TestEnvironment.newEnvironment(settings)).     SSLConfiguration sslConfiguration = sslService.getSSLConfiguration("xpack.security.transport.ssl").     SSLSocketFactory sslSocketFactory = sslService.sslSocketFactory(sslConfiguration).     TransportAddress address = internalCluster().getInstance(Transport.class, node).boundAddress().publishAddress().     try (SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(address.getAddress(), address.getPort())) {         assertThat(socket.isConnected(), is(true)).         // The test simply relies on this (synchronously) connecting (or not), so we don't need a handshake handler         socket.startHandshake().     } }
false;private;0;3;;private PrivateKey getKey() {     return key. }
false;private;0;3;;private Path getKeyPath() {     return keyPath. }
false;private;0;3;;private X509Certificate getCertificate() {     return certificate. }
false;private;0;3;;private Path getCertPath() {     return certPath. }
