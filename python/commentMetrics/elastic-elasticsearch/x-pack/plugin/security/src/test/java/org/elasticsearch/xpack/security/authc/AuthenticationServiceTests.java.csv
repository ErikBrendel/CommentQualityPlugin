commented;modifiers;parameterAmount;loc;comment;code
false;public;0;73;;@Before @SuppressForbidden(reason = "Allow accessing localhost") public void init() throws Exception {     concreteSecurityIndexName = randomFrom(RestrictedIndicesNames.INTERNAL_SECURITY_INDEX_6, RestrictedIndicesNames.INTERNAL_SECURITY_INDEX_7).     token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     message = new InternalMessage().     remoteAddress = new InetSocketAddress(InetAddress.getLocalHost(), 100).     message.remoteAddress(new TransportAddress(remoteAddress)).     restRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withRemoteAddress(remoteAddress).build().     threadContext = new ThreadContext(Settings.EMPTY).     firstRealm = mock(Realm.class).     when(firstRealm.type()).thenReturn("file").     when(firstRealm.name()).thenReturn("file_realm").     secondRealm = mock(Realm.class).     when(secondRealm.type()).thenReturn("second").     when(secondRealm.name()).thenReturn("second_realm").     Settings settings = Settings.builder().put("path.home", createTempDir()).put("node.name", "authc_test").put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true).put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true).build().     XPackLicenseState licenseState = mock(XPackLicenseState.class).     when(licenseState.allowedRealmType()).thenReturn(XPackLicenseState.AllowedRealmType.ALL).     when(licenseState.isAuthAllowed()).thenReturn(true).     realms = spy(new TestRealms(Settings.EMPTY, TestEnvironment.newEnvironment(settings), Collections.<String, Realm.Factory>emptyMap(), licenseState, threadContext, mock(ReservedRealm.class), Arrays.asList(firstRealm, secondRealm), Collections.singletonList(firstRealm))).     auditTrail = mock(AuditTrailService.class).     client = mock(Client.class).     threadPool = new ThreadPool(settings, new FixedExecutorBuilder(settings, TokenService.THREAD_POOL_NAME, 1, 1000, "xpack.security.authc.token.thread_pool")).     threadContext = threadPool.getThreadContext().     when(client.threadPool()).thenReturn(threadPool).     when(client.settings()).thenReturn(settings).     when(client.prepareIndex(any(String.class), any(String.class), any(String.class))).thenReturn(new IndexRequestBuilder(client, IndexAction.INSTANCE)).     when(client.prepareUpdate(any(String.class), any(String.class), any(String.class))).thenReturn(new UpdateRequestBuilder(client, UpdateAction.INSTANCE)).     doAnswer(invocationOnMock -> {         ActionListener<IndexResponse> responseActionListener = (ActionListener<IndexResponse>) invocationOnMock.getArguments()[2].         responseActionListener.onResponse(new IndexResponse()).         return null.     }).when(client).execute(eq(IndexAction.INSTANCE), any(IndexRequest.class), any(ActionListener.class)).     doAnswer(invocationOnMock -> {         GetRequestBuilder builder = new GetRequestBuilder(client, GetAction.INSTANCE).         builder.setIndex((String) invocationOnMock.getArguments()[0]).setType((String) invocationOnMock.getArguments()[1]).setId((String) invocationOnMock.getArguments()[2]).         return builder.     }).when(client).prepareGet(anyString(), anyString(), anyString()).     securityIndex = mock(SecurityIndexManager.class).     doAnswer(invocationOnMock -> {         Runnable runnable = (Runnable) invocationOnMock.getArguments()[1].         runnable.run().         return null.     }).when(securityIndex).prepareIndexIfNeededThenExecute(any(Consumer.class), any(Runnable.class)).     doAnswer(invocationOnMock -> {         Runnable runnable = (Runnable) invocationOnMock.getArguments()[1].         runnable.run().         return null.     }).when(securityIndex).checkIndexVersionThenExecute(any(Consumer.class), any(Runnable.class)).     ClusterService clusterService = ClusterServiceUtils.createClusterService(threadPool).     apiKeyService = new ApiKeyService(settings, Clock.systemUTC(), client, securityIndex, clusterService, threadPool).     tokenService = new TokenService(settings, Clock.systemUTC(), client, securityIndex, clusterService).     service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(settings), tokenService, apiKeyService). }
false;public;0;6;;@After public void shutdownThreadpool() throws InterruptedException {     if (threadPool != null) {         terminate(threadPool).     } }
false;public;0;12;;public void testTokenFirstMissingSecondFound() throws Exception {     when(firstRealm.token(threadContext)).thenReturn(null).     when(secondRealm.token(threadContext)).thenReturn(token).     PlainActionFuture<Authentication> future = new PlainActionFuture<>().     Authenticator authenticator = service.createAuthenticator("_action", message, null, future).     authenticator.extractToken((result) -> {         assertThat(result, notNullValue()).         assertThat(result, is(token)).         verifyZeroInteractions(auditTrail).     }). }
false;public;0;14;;public void testTokenMissing() throws Exception {     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     PlainActionFuture<Authentication> future = new PlainActionFuture<>().     Authenticator authenticator = service.createAuthenticator("_action", message, null, future).     authenticator.extractToken((token) -> {         assertThat(token, nullValue()).         authenticator.handleNullToken().     }).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> future.actionGet()).     assertThat(e.getMessage(), containsString("missing authentication credentials")).     verify(auditTrail).anonymousAccessDenied(reqId, "_action", message).     verifyNoMoreInteractions(auditTrail). }
false;public;0;28;;public void testAuthenticateBothSupportSecondSucceeds() throws Exception {     User user = new User("_username", "r1").     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, null).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, user).     if (randomBoolean()) {         when(firstRealm.token(threadContext)).thenReturn(token).     } else {         when(secondRealm.token(threadContext)).thenReturn(token).     }     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     final AtomicBoolean completed = new AtomicBoolean(false).     service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), is(user)).         assertThat(result.getLookedUpBy(), is(nullValue())).         // TODO implement equals         assertThat(result.getAuthenticatedBy(), is(notNullValue())).         assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail)).     assertTrue(completed.get()).     verify(auditTrail).authenticationFailed(reqId, firstRealm.name(), token, "_action", message).     verify(realms).asList().     verifyNoMoreInteractions(realms). }
false;public;0;42;;public void testAuthenticateSmartRealmOrdering() {     User user = new User("_username", "r1").     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, null).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, user).     when(secondRealm.token(threadContext)).thenReturn(token).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     final AtomicBoolean completed = new AtomicBoolean(false).     service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), is(user)).         assertThat(result.getLookedUpBy(), is(nullValue())).         // TODO implement equals         assertThat(result.getAuthenticatedBy(), is(notNullValue())).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail)).     assertTrue(completed.get()).     completed.set(false).     service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), is(user)).         assertThat(result.getLookedUpBy(), is(nullValue())).         // TODO implement equals         assertThat(result.getAuthenticatedBy(), is(notNullValue())).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail)).     verify(auditTrail).authenticationFailed(reqId, firstRealm.name(), token, "_action", message).     verify(auditTrail, times(2)).authenticationSuccess(reqId, secondRealm.name(), user, "_action", message).     // used above one time     verify(firstRealm, times(2)).name().     // used above one time     verify(secondRealm, times(3)).name().     // used to create realm ref     verify(secondRealm, times(2)).type().     verify(firstRealm, times(2)).token(threadContext).     verify(secondRealm, times(2)).token(threadContext).     verify(firstRealm).supports(token).     verify(secondRealm, times(2)).supports(token).     verify(firstRealm).authenticate(eq(token), any(ActionListener.class)).     verify(secondRealm, times(2)).authenticate(eq(token), any(ActionListener.class)).     verifyNoMoreInteractions(auditTrail, firstRealm, secondRealm). }
false;public;0;35;;public void testCacheClearOnSecurityIndexChange() {     long expectedInvalidation = 0L.     assertEquals(expectedInvalidation, service.getNumInvalidation()).     // existing to no longer present     SecurityIndexManager.State previousState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     SecurityIndexManager.State currentState = dummyState(null).     service.onSecurityIndexStateChange(previousState, currentState).     assertEquals(++expectedInvalidation, service.getNumInvalidation()).     // doesn't exist to exists     previousState = dummyState(null).     currentState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     service.onSecurityIndexStateChange(previousState, currentState).     assertEquals(++expectedInvalidation, service.getNumInvalidation()).     // green or yellow to red     previousState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     currentState = dummyState(ClusterHealthStatus.RED).     service.onSecurityIndexStateChange(previousState, currentState).     assertEquals(expectedInvalidation, service.getNumInvalidation()).     // red to non red     previousState = dummyState(ClusterHealthStatus.RED).     currentState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     service.onSecurityIndexStateChange(previousState, currentState).     assertEquals(++expectedInvalidation, service.getNumInvalidation()).     // green to yellow or yellow to green     previousState = dummyState(randomFrom(ClusterHealthStatus.GREEN, ClusterHealthStatus.YELLOW)).     currentState = dummyState(previousState.indexStatus == ClusterHealthStatus.GREEN ? ClusterHealthStatus.YELLOW : ClusterHealthStatus.GREEN).     service.onSecurityIndexStateChange(previousState, currentState).     assertEquals(expectedInvalidation, service.getNumInvalidation()). }
false;public;0;48;;public void testAuthenticateSmartRealmOrderingDisabled() {     final Settings settings = Settings.builder().put(AuthenticationService.SUCCESS_AUTH_CACHE_ENABLED.getKey(), false).build().     service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(Settings.EMPTY), tokenService, apiKeyService).     User user = new User("_username", "r1").     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, null).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, user).     when(secondRealm.token(threadContext)).thenReturn(token).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     final AtomicBoolean completed = new AtomicBoolean(false).     service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), is(user)).         assertThat(result.getLookedUpBy(), is(nullValue())).         // TODO implement equals         assertThat(result.getAuthenticatedBy(), is(notNullValue())).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail)).     assertTrue(completed.get()).     completed.set(false).     service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), is(user)).         assertThat(result.getLookedUpBy(), is(nullValue())).         // TODO implement equals         assertThat(result.getAuthenticatedBy(), is(notNullValue())).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail)).     verify(auditTrail, times(2)).authenticationFailed(reqId, firstRealm.name(), token, "_action", message).     verify(auditTrail, times(2)).authenticationSuccess(reqId, secondRealm.name(), user, "_action", message).     // used above one time     verify(firstRealm, times(3)).name().     // used above one time     verify(secondRealm, times(3)).name().     // used to create realm ref     verify(secondRealm, times(2)).type().     verify(firstRealm, times(2)).token(threadContext).     verify(secondRealm, times(2)).token(threadContext).     verify(firstRealm, times(2)).supports(token).     verify(secondRealm, times(2)).supports(token).     verify(firstRealm, times(2)).authenticate(eq(token), any(ActionListener.class)).     verify(secondRealm, times(2)).authenticate(eq(token), any(ActionListener.class)).     verifyNoMoreInteractions(auditTrail, firstRealm, secondRealm). }
false;public;0;21;;public void testAuthenticateFirstNotSupportingSecondSucceeds() throws Exception {     User user = new User("_username", "r1").     when(firstRealm.supports(token)).thenReturn(false).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, user).     when(secondRealm.token(threadContext)).thenReturn(token).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     final AtomicBoolean completed = new AtomicBoolean(false).     service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), is(user)).         assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail)).     verify(auditTrail).authenticationSuccess(reqId, secondRealm.name(), user, "_action", message).     verifyNoMoreInteractions(auditTrail).     verify(firstRealm, never()).authenticate(eq(token), any(ActionListener.class)).     assertTrue(completed.get()). }
false;public;0;13;;public void testAuthenticateCached() throws Exception {     final Authentication authentication = new Authentication(new User("_username", "r1"), new RealmRef("test", "cached", "foo"), null).     authentication.writeToContext(threadContext).     Authentication result = authenticateBlocking("_action", message, null).     assertThat(result, notNullValue()).     assertThat(result, is(authentication)).     assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).     verifyZeroInteractions(auditTrail).     verifyZeroInteractions(firstRealm).     verifyZeroInteractions(secondRealm). }
false;public;0;10;;public void testAuthenticateNonExistentRestRequestUserThrowsAuthenticationException() throws Exception {     when(firstRealm.token(threadContext)).thenReturn(new UsernamePasswordToken("idonotexist", new SecureString("passwd".toCharArray()))).     try {         authenticateBlocking(restRequest).         fail("Authentication was successful but should not").     } catch (ElasticsearchSecurityException e) {         assertAuthenticationException(e, containsString("unable to authenticate user [idonotexist] for REST request [/]")).     } }
false;public;0;9;;public void testTokenRestMissing() throws Exception {     when(firstRealm.token(threadContext)).thenReturn(null).     when(secondRealm.token(threadContext)).thenReturn(null).     Authenticator authenticator = service.createAuthenticator(restRequest, mock(ActionListener.class)).     authenticator.extractToken((token) -> {         assertThat(token, nullValue()).     }). }
false;public;0;19;;public void authenticationInContextAndHeader() throws Exception {     User user = new User("_username", "r1").     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user).     Authentication result = authenticateBlocking("_action", message, null).     assertThat(result, notNullValue()).     assertThat(result.getUser(), is(user)).     assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).     String userStr = threadContext.getHeader(AuthenticationField.AUTHENTICATION_KEY).     assertThat(userStr, notNullValue()).     assertThat(userStr, equalTo("_signed_auth")).     Authentication ctxAuth = threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY).     assertThat(ctxAuth, is(result)). }
false;public;0;13;;public void testAuthenticateTransportAnonymous() throws Exception {     when(firstRealm.token(threadContext)).thenReturn(null).     when(secondRealm.token(threadContext)).thenReturn(null).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     try {         authenticateBlocking("_action", message, null).         fail("expected an authentication exception when trying to authenticate an anonymous message").     } catch (ElasticsearchSecurityException e) {         // expected         assertAuthenticationException(e).     }     verify(auditTrail).anonymousAccessDenied(reqId, "_action", message). }
false;public;0;13;;public void testAuthenticateRestAnonymous() throws Exception {     when(firstRealm.token(threadContext)).thenReturn(null).     when(secondRealm.token(threadContext)).thenReturn(null).     try {         authenticateBlocking(restRequest).         fail("expected an authentication exception when trying to authenticate an anonymous message").     } catch (ElasticsearchSecurityException e) {         // expected         assertAuthenticationException(e).     }     String reqId = expectAuditRequestId().     verify(auditTrail).anonymousAccessDenied(reqId, restRequest). }
false;public;0;11;;public void testAuthenticateTransportFallback() throws Exception {     when(firstRealm.token(threadContext)).thenReturn(null).     when(secondRealm.token(threadContext)).thenReturn(null).     User user1 = new User("username", "r1", "r2").     Authentication result = authenticateBlocking("_action", message, user1).     assertThat(result, notNullValue()).     assertThat(result.getUser(), sameInstance(user1)).     assertThat(result.getAuthenticationType(), is(AuthenticationType.INTERNAL)).     assertThreadContextContainsAuthentication(result). }
false;public;0;14;;public void testAuthenticateTransportDisabledUser() throws Exception {     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     User user = new User("username", new String[] { "r1", "r2" }, null, null, null, false).     User fallback = randomBoolean() ? SystemUser.INSTANCE : null.     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking("_action", message, fallback)).     verify(auditTrail).authenticationFailed(reqId, token, "_action", message).     verifyNoMoreInteractions(auditTrail).     assertAuthenticationException(e). }
false;public;0;13;;public void testAuthenticateRestDisabledUser() throws Exception {     User user = new User("username", new String[] { "r1", "r2" }, null, null, null, false).     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking(restRequest)).     String reqId = expectAuditRequestId().     verify(auditTrail).authenticationFailed(reqId, token, restRequest).     verifyNoMoreInteractions(auditTrail).     assertAuthenticationException(e). }
false;public;0;21;;public void testAuthenticateTransportSuccess() throws Exception {     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     User user = new User("username", "r1", "r2").     User fallback = randomBoolean() ? SystemUser.INSTANCE : null.     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user).     final AtomicBoolean completed = new AtomicBoolean(false).     service.authenticate("_action", message, fallback, ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getUser(), sameInstance(user)).         assertThreadContextContainsAuthentication(result).         assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).         setCompletedToTrue(completed).     }, this::logAndFail)).     verify(auditTrail).authenticationSuccess(reqId, firstRealm.name(), user, "_action", message).     verifyNoMoreInteractions(auditTrail).     assertTrue(completed.get()). }
false;public;0;19;;public void testAuthenticateRestSuccess() throws Exception {     User user1 = new User("username", "r1", "r2").     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user1).     // this call does not actually go async     final AtomicBoolean completed = new AtomicBoolean(false).     service.authenticate(restRequest, ActionListener.wrap(authentication -> {         assertThat(authentication, notNullValue()).         assertThat(authentication.getUser(), sameInstance(user1)).         assertThat(authentication.getAuthenticationType(), is(AuthenticationType.REALM)).         assertThreadContextContainsAuthentication(authentication).         setCompletedToTrue(completed).     }, this::logAndFail)).     String reqId = expectAuditRequestId().     verify(auditTrail).authenticationSuccess(reqId, firstRealm.name(), user1, restRequest).     verifyNoMoreInteractions(auditTrail).     assertTrue(completed.get()). }
false;public;0;80;;public void testAuthenticateTransportContextAndHeader() throws Exception {     User user1 = new User("username", "r1", "r2").     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user1).     final AtomicBoolean completed = new AtomicBoolean(false).     final SetOnce<Authentication> authRef = new SetOnce<>().     final SetOnce<String> authHeaderRef = new SetOnce<>().     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         service.authenticate("_action", message, SystemUser.INSTANCE, ActionListener.wrap(authentication -> {             assertThat(authentication, notNullValue()).             assertThat(authentication.getUser(), sameInstance(user1)).             assertThat(authentication.getAuthenticationType(), is(AuthenticationType.REALM)).             assertThreadContextContainsAuthentication(authentication).             authRef.set(authentication).             authHeaderRef.set(threadContext.getHeader(AuthenticationField.AUTHENTICATION_KEY)).             setCompletedToTrue(completed).         }, this::logAndFail)).     }     assertTrue(completed.compareAndSet(true, false)).     reset(firstRealm).     // checking authentication from the context     InternalMessage message1 = new InternalMessage().     ThreadPool threadPool1 = new TestThreadPool("testAutheticateTransportContextAndHeader1").     try {         ThreadContext threadContext1 = threadPool1.getThreadContext().         service = new AuthenticationService(Settings.EMPTY, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool1, new AnonymousUser(Settings.EMPTY), tokenService, apiKeyService).         threadContext1.putTransient(AuthenticationField.AUTHENTICATION_KEY, authRef.get()).         threadContext1.putHeader(AuthenticationField.AUTHENTICATION_KEY, authHeaderRef.get()).         service.authenticate("_action", message1, SystemUser.INSTANCE, ActionListener.wrap(ctxAuth -> {             assertThat(ctxAuth, sameInstance(authRef.get())).             assertThat(threadContext1.getHeader(AuthenticationField.AUTHENTICATION_KEY), sameInstance(authHeaderRef.get())).             setCompletedToTrue(completed).         }, this::logAndFail)).         assertTrue(completed.compareAndSet(true, false)).         verifyZeroInteractions(firstRealm).         reset(firstRealm).     } finally {         terminate(threadPool1).     }     // checking authentication from the user header     ThreadPool threadPool2 = new TestThreadPool("testAutheticateTransportContextAndHeader2").     try {         ThreadContext threadContext2 = threadPool2.getThreadContext().         final String header.         try (ThreadContext.StoredContext ignore = threadContext2.stashContext()) {             service = new AuthenticationService(Settings.EMPTY, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool2, new AnonymousUser(Settings.EMPTY), tokenService, apiKeyService).             threadContext2.putHeader(AuthenticationField.AUTHENTICATION_KEY, authHeaderRef.get()).             BytesStreamOutput output = new BytesStreamOutput().             threadContext2.writeTo(output).             StreamInput input = output.bytes().streamInput().             threadContext2 = new ThreadContext(Settings.EMPTY).             threadContext2.readHeaders(input).             header = threadContext2.getHeader(AuthenticationField.AUTHENTICATION_KEY).         }         threadPool2.getThreadContext().putHeader(AuthenticationField.AUTHENTICATION_KEY, header).         service = new AuthenticationService(Settings.EMPTY, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool2, new AnonymousUser(Settings.EMPTY), tokenService, apiKeyService).         service.authenticate("_action", new InternalMessage(), SystemUser.INSTANCE, ActionListener.wrap(result -> {             assertThat(result, notNullValue()).             assertThat(result.getUser(), equalTo(user1)).             assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).             setCompletedToTrue(completed).         }, this::logAndFail)).         assertTrue(completed.get()).         verifyZeroInteractions(firstRealm).     } finally {         terminate(threadPool2).     } }
false;public;0;13;;public void testAuthenticateTamperedUser() throws Exception {     InternalMessage message = new InternalMessage().     threadContext.putHeader(AuthenticationField.AUTHENTICATION_KEY, "_signed_auth").     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     try {         authenticateBlocking("_action", message, randomBoolean() ? SystemUser.INSTANCE : null).     } catch (Exception e) {         // expected         verify(auditTrail).tamperedRequest(reqId, "_action", message).         verifyNoMoreInteractions(auditTrail).     } }
false;public;0;23;;public void testAnonymousUserRest() throws Exception {     String username = randomBoolean() ? AnonymousUser.DEFAULT_ANONYMOUS_USERNAME : "user1".     Settings.Builder builder = Settings.builder().putList(AnonymousUser.ROLES_SETTING.getKey(), "r1", "r2", "r3").     if (username.equals(AnonymousUser.DEFAULT_ANONYMOUS_USERNAME) == false) {         builder.put(AnonymousUser.USERNAME_SETTING.getKey(), username).     }     Settings settings = builder.build().     final AnonymousUser anonymousUser = new AnonymousUser(settings).     service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser, tokenService, apiKeyService).     RestRequest request = new FakeRestRequest().     Authentication result = authenticateBlocking(request).     assertThat(result, notNullValue()).     assertThat(result.getUser(), sameInstance((Object) anonymousUser)).     assertThat(result.getAuthenticationType(), is(AuthenticationType.ANONYMOUS)).     assertThreadContextContainsAuthentication(result).     String reqId = expectAuditRequestId().     verify(auditTrail).authenticationSuccess(reqId, "__anonymous", new AnonymousUser(settings), request).     verifyNoMoreInteractions(auditTrail). }
false;public;0;15;;public void testAnonymousUserTransportNoDefaultUser() throws Exception {     Settings settings = Settings.builder().putList(AnonymousUser.ROLES_SETTING.getKey(), "r1", "r2", "r3").build().     final AnonymousUser anonymousUser = new AnonymousUser(settings).     service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser, tokenService, apiKeyService).     InternalMessage message = new InternalMessage().     Authentication result = authenticateBlocking("_action", message, null).     assertThat(result, notNullValue()).     assertThat(result.getUser(), sameInstance(anonymousUser)).     assertThat(result.getAuthenticationType(), is(AuthenticationType.ANONYMOUS)).     assertThreadContextContainsAuthentication(result). }
false;public;0;16;;public void testAnonymousUserTransportWithDefaultUser() throws Exception {     Settings settings = Settings.builder().putList(AnonymousUser.ROLES_SETTING.getKey(), "r1", "r2", "r3").build().     final AnonymousUser anonymousUser = new AnonymousUser(settings).     service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser, tokenService, apiKeyService).     InternalMessage message = new InternalMessage().     Authentication result = authenticateBlocking("_action", message, SystemUser.INSTANCE).     assertThat(result, notNullValue()).     assertThat(result.getUser(), sameInstance(SystemUser.INSTANCE)).     assertThat(result.getAuthenticationType(), is(AuthenticationType.INTERNAL)).     assertThreadContextContainsAuthentication(result). }
false;public;0;11;;public void testRealmTokenThrowingException() throws Exception {     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     when(firstRealm.token(threadContext)).thenThrow(authenticationError("realm doesn't like tokens")).     try {         authenticateBlocking("_action", message, null).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't like tokens")).         verify(auditTrail).authenticationFailed(reqId, "_action", message).     } }
false;public;0;11;;public void testRealmTokenThrowingExceptionRest() throws Exception {     when(firstRealm.token(threadContext)).thenThrow(authenticationError("realm doesn't like tokens")).     try {         authenticateBlocking(restRequest).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't like tokens")).         String reqId = expectAuditRequestId().         verify(auditTrail).authenticationFailed(reqId, restRequest).     } }
false;public;0;14;;public void testRealmSupportsMethodThrowingException() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenThrow(authenticationError("realm doesn't like supports")).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     try {         authenticateBlocking("_action", message, null).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't like supports")).         verify(auditTrail).authenticationFailed(reqId, token, "_action", message).     } }
false;public;0;14;;public void testRealmSupportsMethodThrowingExceptionRest() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenThrow(authenticationError("realm doesn't like supports")).     try {         authenticateBlocking(restRequest).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't like supports")).         String reqId = expectAuditRequestId().         verify(auditTrail).authenticationFailed(reqId, token, restRequest).     } }
false;public;0;42;;public void testRealmAuthenticateTerminatingAuthenticationProcess() throws Exception {     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     final AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     final boolean terminateWithNoException = rarely().     final boolean throwElasticsearchSecurityException = (terminateWithNoException == false) && randomBoolean().     final boolean withAuthenticateHeader = throwElasticsearchSecurityException && randomBoolean().     Exception throwE = new Exception("general authentication error").     final String basicScheme = "Basic realm=\"" + XPackField.SECURITY + "\" charset=\"UTF-8\"".     String selectedScheme = randomFrom(basicScheme, "Negotiate IOJoj").     if (throwElasticsearchSecurityException) {         throwE = new ElasticsearchSecurityException("authentication error", RestStatus.UNAUTHORIZED).         if (withAuthenticateHeader) {             ((ElasticsearchSecurityException) throwE).addHeader("WWW-Authenticate", selectedScheme).         }     }     mockAuthenticate(secondRealm, token, (terminateWithNoException) ? null : throwE, true).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking("_action", message, null)).     if (terminateWithNoException) {         assertThat(e.getMessage(), is("terminate authc process")).         assertThat(e.getHeader("WWW-Authenticate"), contains(basicScheme)).     } else {         if (throwElasticsearchSecurityException) {             assertThat(e.getMessage(), is("authentication error")).             if (withAuthenticateHeader) {                 assertThat(e.getHeader("WWW-Authenticate"), contains(selectedScheme)).             } else {                 assertThat(e.getHeader("WWW-Authenticate"), contains(basicScheme)).             }         } else {             assertThat(e.getMessage(), is("error attempting to authenticate request")).             assertThat(e.getHeader("WWW-Authenticate"), contains(basicScheme)).         }     }     verify(auditTrail).authenticationFailed(reqId, secondRealm.name(), token, "_action", message).     verify(auditTrail).authenticationFailed(reqId, token, "_action", message).     verifyNoMoreInteractions(auditTrail). }
false;public;0;16;;public void testRealmAuthenticateThrowingException() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     doThrow(authenticationError("realm doesn't like authenticate")).when(secondRealm).authenticate(eq(token), any(ActionListener.class)).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     try {         authenticateBlocking("_action", message, null).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't like authenticate")).         verify(auditTrail).authenticationFailed(reqId, token, "_action", message).     } }
false;public;0;16;;public void testRealmAuthenticateThrowingExceptionRest() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     doThrow(authenticationError("realm doesn't like authenticate")).when(secondRealm).authenticate(eq(token), any(ActionListener.class)).     try {         authenticateBlocking(restRequest).         fail("exception should bubble out").     } catch (ElasticsearchSecurityException e) {         assertThat(e.getMessage(), is("realm doesn't like authenticate")).         String reqId = expectAuditRequestId().         verify(auditTrail).authenticationFailed(reqId, token, restRequest).     } }
false;public;0;20;;public void testRealmLookupThrowingException() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "run_as").     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, new User("lookup user", new String[] { "user" })).     mockRealmLookupReturnsNull(firstRealm, "run_as").     doThrow(authenticationError("realm doesn't want to lookup")).when(secondRealm).lookupUser(eq("run_as"), any(ActionListener.class)).     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     try {         authenticateBlocking("_action", message, null).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't want to lookup")).         verify(auditTrail).authenticationFailed(reqId, token, "_action", message).     } }
false;public;0;19;;public void testRealmLookupThrowingExceptionRest() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "run_as").     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, new User("lookup user", new String[] { "user" })).     mockRealmLookupReturnsNull(firstRealm, "run_as").     doThrow(authenticationError("realm doesn't want to lookup")).when(secondRealm).lookupUser(eq("run_as"), any(ActionListener.class)).     try {         authenticateBlocking(restRequest).         fail("exception should bubble out").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), is("realm doesn't want to lookup")).         String reqId = expectAuditRequestId().         verify(auditTrail).authenticationFailed(reqId, token, restRequest).     } }
false;public;0;48;;public void testRunAsLookupSameRealm() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "run_as").     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     final User user = new User("lookup user", new String[] { "user" }, "lookup user", "lookup@foo.foo", Collections.singletonMap("foo", "bar"), true).     mockAuthenticate(secondRealm, token, user).     mockRealmLookupReturnsNull(firstRealm, "run_as").     doAnswer((i) -> {         ActionListener<User> listener = (ActionListener<User>) i.getArguments()[1].         listener.onResponse(new User("looked up user", new String[] { "some role" })).         return null.     }).when(secondRealm).lookupUser(eq("run_as"), any(ActionListener.class)).     final AtomicBoolean completed = new AtomicBoolean(false).     ActionListener<Authentication> listener = ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).         User authenticated = result.getUser().         assertThat(authenticated.principal(), is("looked up user")).         assertThat(authenticated.roles(), arrayContaining("some role")).         assertThreadContextContainsAuthentication(result).         assertThat(SystemUser.is(authenticated), is(false)).         assertThat(authenticated.isRunAs(), is(true)).         User authUser = authenticated.authenticatedUser().         assertThat(authUser.principal(), is("lookup user")).         assertThat(authUser.roles(), arrayContaining("user")).         assertEquals(user.metadata(), authUser.metadata()).         assertEquals(user.email(), authUser.email()).         assertEquals(user.enabled(), authUser.enabled()).         assertEquals(user.fullName(), authUser.fullName()).         setCompletedToTrue(completed).     }, this::logAndFail).     // we do not actually go async     if (randomBoolean()) {         service.authenticate("_action", message, (User) null, listener).     } else {         service.authenticate(restRequest, listener).     }     assertTrue(completed.get()). }
false;public;0;38;;@SuppressWarnings("unchecked") public void testRunAsLookupDifferentRealm() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "run_as").     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, new User("lookup user", new String[] { "user" })).     doAnswer((i) -> {         ActionListener<User> listener = (ActionListener<User>) i.getArguments()[1].         listener.onResponse(new User("looked up user", new String[] { "some role" })).         return null.     }).when(firstRealm).lookupUser(eq("run_as"), any(ActionListener.class)).     final AtomicBoolean completed = new AtomicBoolean(false).     ActionListener<Authentication> listener = ActionListener.wrap(result -> {         assertThat(result, notNullValue()).         assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM)).         User authenticated = result.getUser().         assertThat(SystemUser.is(authenticated), is(false)).         assertThat(authenticated.isRunAs(), is(true)).         assertThat(authenticated.authenticatedUser().principal(), is("lookup user")).         assertThat(authenticated.authenticatedUser().roles(), arrayContaining("user")).         assertThat(authenticated.principal(), is("looked up user")).         assertThat(authenticated.roles(), arrayContaining("some role")).         assertThreadContextContainsAuthentication(result).         setCompletedToTrue(completed).     }, this::logAndFail).     // call service asynchronously but it doesn't actually go async     if (randomBoolean()) {         service.authenticate("_action", message, (User) null, listener).     } else {         service.authenticate(restRequest, listener).     }     assertTrue(completed.get()). }
false;public;0;18;;public void testRunAsWithEmptyRunAsUsernameRest() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     User user = new User("lookup user", new String[] { "user" }).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "").     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, user).     try {         authenticateBlocking(restRequest).         fail("exception should be thrown").     } catch (ElasticsearchException e) {         String reqId = expectAuditRequestId().         verify(auditTrail).runAsDenied(eq(reqId), any(Authentication.class), eq(restRequest), eq(EmptyAuthorizationInfo.INSTANCE)).         verifyNoMoreInteractions(auditTrail).     } }
false;public;0;19;;public void testRunAsWithEmptyRunAsUsername() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     User user = new User("lookup user", new String[] { "user" }).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "").     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, user).     try {         authenticateBlocking("_action", message, null).         fail("exception should be thrown").     } catch (ElasticsearchException e) {         verify(auditTrail).runAsDenied(eq(reqId), any(Authentication.class), eq("_action"), eq(message), eq(EmptyAuthorizationInfo.INSTANCE)).         verifyNoMoreInteractions(auditTrail).     } }
false;public;0;22;;@SuppressWarnings("unchecked") public void testAuthenticateTransportDisabledRunAsUser() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "run_as").     final String reqId = AuditUtil.getOrGenerateRequestId(threadContext).     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, new User("lookup user", new String[] { "user" })).     mockRealmLookupReturnsNull(firstRealm, "run_as").     doAnswer((i) -> {         ActionListener<User> listener = (ActionListener<User>) i.getArguments()[1].         listener.onResponse(new User("looked up user", new String[] { "some role" }, null, null, null, false)).         return null.     }).when(secondRealm).lookupUser(eq("run_as"), any(ActionListener.class)).     User fallback = randomBoolean() ? SystemUser.INSTANCE : null.     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking("_action", message, fallback)).     verify(auditTrail).authenticationFailed(reqId, token, "_action", message).     verifyNoMoreInteractions(auditTrail).     assertAuthenticationException(e). }
false;public;0;22;;public void testAuthenticateRestDisabledRunAsUser() throws Exception {     AuthenticationToken token = mock(AuthenticationToken.class).     when(token.principal()).thenReturn(randomAlphaOfLength(5)).     threadContext.putHeader(AuthenticationServiceField.RUN_AS_USER_HEADER, "run_as").     when(secondRealm.token(threadContext)).thenReturn(token).     when(secondRealm.supports(token)).thenReturn(true).     mockAuthenticate(secondRealm, token, new User("lookup user", new String[] { "user" })).     mockRealmLookupReturnsNull(firstRealm, "run_as").     doAnswer((i) -> {         @SuppressWarnings("unchecked")         ActionListener<User> listener = (ActionListener<User>) i.getArguments()[1].         listener.onResponse(new User("looked up user", new String[] { "some role" }, null, null, null, false)).         return null.     }).when(secondRealm).lookupUser(eq("run_as"), any(ActionListener.class)).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking(restRequest)).     String reqId = expectAuditRequestId().     verify(auditTrail).authenticationFailed(reqId, token, restRequest).     verifyNoMoreInteractions(auditTrail).     assertAuthenticationException(e). }
false;public;0;29;;public void testAuthenticateWithToken() throws Exception {     User user = new User("_username", "r1").     final AtomicBoolean completed = new AtomicBoolean(false).     final Authentication expected = new Authentication(user, new RealmRef("realm", "custom", "node"), null).     PlainActionFuture<Tuple<UserToken, String>> tokenFuture = new PlainActionFuture<>().     try (ThreadContext.StoredContext ctx = threadContext.stashContext()) {         Authentication originatingAuth = new Authentication(new User("creator"), new RealmRef("test", "test", "test"), null).         tokenService.createUserToken(expected, originatingAuth, tokenFuture, Collections.emptyMap(), true).     }     String token = tokenService.getUserTokenString(tokenFuture.get().v1()).     when(client.prepareMultiGet()).thenReturn(new MultiGetRequestBuilder(client, MultiGetAction.INSTANCE)).     mockGetTokenFromId(tokenFuture.get().v1(), false, client).     when(securityIndex.isAvailable()).thenReturn(true).     when(securityIndex.indexExists()).thenReturn(true).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         threadContext.putHeader("Authorization", "Bearer " + token).         service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {             assertThat(result, notNullValue()).             assertThat(result.getUser(), is(user)).             assertThat(result.getLookedUpBy(), is(nullValue())).             assertThat(result.getAuthenticatedBy(), is(notNullValue())).             assertThat(result.getAuthenticationType(), is(AuthenticationType.TOKEN)).             setCompletedToTrue(completed).         }, this::logAndFail)).     }     assertTrue(completed.get()).     verify(auditTrail).authenticationSuccess(anyString(), eq("realm"), eq(user), eq("_action"), same(message)).     verifyNoMoreInteractions(auditTrail). }
false;public;0;51;;public void testInvalidToken() throws Exception {     final User user = new User("_username", "r1").     when(firstRealm.token(threadContext)).thenReturn(token).     when(firstRealm.supports(token)).thenReturn(true).     mockAuthenticate(firstRealm, token, user).     final int numBytes = randomIntBetween(TokenService.MINIMUM_BYTES, TokenService.MINIMUM_BYTES + 32).     final byte[] randomBytes = new byte[numBytes].     random().nextBytes(randomBytes).     final CountDownLatch latch = new CountDownLatch(1).     final Authentication expected = new Authentication(user, new RealmRef(firstRealm.name(), firstRealm.type(), "authc_test"), null).     AtomicBoolean success = new AtomicBoolean(false).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         threadContext.putHeader("Authorization", "Bearer " + Base64.getEncoder().encodeToString(randomBytes)).         service.authenticate("_action", message, (User) null, ActionListener.wrap(result -> {             assertThat(result, notNullValue()).             assertThat(result.getUser(), is(user)).             assertThat(result.getLookedUpBy(), is(nullValue())).             assertThat(result.getAuthenticatedBy(), is(notNullValue())).             assertThreadContextContainsAuthentication(result).             assertEquals(expected, result).             success.set(true).             latch.countDown().         }, e -> {             if (e instanceof IllegalStateException) {                 assertThat(e.getMessage(), containsString("array length must be <= to " + ArrayUtil.MAX_ARRAY_LENGTH + " but was: ")).                 latch.countDown().             } else if (e instanceof NegativeArraySizeException) {                 assertThat(e.getMessage(), containsString("array size must be positive but was: ")).                 latch.countDown().             } else {                 logger.error("unexpected exception", e).                 latch.countDown().                 fail("unexpected exception: " + e.getMessage()).             }         })).     } catch (IllegalStateException ex) {         assertThat(ex.getMessage(), containsString("array length must be <= to " + ArrayUtil.MAX_ARRAY_LENGTH + " but was: ")).         latch.countDown().     } catch (NegativeArraySizeException ex) {         assertThat(ex.getMessage(), containsString("array size must be positive but was: ")).         latch.countDown().     }     // we need to use a latch here because the key computation goes async on another thread!     latch.await().     if (success.get()) {         final String realmName = firstRealm.name().         verify(auditTrail).authenticationSuccess(anyString(), eq(realmName), eq(user), eq("_action"), same(message)).     }     verifyNoMoreInteractions(auditTrail). }
false;public;0;25;;public void testExpiredToken() throws Exception {     when(securityIndex.isAvailable()).thenReturn(true).     when(securityIndex.indexExists()).thenReturn(true).     User user = new User("_username", "r1").     final Authentication expected = new Authentication(user, new RealmRef("realm", "custom", "node"), null).     PlainActionFuture<Tuple<UserToken, String>> tokenFuture = new PlainActionFuture<>().     try (ThreadContext.StoredContext ctx = threadContext.stashContext()) {         Authentication originatingAuth = new Authentication(new User("creator"), new RealmRef("test", "test", "test"), null).         tokenService.createUserToken(expected, originatingAuth, tokenFuture, Collections.emptyMap(), true).     }     String token = tokenService.getUserTokenString(tokenFuture.get().v1()).     mockGetTokenFromId(tokenFuture.get().v1(), true, client).     doAnswer(invocationOnMock -> {         ((Runnable) invocationOnMock.getArguments()[1]).run().         return null.     }).when(securityIndex).prepareIndexIfNeededThenExecute(any(Consumer.class), any(Runnable.class)).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         threadContext.putHeader("Authorization", "Bearer " + token).         ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking("_action", message, null)).         assertEquals(RestStatus.UNAUTHORIZED, e.status()).         assertEquals("token expired", e.getMessage()).     } }
false;public;0;10;;public void testApiKeyAuthInvalidHeader() {     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         final String invalidHeader = randomFrom("apikey", "apikey ", "apikey foo").         threadContext.putHeader("Authorization", invalidHeader).         ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking("_action", message, null)).         assertEquals(RestStatus.UNAUTHORIZED, e.status()).         assertThat(e.getMessage(), containsString("missing authentication credentials")).     } }
false;public;0;38;;@SuppressWarnings("unchecked") public void testApiKeyAuth() {     final String id = randomAlphaOfLength(12).     final String key = UUIDs.randomBase64UUID(random()).     final String headerValue = "ApiKey " + Base64.getEncoder().encodeToString((id + ":" + key).getBytes(StandardCharsets.UTF_8)).     doAnswer(invocationOnMock -> {         final GetRequest request = (GetRequest) invocationOnMock.getArguments()[0].         final ActionListener<GetResponse> listener = (ActionListener<GetResponse>) invocationOnMock.getArguments()[1].         if (request.id().equals(id)) {             final Map<String, Object> source = new HashMap<>().             source.put("doc_type", "api_key").             source.put("creation_time", Instant.now().minus(5, ChronoUnit.MINUTES).toEpochMilli()).             source.put("api_key_invalidated", false).             source.put("api_key_hash", new String(Hasher.BCRYPT4.hash(new SecureString(key.toCharArray())))).             source.put("role_descriptors", Collections.singletonMap("api key role", Collections.singletonMap("cluster", "all"))).             source.put("name", "my api key for testApiKeyAuth").             Map<String, Object> creatorMap = new HashMap<>().             creatorMap.put("principal", "johndoe").             creatorMap.put("metadata", Collections.emptyMap()).             creatorMap.put("realm", "auth realm").             source.put("creator", creatorMap).             GetResponse getResponse = new GetResponse(new GetResult(request.index(), request.type(), request.id(), 0, 1, 1L, true, BytesReference.bytes(JsonXContent.contentBuilder().map(source)), Collections.emptyMap())).             listener.onResponse(getResponse).         } else {             listener.onResponse(new GetResponse(new GetResult(request.index(), request.type(), request.id(), SequenceNumbers.UNASSIGNED_SEQ_NO, 1, -1L, false, null, Collections.emptyMap()))).         }         return Void.TYPE.     }).when(client).get(any(GetRequest.class), any(ActionListener.class)).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         threadContext.putHeader("Authorization", headerValue).         final Authentication authentication = authenticateBlocking("_action", message, null).         assertThat(authentication.getUser().principal(), is("johndoe")).         assertThat(authentication.getAuthenticationType(), is(AuthenticationType.API_KEY)).     } }
false;public;0;39;;public void testExpiredApiKey() {     final String id = randomAlphaOfLength(12).     final String key = UUIDs.randomBase64UUID(random()).     final String headerValue = "ApiKey " + Base64.getEncoder().encodeToString((id + ":" + key).getBytes(StandardCharsets.UTF_8)).     doAnswer(invocationOnMock -> {         final GetRequest request = (GetRequest) invocationOnMock.getArguments()[0].         final ActionListener<GetResponse> listener = (ActionListener<GetResponse>) invocationOnMock.getArguments()[1].         if (request.id().equals(id)) {             final Map<String, Object> source = new HashMap<>().             source.put("doc_type", "api_key").             source.put("creation_time", Instant.now().minus(5L, ChronoUnit.HOURS).toEpochMilli()).             source.put("expiration_time", Instant.now().minus(1L, ChronoUnit.HOURS).toEpochMilli()).             source.put("api_key_invalidated", false).             source.put("api_key_hash", new String(Hasher.BCRYPT4.hash(new SecureString(key.toCharArray())))).             source.put("role_descriptors", Collections.singletonList(Collections.singletonMap("name", "a role"))).             source.put("name", "my api key for testApiKeyAuth").             Map<String, Object> creatorMap = new HashMap<>().             creatorMap.put("principal", "johndoe").             creatorMap.put("metadata", Collections.emptyMap()).             creatorMap.put("realm", "auth realm").             source.put("creator", creatorMap).             GetResponse getResponse = new GetResponse(new GetResult(request.index(), request.type(), request.id(), 0, 1, 1L, true, BytesReference.bytes(JsonXContent.contentBuilder().map(source)), Collections.emptyMap())).             listener.onResponse(getResponse).         } else {             listener.onResponse(new GetResponse(new GetResult(request.index(), request.type(), request.id(), SequenceNumbers.UNASSIGNED_SEQ_NO, 1, -1L, false, null, Collections.emptyMap()))).         }         return Void.TYPE.     }).when(client).get(any(GetRequest.class), any(ActionListener.class)).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         threadContext.putHeader("Authorization", headerValue).         ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> authenticateBlocking("_action", message, null)).         assertThat(e.getMessage(), containsString("api key is expired")).         assertEquals(RestStatus.UNAUTHORIZED, e.status()).     } }
false;;1;6;;void assertThreadContextContainsAuthentication(Authentication authentication) throws IOException {     Authentication contextAuth = threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY).     assertThat(contextAuth, notNullValue()).     assertThat(contextAuth, is(authentication)).     assertThat(threadContext.getHeader(AuthenticationField.AUTHENTICATION_KEY), equalTo((Object) authentication.encode())). }
false;private;3;22;;@SuppressWarnings("unchecked") private void mockAuthenticate(Realm realm, AuthenticationToken token, User user) {     final boolean separateThread = randomBoolean().     doAnswer(i -> {         ActionListener<AuthenticationResult> listener = (ActionListener<AuthenticationResult>) i.getArguments()[1].         Runnable run = () -> {             if (user == null) {                 listener.onResponse(AuthenticationResult.notHandled()).             } else {                 listener.onResponse(AuthenticationResult.success(user)).             }         }.         if (separateThread) {             final Thread thread = new Thread(run).             thread.start().             thread.join().         } else {             run.run().         }         return null.     }).when(realm).authenticate(eq(token), any(ActionListener.class)). }
false;private;4;12;;@SuppressWarnings("unchecked") private void mockAuthenticate(Realm realm, AuthenticationToken token, Exception e, boolean terminate) {     doAnswer((i) -> {         ActionListener<AuthenticationResult> listener = (ActionListener<AuthenticationResult>) i.getArguments()[1].         if (terminate) {             listener.onResponse(AuthenticationResult.terminate("terminate authc process", e)).         } else {             listener.onResponse(AuthenticationResult.unsuccessful("unsuccessful, but continue authc process", e)).         }         return null.     }).when(realm).authenticate(eq(token), any(ActionListener.class)). }
false;private;1;5;;private Authentication authenticateBlocking(RestRequest restRequest) {     PlainActionFuture<Authentication> future = new PlainActionFuture<>().     service.authenticate(restRequest, future).     return future.actionGet(). }
false;private;3;5;;private Authentication authenticateBlocking(String action, TransportMessage message, User fallbackUser) {     PlainActionFuture<Authentication> future = new PlainActionFuture<>().     service.authenticate(action, message, fallbackUser, future).     return future.actionGet(). }
false;private;0;5;;private String expectAuditRequestId() {     String reqId = AuditUtil.extractRequestId(threadContext).     assertThat(reqId, not(isEmptyOrNullString())).     return reqId. }
false;private,static;2;8;;@SuppressWarnings("unchecked") private static void mockRealmLookupReturnsNull(Realm realm, String username) {     doAnswer((i) -> {         ActionListener<?> listener = (ActionListener<?>) i.getArguments()[1].         listener.onResponse(null).         return null.     }).when(realm).lookupUser(eq(username), any(ActionListener.class)). }
false;private;1;4;;private void logAndFail(Exception e) {     logger.error("unexpected exception", e).     fail("unexpected exception " + e.getMessage()). }
false;private;1;3;;private void setCompletedToTrue(AtomicBoolean completed) {     assertTrue(completed.compareAndSet(false, true)). }
false;private;1;3;;private SecurityIndexManager.State dummyState(ClusterHealthStatus indexStatus) {     return new SecurityIndexManager.State(true, true, true, true, null, concreteSecurityIndexName, indexStatus). }
