commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Before public void setupRealms() {     globalSettings = Settings.builder().put("path.home", createTempDir()).build().     env = TestEnvironment.newEnvironment(globalSettings).     threadContext = new ThreadContext(globalSettings).     final int realmCount = randomIntBetween(5, 9).     realms = new ArrayList<>(realmCount).     for (int i = 1. i <= realmCount. i++) {         realms.add(new MockLookupRealm(buildRealmConfig("lookup-" + i, Settings.EMPTY))).     }     shuffle(realms). }
false;private;1;4;;private <T> List<T> shuffle(List<T> list) {     Collections.shuffle(list, random()).     return list. }
false;private;2;8;;private RealmConfig buildRealmConfig(String name, Settings settings) {     return new RealmConfig(new RealmConfig.RealmIdentifier("test", name), Settings.builder().put(settings).normalizePrefix("xpack.security.authc.realms.test." + name + ".").put(globalSettings).build(), env, threadContext). }
false;public;0;11;;public void testEmptyDelegationList() throws ExecutionException, InterruptedException {     final XPackLicenseState license = getLicenseState(true).     final DelegatedAuthorizationSupport das = new DelegatedAuthorizationSupport(realms, buildRealmConfig("r", Settings.EMPTY), license).     assertThat(das.hasDelegation(), equalTo(false)).     final PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     das.resolve("any", future).     final AuthenticationResult result = future.get().     assertThat(result.getStatus(), equalTo(AuthenticationResult.Status.CONTINUE)).     assertThat(result.getUser(), nullValue()).     assertThat(result.getMessage(), equalTo("No [authorization_realms] have been configured")). }
false;public;0;10;;public void testMissingRealmInDelegationList() {     final XPackLicenseState license = getLicenseState(true).     final Settings settings = Settings.builder().putList("authorization_realms", "no-such-realm").build().     final IllegalArgumentException ex = expectThrows(IllegalArgumentException.class, () -> new DelegatedAuthorizationSupport(realms, buildRealmConfig("r", settings), license)).     assertThat(ex.getMessage(), equalTo("configured authorization realm [no-such-realm] does not exist (or is not enabled)")). }
false;public;0;15;;public void testDelegationChainsAreRejected() {     final XPackLicenseState license = getLicenseState(true).     final Settings settings = Settings.builder().putList("authorization_realms", "lookup-1", "lookup-2", "lookup-3").build().     globalSettings = Settings.builder().put(globalSettings).putList("xpack.security.authc.realms.test.lookup-2.authorization_realms", "lookup-1").build().     final IllegalArgumentException ex = expectThrows(IllegalArgumentException.class, () -> new DelegatedAuthorizationSupport(realms, buildRealmConfig("realm1", settings), license)).     assertThat(ex.getMessage(), equalTo("cannot use realm [test/lookup-2] as an authorization realm - it is already delegating authorization to [[lookup-1]]")). }
false;public;0;16;;public void testMatchInDelegationList() throws Exception {     final XPackLicenseState license = getLicenseState(true).     final List<MockLookupRealm> useRealms = shuffle(randomSubsetOf(randomIntBetween(1, realms.size()), realms)).     final Settings settings = Settings.builder().putList("authorization_realms", useRealms.stream().map(Realm::name).collect(Collectors.toList())).build().     final User user = new User("my_user").     randomFrom(useRealms).registerUser(user).     final DelegatedAuthorizationSupport das = new DelegatedAuthorizationSupport(realms, buildRealmConfig("r", settings), license).     assertThat(das.hasDelegation(), equalTo(true)).     final PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     das.resolve("my_user", future).     final AuthenticationResult result = future.get().     assertThat(result.getStatus(), equalTo(AuthenticationResult.Status.SUCCESS)).     assertThat(result.getUser(), sameInstance(user)). }
false;public;0;24;;public void testRealmsAreOrdered() throws Exception {     final XPackLicenseState license = getLicenseState(true).     final List<MockLookupRealm> useRealms = shuffle(randomSubsetOf(randomIntBetween(3, realms.size()), realms)).     final List<String> names = useRealms.stream().map(Realm::name).collect(Collectors.toList()).     final Settings settings = Settings.builder().putList("authorization_realms", names).build().     final List<User> users = new ArrayList<>(names.size()).     final String username = randomAlphaOfLength(8).     for (MockLookupRealm r : useRealms) {         final User user = new User(username, "role_" + r.name()).         users.add(user).         r.registerUser(user).     }     final DelegatedAuthorizationSupport das = new DelegatedAuthorizationSupport(realms, buildRealmConfig("r", settings), license).     assertThat(das.hasDelegation(), equalTo(true)).     final PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     das.resolve(username, future).     final AuthenticationResult result = future.get().     assertThat(result.getStatus(), equalTo(AuthenticationResult.Status.SUCCESS)).     assertThat(result.getUser(), sameInstance(users.get(0))).     assertThat(result.getUser().roles(), arrayContaining("role_" + useRealms.get(0).name())). }
false;public;0;16;;public void testNoMatchInDelegationList() throws Exception {     final XPackLicenseState license = getLicenseState(true).     final List<MockLookupRealm> useRealms = shuffle(randomSubsetOf(randomIntBetween(1, realms.size()), realms)).     final Settings settings = Settings.builder().putList("authorization_realms", useRealms.stream().map(Realm::name).collect(Collectors.toList())).build().     final DelegatedAuthorizationSupport das = new DelegatedAuthorizationSupport(realms, buildRealmConfig("r", settings), license).     assertThat(das.hasDelegation(), equalTo(true)).     final PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     das.resolve("my_user", future).     final AuthenticationResult result = future.get().     assertThat(result.getStatus(), equalTo(AuthenticationResult.Status.CONTINUE)).     assertThat(result.getUser(), nullValue()).     assertThat(result.getMessage(), equalTo("the principal [my_user] was authenticated, but no user could be found in realms [" + collectionToDelimitedString(useRealms.stream().map(Realm::toString).collect(Collectors.toList()), ",") + "]")). }
false;public;0;16;;public void testLicenseRejection() throws Exception {     final XPackLicenseState license = getLicenseState(false).     final Settings settings = Settings.builder().putList("authorization_realms", realms.get(0).name()).build().     final DelegatedAuthorizationSupport das = new DelegatedAuthorizationSupport(realms, buildRealmConfig("r", settings), license).     assertThat(das.hasDelegation(), equalTo(true)).     final PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>().     das.resolve("my_user", future).     final AuthenticationResult result = future.get().     assertThat(result.getStatus(), equalTo(AuthenticationResult.Status.CONTINUE)).     assertThat(result.getUser(), nullValue()).     assertThat(result.getMessage(), equalTo("authorization_realms are not permitted")).     assertThat(result.getException(), instanceOf(ElasticsearchSecurityException.class)).     assertThat(result.getException().getMessage(), equalTo("current license is non-compliant for [authorization_realms]")). }
false;private;1;5;;private XPackLicenseState getLicenseState(boolean authzRealmsAllowed) {     final XPackLicenseState license = mock(XPackLicenseState.class).     when(license.isAuthorizationRealmAllowed()).thenReturn(authzRealmsAllowed).     return license. }
