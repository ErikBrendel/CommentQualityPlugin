commented;modifiers;parameterAmount;loc;comment;code
false;public;0;25;;@Before public void init() throws Exception {     authcService = mock(AuthenticationService.class).     authzService = mock(AuthorizationService.class).     licenseState = mock(XPackLicenseState.class).     when(licenseState.isAuthAllowed()).thenReturn(true).     when(licenseState.isStatsAndHealthAllowed()).thenReturn(true).     ThreadPool threadPool = mock(ThreadPool.class).     threadContext = new ThreadContext(Settings.EMPTY).     when(threadPool.getThreadContext()).thenReturn(threadContext).     failDestructiveOperations = randomBoolean().     Settings settings = Settings.builder().put(DestructiveOperations.REQUIRES_NAME_SETTING.getKey(), failDestructiveOperations).build().     DestructiveOperations destructiveOperations = new DestructiveOperations(settings, new ClusterSettings(settings, Collections.singleton(DestructiveOperations.REQUIRES_NAME_SETTING))).     ClusterState state = mock(ClusterState.class).     DiscoveryNodes nodes = DiscoveryNodes.builder().add(new DiscoveryNode("id1", buildNewFakeTransportAddress(), Version.CURRENT)).add(new DiscoveryNode("id2", buildNewFakeTransportAddress(), Version.V_6_0_0)).build().     when(state.nodes()).thenReturn(nodes).     SecurityContext securityContext = new SecurityContext(settings, threadContext).     filter = new SecurityActionFilter(authcService, authzService, licenseState, threadPool, securityContext, destructiveOperations). }
false;public;0;23;;public void testApply() throws Exception {     ActionRequest request = mock(ActionRequest.class).     ActionListener listener = mock(ActionListener.class).     ActionFilterChain chain = mock(ActionFilterChain.class).     Task task = mock(Task.class).     User user = new User("username", "r1", "r2").     Authentication authentication = new Authentication(user, new RealmRef("test", "test", "foo"), null).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq("_action"), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class)).     doAnswer((i) -> {         ActionListener<Void> callback = (ActionListener<Void>) i.getArguments()[3].         callback.onResponse(null).         return Void.TYPE.     }).when(authzService).authorize(any(Authentication.class), any(String.class), any(TransportRequest.class), any(ActionListener.class)).     filter.apply(task, "_action", request, listener, chain).     verify(authzService).authorize(eq(authentication), eq("_action"), eq(request), any(ActionListener.class)).     verify(chain).proceed(eq(task), eq("_action"), eq(request), isA(ContextPreservingActionListener.class)). }
false;public;0;29;;public void testApplyRestoresThreadContext() throws Exception {     ActionRequest request = mock(ActionRequest.class).     ActionListener listener = mock(ActionListener.class).     ActionFilterChain chain = mock(ActionFilterChain.class).     Task task = mock(Task.class).     User user = new User("username", "r1", "r2").     Authentication authentication = new Authentication(user, new RealmRef("test", "test", "foo"), null).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).         threadContext.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication).         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq("_action"), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class)).     doAnswer((i) -> {         ActionListener<Void> callback = (ActionListener<Void>) i.getArguments()[3].         callback.onResponse(null).         return Void.TYPE.     }).when(authzService).authorize(any(Authentication.class), any(String.class), any(TransportRequest.class), any(ActionListener.class)).     assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).     filter.apply(task, "_action", request, listener, chain).     assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).     verify(authzService).authorize(eq(authentication), eq("_action"), eq(request), any(ActionListener.class)).     verify(chain).proceed(eq(task), eq("_action"), eq(request), isA(ContextPreservingActionListener.class)). }
false;public;0;43;;public void testApplyAsSystemUser() throws Exception {     ActionRequest request = mock(ActionRequest.class).     ActionListener listener = mock(ActionListener.class).     User user = new User("username", "r1", "r2").     Authentication authentication = new Authentication(user, new RealmRef("test", "test", "foo"), null).     SetOnce<Authentication> authenticationSetOnce = new SetOnce<>().     ActionFilterChain chain = (task, action, request1, listener1) -> {         authenticationSetOnce.set(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).     }.     Task task = mock(Task.class).     final boolean hasExistingAuthentication = randomBoolean().     final String action = "internal:foo".     if (hasExistingAuthentication) {         threadContext.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication).         threadContext.putHeader(AuthenticationField.AUTHENTICATION_KEY, "foo").         threadContext.putTransient(AuthorizationService.ORIGINATING_ACTION_KEY, "indices:foo").     } else {         assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).     }     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).         return Void.TYPE.     }).when(authcService).authenticate(eq(action), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class)).     doAnswer((i) -> {         ActionListener<Void> callback = (ActionListener<Void>) i.getArguments()[3].         callback.onResponse(null).         return Void.TYPE.     }).when(authzService).authorize(any(Authentication.class), any(String.class), any(TransportRequest.class), any(ActionListener.class)).     filter.apply(task, action, request, listener, chain).     if (hasExistingAuthentication) {         assertEquals(authentication, threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).     } else {         assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY)).     }     assertNotNull(authenticationSetOnce.get()).     assertNotEquals(authentication, authenticationSetOnce.get()).     assertEquals(SystemUser.INSTANCE, authenticationSetOnce.get().getUser()). }
false;public;0;31;;public void testApplyDestructiveOperations() throws Exception {     ActionRequest request = new MockIndicesRequest(IndicesOptions.fromOptions(randomBoolean(), randomBoolean(), randomBoolean(), randomBoolean()), randomFrom("*", "_all", "test*")).     String action = randomFrom(CloseIndexAction.NAME, OpenIndexAction.NAME, DeleteIndexAction.NAME).     ActionListener listener = mock(ActionListener.class).     ActionFilterChain chain = mock(ActionFilterChain.class).     Task task = mock(Task.class).     User user = new User("username", "r1", "r2").     Authentication authentication = new Authentication(user, new RealmRef("test", "test", "foo"), null).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq(action), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class)).     doAnswer((i) -> {         ActionListener<Void> callback = (ActionListener<Void>) i.getArguments()[3].         callback.onResponse(null).         return Void.TYPE.     }).when(authzService).authorize(any(Authentication.class), any(String.class), any(TransportRequest.class), any(ActionListener.class)).     filter.apply(task, action, request, listener, chain).     if (failDestructiveOperations) {         verify(listener).onFailure(isA(IllegalArgumentException.class)).         verifyNoMoreInteractions(authzService, chain).     } else {         verify(authzService).authorize(eq(authentication), eq(action), eq(request), any(ActionListener.class)).         verify(chain).proceed(eq(task), eq(action), eq(request), isA(ContextPreservingActionListener.class)).     } }
false;public;0;19;;public void testActionProcessException() throws Exception {     ActionRequest request = mock(ActionRequest.class).     ActionListener listener = mock(ActionListener.class).     ActionFilterChain chain = mock(ActionFilterChain.class).     RuntimeException exception = new RuntimeException("process-error").     Task task = mock(Task.class).     User user = new User("username", "r1", "r2").     Authentication authentication = new Authentication(user, new RealmRef("test", "test", "foo"), null).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq("_action"), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class)).     doThrow(exception).when(authzService).authorize(eq(authentication), eq("_action"), eq(request), any(ActionListener.class)).     filter.apply(task, "_action", request, listener, chain).     verify(listener).onFailure(exception).     verifyNoMoreInteractions(chain). }
false;public;0;11;;public void testApplyUnlicensed() throws Exception {     ActionRequest request = mock(ActionRequest.class).     ActionListener listener = mock(ActionListener.class).     ActionFilterChain chain = mock(ActionFilterChain.class).     Task task = mock(Task.class).     when(licenseState.isAuthAllowed()).thenReturn(false).     filter.apply(task, "_action", request, listener, chain).     verifyZeroInteractions(authcService).     verifyZeroInteractions(authzService).     verify(chain).proceed(eq(task), eq("_action"), eq(request), eq(listener)). }
