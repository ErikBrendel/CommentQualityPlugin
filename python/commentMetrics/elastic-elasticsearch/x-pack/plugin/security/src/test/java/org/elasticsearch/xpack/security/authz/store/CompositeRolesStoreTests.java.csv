# id;timestamp;commentText;codeText;commentWords;codeWords
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1524684173;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        Role role = CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache)___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,role,role,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1526029249;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        Role role = CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache)___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,role,role,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1528762805;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        Role role = CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache)___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,role,role,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1532069817;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        Role role = CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache)___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,role,role,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1532456624;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1538067637;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1539723533;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1548088793;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1548110080;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1548146117;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1549336917;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls =_                role.indices().authorize("indices:data/read/search", Collections.singleton("test"), metaData, cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1549399169;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls = role.indices().authorize("indices:data/read/search",_            Collections.singleton("test"), metaData.getAliasAndIndexLookup(), cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,get,alias,and,index,lookup,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
CompositeRolesStoreTests -> public void testMergingRolesWithFls();1551160396;This test is a direct result of a issue where field level security permissions were not_being merged correctly. The improper merging resulted in an allow all result when merging_permissions from different roles instead of properly creating a union of their languages;public void testMergingRolesWithFls() {_        RoleDescriptor flsRole = new RoleDescriptor("fls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .grantedFields("*")_                        .deniedFields("L1.*", "L2.*")_                        .indices("*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        RoleDescriptor addsL1Fields = new RoleDescriptor("dls", null, new IndicesPrivileges[] {_                IndicesPrivileges.builder()_                        .indices("*")_                        .grantedFields("L1.*")_                        .privileges("read")_                        .query("{ \"match\": {\"eventType.typeCode\": \"foo\"} }")_                        .build()_        }, null)__        FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY)__        PlainActionFuture<Role> future = new PlainActionFuture<>()__        CompositeRolesStore.buildRoleFromDescriptors(Sets.newHashSet(flsRole, addsL1Fields), cache, null, future)__        Role role = future.actionGet()___        MetaData metaData = MetaData.builder()_                .put(new IndexMetaData.Builder("test")_                        .settings(Settings.builder().put("index.version.created", Version.CURRENT).build())_                        .numberOfShards(1).numberOfReplicas(0).build(), true)_                .build()__        Map<String, IndicesAccessControl.IndexAccessControl> acls = role.indices().authorize("indices:data/read/search",_            Collections.singleton("test"), metaData.getAliasAndIndexLookup(), cache)__        assertFalse(acls.isEmpty())__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L1.foo"))__        assertFalse(acls.get("test").getFieldPermissions().grantsAccessTo("L2.foo"))__        assertTrue(acls.get("test").getFieldPermissions().grantsAccessTo("L3.foo"))__    };this,test,is,a,direct,result,of,a,issue,where,field,level,security,permissions,were,not,being,merged,correctly,the,improper,merging,resulted,in,an,allow,all,result,when,merging,permissions,from,different,roles,instead,of,properly,creating,a,union,of,their,languages;public,void,test,merging,roles,with,fls,role,descriptor,fls,role,new,role,descriptor,fls,null,new,indices,privileges,indices,privileges,builder,granted,fields,denied,fields,l1,l2,indices,privileges,read,query,match,event,type,type,code,foo,build,null,role,descriptor,adds,l1fields,new,role,descriptor,dls,null,new,indices,privileges,indices,privileges,builder,indices,granted,fields,l1,privileges,read,query,match,event,type,type,code,foo,build,null,field,permissions,cache,cache,new,field,permissions,cache,settings,empty,plain,action,future,role,future,new,plain,action,future,composite,roles,store,build,role,from,descriptors,sets,new,hash,set,fls,role,adds,l1fields,cache,null,future,role,role,future,action,get,meta,data,meta,data,meta,data,builder,put,new,index,meta,data,builder,test,settings,settings,builder,put,index,version,created,version,current,build,number,of,shards,1,number,of,replicas,0,build,true,build,map,string,indices,access,control,index,access,control,acls,role,indices,authorize,indices,data,read,search,collections,singleton,test,meta,data,get,alias,and,index,lookup,cache,assert,false,acls,is,empty,assert,true,acls,get,test,get,field,permissions,grants,access,to,l1,foo,assert,false,acls,get,test,get,field,permissions,grants,access,to,l2,foo,assert,true,acls,get,test,get,field,permissions,grants,access,to,l3,foo
