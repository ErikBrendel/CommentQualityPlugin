commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;45;;@Override protected Settings nodeSettings(int nodeOrdinal) {     final Settings settings.     try {         final String samlIdpEntityId = "urn:idp:entity".         final Path samlIdpPath = createTempFile("idp", "xml").         SamlRealmTestHelper.writeIdpMetaData(samlIdpPath, samlIdpEntityId).         final Path kerbKeyTab = createTempFile("es", "keytab").         KerberosRealmTestCase.writeKeyTab(kerbKeyTab, null).         settings = Settings.builder().put(super.nodeSettings(nodeOrdinal).filter(s -> s.startsWith("xpack.security.authc.realms.") == false)).put("xpack.security.authc.token.enabled", true).put("xpack.security.authc.realms.file.file1.order", 1).put("xpack.security.authc.realms.native.native1.order", 2).put("xpack.security.authc.realms.ldap.ldap1.order", 3).put("xpack.security.authc.realms.ldap.ldap1.url", "ldap://127.0.0.1:389").put("xpack.security.authc.realms.ldap.ldap1.user_dn_templates", "cn={0},dc=example,dc=com").put("xpack.security.authc.realms.active_directory.ad1.order", 4).put("xpack.security.authc.realms.active_directory.ad1.url", "ldap://127.0.0.1:389").put("xpack.security.authc.realms.pki.pki1.order", 5).put("xpack.security.authc.realms.saml.saml1.order", 6).put("xpack.security.authc.realms.saml.saml1.idp.metadata.path", samlIdpPath.toAbsolutePath()).put("xpack.security.authc.realms.saml.saml1.idp.entity_id", samlIdpEntityId).put("xpack.security.authc.realms.saml.saml1.sp.entity_id", "urn:sp:entity").put("xpack.security.authc.realms.saml.saml1.sp.acs", "http://localhost/acs").put("xpack.security.authc.realms.saml.saml1.attributes.principal", "uid").put("xpack.security.authc.realms.kerberos.kerb1.order", 7).put("xpack.security.authc.realms.kerberos.kerb1.keytab.path", kerbKeyTab.toAbsolutePath()).build().     } catch (IOException e) {         throw new RuntimeException(e).     }     final Set<String> configuredRealmTypes = RealmSettings.getRealmSettings(settings).keySet().stream().map(RealmConfig.RealmIdentifier::getType).collect(Collectors.toSet()).     assertThat("One or more realm type are not configured " + configuredRealmTypes, configuredRealmTypes, Matchers.containsInAnyOrder(InternalRealms.getConfigurableRealmsTypes().toArray(Strings.EMPTY_ARRAY))).     return settings. }
true;public,static;0;13;/**  * Some realms (currently only SAML, but maybe more in the future) hold on to resources that may need to be explicitly closed.  */ ;/**  * Some realms (currently only SAML, but maybe more in the future) hold on to resources that may need to be explicitly closed.  */ @AfterClass public static void closeRealms() throws IOException {     final Logger logger = LogManager.getLogger(SecurityRealmSettingsTests.class).     final Iterable<Realms> realms = internalCluster().getInstances(Realms.class).     for (Realms rx : realms) {         for (Realm r : rx) {             if (r instanceof Closeable) {                 logger.info("Closing realm [{}] [{} @ {}]", r, r.getClass().getSimpleName(), System.identityHashCode(r)).                 ((Closeable) r).close().             }         }     } }
true;protected;0;3;/**  * Always enable transport SSL so that it is possible to have a PKI Realm  */ ;/**  * Always enable transport SSL so that it is possible to have a PKI Realm  */ protected boolean transportSSLEnabled() {     return true. }
false;public;0;8;;public void testClusterStarted() {     final AuthenticateRequest request = new AuthenticateRequest().     request.username(nodeClientUsername()).     final AuthenticateResponse authenticate = client().execute(AuthenticateAction.INSTANCE, request).actionGet(10, TimeUnit.SECONDS).     assertThat(authenticate.authentication(), notNullValue()).     assertThat(authenticate.authentication().getUser(), notNullValue()).     assertThat(authenticate.authentication().getUser().enabled(), is(true)). }
