commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@BeforeClass public static void init() throws Exception {     roles = new String[randomIntBetween(5, 10)].     for (int i = 0. i < roles.length. i++) {         roles[i] = randomAlphaOfLength(6) + "_" + i.     } }
false;public;0;23;;@Before public void setupForTests() {     SecurityClient c = securityClient().     // create roles     for (String role : roles) {         c.preparePutRole(role).cluster("none").addIndices(new String[] { "*" }, new String[] { "ALL" }, null, null, null, randomBoolean()).get().         logger.debug("--> created role [{}]", role).     }     ensureGreen(SecurityIndexManager.SECURITY_INDEX_NAME).     final Set<String> rolesSet = new HashSet<>(Arrays.asList(roles)).     // warm up the caches on every node     for (NativeRolesStore rolesStore : internalCluster().getInstances(NativeRolesStore.class)) {         PlainActionFuture<RoleRetrievalResult> future = new PlainActionFuture<>().         rolesStore.getRoleDescriptors(rolesSet, future).         assertThat(future.actionGet(), notNullValue()).         assertTrue(future.actionGet().isSuccess()).     } }
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;public;0;20;;public void testModifyingViaApiClearsCache() throws Exception {     Client client = internalCluster().transportClient().     SecurityClient securityClient = securityClient(client).     int modifiedRolesCount = randomIntBetween(1, roles.length).     List<String> toModify = randomSubsetOf(modifiedRolesCount, roles).     logger.debug("--> modifying roles {} to have run_as", toModify).     for (String role : toModify) {         PutRoleResponse response = securityClient.preparePutRole(role).cluster("none").addIndices(new String[] { "*" }, new String[] { "ALL" }, null, null, null, randomBoolean()).runAs(role).setRefreshPolicy(randomBoolean() ? IMMEDIATE : NONE).get().         assertThat(response.isCreated(), is(false)).         logger.debug("--> updated role [{}] with run_as", role).     }     assertRolesAreCorrect(securityClient, toModify). }
false;public;0;12;;public void testDeletingViaApiClearsCache() throws Exception {     final int rolesToDelete = randomIntBetween(1, roles.length - 1).     List<String> toDelete = randomSubsetOf(rolesToDelete, roles).     for (String role : toDelete) {         DeleteRoleResponse response = securityClient().prepareDeleteRole(role).get().         assertTrue(response.found()).     }     GetRolesResponse roleResponse = securityClient().prepareGetRoles().names(roles).get().     assertTrue(roleResponse.hasRoles()).     assertThat(roleResponse.roles().length, is(roles.length - rolesToDelete)). }
false;private;2;15;;private void assertRolesAreCorrect(SecurityClient securityClient, List<String> toModify) {     for (String role : roles) {         logger.debug("--> getting role [{}]", role).         GetRolesResponse roleResponse = securityClient.prepareGetRoles().names(role).get().         assertThat(roleResponse.hasRoles(), is(true)).         final String[] runAs = roleResponse.roles()[0].getRunAs().         if (toModify.contains(role)) {             assertThat("role [" + role + "] should be modified and have run as", runAs == null || runAs.length == 0, is(false)).             assertThat(Arrays.asList(runAs).contains(role), is(true)).         } else {             assertThat("role [" + role + "] should be cached and not have run as set but does!", runAs == null || runAs.length == 0, is(true)).         }     } }
