commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean addMockHttpTransport() {     // enable http     return false. }
false;protected;1;6;;@Override protected Settings nodeSettings(int nodeOrdinal) {     final Settings.Builder builder = Settings.builder().put(super.nodeSettings(nodeOrdinal)).     addSSLSettingsForNodePEMFiles(builder, "xpack.security.http.", randomBoolean()).     return builder.put("xpack.security.http.ssl.enabled", true).build(). }
false;protected;0;4;;@Override protected boolean transportSSLEnabled() {     return true. }
true;public;0;23;// no SSL exception as this is the exception is returned when connecting ;// no SSL exception as this is the exception is returned when connecting public void testThatUnconfiguredCiphersAreRejected() throws Exception {     Set<String> supportedCiphers = Sets.newHashSet(SSLContext.getDefault().getSupportedSSLParameters().getCipherSuites()).     Set<String> defaultXPackCiphers = Sets.newHashSet(XPackSettings.DEFAULT_CIPHERS).     final List<String> unconfiguredCiphers = new ArrayList<>(Sets.difference(supportedCiphers, defaultXPackCiphers)).     Collections.shuffle(unconfiguredCiphers, random()).     assumeFalse("the unconfigured ciphers list is empty", unconfiguredCiphers.isEmpty()).     try (TransportClient transportClient = new TestXPackTransportClient(Settings.builder().put(transportClientSettings()).put("node.name", "programmatic_transport_client").put("cluster.name", internalCluster().getClusterName()).putList("xpack.security.transport.ssl.cipher_suites", unconfiguredCiphers).build(), LocalStateSecurity.class)) {         TransportAddress transportAddress = randomFrom(internalCluster().getInstance(Transport.class).boundAddress().boundAddresses()).         transportClient.addTransportAddress(transportAddress).         transportClient.admin().cluster().prepareHealth().get().         fail("Expected NoNodeAvailableException").     } catch (NoNodeAvailableException e) {         assertThat(e.getMessage(), containsString("None of the configured nodes are available: [{#transport#")).     } }
false;public;0;18;;public void testThatTransportClientUsingSSLv3ProtocolIsRejected() {     assumeFalse("Can't run in a FIPS JVM as SSLv3 SSLContext not available", inFipsJvm()).     try (TransportClient transportClient = new TestXPackTransportClient(Settings.builder().put(transportClientSettings()).put("node.name", "programmatic_transport_client").put("cluster.name", internalCluster().getClusterName()).putList("xpack.security.transport.ssl.supported_protocols", new String[] { "SSLv3" }).build(), LocalStateSecurity.class)) {         TransportAddress transportAddress = randomFrom(internalCluster().getInstance(Transport.class).boundAddress().boundAddresses()).         transportClient.addTransportAddress(transportAddress).         transportClient.admin().cluster().prepareHealth().get().         fail("Expected NoNodeAvailableException").     } catch (NoNodeAvailableException e) {         assertThat(e.getMessage(), containsString("None of the configured nodes are available: [{#transport#")).     } }
false;public;0;24;;public void testThatConnectionToHTTPWorks() throws Exception {     Settings.Builder builder = Settings.builder().     addSSLSettingsForPEMFiles(builder, "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.pem", "testclient", "/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testclient.crt", "xpack.security.http.", Arrays.asList("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.crt")).     SSLService service = new SSLService(builder.build(), null).     CredentialsProvider provider = new BasicCredentialsProvider().     provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(nodeClientUsername(), new String(nodeClientPassword().getChars()))).     SSLConfiguration sslConfiguration = service.getSSLConfiguration("xpack.security.http.ssl").     try (CloseableHttpClient client = HttpClients.custom().setSSLSocketFactory(new SSLConnectionSocketFactory(service.sslSocketFactory(sslConfiguration), SSLConnectionSocketFactory.getDefaultHostnameVerifier())).setDefaultCredentialsProvider(provider).build().         CloseableHttpResponse response = SocketAccess.doPrivileged(() -> client.execute(new HttpGet(getNodeUrl())))) {         assertThat(response.getStatusLine().getStatusCode(), is(200)).         String data = Streams.copyToString(new InputStreamReader(response.getEntity().getContent(), StandardCharsets.UTF_8)).         assertThat(data, containsString("You Know, for Search")).     } }
false;public;0;13;;public void testThatHttpUsingSSLv3IsRejected() throws Exception {     assumeFalse("Can't run in a FIPS JVM as we can't even get an instance of SSL SSL Context", inFipsJvm()).     SSLContext sslContext = SSLContext.getInstance("SSL").     TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).     factory.init((KeyStore) null).     sslContext.init(null, factory.getTrustManagers(), new SecureRandom()).     SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(sslContext, new String[] { "SSLv3" }, null, NoopHostnameVerifier.INSTANCE).     try (CloseableHttpClient client = HttpClients.custom().setSSLSocketFactory(sf).build()) {         expectThrows(SSLHandshakeException.class, () -> SocketAccess.doPrivileged(() -> client.execute(new HttpGet(getNodeUrl())))).     } }
false;private;0;6;;private String getNodeUrl() {     TransportAddress transportAddress = randomFrom(internalCluster().getInstance(HttpServerTransport.class).boundAddress().boundAddresses()).     final InetSocketAddress inetSocketAddress = transportAddress.address().     return String.format(Locale.ROOT, "https://%s/", NetworkAddress.format(inetSocketAddress)). }
