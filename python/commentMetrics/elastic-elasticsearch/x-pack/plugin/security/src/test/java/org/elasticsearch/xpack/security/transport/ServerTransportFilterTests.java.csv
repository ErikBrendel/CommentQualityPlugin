commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Before public void init() throws Exception {     authcService = mock(AuthenticationService.class).     authzService = mock(AuthorizationService.class).     channel = mock(TransportChannel.class).     when(channel.getProfileName()).thenReturn(TransportSettings.DEFAULT_PROFILE).     when(channel.getVersion()).thenReturn(Version.CURRENT).     failDestructiveOperations = randomBoolean().     Settings settings = Settings.builder().put(DestructiveOperations.REQUIRES_NAME_SETTING.getKey(), failDestructiveOperations).build().     destructiveOperations = new DestructiveOperations(settings, new ClusterSettings(settings, Collections.singleton(DestructiveOperations.REQUIRES_NAME_SETTING))). }
false;public;0;17;;public void testInbound() throws Exception {     TransportRequest request = mock(TransportRequest.class).     Authentication authentication = mock(Authentication.class).     when(authentication.getVersion()).thenReturn(Version.CURRENT).     when(authentication.getUser()).thenReturn(SystemUser.INSTANCE).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq("_action"), eq(request), eq((User) null), any(ActionListener.class)).     ServerTransportFilter filter = getClientOrNodeFilter().     PlainActionFuture<Void> future = new PlainActionFuture<>().     filter.inbound("_action", request, channel, future).     // future.get(). // don't block it's not called really just mocked     verify(authzService).authorize(eq(authentication), eq("_action"), eq(request), any(ActionListener.class)). }
false;public;0;24;;public void testInboundDestructiveOperations() throws Exception {     String action = randomFrom(CloseIndexAction.NAME, OpenIndexAction.NAME, DeleteIndexAction.NAME).     TransportRequest request = new MockIndicesRequest(IndicesOptions.fromOptions(randomBoolean(), randomBoolean(), randomBoolean(), randomBoolean()), randomFrom("*", "_all", "test*")).     Authentication authentication = mock(Authentication.class).     when(authentication.getVersion()).thenReturn(Version.CURRENT).     when(authentication.getUser()).thenReturn(SystemUser.INSTANCE).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq(action), eq(request), eq((User) null), any(ActionListener.class)).     ServerTransportFilter filter = getClientOrNodeFilter().     PlainActionFuture listener = mock(PlainActionFuture.class).     filter.inbound(action, request, channel, listener).     if (failDestructiveOperations) {         verify(listener).onFailure(isA(IllegalArgumentException.class)).         verifyNoMoreInteractions(authzService).     } else {         verify(authzService).authorize(eq(authentication), eq(action), eq(request), any(ActionListener.class)).     } }
false;public;0;20;;public void testInboundAuthenticationException() throws Exception {     TransportRequest request = mock(TransportRequest.class).     Exception authE = authenticationError("authc failed").     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onFailure(authE).         return Void.TYPE.     }).when(authcService).authenticate(eq("_action"), eq(request), eq((User) null), any(ActionListener.class)).     ServerTransportFilter filter = getClientOrNodeFilter().     try {         PlainActionFuture<Void> future = new PlainActionFuture<>().         filter.inbound("_action", request, channel, future).         future.actionGet().         fail("expected filter inbound to throw an authentication exception on authentication error").     } catch (ElasticsearchSecurityException e) {         assertThat(e.getMessage(), equalTo("authc failed")).     }     verifyZeroInteractions(authzService). }
false;public;0;21;;public void testInboundAuthorizationException() throws Exception {     ServerTransportFilter filter = getClientOrNodeFilter().     TransportRequest request = mock(TransportRequest.class).     Authentication authentication = mock(Authentication.class).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq("_action"), eq(request), eq((User) null), any(ActionListener.class)).     when(authentication.getVersion()).thenReturn(Version.CURRENT).     when(authentication.getUser()).thenReturn(XPackUser.INSTANCE).     PlainActionFuture<Void> future = new PlainActionFuture<>().     doThrow(authorizationError("authz failed")).when(authzService).authorize(eq(authentication), eq("_action"), eq(request), any(ActionListener.class)).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> {         filter.inbound("_action", request, channel, future).         future.actionGet().     }).     assertThat(e.getMessage(), equalTo("authz failed")). }
false;public;0;12;;public void testClientProfileRejectsNodeActions() throws Exception {     TransportRequest request = mock(TransportRequest.class).     ServerTransportFilter filter = getClientFilter(true).     ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> filter.inbound("internal:foo/bar", request, channel, new PlainActionFuture<>())).     assertEquals("executing internal/shard actions is considered malicious and forbidden", e.getMessage()).     e = expectThrows(ElasticsearchSecurityException.class, () -> filter.inbound("indices:action" + randomFrom("[s]", "[p]", "[r]", "[n]", "[s][p]", "[s][r]", "[f]"), request, channel, new PlainActionFuture<>())).     assertEquals("executing internal/shard actions is considered malicious and forbidden", e.getMessage()).     verifyZeroInteractions(authcService). }
false;public;0;28;;public void testNodeProfileAllowsNodeActions() throws Exception {     final String internalAction = "internal:foo/bar".     final String nodeOrShardAction = "indices:action" + randomFrom("[s]", "[p]", "[r]", "[n]", "[s][p]", "[s][r]", "[f]").     ServerTransportFilter filter = getNodeFilter(true).     TransportRequest request = mock(TransportRequest.class).     Authentication authentication = new Authentication(new User("test", "superuser"), new RealmRef("test", "test", "node1"), null).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq(internalAction), eq(request), eq((User) null), any(ActionListener.class)).     doAnswer((i) -> {         ActionListener callback = (ActionListener) i.getArguments()[3].         callback.onResponse(authentication).         return Void.TYPE.     }).when(authcService).authenticate(eq(nodeOrShardAction), eq(request), eq((User) null), any(ActionListener.class)).     filter.inbound(internalAction, request, channel, new PlainActionFuture<>()).     verify(authcService).authenticate(eq(internalAction), eq(request), eq((User) null), any(ActionListener.class)).     verify(authzService).authorize(eq(authentication), eq(internalAction), eq(request), any(ActionListener.class)).     filter.inbound(nodeOrShardAction, request, channel, new PlainActionFuture<>()).     verify(authcService).authenticate(eq(nodeOrShardAction), eq(request), eq((User) null), any(ActionListener.class)).     verify(authzService).authorize(eq(authentication), eq(nodeOrShardAction), eq(request), any(ActionListener.class)).     verifyNoMoreInteractions(authcService, authzService). }
false;private;0;3;;private ServerTransportFilter getClientOrNodeFilter() throws IOException {     return randomBoolean() ? getNodeFilter(true) : getClientFilter(true). }
false;private;1;6;;private ServerTransportFilter.ClientProfile getClientFilter(boolean reservedRealmEnabled) throws IOException {     Settings settings = Settings.builder().put("path.home", createTempDir()).build().     ThreadContext threadContext = new ThreadContext(settings).     return new ServerTransportFilter.ClientProfile(authcService, authzService, threadContext, false, destructiveOperations, reservedRealmEnabled, new SecurityContext(settings, threadContext), new XPackLicenseState(settings)). }
false;private;1;6;;private ServerTransportFilter.NodeProfile getNodeFilter(boolean reservedRealmEnabled) throws IOException {     Settings settings = Settings.builder().put("path.home", createTempDir()).build().     ThreadContext threadContext = new ThreadContext(settings).     return new ServerTransportFilter.NodeProfile(authcService, authzService, threadContext, false, destructiveOperations, reservedRealmEnabled, new SecurityContext(settings, threadContext), new XPackLicenseState(settings)). }
