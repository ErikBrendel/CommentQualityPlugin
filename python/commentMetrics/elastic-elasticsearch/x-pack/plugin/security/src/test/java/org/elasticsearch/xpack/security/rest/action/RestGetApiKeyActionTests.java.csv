commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public void setUp() throws Exception {     super.setUp().     settings = Settings.builder().put("path.home", createTempDir().toString()).put("node.name", "test-" + getTestName()).put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build().     threadPool = new ThreadPool(settings).     when(mockLicenseState.isSecurityAvailable()).thenReturn(true). }
false;public;0;5;;@Override public void tearDown() throws Exception {     super.tearDown().     terminate(threadPool). }
false;public;1;4;;@Override public void sendResponse(RestResponse restResponse) {     responseSetOnce.set(restResponse). }
false;public;3;23;;@SuppressWarnings("unchecked") @Override public <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request, ActionListener<Response> listener) {     GetApiKeyRequest getApiKeyRequest = (GetApiKeyRequest) request.     ActionRequestValidationException validationException = getApiKeyRequest.validate().     if (validationException != null) {         listener.onFailure(validationException).         return.     }     if (getApiKeyRequest.getApiKeyName() != null && getApiKeyRequest.getApiKeyName().equals("api-key-name-1") || getApiKeyRequest.getApiKeyId() != null && getApiKeyRequest.getApiKeyId().equals("api-key-id-1") || getApiKeyRequest.getRealmName() != null && getApiKeyRequest.getRealmName().equals("realm-1") || getApiKeyRequest.getUserName() != null && getApiKeyRequest.getUserName().equals("user-x")) {         if (replyEmptyResponse) {             listener.onResponse((Response) GetApiKeyResponse.emptyResponse()).         } else {             listener.onResponse((Response) getApiKeyResponseExpected).         }     } else {         listener.onFailure(new ElasticsearchSecurityException("encountered an error while creating API key")).     } }
false;public;0;67;;public void testGetApiKey() throws Exception {     final Map<String, String> param1 = mapBuilder().put("realm_name", "realm-1").put("username", "user-x").map().     final Map<String, String> param2 = mapBuilder().put("realm_name", "realm-1").map().     final Map<String, String> param3 = mapBuilder().put("username", "user-x").map().     final Map<String, String> param4 = mapBuilder().put("id", "api-key-id-1").map().     final Map<String, String> param5 = mapBuilder().put("name", "api-key-name-1").map().     final Map<String, String> params = randomFrom(param1, param2, param3, param4, param5).     final boolean replyEmptyResponse = rarely().     final FakeRestRequest restRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withParams(params).build().     final SetOnce<RestResponse> responseSetOnce = new SetOnce<>().     final RestChannel restChannel = new AbstractRestChannel(restRequest, randomBoolean()) {          @Override         public void sendResponse(RestResponse restResponse) {             responseSetOnce.set(restResponse).         }     }.     final Instant creation = Instant.now().     final Instant expiration = randomFrom(Arrays.asList(null, Instant.now().plus(10, ChronoUnit.DAYS))).     final GetApiKeyResponse getApiKeyResponseExpected = new GetApiKeyResponse(Collections.singletonList(new ApiKey("api-key-name-1", "api-key-id-1", creation, expiration, false, "user-x", "realm-1"))).     try (NodeClient client = new NodeClient(Settings.EMPTY, threadPool) {          @SuppressWarnings("unchecked")         @Override         public <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request, ActionListener<Response> listener) {             GetApiKeyRequest getApiKeyRequest = (GetApiKeyRequest) request.             ActionRequestValidationException validationException = getApiKeyRequest.validate().             if (validationException != null) {                 listener.onFailure(validationException).                 return.             }             if (getApiKeyRequest.getApiKeyName() != null && getApiKeyRequest.getApiKeyName().equals("api-key-name-1") || getApiKeyRequest.getApiKeyId() != null && getApiKeyRequest.getApiKeyId().equals("api-key-id-1") || getApiKeyRequest.getRealmName() != null && getApiKeyRequest.getRealmName().equals("realm-1") || getApiKeyRequest.getUserName() != null && getApiKeyRequest.getUserName().equals("user-x")) {                 if (replyEmptyResponse) {                     listener.onResponse((Response) GetApiKeyResponse.emptyResponse()).                 } else {                     listener.onResponse((Response) getApiKeyResponseExpected).                 }             } else {                 listener.onFailure(new ElasticsearchSecurityException("encountered an error while creating API key")).             }         }     }) {         final RestGetApiKeyAction restGetApiKeyAction = new RestGetApiKeyAction(Settings.EMPTY, mockRestController, mockLicenseState).         restGetApiKeyAction.handleRequest(restRequest, restChannel, client).         final RestResponse restResponse = responseSetOnce.get().         assertNotNull(restResponse).         assertThat(restResponse.status(), (replyEmptyResponse && params.get("id") != null) ? is(RestStatus.NOT_FOUND) : is(RestStatus.OK)).         final GetApiKeyResponse actual = GetApiKeyResponse.fromXContent(createParser(XContentType.JSON.xContent(), restResponse.content())).         if (replyEmptyResponse) {             assertThat(actual.getApiKeyInfos().length, is(0)).         } else {             assertThat(actual.getApiKeyInfos(), arrayContaining(new ApiKey("api-key-name-1", "api-key-id-1", creation, expiration, false, "user-x", "realm-1"))).         }     } }
false;private,static;0;3;;private static MapBuilder<String, String> mapBuilder() {     return MapBuilder.newMapBuilder(). }
