commented;modifiers;parameterAmount;loc;comment;code
false;public;3;48;;public void getPrivileges(Collection<String> applications, Collection<String> names, ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {     final SecurityIndexManager frozenSecurityIndex = securityIndexManager.freeze().     if (frozenSecurityIndex.indexExists() == false) {         listener.onResponse(Collections.emptyList()).     } else if (frozenSecurityIndex.isAvailable() == false) {         listener.onFailure(frozenSecurityIndex.getUnavailableReason()).     } else if (applications != null && applications.size() == 1 && names != null && names.size() == 1) {         getPrivilege(Objects.requireNonNull(Iterables.get(applications, 0)), Objects.requireNonNull(Iterables.get(names, 0)), ActionListener.wrap(privilege -> listener.onResponse(privilege == null ? Collections.emptyList() : Collections.singletonList(privilege)), listener::onFailure)).     } else {         securityIndexManager.checkIndexVersionThenExecute(listener::onFailure, () -> {             final QueryBuilder query.             final TermQueryBuilder typeQuery = QueryBuilders.termQuery(ApplicationPrivilegeDescriptor.Fields.TYPE.getPreferredName(), DOC_TYPE_VALUE).             if (isEmpty(applications) && isEmpty(names)) {                 query = typeQuery.             } else if (isEmpty(names)) {                 query = QueryBuilders.boolQuery().filter(typeQuery).filter(QueryBuilders.termsQuery(ApplicationPrivilegeDescriptor.Fields.APPLICATION.getPreferredName(), applications)).             } else if (isEmpty(applications)) {                 query = QueryBuilders.boolQuery().filter(typeQuery).filter(QueryBuilders.termsQuery(ApplicationPrivilegeDescriptor.Fields.NAME.getPreferredName(), names)).             } else {                 final String[] docIds = applications.stream().flatMap(a -> names.stream().map(n -> toDocId(a, n))).toArray(String[]::new).                 query = QueryBuilders.boolQuery().filter(typeQuery).filter(QueryBuilders.idsQuery("doc").addIds(docIds)).             }             final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false).             try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {                 SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME).setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)).setQuery(query).setSize(1000).setFetchSource(true).request().                 logger.trace(() -> new ParameterizedMessage("Searching for privileges [{}] with query [{}]", names, Strings.toString(query))).                 request.indicesOptions().ignoreUnavailable().                 ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), hit -> buildPrivilege(hit.getId(), hit.getSourceRef())).             }         }).     } }
false;private,static;1;3;;private static boolean isEmpty(Collection<String> collection) {     return collection == null || collection.isEmpty(). }
false;public;1;8;;@Override public void onResponse(GetResponse response) {     if (response.isExists()) {         listener.onResponse(buildPrivilege(response.getId(), response.getSourceAsBytesRef())).     } else {         listener.onResponse(null).     } }
false;public;1;11;;@Override public void onFailure(Exception e) {     // if the index or the shard is not there / available we just claim the privilege is not there     if (TransportActions.isShardNotAvailableException(e)) {         logger.warn(new ParameterizedMessage("failed to load privilege [{}] index not available", name), e).         listener.onResponse(null).     } else {         logger.error(new ParameterizedMessage("failed to load privilege [{}]", name), e).         listener.onFailure(e).     } }
false;;3;35;;void getPrivilege(String application, String name, ActionListener<ApplicationPrivilegeDescriptor> listener) {     final SecurityIndexManager frozenSecurityIndex = securityIndexManager.freeze().     if (frozenSecurityIndex.isAvailable() == false) {         logger.warn(new ParameterizedMessage("failed to load privilege [{}] index not available", name), frozenSecurityIndex.getUnavailableReason()).         listener.onResponse(null).     } else {         securityIndexManager.checkIndexVersionThenExecute(listener::onFailure, () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareGet(SECURITY_INDEX_NAME, "doc", toDocId(application, name)).request(), new ActionListener<GetResponse>() {              @Override             public void onResponse(GetResponse response) {                 if (response.isExists()) {                     listener.onResponse(buildPrivilege(response.getId(), response.getSourceAsBytesRef())).                 } else {                     listener.onResponse(null).                 }             }              @Override             public void onFailure(Exception e) {                 // if the index or the shard is not there / available we just claim the privilege is not there                 if (TransportActions.isShardNotAvailableException(e)) {                     logger.warn(new ParameterizedMessage("failed to load privilege [{}] index not available", name), e).                     listener.onResponse(null).                 } else {                     logger.error(new ParameterizedMessage("failed to load privilege [{}]", name), e).                     listener.onFailure(e).                 }             }         }, client::get)).     } }
false;public;3;17;;public void putPrivileges(Collection<ApplicationPrivilegeDescriptor> privileges, WriteRequest.RefreshPolicy refreshPolicy, ActionListener<Map<String, List<String>>> listener) {     securityIndexManager.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {         ActionListener<IndexResponse> groupListener = new GroupedActionListener<>(ActionListener.wrap((Collection<IndexResponse> responses) -> {             final Map<String, List<String>> createdNames = responses.stream().filter(r -> r.getResult() == DocWriteResponse.Result.CREATED).map(r -> r.getId()).map(NativePrivilegeStore::nameFromDocId).collect(TUPLES_TO_MAP).             clearRolesCache(listener, createdNames).         }, listener::onFailure), privileges.size(), Collections.emptyList()).         for (ApplicationPrivilegeDescriptor privilege : privileges) {             innerPutPrivilege(privilege, refreshPolicy, groupListener).         }     }). }
false;private;3;16;;private void innerPutPrivilege(ApplicationPrivilegeDescriptor privilege, WriteRequest.RefreshPolicy refreshPolicy, ActionListener<IndexResponse> listener) {     try {         final String name = privilege.getName().         final XContentBuilder xContentBuilder = privilege.toXContent(jsonBuilder(), true).         ClientHelper.executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareIndex(SECURITY_INDEX_NAME, "doc", toDocId(privilege.getApplication(), name)).setSource(xContentBuilder).setRefreshPolicy(refreshPolicy).request(), listener, client::index).     } catch (Exception e) {         logger.warn("Failed to put privilege {} - {}", Strings.toString(privilege), e.toString()).         listener.onFailure(e).     } }
false;public;4;27;;public void deletePrivileges(String application, Collection<String> names, WriteRequest.RefreshPolicy refreshPolicy, ActionListener<Map<String, List<String>>> listener) {     final SecurityIndexManager frozenSecurityIndex = securityIndexManager.freeze().     if (frozenSecurityIndex.indexExists() == false) {         listener.onResponse(Collections.emptyMap()).     } else if (frozenSecurityIndex.isAvailable() == false) {         listener.onFailure(frozenSecurityIndex.getUnavailableReason()).     } else {         securityIndexManager.checkIndexVersionThenExecute(listener::onFailure, () -> {             ActionListener<DeleteResponse> groupListener = new GroupedActionListener<>(ActionListener.wrap(responses -> {                 final Map<String, List<String>> deletedNames = responses.stream().filter(r -> r.getResult() == DocWriteResponse.Result.DELETED).map(r -> r.getId()).map(NativePrivilegeStore::nameFromDocId).collect(TUPLES_TO_MAP).                 clearRolesCache(listener, deletedNames).             }, listener::onFailure), names.size(), Collections.emptyList()).             for (String name : names) {                 ClientHelper.executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareDelete(SECURITY_INDEX_NAME, "doc", toDocId(application, name)).setRefreshPolicy(refreshPolicy).request(), groupListener, client::delete).             }         }).     } }
false;public;1;4;;@Override public void onResponse(ClearRolesCacheResponse nodes) {     listener.onResponse(value). }
false;public;1;6;;@Override public void onFailure(Exception e) {     logger.error("unable to clear role cache", e).     listener.onFailure(new ElasticsearchException("clearing the role cache failed. please clear the role cache manually", e)). }
false;private;2;18;;private <T> void clearRolesCache(ActionListener<T> listener, T value) {     // This currently clears _all_ roles, but could be improved to clear only those roles that reference the affected application     ClearRolesCacheRequest request = new ClearRolesCacheRequest().     executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request, new ActionListener<ClearRolesCacheResponse>() {          @Override         public void onResponse(ClearRolesCacheResponse nodes) {             listener.onResponse(value).         }          @Override         public void onFailure(Exception e) {             logger.error("unable to clear role cache", e).             listener.onFailure(new ElasticsearchException("clearing the role cache failed. please clear the role cache manually", e)).         }     }, securityClient::clearRolesCache). }
false;private;2;24;;private ApplicationPrivilegeDescriptor buildPrivilege(String docId, BytesReference source) {     logger.trace("Building privilege from [{}] [{}]", docId, source == null ? "<<null>>" : source.utf8ToString()).     if (source == null) {         return null.     }     final Tuple<String, String> name = nameFromDocId(docId).     try {         try (StreamInput input = source.streamInput().             XContentParser parser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, input)) {             final ApplicationPrivilegeDescriptor privilege = ApplicationPrivilegeDescriptor.parse(parser, null, null, true).             assert privilege.getApplication().equals(name.v1()) : "Incorrect application name for privilege. Expected [" + name.v1() + "] but was " + privilege.getApplication().             assert privilege.getName().equals(name.v2()) : "Incorrect name for application privilege. Expected [" + name.v2() + "] but was " + privilege.getName().             return privilege.         }     } catch (IOException | XContentParseException e) {         logger.error(new ParameterizedMessage("cannot parse application privilege [{}]", name), e).         return null.     } }
false;private,static;1;7;;private static Tuple<String, String> nameFromDocId(String docId) {     final String name = docId.substring(DOC_TYPE_VALUE.length() + 1).     assert name != null && name.length() > 0 : "Invalid name '" + name + "'".     final int colon = name.indexOf(':').     assert colon > 0 : "Invalid name '" + name + "' (missing colon)".     return new Tuple<>(name.substring(0, colon), name.substring(colon + 1)). }
false;private,static;2;3;;private static String toDocId(String application, String name) {     return DOC_TYPE_VALUE + "_" + application + ":" + name. }
