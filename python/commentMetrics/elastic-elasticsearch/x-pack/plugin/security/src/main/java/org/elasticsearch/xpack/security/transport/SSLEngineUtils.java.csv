commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;4;;public static void extractClientCertificates(Logger logger, ThreadContext threadContext, HttpChannel httpChannel) {     SSLEngine sslEngine = getSSLEngine(httpChannel).     extract(logger, threadContext, sslEngine, httpChannel). }
false;public,static;3;4;;public static void extractClientCertificates(Logger logger, ThreadContext threadContext, TcpChannel tcpChannel) {     SSLEngine sslEngine = getSSLEngine(tcpChannel).     extract(logger, threadContext, sslEngine, tcpChannel). }
false;public,static;1;14;;public static SSLEngine getSSLEngine(HttpChannel httpChannel) {     if (httpChannel instanceof Netty4HttpChannel) {         Channel nettyChannel = ((Netty4HttpChannel) httpChannel).getNettyChannel().         SslHandler handler = nettyChannel.pipeline().get(SslHandler.class).         assert handler != null : "Must have SslHandler".         return handler.engine().     } else if (httpChannel instanceof NioHttpChannel) {         SocketChannelContext context = ((NioHttpChannel) httpChannel).getContext().         assert context instanceof SSLChannelContext : "Must be SSLChannelContext.class, found:  " + context.getClass().         return ((SSLChannelContext) context).getSSLEngine().     } else {         throw new AssertionError("Unknown channel class type: " + httpChannel.getClass()).     } }
false;public,static;1;20;;public static SSLEngine getSSLEngine(TcpChannel tcpChannel) {     if (tcpChannel instanceof Netty4TcpChannel) {         Channel nettyChannel = ((Netty4TcpChannel) tcpChannel).getNettyChannel().         SslHandler handler = nettyChannel.pipeline().get(SslHandler.class).         if (handler == null) {             if (nettyChannel.isOpen()) {                 assert false : "Must have SslHandler".             } else {                 throw new ChannelException("Channel is closed.").             }         }         return handler.engine().     } else if (tcpChannel instanceof NioTcpChannel) {         SocketChannelContext context = ((NioTcpChannel) tcpChannel).getContext().         assert context instanceof SSLChannelContext : "Must be SSLChannelContext.class, found:  " + context.getClass().         return ((SSLChannelContext) context).getSSLEngine().     } else {         throw new AssertionError("Unknown channel class type: " + tcpChannel.getClass()).     } }
false;private,static;4;20;;private static void extract(Logger logger, ThreadContext threadContext, SSLEngine sslEngine, Object channel) {     try {         Certificate[] certs = sslEngine.getSession().getPeerCertificates().         if (certs instanceof X509Certificate[]) {             threadContext.putTransient(PkiRealm.PKI_CERT_HEADER_NAME, certs).         }     } catch (SSLPeerUnverifiedException e) {         // authentication was required then this connection should be closed before ever getting into this class         assert sslEngine.getNeedClientAuth() == false.         assert sslEngine.getWantClientAuth().         if (logger.isTraceEnabled()) {             logger.trace((Supplier<?>) () -> new ParameterizedMessage("SSL Peer did not present a certificate on channel [{}]", channel), e).         } else if (logger.isDebugEnabled()) {             logger.debug("SSL Peer did not present a certificate on channel [{}]", channel).         }     } }
