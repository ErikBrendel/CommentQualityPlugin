commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<Realm> getRealms() {     return Collections.unmodifiableList(realms). }
false;public;0;3;;public boolean hasRealms() {     return realms.isEmpty() == false. }
true;public;2;19;/**  * Lookup the {@code principal} in the list of {@link #realms}.  * The realms are consulted in order. When one realm responds with a non-null {@link User}, this  * is returned with the matching realm, through the {@code listener}.  * If no user if found (including the case where the {@link #realms} list is empty), then  * {@link ActionListener#onResponse(Object)} is called with a {@code null} {@link Tuple}.  */ ;/**  * Lookup the {@code principal} in the list of {@link #realms}.  * The realms are consulted in order. When one realm responds with a non-null {@link User}, this  * is returned with the matching realm, through the {@code listener}.  * If no user if found (including the case where the {@link #realms} list is empty), then  * {@link ActionListener#onResponse(Object)} is called with a {@code null} {@link Tuple}.  */ public void lookup(String principal, ActionListener<Tuple<User, Realm>> listener) {     final IteratingActionListener<Tuple<User, Realm>, ? extends Realm> userLookupListener = new IteratingActionListener<>(listener, (realm, lookupUserListener) -> realm.lookupUser(principal, ActionListener.wrap(foundUser -> {         if (foundUser != null) {             lookupUserListener.onResponse(new Tuple<>(foundUser, realm)).         } else {             lookupUserListener.onResponse(null).         }     }, lookupUserListener::onFailure)), realms, threadContext).     try {         userLookupListener.run().     } catch (Exception e) {         listener.onFailure(e).     } }
