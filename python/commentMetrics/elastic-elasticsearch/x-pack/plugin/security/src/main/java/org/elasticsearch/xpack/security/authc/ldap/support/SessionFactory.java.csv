commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;3;2;/**  * Authenticates the given user and opens a new connection that bound to it (meaning, all  * operations under the returned connection will be executed on behalf of the authenticated  * user.  *  * @param user     The name of the user to authenticate the connection with.  * @param password The password of the user  * @param listener the listener to call on a failure or result  */ ;/**  * Authenticates the given user and opens a new connection that bound to it (meaning, all  * operations under the returned connection will be executed on behalf of the authenticated  * user.  *  * @param user     The name of the user to authenticate the connection with.  * @param password The password of the user  * @param listener the listener to call on a failure or result  */ public abstract void session(String user, SecureString password, ActionListener<LdapSession> listener).
true;public;0;3;/**  * Returns a flag to indicate if this session factory supports unauthenticated sessions.  * This means that a session can be established without providing any credentials in a call to  * {@link #unauthenticatedSession(String, ActionListener)}  *  * @return true if the factory supports unauthenticated sessions  */ ;/**  * Returns a flag to indicate if this session factory supports unauthenticated sessions.  * This means that a session can be established without providing any credentials in a call to  * {@link #unauthenticatedSession(String, ActionListener)}  *  * @return true if the factory supports unauthenticated sessions  */ public boolean supportsUnauthenticatedSession() {     return false. }
true;public;2;3;/**  * Returns an {@link LdapSession} for the user identified by the String parameter  *  * @param username the identifier for the user  * @param listener the listener to call on a failure or result  */ ;/**  * Returns an {@link LdapSession} for the user identified by the String parameter  *  * @param username the identifier for the user  * @param listener the listener to call on a failure or result  */ public void unauthenticatedSession(String username, ActionListener<LdapSession> listener) {     throw new UnsupportedOperationException("unauthenticated sessions are not supported"). }
false;protected,static;3;38;;protected static LDAPConnectionOptions connectionOptions(RealmConfig config, SSLService sslService, Logger logger) {     LDAPConnectionOptions options = new LDAPConnectionOptions().     options.setConnectTimeoutMillis(Math.toIntExact(config.getSetting(SessionFactorySettings.TIMEOUT_TCP_CONNECTION_SETTING).millis())).     options.setFollowReferrals(config.getSetting(SessionFactorySettings.FOLLOW_REFERRALS_SETTING)).     options.setResponseTimeoutMillis(config.getSetting(SessionFactorySettings.TIMEOUT_TCP_READ_SETTING).millis()).     options.setAllowConcurrentSocketFactoryUse(true).     final boolean verificationModeExists = config.hasSetting(SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM).     final boolean hostnameVerificationExists = config.hasSetting(SessionFactorySettings.HOSTNAME_VERIFICATION_SETTING).     if (verificationModeExists && hostnameVerificationExists) {         throw new IllegalArgumentException("[" + RealmSettings.getFullSettingKey(config, SessionFactorySettings.HOSTNAME_VERIFICATION_SETTING) + "] and [" + RealmSettings.getFullSettingKey(config, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM) + "] may not be used at the same time").     } else if (verificationModeExists) {         final String sslKey = RealmSettings.realmSslPrefix(config.identifier()).         final SSLConfiguration sslConfiguration = sslService.getSSLConfiguration(sslKey).         if (sslConfiguration == null) {             throw new IllegalStateException("cannot find SSL configuration for " + sslKey).         }         if (sslConfiguration.verificationMode().isHostnameVerificationEnabled()) {             options.setSSLSocketVerifier(new HostNameSSLSocketVerifier(true)).         }     } else if (hostnameVerificationExists) {         new DeprecationLogger(logger).deprecated("the setting [{}] has been deprecated and " + "will be removed in a future version. use [{}] instead", RealmSettings.getFullSettingKey(config, SessionFactorySettings.HOSTNAME_VERIFICATION_SETTING), RealmSettings.getFullSettingKey(config, SSLConfigurationSettings.VERIFICATION_MODE_SETTING_REALM)).         if (config.getSetting(SessionFactorySettings.HOSTNAME_VERIFICATION_SETTING)) {             options.setSSLSocketVerifier(new HostNameSSLSocketVerifier(true)).         }     } else {         options.setSSLSocketVerifier(new HostNameSSLSocketVerifier(true)).     }     return options. }
false;private;1;9;;private LDAPServers ldapServers(RealmConfig config) {     // Parse LDAP urls     List<String> ldapUrls = config.getSetting(SessionFactorySettings.URLS_SETTING, () -> getDefaultLdapUrls(config)).     if (ldapUrls == null || ldapUrls.isEmpty()) {         throw new IllegalArgumentException("missing required LDAP setting [" + RealmSettings.getFullSettingKey(config, SessionFactorySettings.URLS_SETTING) + "]").     }     return new LDAPServers(ldapUrls.toArray(new String[ldapUrls.size()])). }
false;protected;1;3;;protected List<String> getDefaultLdapUrls(RealmConfig config) {     return null. }
false;private;3;16;;private ServerSet serverSet(RealmConfig realmConfig, SSLService clientSSLService, LDAPServers ldapServers) {     SocketFactory socketFactory = null.     if (ldapServers.ssl()) {         final String sslKey = RealmSettings.realmSslPrefix(config.identifier()).         final SSLConfiguration ssl = clientSSLService.getSSLConfiguration(sslKey).         socketFactory = clientSSLService.sslSocketFactory(ssl).         if (ssl.verificationMode().isHostnameVerificationEnabled()) {             logger.debug("using encryption for LDAP connections with hostname verification").         } else {             logger.debug("using encryption for LDAP connections without hostname verification").         }     }     return LdapLoadBalancing.serverSet(ldapServers.addresses(), ldapServers.ports(), realmConfig, socketFactory, connectionOptions(realmConfig, sslService, logger)). }
true;;0;3;// package private to use for testing ;// package private to use for testing ServerSet getServerSet() {     return serverSet. }
false;public;0;3;;public boolean isSslUsed() {     return sslUsed. }
false;public;0;3;;public String[] addresses() {     return addresses. }
false;public;0;3;;public int[] ports() {     return ports. }
false;public;0;3;;public boolean ssl() {     return ssl. }
true;private;1;19;/**  * @param ldapUrls URLS in the form of "ldap://..." or "ldaps://..."  */ ;/**  * @param ldapUrls URLS in the form of "ldap://..." or "ldaps://..."  */ private boolean secureUrls(String[] ldapUrls) {     if (ldapUrls.length == 0) {         return true.     }     final boolean allSecure = Arrays.stream(ldapUrls).allMatch(s -> STARTS_WITH_LDAPS.matcher(s).find()).     final boolean allClear = Arrays.stream(ldapUrls).allMatch(s -> STARTS_WITH_LDAP.matcher(s).find()).     if (!allSecure && !allClear) {         // No mixing is allowed because we use the same socketfactory         throw new IllegalArgumentException("configured LDAP protocols are not all equal (ldaps://.. and ldap://..): [" + Strings.arrayToCommaDelimitedString(ldapUrls) + "]").     }     return allSecure. }
