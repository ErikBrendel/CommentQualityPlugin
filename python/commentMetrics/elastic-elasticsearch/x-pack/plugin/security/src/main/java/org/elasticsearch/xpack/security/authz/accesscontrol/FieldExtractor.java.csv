commented;modifiers;parameterAmount;loc;comment;code
true;static;2;65;/**  * Populates {@code fields} with the set of fields used by the query, or throws  * UnsupportedOperationException if it doesn't know how to do this.  */ ;/**  * Populates {@code fields} with the set of fields used by the query, or throws  * UnsupportedOperationException if it doesn't know how to do this.  */ static void extractFields(Query query, Set<String> fields) throws UnsupportedOperationException {     // NOTE: we expect a rewritten query, so we only need logic for "atomic" queries here:     if (query instanceof BooleanQuery) {         // extract from all clauses         BooleanQuery q = (BooleanQuery) query.         for (BooleanClause clause : q.clauses()) {             extractFields(clause.getQuery(), fields).         }     } else if (query instanceof DisjunctionMaxQuery) {         // extract from all clauses         DisjunctionMaxQuery q = (DisjunctionMaxQuery) query.         for (Query clause : q.getDisjuncts()) {             extractFields(clause, fields).         }     } else if (query instanceof SpanTermQuery) {         // we just do SpanTerm, other spans are trickier, they could contain         // the evil FieldMaskingSpanQuery: so SpanQuery.getField cannot be trusted.         fields.add(((SpanTermQuery) query).getField()).     } else if (query instanceof TermQuery) {         fields.add(((TermQuery) query).getTerm().field()).     } else if (query instanceof SynonymQuery) {         SynonymQuery q = (SynonymQuery) query.         // all terms must have the same field         fields.add(q.getTerms().get(0).field()).     } else if (query instanceof PhraseQuery) {         PhraseQuery q = (PhraseQuery) query.         // all terms must have the same field         fields.add(q.getTerms()[0].field()).     } else if (query instanceof MultiPhraseQuery) {         MultiPhraseQuery q = (MultiPhraseQuery) query.         // all terms must have the same field         fields.add(q.getTermArrays()[0][0].field()).     } else if (query instanceof PointRangeQuery) {         fields.add(((PointRangeQuery) query).getField()).     } else if (query instanceof PointInSetQuery) {         fields.add(((PointInSetQuery) query).getField()).     } else if (query instanceof DocValuesFieldExistsQuery) {         fields.add(((DocValuesFieldExistsQuery) query).getField()).     } else if (query instanceof DocValuesNumbersQuery) {         fields.add(((DocValuesNumbersQuery) query).getField()).     } else if (query instanceof IndexOrDocValuesQuery) {         // Both queries are supposed to be equivalent, so if any of them can be extracted, we are good         try {             Set<String> dvQueryFields = new HashSet<>(1).             extractFields(((IndexOrDocValuesQuery) query).getRandomAccessQuery(), dvQueryFields).             fields.addAll(dvQueryFields).         } catch (UnsupportedOperationException e) {             extractFields(((IndexOrDocValuesQuery) query).getIndexQuery(), fields).         }     } else if (query instanceof TermInSetQuery) {         // TermInSetQuery#field is inaccessible         TermInSetQuery termInSetQuery = (TermInSetQuery) query.         TermIterator termIterator = termInSetQuery.getTermData().iterator().         // there should only be one field         if (termIterator.next() != null) {             fields.add(termIterator.field()).         }     } else if (query instanceof MatchAllDocsQuery) {     // no field     } else if (query instanceof MatchNoDocsQuery) {     // no field     } else {         // we don't know how to get the fields from it         throw new UnsupportedOperationException().     } }
