commented;modifiers;parameterAmount;loc;comment;code
false;public;2;28;;public void roles(Set<String> roleNames, ActionListener<Role> roleActionListener) {     final RoleKey roleKey = new RoleKey(roleNames, ROLES_STORE_SOURCE).     Role existing = roleCache.get(roleKey).     if (existing != null) {         roleActionListener.onResponse(existing).     } else {         final long invalidationCounter = numInvalidation.get().         roleDescriptors(roleNames, ActionListener.wrap(rolesRetrievalResult -> {             final boolean missingRoles = rolesRetrievalResult.getMissingRoles().isEmpty() == false.             if (missingRoles) {                 logger.debug("Could not find roles with names {}", rolesRetrievalResult.getMissingRoles()).             }             final Set<RoleDescriptor> effectiveDescriptors.             if (licenseState.isDocumentAndFieldLevelSecurityAllowed()) {                 effectiveDescriptors = rolesRetrievalResult.getRoleDescriptors().             } else {                 effectiveDescriptors = rolesRetrievalResult.getRoleDescriptors().stream().filter((rd) -> rd.isUsingDocumentOrFieldLevelSecurity() == false).collect(Collectors.toSet()).             }             buildThenMaybeCacheRole(roleKey, effectiveDescriptors, rolesRetrievalResult.getMissingRoles(), rolesRetrievalResult.isSuccess(), invalidationCounter, roleActionListener).         }, roleActionListener::onFailure)).     } }
false;public;3;53;;public void getRoles(User user, Authentication authentication, ActionListener<Role> roleActionListener) {     // passed into this method. The XPackUser has the Superuser role and we can simply return that     if (SystemUser.is(user)) {         throw new IllegalArgumentException("the user [" + user.principal() + "] is the system user and we should never try to get its" + " roles").     }     if (XPackUser.is(user)) {         assert XPackUser.INSTANCE.roles().length == 1.         roleActionListener.onResponse(XPackUser.ROLE).         return.     }     if (XPackSecurityUser.is(user)) {         roleActionListener.onResponse(ReservedRolesStore.SUPERUSER_ROLE).         return.     }     final Authentication.AuthenticationType authType = authentication.getAuthenticationType().     if (authType == Authentication.AuthenticationType.API_KEY) {         apiKeyService.getRoleForApiKey(authentication, ActionListener.wrap(apiKeyRoleDescriptors -> {             final List<RoleDescriptor> descriptors = apiKeyRoleDescriptors.getRoleDescriptors().             if (descriptors == null) {                 roleActionListener.onFailure(new IllegalStateException("missing role descriptors")).             } else if (apiKeyRoleDescriptors.getLimitedByRoleDescriptors() == null) {                 buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + "_role_desc", roleActionListener).             } else {                 buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + "_role_desc", ActionListener.wrap(role -> buildAndCacheRoleFromDescriptors(apiKeyRoleDescriptors.getLimitedByRoleDescriptors(), apiKeyRoleDescriptors.getApiKeyId() + "_limited_role_desc", ActionListener.wrap(limitedBy -> roleActionListener.onResponse(LimitedRole.createLimitedRole(role, limitedBy)), roleActionListener::onFailure)), roleActionListener::onFailure)).             }         }, roleActionListener::onFailure)).     } else {         Set<String> roleNames = new HashSet<>(Arrays.asList(user.roles())).         if (isAnonymousEnabled && anonymousUser.equals(user) == false) {             if (anonymousUser.roles().length == 0) {                 throw new IllegalStateException("anonymous is only enabled when the anonymous user has roles").             }             Collections.addAll(roleNames, anonymousUser.roles()).         }         if (roleNames.isEmpty()) {             roleActionListener.onResponse(Role.EMPTY).         } else if (roleNames.contains(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName())) {             roleActionListener.onResponse(ReservedRolesStore.SUPERUSER_ROLE).         } else {             roles(roleNames, roleActionListener).         }     } }
false;public;3;14;;public void buildAndCacheRoleFromDescriptors(Collection<RoleDescriptor> roleDescriptors, String source, ActionListener<Role> listener) {     if (ROLES_STORE_SOURCE.equals(source)) {         throw new IllegalArgumentException("source [" + ROLES_STORE_SOURCE + "] is reserved for internal use").     }     RoleKey roleKey = new RoleKey(roleDescriptors.stream().map(RoleDescriptor::getName).collect(Collectors.toSet()), source).     Role existing = roleCache.get(roleKey).     if (existing != null) {         listener.onResponse(existing).     } else {         final long invalidationCounter = numInvalidation.get().         buildThenMaybeCacheRole(roleKey, roleDescriptors, Collections.emptySet(), true, invalidationCounter, listener).     } }
false;private;6;25;;private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor> roleDescriptors, Set<String> missing, boolean tryCache, long invalidationCounter, ActionListener<Role> listener) {     logger.trace("Building role from descriptors [{}] for names [{}] from source [{}]", roleDescriptors, roleKey.names, roleKey.source).     buildRoleFromDescriptors(roleDescriptors, fieldPermissionsCache, privilegeStore, ActionListener.wrap(role -> {         if (role != null && tryCache) {             try (ReleasableLock ignored = readLock.acquire()) {                 /* this is kinda spooky. We use a read/write lock to ensure we don't modify the cache if we hold                      * the write lock (fetching stats for instance - which is kinda overkill?) but since we fetching                      * stuff in an async fashion we need to make sure that if the cache got invalidated since we                      * started the request we don't put a potential stale result in the cache, hence the                      * numInvalidation.get() comparison to the number of invalidation when we started. we just try to                      * be on the safe side and don't cache potentially stale results                      */                 if (invalidationCounter == numInvalidation.get()) {                     roleCache.computeIfAbsent(roleKey, (s) -> role).                 }             }             for (String missingRole : missing) {                 negativeLookupCache.computeIfAbsent(missingRole, s -> Boolean.TRUE).             }         }         listener.onResponse(role).     }, listener::onFailure)). }
false;public;2;9;;public void getRoleDescriptors(Set<String> roleNames, ActionListener<Set<RoleDescriptor>> listener) {     roleDescriptors(roleNames, ActionListener.wrap(rolesRetrievalResult -> {         if (rolesRetrievalResult.isSuccess()) {             listener.onResponse(rolesRetrievalResult.getRoleDescriptors()).         } else {             listener.onFailure(new ElasticsearchException("role retrieval had one or more failures")).         }     }, listener::onFailure)). }
false;private;2;12;;private void roleDescriptors(Set<String> roleNames, ActionListener<RolesRetrievalResult> rolesResultListener) {     final Set<String> filteredRoleNames = roleNames.stream().filter((s) -> {         if (negativeLookupCache.get(s) != null) {             logger.debug("Requested role [{}] does not exist (cached)", s).             return false.         } else {             return true.         }     }).collect(Collectors.toSet()).     loadRoleDescriptorsAsync(filteredRoleNames, rolesResultListener). }
false;private;2;32;;private void loadRoleDescriptorsAsync(Set<String> roleNames, ActionListener<RolesRetrievalResult> listener) {     final RolesRetrievalResult rolesResult = new RolesRetrievalResult().     final List<BiConsumer<Set<String>, ActionListener<RoleRetrievalResult>>> asyncRoleProviders = licenseState.isCustomRoleProvidersAllowed() ? allRoleProviders : builtInRoleProviders.     final ActionListener<RoleRetrievalResult> descriptorsListener = ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(ignore -> {         rolesResult.setMissingRoles(roleNames).         listener.onResponse(rolesResult).     }, listener::onFailure), threadContext).     final Predicate<RoleRetrievalResult> iterationPredicate = result -> roleNames.isEmpty() == false.     new IteratingActionListener<>(descriptorsListener, (rolesProvider, providerListener) -> {         // try to resolve descriptors with role provider         rolesProvider.accept(roleNames, ActionListener.wrap(result -> {             if (result.isSuccess()) {                 logger.debug(() -> new ParameterizedMessage("Roles [{}] were resolved by [{}]", names(result.getDescriptors()), rolesProvider)).                 final Set<RoleDescriptor> resolvedDescriptors = result.getDescriptors().                 rolesResult.addDescriptors(resolvedDescriptors).                 // remove resolved descriptors from the set of roles still needed to be resolved                 for (RoleDescriptor descriptor : resolvedDescriptors) {                     roleNames.remove(descriptor.getName()).                 }             } else {                 logger.warn(new ParameterizedMessage("role retrieval failed from [{}]", rolesProvider), result.getFailure()).                 rolesResult.setFailure().             }             providerListener.onResponse(result).         }, providerListener::onFailure)).     }, asyncRoleProviders, threadContext, Function.identity(), iterationPredicate).run(). }
false;private;1;3;;private String names(Collection<RoleDescriptor> descriptors) {     return descriptors.stream().map(RoleDescriptor::getName).collect(Collectors.joining(",")). }
false;public,static;4;74;;public static void buildRoleFromDescriptors(Collection<RoleDescriptor> roleDescriptors, FieldPermissionsCache fieldPermissionsCache, NativePrivilegeStore privilegeStore, ActionListener<Role> listener) {     if (roleDescriptors.isEmpty()) {         listener.onResponse(Role.EMPTY).         return.     }     Set<String> clusterPrivileges = new HashSet<>().     final List<ConditionalClusterPrivilege> conditionalClusterPrivileges = new ArrayList<>().     Set<String> runAs = new HashSet<>().     final Map<Set<String>, MergeableIndicesPrivilege> restrictedIndicesPrivilegesMap = new HashMap<>().     final Map<Set<String>, MergeableIndicesPrivilege> indicesPrivilegesMap = new HashMap<>().     // Keyed by application + resource     Map<Tuple<String, Set<String>>, Set<String>> applicationPrivilegesMap = new HashMap<>().     List<String> roleNames = new ArrayList<>(roleDescriptors.size()).     for (RoleDescriptor descriptor : roleDescriptors) {         roleNames.add(descriptor.getName()).         if (descriptor.getClusterPrivileges() != null) {             clusterPrivileges.addAll(Arrays.asList(descriptor.getClusterPrivileges())).         }         if (descriptor.getConditionalClusterPrivileges() != null) {             conditionalClusterPrivileges.addAll(Arrays.asList(descriptor.getConditionalClusterPrivileges())).         }         if (descriptor.getRunAs() != null) {             runAs.addAll(Arrays.asList(descriptor.getRunAs())).         }         MergeableIndicesPrivilege.collatePrivilegesByIndices(descriptor.getIndicesPrivileges(), true, restrictedIndicesPrivilegesMap).         MergeableIndicesPrivilege.collatePrivilegesByIndices(descriptor.getIndicesPrivileges(), false, indicesPrivilegesMap).         for (RoleDescriptor.ApplicationResourcePrivileges appPrivilege : descriptor.getApplicationPrivileges()) {             Tuple<String, Set<String>> key = new Tuple<>(appPrivilege.getApplication(), newHashSet(appPrivilege.getResources())).             applicationPrivilegesMap.compute(key, (k, v) -> {                 if (v == null) {                     return newHashSet(appPrivilege.getPrivileges()).                 } else {                     v.addAll(Arrays.asList(appPrivilege.getPrivileges())).                     return v.                 }             }).         }     }     final Privilege runAsPrivilege = runAs.isEmpty() ? Privilege.NONE : new Privilege(runAs, runAs.toArray(Strings.EMPTY_ARRAY)).     final Role.Builder builder = Role.builder(roleNames.toArray(new String[roleNames.size()])).cluster(clusterPrivileges, conditionalClusterPrivileges).runAs(runAsPrivilege).     indicesPrivilegesMap.entrySet().forEach((entry) -> {         MergeableIndicesPrivilege privilege = entry.getValue().         builder.add(fieldPermissionsCache.getFieldPermissions(privilege.fieldPermissionsDefinition), privilege.query, IndexPrivilege.get(privilege.privileges), false, privilege.indices.toArray(Strings.EMPTY_ARRAY)).     }).     restrictedIndicesPrivilegesMap.entrySet().forEach((entry) -> {         MergeableIndicesPrivilege privilege = entry.getValue().         builder.add(fieldPermissionsCache.getFieldPermissions(privilege.fieldPermissionsDefinition), privilege.query, IndexPrivilege.get(privilege.privileges), true, privilege.indices.toArray(Strings.EMPTY_ARRAY)).     }).     if (applicationPrivilegesMap.isEmpty()) {         listener.onResponse(builder.build()).     } else {         final Set<String> applicationNames = applicationPrivilegesMap.keySet().stream().map(Tuple::v1).collect(Collectors.toSet()).         final Set<String> applicationPrivilegeNames = applicationPrivilegesMap.values().stream().flatMap(Collection::stream).collect(Collectors.toSet()).         privilegeStore.getPrivileges(applicationNames, applicationPrivilegeNames, ActionListener.wrap(appPrivileges -> {             applicationPrivilegesMap.forEach((key, names) -> builder.addApplicationPrivilege(ApplicationPrivilege.get(key.v1(), names, appPrivileges), key.v2())).             listener.onResponse(builder.build()).         }, listener::onFailure)).     } }
false;public;0;7;;public void invalidateAll() {     numInvalidation.incrementAndGet().     negativeLookupCache.invalidateAll().     try (ReleasableLock ignored = readLock.acquire()) {         roleCache.invalidateAll().     } }
false;public;1;15;;public void invalidate(String role) {     numInvalidation.incrementAndGet().     // the cache cannot be modified while doing this operation per the terms of the cache iterator     try (ReleasableLock ignored = writeLock.acquire()) {         Iterator<RoleKey> keyIter = roleCache.keys().iterator().         while (keyIter.hasNext()) {             RoleKey key = keyIter.next().             if (key.names.contains(role)) {                 keyIter.remove().             }         }     }     negativeLookupCache.invalidate(role). }
false;public;1;16;;public void invalidate(Set<String> roles) {     numInvalidation.incrementAndGet().     // the cache cannot be modified while doing this operation per the terms of the cache iterator     try (ReleasableLock ignored = writeLock.acquire()) {         Iterator<RoleKey> keyIter = roleCache.keys().iterator().         while (keyIter.hasNext()) {             RoleKey key = keyIter.next().             if (Sets.haveEmptyIntersection(key.names, roles) == false) {                 keyIter.remove().             }         }     }     roles.forEach(negativeLookupCache::invalidate). }
false;public;1;8;;public void usageStats(ActionListener<Map<String, Object>> listener) {     final Map<String, Object> usage = new HashMap<>(2).     usage.put("file", fileRolesStore.usageStats()).     nativeRolesStore.usageStats(ActionListener.wrap(map -> {         usage.put("native", map).         listener.onResponse(usage).     }, listener::onFailure)). }
false;public;2;6;;public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {     if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState) || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {         invalidateAll().     } }
true;;1;3;// pkg - private for testing ;// pkg - private for testing boolean isValueInNegativeLookupCache(String key) {     return negativeLookupCache.get(key) != null. }
false;;1;14;;void merge(MergeableIndicesPrivilege other) {     assert indices.equals(other.indices) : "index names must be equivalent in order to merge".     Set<FieldGrantExcludeGroup> groups = new HashSet<>().     groups.addAll(this.fieldPermissionsDefinition.getFieldGrantExcludeGroups()).     groups.addAll(other.fieldPermissionsDefinition.getFieldGrantExcludeGroups()).     this.fieldPermissionsDefinition = new FieldPermissionsDefinition(groups).     this.privileges.addAll(other.privileges).     if (this.query == null || other.query == null) {         this.query = null.     } else {         this.query.addAll(other.query).     } }
false;private,static;3;23;;private static void collatePrivilegesByIndices(IndicesPrivileges[] indicesPrivileges, boolean allowsRestrictedIndices, Map<Set<String>, MergeableIndicesPrivilege> indicesPrivilegesMap) {     for (final IndicesPrivileges indicesPrivilege : indicesPrivileges) {         // if a index privilege is an explicit denial, then we treat it as non-existent since we skipped these in the past when         // merging         final boolean isExplicitDenial = indicesPrivileges.length == 1 && "none".equalsIgnoreCase(indicesPrivilege.getPrivileges()[0]).         if (isExplicitDenial || (indicesPrivilege.allowRestrictedIndices() != allowsRestrictedIndices)) {             continue.         }         final Set<String> key = newHashSet(indicesPrivilege.getIndices()).         indicesPrivilegesMap.compute(key, (k, value) -> {             if (value == null) {                 return new MergeableIndicesPrivilege(indicesPrivilege.getIndices(), indicesPrivilege.getPrivileges(), indicesPrivilege.getGrantedFields(), indicesPrivilege.getDeniedFields(), indicesPrivilege.getQuery()).             } else {                 value.merge(new MergeableIndicesPrivilege(indicesPrivilege.getIndices(), indicesPrivilege.getPrivileges(), indicesPrivilege.getGrantedFields(), indicesPrivilege.getDeniedFields(), indicesPrivilege.getQuery())).                 return value.             }         }).     } }
false;private;1;3;;private void addDescriptors(Set<RoleDescriptor> descriptors) {     roleDescriptors.addAll(descriptors). }
false;private;0;3;;private Set<RoleDescriptor> getRoleDescriptors() {     return roleDescriptors. }
false;private;0;3;;private void setFailure() {     success = false. }
false;private;0;3;;private boolean isSuccess() {     return success. }
false;private;1;3;;private void setMissingRoles(Set<String> missingRoles) {     this.missingRoles = missingRoles. }
false;private;0;3;;private Set<String> getMissingRoles() {     return missingRoles. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     RoleKey roleKey = (RoleKey) o.     return names.equals(roleKey.names) && source.equals(roleKey.source). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(names, source). }
false;public,static;0;3;;public static List<Setting<?>> getSettings() {     return Arrays.asList(CACHE_SIZE_SETTING, NEGATIVE_LOOKUP_CACHE_SIZE_SETTING). }
