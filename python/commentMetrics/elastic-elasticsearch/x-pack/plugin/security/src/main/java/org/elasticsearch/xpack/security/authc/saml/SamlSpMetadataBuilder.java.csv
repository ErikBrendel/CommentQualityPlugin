commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * The format that the service provider expects for incoming NameID element.  */ ;/**  * The format that the service provider expects for incoming NameID element.  */ public SamlSpMetadataBuilder nameIdFormat(String nameIdFormat) {     this.nameIdFormat = nameIdFormat.     return this. }
true;public;1;4;/**  * The name of the service, for use in a {@link AttributeConsumingService}  */ ;/**  * The name of the service, for use in a {@link AttributeConsumingService}  */ public SamlSpMetadataBuilder serviceName(String serviceName) {     this.serviceName = serviceName.     return this. }
true;public;2;7;/**  * Request a named attribute be provided as part of assertions. Specified  in a {@link AttributeConsumingService}  */ ;/**  * Request a named attribute be provided as part of assertions. Specified  in a {@link AttributeConsumingService}  */ public SamlSpMetadataBuilder withAttribute(String friendlyName, String name) {     if (Strings.isNullOrEmpty(name)) {         throw new IllegalArgumentException("Attribute name cannot be empty (friendly name was [" + friendlyName + "])").     }     this.attributeNames.put(name, friendlyName).     return this. }
true;public;1;4;/**  * The (POST) URL to be used to accept SAML assertions (authentication results)  */ ;/**  * The (POST) URL to be used to accept SAML assertions (authentication results)  */ public SamlSpMetadataBuilder assertionConsumerServiceUrl(String acsUrl) {     this.assertionConsumerServiceUrl = acsUrl.     return this. }
true;public;1;4;/**  * The (GET/Redirect) URL to be used to handle SAML logout / session termination  */ ;/**  * The (GET/Redirect) URL to be used to handle SAML logout / session termination  */ public SamlSpMetadataBuilder singleLogoutServiceUrl(String slsUrl) {     this.singleLogoutServiceUrl = slsUrl.     return this. }
true;public;1;4;/**  * Whether this Service Provider signs {@link org.opensaml.saml.saml2.core.AuthnRequest} messages.  */ ;/**  * Whether this Service Provider signs {@link org.opensaml.saml.saml2.core.AuthnRequest} messages.  */ public SamlSpMetadataBuilder authnRequestsSigned(Boolean authnRequestsSigned) {     this.authnRequestsSigned = authnRequestsSigned.     return this. }
true;public;1;4;/**  * The certificate that the service provider users to sign SAML requests.  */ ;/**  * The certificate that the service provider users to sign SAML requests.  */ public SamlSpMetadataBuilder signingCertificate(X509Certificate signingCertificate) {     this.signingCertificate = signingCertificate.     return this. }
true;public;1;3;/**  * The certificate credential that should be used to send encrypted data to the service provider.  */ ;/**  * The certificate credential that should be used to send encrypted data to the service provider.  */ public SamlSpMetadataBuilder signingCredential(X509Credential credential) {     return signingCertificate(credential == null ? null : credential.getEntityCertificate()). }
true;public;1;6;/**  * The certificate that should be used to send encrypted data to the service provider.  */ ;/**  * The certificate that should be used to send encrypted data to the service provider.  */ public SamlSpMetadataBuilder encryptionCertificates(Collection<X509Certificate> encryptionCertificates) {     if (encryptionCertificates != null) {         this.encryptionCertificates.addAll(encryptionCertificates).     }     return this. }
true;public;1;4;/**  * The certificate credential that should be used to send encrypted data to the service provider.  */ ;/**  * The certificate credential that should be used to send encrypted data to the service provider.  */ public SamlSpMetadataBuilder encryptionCredentials(Collection<X509Credential> credentials) {     return encryptionCertificates(credentials == null ? Collections.emptyList() : credentials.stream().map(credential -> credential.getEntityCertificate()).collect(Collectors.toList())). }
true;public;1;4;/**  * The organisation that operates the service provider  */ ;/**  * The organisation that operates the service provider  */ public SamlSpMetadataBuilder organization(OrganizationInfo organization) {     this.organization = organization.     return this. }
true;public;3;3;/**  * The organisation that operates the service provider  */ ;/**  * The organisation that operates the service provider  */ public SamlSpMetadataBuilder organization(String orgName, String displayName, String url) {     return organization(new OrganizationInfo(orgName, displayName, url)). }
true;public;1;4;/**  * A contact within the organisation that operates the service provider  */ ;/**  * A contact within the organisation that operates the service provider  */ public SamlSpMetadataBuilder withContact(ContactInfo contact) {     this.contacts.add(contact).     return this. }
true;public;4;3;/**  * A contact within the organisation that operates the service provider  *  * @param type Must be one of the standard types on {@link ContactPersonTypeEnumeration}  */ ;/**  * A contact within the organisation that operates the service provider  *  * @param type Must be one of the standard types on {@link ContactPersonTypeEnumeration}  */ public SamlSpMetadataBuilder withContact(String type, String givenName, String surName, String email) {     return withContact(new ContactInfo(ContactInfo.getType(type), givenName, surName, email)). }
true;public;0;30;/**  * Constructs an {@link EntityDescriptor} that contains a single {@link SPSSODescriptor}.  */ ;/**  * Constructs an {@link EntityDescriptor} that contains a single {@link SPSSODescriptor}.  */ public EntityDescriptor build() throws Exception {     final SPSSODescriptor spRoleDescriptor = new SPSSODescriptorBuilder().buildObject().     spRoleDescriptor.removeAllSupportedProtocols().     spRoleDescriptor.addSupportedProtocol(SAMLConstants.SAML20P_NS).     spRoleDescriptor.setWantAssertionsSigned(true).     spRoleDescriptor.setAuthnRequestsSigned(this.authnRequestsSigned).     if (Strings.hasLength(nameIdFormat)) {         spRoleDescriptor.getNameIDFormats().add(buildNameIdFormat()).     }     spRoleDescriptor.getAssertionConsumerServices().add(buildAssertionConsumerService()).     if (attributeNames.size() > 0) {         spRoleDescriptor.getAttributeConsumingServices().add(buildAttributeConsumerService()).     }     if (Strings.hasText(singleLogoutServiceUrl)) {         spRoleDescriptor.getSingleLogoutServices().add(buildSingleLogoutService()).     }     spRoleDescriptor.getKeyDescriptors().addAll(buildKeyDescriptors()).     final EntityDescriptor descriptor = new EntityDescriptorBuilder().buildObject().     descriptor.setEntityID(this.entityId).     descriptor.getRoleDescriptors().add(spRoleDescriptor).     if (organization != null) {         descriptor.setOrganization(buildOrganization()).     }     contacts.forEach(c -> descriptor.getContactPersons().add(buildContact(c))).     return descriptor. }
false;private;0;5;;private NameIDFormat buildNameIdFormat() {     final NameIDFormat format = new NameIDFormatBuilder().buildObject().     format.setFormat(this.nameIdFormat).     return format. }
false;private;0;11;;private AssertionConsumerService buildAssertionConsumerService() {     if (Strings.isNullOrEmpty(assertionConsumerServiceUrl)) {         throw new IllegalStateException("AssertionConsumerService URL has not been specified").     }     final AssertionConsumerService acs = new AssertionConsumerServiceBuilder().buildObject().     acs.setBinding(SAMLConstants.SAML2_POST_BINDING_URI).     acs.setIndex(1).     acs.setIsDefault(Boolean.TRUE).     acs.setLocation(assertionConsumerServiceUrl).     return acs. }
false;private;0;10;;private AttributeConsumingService buildAttributeConsumerService() {     final AttributeConsumingService service = new AttributeConsumingServiceBuilder().buildObject().     service.setIndex(1).     service.setIsDefault(true).     service.getNames().add(buildServiceName()).     attributeNames.forEach((name, friendlyName) -> {         service.getRequestAttributes().add(buildRequestedAttribute(friendlyName, name)).     }).     return service. }
false;private;0;6;;private ServiceName buildServiceName() {     final ServiceName name = new ServiceNameBuilder().buildObject().     name.setValue(serviceName).     name.setXMLLang(locale.toLanguageTag()).     return name. }
false;private;2;9;;private RequestedAttribute buildRequestedAttribute(String friendlyName, String name) {     final RequestedAttribute attribute = new RequestedAttributeBuilder().buildObject().     if (Strings.hasText(friendlyName)) {         attribute.setFriendlyName(friendlyName).     }     attribute.setName(name).     attribute.setNameFormat(RequestedAttribute.URI_REFERENCE).     return attribute. }
false;private;0;9;;private SingleLogoutService buildSingleLogoutService() {     final SingleLogoutService service = new SingleLogoutServiceBuilder().buildObject().     // The draft Interoperable SAML 2 profile requires redirect binding.     // That's annoying, because they require POST binding for the ACS so now SPs need to     // support 2 bindings that have different signature passing rules, etc. *sigh*     service.setBinding(SAMLConstants.SAML2_REDIRECT_BINDING_URI).     service.setLocation(singleLogoutServiceUrl).     return service. }
false;private;0;16;;private List<? extends KeyDescriptor> buildKeyDescriptors() throws CertificateEncodingException {     if (encryptionCertificates.isEmpty() && signingCertificate == null) {         return Collections.emptyList().     }     if (encryptionCertificates.size() == 1 && Objects.equals(encryptionCertificates.get(0), signingCertificate)) {         return Collections.singletonList(buildKeyDescriptor(encryptionCertificates.get(0), UsageType.UNSPECIFIED)).     }     List<KeyDescriptor> keys = new ArrayList<>().     if (signingCertificate != null) {         keys.add(buildKeyDescriptor(signingCertificate, UsageType.SIGNING)).     }     for (X509Certificate encryptionCertificate : encryptionCertificates) {         keys.add(buildKeyDescriptor(encryptionCertificate, UsageType.ENCRYPTION)).     }     return keys. }
false;private;2;8;;private KeyDescriptor buildKeyDescriptor(X509Certificate certificate, UsageType usageType) throws CertificateEncodingException {     final KeyDescriptor descriptor = new KeyDescriptorBuilder().buildObject().     descriptor.setUse(usageType).     final KeyInfo keyInfo = new KeyInfoBuilder().buildObject().     KeyInfoSupport.addCertificate(keyInfo, certificate).     descriptor.setKeyInfo(keyInfo).     return descriptor. }
false;private;0;18;;private Organization buildOrganization() {     final String lang = locale.toLanguageTag().     final OrganizationName name = new OrganizationNameBuilder().buildObject().     name.setValue(this.organization.organizationName).     name.setXMLLang(lang).     final OrganizationDisplayName displayName = new OrganizationDisplayNameBuilder().buildObject().     displayName.setValue(this.organization.displayName).     displayName.setXMLLang(lang).     final OrganizationURL url = new OrganizationURLBuilder().buildObject().     url.setValue(this.organization.url).     url.setXMLLang(lang).     final Organization org = new OrganizationBuilder().buildObject().     org.getOrganizationNames().add(name).     org.getDisplayNames().add(displayName).     org.getURLs().add(url).     return org. }
false;private;1;15;;private ContactPerson buildContact(ContactInfo contact) {     final GivenName givenName = new GivenNameBuilder().buildObject().     givenName.setName(contact.givenName).     final SurName surName = new SurNameBuilder().buildObject().     surName.setName(contact.surName).     final EmailAddress email = new EmailAddressBuilder().buildObject().     email.setAddress(contact.email).     final ContactPerson person = new ContactPersonBuilder().buildObject().     person.setType(contact.type).     person.setGivenName(givenName).     person.setSurName(surName).     person.getEmailAddresses().add(email).     return person. }
false;private,static;1;8;;private static ContactPersonTypeEnumeration getType(String name) {     final ContactPersonTypeEnumeration type = TYPES.get(name.toLowerCase(Locale.ROOT)).     if (type == null) {         throw new IllegalArgumentException("Invalid contact type " + name + " allowed values are " + Strings.collectionToCommaDelimitedString(TYPES.keySet())).     }     return type. }
