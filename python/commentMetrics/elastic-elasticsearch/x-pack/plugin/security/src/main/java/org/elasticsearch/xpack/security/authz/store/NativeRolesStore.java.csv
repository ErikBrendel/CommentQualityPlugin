commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void accept(Set<String> names, ActionListener<RoleRetrievalResult> listener) {     getRoleDescriptors(names, listener). }
true;public;2;57;/**  * Retrieve a list of roles, if rolesToGet is null or empty, fetch all roles  */ ;/**  * Retrieve a list of roles, if rolesToGet is null or empty, fetch all roles  */ public void getRoleDescriptors(Set<String> names, final ActionListener<RoleRetrievalResult> listener) {     final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze().     if (frozenSecurityIndex.indexExists() == false) {         // TODO remove this short circuiting and fix tests that fail without this!         listener.onResponse(RoleRetrievalResult.success(Collections.emptySet())).     } else if (frozenSecurityIndex.isAvailable() == false) {         listener.onResponse(RoleRetrievalResult.failure(frozenSecurityIndex.getUnavailableReason())).     } else if (names == null || names.isEmpty()) {         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {             QueryBuilder query = QueryBuilders.termQuery(RoleDescriptor.Fields.TYPE.getPreferredName(), ROLE_TYPE).             final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false).             try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {                 SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)).setQuery(query).setSize(1000).setFetchSource(true).request().                 request.indicesOptions().ignoreUnavailable().                 ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, ActionListener.wrap(roles -> listener.onResponse(RoleRetrievalResult.success(new HashSet<>(roles))), e -> listener.onResponse(RoleRetrievalResult.failure(e)))), (hit) -> transformRole(hit.getId(), hit.getSourceRef(), logger, licenseState)).             }         }).     } else if (names.size() == 1) {         getRoleDescriptor(Objects.requireNonNull(names.iterator().next()), listener).     } else {         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {             final String[] roleIds = names.stream().map(NativeRolesStore::getIdForRole).toArray(String[]::new).             MultiGetRequest multiGetRequest = client.prepareMultiGet().add(SECURITY_INDEX_NAME, ROLE_DOC_TYPE, roleIds).request().             executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, multiGetRequest, ActionListener.<MultiGetResponse>wrap(mGetResponse -> {                 final MultiGetItemResponse[] responses = mGetResponse.getResponses().                 Set<RoleDescriptor> descriptors = new HashSet<>().                 for (int i = 0. i < responses.length. i++) {                     MultiGetItemResponse item = responses[i].                     if (item.isFailed()) {                         final Exception failure = item.getFailure().getFailure().                         for (int j = i + 1. j < responses.length. j++) {                             item = responses[j].                             if (item.isFailed()) {                                 failure.addSuppressed(failure).                             }                         }                         listener.onResponse(RoleRetrievalResult.failure(failure)).                         return.                     } else if (item.getResponse().isExists()) {                         descriptors.add(transformRole(item.getResponse())).                     }                 }                 listener.onResponse(RoleRetrievalResult.success(descriptors)).             }, e -> listener.onResponse(RoleRetrievalResult.failure(e))), client::multiGet).         }).     } }
false;public;1;5;;@Override public void onResponse(DeleteResponse deleteResponse) {     clearRoleCache(deleteRoleRequest.name(), listener, deleteResponse.getResult() == DocWriteResponse.Result.DELETED). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.error("failed to delete role from the index", e).     listener.onFailure(e). }
false;public;2;28;;public void deleteRole(final DeleteRoleRequest deleteRoleRequest, final ActionListener<Boolean> listener) {     final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze().     if (frozenSecurityIndex.indexExists() == false) {         listener.onResponse(false).     } else if (frozenSecurityIndex.isAvailable() == false) {         listener.onFailure(frozenSecurityIndex.getUnavailableReason()).     } else {         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {             DeleteRequest request = client.prepareDelete(SecurityIndexManager.SECURITY_INDEX_NAME, ROLE_DOC_TYPE, getIdForRole(deleteRoleRequest.name())).request().             request.setRefreshPolicy(deleteRoleRequest.getRefreshPolicy()).             executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request, new ActionListener<DeleteResponse>() {                  @Override                 public void onResponse(DeleteResponse deleteResponse) {                     clearRoleCache(deleteRoleRequest.name(), listener, deleteResponse.getResult() == DocWriteResponse.Result.DELETED).                 }                  @Override                 public void onFailure(Exception e) {                     logger.error("failed to delete role from the index", e).                     listener.onFailure(e).                 }             }, client::delete).         }).     } }
false;public;3;9;;public void putRole(final PutRoleRequest request, final RoleDescriptor role, final ActionListener<Boolean> listener) {     if (licenseState.isDocumentAndFieldLevelSecurityAllowed()) {         innerPutRole(request, role, listener).     } else if (role.isUsingDocumentOrFieldLevelSecurity()) {         listener.onFailure(LicenseUtils.newComplianceException("field and document level security")).     } else {         innerPutRole(request, role, listener).     } }
false;public;1;6;;@Override public void onResponse(IndexResponse indexResponse) {     final boolean created = indexResponse.getResult() == DocWriteResponse.Result.CREATED.     logger.trace("Created role: [{}]", indexRequest).     clearRoleCache(role.getName(), listener, created). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.error(new ParameterizedMessage("failed to put role [{}]", request.name()), e).     listener.onFailure(e). }
true;;3;31;// pkg-private for testing ;// pkg-private for testing void innerPutRole(final PutRoleRequest request, final RoleDescriptor role, final ActionListener<Boolean> listener) {     securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {         final XContentBuilder xContentBuilder.         try {             xContentBuilder = role.toXContent(jsonBuilder(), ToXContent.EMPTY_PARAMS, true).         } catch (IOException e) {             listener.onFailure(e).             return.         }         final IndexRequest indexRequest = client.prepareIndex(SECURITY_INDEX_NAME, ROLE_DOC_TYPE, getIdForRole(role.getName())).setSource(xContentBuilder).setRefreshPolicy(request.getRefreshPolicy()).request().         executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest, new ActionListener<IndexResponse>() {              @Override             public void onResponse(IndexResponse indexResponse) {                 final boolean created = indexResponse.getResult() == DocWriteResponse.Result.CREATED.                 logger.trace("Created role: [{}]", indexRequest).                 clearRoleCache(role.getName(), listener, created).             }              @Override             public void onFailure(Exception e) {                 logger.error(new ParameterizedMessage("failed to put role [{}]", request.name()), e).                 listener.onFailure(e).             }         }, client::index).     }). }
false;public;1;21;;@Override public void onResponse(MultiSearchResponse items) {     Item[] responses = items.getResponses().     if (responses[0].isFailure()) {         usageStats.put("size", 0).     } else {         usageStats.put("size", responses[0].getResponse().getHits().getTotalHits().value).     }     if (responses[1].isFailure()) {         usageStats.put("fls", false).     } else {         usageStats.put("fls", responses[1].getResponse().getHits().getTotalHits().value > 0L).     }     if (responses[2].isFailure()) {         usageStats.put("dls", false).     } else {         usageStats.put("dls", responses[2].getResponse().getHits().getTotalHits().value > 0L).     }     listener.onResponse(usageStats). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;1;64;;public void usageStats(ActionListener<Map<String, Object>> listener) {     Map<String, Object> usageStats = new HashMap<>(3).     if (securityIndex.isAvailable() == false) {         usageStats.put("size", 0L).         usageStats.put("fls", false).         usageStats.put("dls", false).         listener.onResponse(usageStats).     } else {         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareMultiSearch().add(client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setQuery(QueryBuilders.termQuery(RoleDescriptor.Fields.TYPE.getPreferredName(), ROLE_TYPE)).setTrackTotalHits(true).setSize(0)).add(client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setQuery(QueryBuilders.boolQuery().must(QueryBuilders.termQuery(RoleDescriptor.Fields.TYPE.getPreferredName(), ROLE_TYPE)).must(QueryBuilders.boolQuery().should(existsQuery("indices.field_security.grant")).should(existsQuery("indices.field_security.except")).should(existsQuery("indices.fields")))).setTrackTotalHits(true).setSize(0).setTerminateAfter(1)).add(client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setQuery(QueryBuilders.boolQuery().must(QueryBuilders.termQuery(RoleDescriptor.Fields.TYPE.getPreferredName(), ROLE_TYPE)).filter(existsQuery("indices.query"))).setTrackTotalHits(true).setSize(0).setTerminateAfter(1)).request(), new ActionListener<MultiSearchResponse>() {              @Override             public void onResponse(MultiSearchResponse items) {                 Item[] responses = items.getResponses().                 if (responses[0].isFailure()) {                     usageStats.put("size", 0).                 } else {                     usageStats.put("size", responses[0].getResponse().getHits().getTotalHits().value).                 }                 if (responses[1].isFailure()) {                     usageStats.put("fls", false).                 } else {                     usageStats.put("fls", responses[1].getResponse().getHits().getTotalHits().value > 0L).                 }                 if (responses[2].isFailure()) {                     usageStats.put("dls", false).                 } else {                     usageStats.put("dls", responses[2].getResponse().getHits().getTotalHits().value > 0L).                 }                 listener.onResponse(usageStats).             }              @Override             public void onFailure(Exception e) {                 listener.onFailure(e).             }         }, client::multiSearch)).     } }
false;public;0;4;;@Override public String toString() {     return "native roles store". }
false;public;1;6;;@Override public void onResponse(GetResponse response) {     final RoleDescriptor descriptor = transformRole(response).     resultListener.onResponse(RoleRetrievalResult.success(descriptor == null ? Collections.emptySet() : Collections.singleton(descriptor))). }
false;public;1;4;;@Override public void onFailure(Exception e) {     resultListener.onResponse(RoleRetrievalResult.failure(e)). }
false;private;2;24;;private void getRoleDescriptor(final String roleId, ActionListener<RoleRetrievalResult> resultListener) {     final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze().     if (frozenSecurityIndex.indexExists() == false) {         // TODO remove this short circuiting and fix tests that fail without this!         resultListener.onResponse(RoleRetrievalResult.success(Collections.emptySet())).     } else if (frozenSecurityIndex.isAvailable() == false) {         resultListener.onResponse(RoleRetrievalResult.failure(frozenSecurityIndex.getUnavailableReason())).     } else {         securityIndex.checkIndexVersionThenExecute(e -> resultListener.onResponse(RoleRetrievalResult.failure(e)), () -> executeGetRoleRequest(roleId, new ActionListener<GetResponse>() {              @Override             public void onResponse(GetResponse response) {                 final RoleDescriptor descriptor = transformRole(response).                 resultListener.onResponse(RoleRetrievalResult.success(descriptor == null ? Collections.emptySet() : Collections.singleton(descriptor))).             }              @Override             public void onFailure(Exception e) {                 resultListener.onResponse(RoleRetrievalResult.failure(e)).             }         })).     } }
false;private;2;8;;private void executeGetRoleRequest(String role, ActionListener<GetResponse> listener) {     securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareGet(SECURITY_INDEX_NAME, ROLE_DOC_TYPE, getIdForRole(role)).request(), listener, client::get)). }
false;public;1;4;;@Override public void onResponse(ClearRolesCacheResponse nodes) {     listener.onResponse(response). }
false;public;1;7;;@Override public void onFailure(Exception e) {     logger.error(new ParameterizedMessage("unable to clear cache for role [{}]", role), e).     ElasticsearchException exception = new ElasticsearchException("clearing the cache for [" + role + "] failed. please clear the role cache manually", e).     listener.onFailure(exception). }
false;private;3;18;;private <Response> void clearRoleCache(final String role, ActionListener<Response> listener, Response response) {     ClearRolesCacheRequest request = new ClearRolesCacheRequest().names(role).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request, new ActionListener<ClearRolesCacheResponse>() {          @Override         public void onResponse(ClearRolesCacheResponse nodes) {             listener.onResponse(response).         }          @Override         public void onFailure(Exception e) {             logger.error(new ParameterizedMessage("unable to clear cache for role [{}]", role), e).             ElasticsearchException exception = new ElasticsearchException("clearing the cache for [" + role + "] failed. please clear the role cache manually", e).             listener.onFailure(exception).         }     }, securityClient::clearRolesCache). }
false;private;1;8;;@Nullable private RoleDescriptor transformRole(GetResponse response) {     if (response.isExists() == false) {         return null.     }     return transformRole(response.getId(), response.getSourceAsBytesRef(), logger, licenseState). }
false;static;4;38;;@Nullable static RoleDescriptor transformRole(String id, BytesReference sourceBytes, Logger logger, XPackLicenseState licenseState) {     assert id.startsWith(ROLE_TYPE) : "[" + id + "] does not have role prefix".     final String name = id.substring(ROLE_TYPE.length() + 1).     try {         // we pass true as last parameter because we do not want to reject permissions if the field permissions         // are given in 2.x syntax         RoleDescriptor roleDescriptor = RoleDescriptor.parse(name, sourceBytes, true, XContentType.JSON).         if (licenseState.isDocumentAndFieldLevelSecurityAllowed()) {             return roleDescriptor.         } else {             final boolean dlsEnabled = Arrays.stream(roleDescriptor.getIndicesPrivileges()).anyMatch(IndicesPrivileges::isUsingDocumentLevelSecurity).             final boolean flsEnabled = Arrays.stream(roleDescriptor.getIndicesPrivileges()).anyMatch(IndicesPrivileges::isUsingFieldLevelSecurity).             if (dlsEnabled || flsEnabled) {                 List<String> unlicensedFeatures = new ArrayList<>(2).                 if (flsEnabled) {                     unlicensedFeatures.add("fls").                 }                 if (dlsEnabled) {                     unlicensedFeatures.add("dls").                 }                 Map<String, Object> transientMap = new HashMap<>(2).                 transientMap.put("unlicensed_features", unlicensedFeatures).                 transientMap.put("enabled", false).                 return new RoleDescriptor(roleDescriptor.getName(), roleDescriptor.getClusterPrivileges(), roleDescriptor.getIndicesPrivileges(), roleDescriptor.getRunAs(), roleDescriptor.getMetadata(), transientMap).             } else {                 return roleDescriptor.             }         }     } catch (Exception e) {         logger.error(new ParameterizedMessage("error in the format of data for role [{}]", name), e).         return null.     } }
false;public,static;1;4;;public static void addSettings(List<Setting<?>> settings) {     settings.add(CACHE_SIZE_SETTING).     settings.add(CACHE_TTL_SETTING). }
true;private,static;1;3;/**  * Gets the document's id field for the given role name.  */ ;/**  * Gets the document's id field for the given role name.  */ private static String getIdForRole(final String roleName) {     return ROLE_TYPE + "-" + roleName. }
