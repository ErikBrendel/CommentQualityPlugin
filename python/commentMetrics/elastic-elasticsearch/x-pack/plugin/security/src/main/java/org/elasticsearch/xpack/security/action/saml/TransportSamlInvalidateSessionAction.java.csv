commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;11;;@Override protected void doExecute(Task task, SamlInvalidateSessionRequest request, ActionListener<SamlInvalidateSessionResponse> listener) {     List<SamlRealm> realms = findSamlRealms(this.realms, request.getRealmName(), request.getAssertionConsumerServiceURL()).     if (realms.isEmpty()) {         listener.onFailure(SamlUtils.samlException("Cannot find any matching realm for [{}]", request)).     } else if (realms.size() > 1) {         listener.onFailure(SamlUtils.samlException("Found multiple matching realms [{}] for [{}]", realms, request)).     } else {         invalidateSession(realms.get(0), request, listener).     } }
false;private;3;12;;private void invalidateSession(SamlRealm realm, SamlInvalidateSessionRequest request, ActionListener<SamlInvalidateSessionResponse> listener) {     try {         final SamlLogoutRequestHandler.Result result = realm.getLogoutHandler().parseFromQueryString(request.getQueryString()).         findAndInvalidateTokens(realm, result, ActionListener.wrap(count -> listener.onResponse(new SamlInvalidateSessionResponse(realm.name(), count, buildLogoutResponseUrl(realm, result))), listener::onFailure)).     } catch (ElasticsearchSecurityException e) {         logger.info("Failed to invalidate SAML session", e).         listener.onFailure(e).     } }
false;private;2;4;;private String buildLogoutResponseUrl(SamlRealm realm, SamlLogoutRequestHandler.Result result) {     final LogoutResponse response = realm.buildLogoutResponse(result.getRequestId()).     return new SamlRedirect(response, realm.getSigningConfiguration()).getRedirectUrl(result.getRelayState()). }
false;private;3;23;;private void findAndInvalidateTokens(SamlRealm realm, SamlLogoutRequestHandler.Result result, ActionListener<Integer> listener) {     final Map<String, Object> tokenMetadata = realm.createTokenMetadata(result.getNameId(), result.getSession()).     if (Strings.isNullOrEmpty((String) tokenMetadata.get(SamlRealm.TOKEN_METADATA_NAMEID_VALUE))) {         // If we don't have a valid name-id to match against, don't do anything         logger.debug("Logout request [{}] has no NameID value, so cannot invalidate any sessions", result).         listener.onResponse(0).         return.     }     tokenService.findActiveTokensForRealm(realm.name(), ActionListener.wrap(tokens -> {         logger.debug("Found [{}] token pairs to invalidate for SAML metadata [{}]", tokens.size(), tokenMetadata).         if (tokens.isEmpty()) {             listener.onResponse(0).         } else {             GroupedActionListener<TokensInvalidationResult> groupedListener = new GroupedActionListener<>(ActionListener.wrap(collection -> listener.onResponse(collection.size()), listener::onFailure), tokens.size(), Collections.emptyList()).             tokens.forEach(tuple -> invalidateTokenPair(tuple, groupedListener)).         }     }, listener::onFailure), containsMetadata(tokenMetadata)). }
false;private;2;9;;private void invalidateTokenPair(Tuple<UserToken, String> tokenPair, ActionListener<TokensInvalidationResult> listener) {     // Invalidate the refresh token first, so the client doesn't trigger a refresh once the access token is invalidated     tokenService.invalidateRefreshToken(tokenPair.v2(), ActionListener.wrap(ignore -> tokenService.invalidateAccessToken(tokenPair.v1(), ActionListener.wrap(listener::onResponse, e -> {         logger.info("Failed to invalidate SAML access_token [{}] - {}", tokenPair.v1().getId(), e.toString()).         listener.onFailure(e).     })), listener::onFailure)). }
false;private;1;6;;private Predicate<Map<String, Object>> containsMetadata(Map<String, Object> requiredMetadata) {     return source -> {         Map<String, Object> actualMetadata = (Map<String, Object>) source.get("metadata").         return requiredMetadata.entrySet().stream().allMatch(e -> Objects.equals(actualMetadata.get(e.getKey()), e.getValue())).     }. }
