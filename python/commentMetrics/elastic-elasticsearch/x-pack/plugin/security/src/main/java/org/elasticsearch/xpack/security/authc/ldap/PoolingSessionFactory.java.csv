commented;modifiers;parameterAmount;loc;comment;code
false;public,final;3;8;;@Override public final void session(String user, SecureString password, ActionListener<LdapSession> listener) {     if (useConnectionPool) {         getSessionWithPool(connectionPool, user, password, listener).     } else {         getSessionWithoutPool(user, password, listener).     } }
false;public,final;2;8;;@Override public final void unauthenticatedSession(String user, ActionListener<LdapSession> listener) {     if (useConnectionPool) {         getUnauthenticatedSessionWithPool(connectionPool, user, listener).     } else {         getUnauthenticatedSessionWithoutPool(user, listener).     } }
true;abstract;4;2;/**  * Attempts to get a {@link LdapSession} using the provided credentials and makes use of the provided connection pool  */ ;/**  * Attempts to get a {@link LdapSession} using the provided credentials and makes use of the provided connection pool  */ abstract void getSessionWithPool(LDAPConnectionPool connectionPool, String user, SecureString password, ActionListener<LdapSession> listener).
true;abstract;3;1;/**  * Attempts to get a {@link LdapSession} using the provided credentials and opens a new connection to the ldap server  */ ;/**  * Attempts to get a {@link LdapSession} using the provided credentials and opens a new connection to the ldap server  */ abstract void getSessionWithoutPool(String user, SecureString password, ActionListener<LdapSession> listener).
true;abstract;3;1;/**  * Attempts to search using a pooled connection for the user and provides an unauthenticated {@link LdapSession} to the listener if the  * user is found  */ ;/**  * Attempts to search using a pooled connection for the user and provides an unauthenticated {@link LdapSession} to the listener if the  * user is found  */ abstract void getUnauthenticatedSessionWithPool(LDAPConnectionPool connectionPool, String user, ActionListener<LdapSession> listener).
true;abstract;2;1;/**  * Attempts to search using a new connection for the user and provides an unauthenticated {@link LdapSession} to the listener if the  * user is found  */ ;/**  * Attempts to search using a new connection for the user and provides an unauthenticated {@link LdapSession} to the listener if the  * user is found  */ abstract void getUnauthenticatedSessionWithoutPool(String user, ActionListener<LdapSession> listener).
true;static;6;38;/**  * Creates the connection pool that will be used by the session factory and initializes the health check support  */ ;/**  * Creates the connection pool that will be used by the session factory and initializes the health check support  */ static LDAPConnectionPool createConnectionPool(RealmConfig config, ServerSet serverSet, TimeValue timeout, Logger logger, BindRequest bindRequest, Supplier<String> healthCheckDnSupplier) throws LDAPException {     final int initialSize = config.getSetting(PoolingSessionFactorySettings.POOL_INITIAL_SIZE).     final int size = config.getSetting(PoolingSessionFactorySettings.POOL_SIZE).     LDAPConnectionPool pool = null.     boolean success = false.     try {         pool = LdapUtils.privilegedConnect(() -> new LDAPConnectionPool(serverSet, bindRequest, initialSize, size)).         pool.setRetryFailedOperationsDueToInvalidConnections(true).         if (config.getSetting(PoolingSessionFactorySettings.HEALTH_CHECK_ENABLED)) {             String entryDn = config.getSetting(PoolingSessionFactorySettings.HEALTH_CHECK_DN).orElseGet(healthCheckDnSupplier).             final long healthCheckInterval = config.getSetting(PoolingSessionFactorySettings.HEALTH_CHECK_INTERVAL).millis().             if (entryDn != null) {                 // Checks the status of the LDAP connection at a specified interval in the background. We do not check on                 // create as the LDAP server may require authentication to get an entry and a bind request has not been executed                 // yet so we could end up never getting a connection. We do not check on checkout as we always set retry operations                 // and the pool will handle a bad connection without the added latency on every operation                 LDAPConnectionPoolHealthCheck healthCheck = new GetEntryLDAPConnectionPoolHealthCheck(entryDn, timeout.millis(), false, false, false, true, false).                 pool.setHealthCheck(healthCheck).                 pool.setHealthCheckIntervalMillis(healthCheckInterval).             } else {                 logger.warn(new ParameterizedMessage("[{}] and [{}} have not been specified or are not valid distinguished names," + "so connection health checking is disabled", RealmSettings.getFullSettingKey(config, PoolingSessionFactorySettings.BIND_DN), RealmSettings.getFullSettingKey(config, PoolingSessionFactorySettings.HEALTH_CHECK_DN))).             }         }         success = true.         return pool.     } finally {         if (success == false && pool != null) {             pool.close().         }     } }
true;public,final;0;6;/**  * This method is used to cleanup the connection pool if one is being used  */ ;/**  * This method is used to cleanup the connection pool if one is being used  */ @Override public final void close() {     if (connectionPool != null) {         connectionPool.close().     } }
true;;0;3;/**  * For tests use only  *  * @return the connection pool for LDAP queries  */ ;/**  * For tests use only  *  * @return the connection pool for LDAP queries  */ LDAPConnectionPool getConnectionPool() {     return connectionPool. }
