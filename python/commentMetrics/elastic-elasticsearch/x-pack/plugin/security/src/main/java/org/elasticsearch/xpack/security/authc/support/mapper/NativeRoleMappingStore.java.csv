commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(Object o) { // nothing }
false;public;1;4;;@Override public void onFailure(Exception e) { // nothing }
false;private;1;4;;private String getNameFromId(String id) {     assert id.startsWith(ID_PREFIX).     return id.substring(ID_PREFIX.length()). }
false;private;1;3;;private String getIdForName(String name) {     return ID_PREFIX + name. }
true;;1;29;/**  * Loads all mappings from the index.  * <em>package private</em> for unit testing  */ ;/**  * Loads all mappings from the index.  * <em>package private</em> for unit testing  */ void loadMappings(ActionListener<List<ExpressionRoleMapping>> listener) {     if (securityIndex.isIndexUpToDate() == false) {         listener.onFailure(new IllegalStateException("Security index is not on the current version - the native realm will not be operational until " + "the upgrade API is run on the security index")).         return.     }     final QueryBuilder query = QueryBuilders.termQuery(DOC_TYPE_FIELD, DOC_TYPE_ROLE_MAPPING).     final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false).     try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {         SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME).setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)).setTypes(SECURITY_GENERIC_TYPE).setQuery(query).setSize(1000).setFetchSource(true).request().         request.indicesOptions().ignoreUnavailable().         ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, ActionListener.wrap((Collection<ExpressionRoleMapping> mappings) -> listener.onResponse(mappings.stream().filter(Objects::nonNull).collect(Collectors.toList())), ex -> {             logger.error(new ParameterizedMessage("failed to load role mappings from index [{}] skipping all mappings.", SECURITY_INDEX_NAME), ex).             listener.onResponse(Collections.emptyList()).         })), doc -> buildMapping(getNameFromId(doc.getId()), doc.getSourceRef())).     } }
false;private;2;10;;private ExpressionRoleMapping buildMapping(String id, BytesReference source) {     try (InputStream stream = source.streamInput().         XContentParser parser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {         return ExpressionRoleMapping.parse(id, parser).     } catch (Exception e) {         logger.warn(new ParameterizedMessage("Role mapping [{}] cannot be parsed and will be skipped", id), e).         return null.     } }
true;public;2;3;/**  * Stores (create or update) a single mapping in the index  */ ;/**  * Stores (create or update) a single mapping in the index  */ public void putRoleMapping(PutRoleMappingRequest request, ActionListener<Boolean> listener) {     modifyMapping(request.getName(), this::innerPutMapping, request, listener). }
true;public;2;3;/**  * Deletes a named mapping from the index  */ ;/**  * Deletes a named mapping from the index  */ public void deleteRoleMapping(DeleteRoleMappingRequest request, ActionListener<Boolean> listener) {     modifyMapping(request.getName(), this::innerDeleteMapping, request, listener). }
false;private;4;15;;private <Request, Result> void modifyMapping(String name, CheckedBiConsumer<Request, ActionListener<Result>, Exception> inner, Request request, ActionListener<Result> listener) {     if (securityIndex.isIndexUpToDate() == false) {         listener.onFailure(new IllegalStateException("Security index is not on the current version - the native realm will not be operational until " + "the upgrade API is run on the security index")).     } else {         try {             inner.accept(request, ActionListener.wrap(r -> refreshRealms(listener, r), listener::onFailure)).         } catch (Exception e) {             logger.error(new ParameterizedMessage("failed to modify role-mapping [{}]", name), e).             listener.onFailure(e).         }     } }
false;public;1;5;;@Override public void onResponse(IndexResponse indexResponse) {     boolean created = indexResponse.getResult() == CREATED.     listener.onResponse(created). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.error(new ParameterizedMessage("failed to put role-mapping [{}]", mapping.getName()), e).     listener.onFailure(e). }
false;private;2;30;;private void innerPutMapping(PutRoleMappingRequest request, ActionListener<Boolean> listener) {     final ExpressionRoleMapping mapping = request.getMapping().     securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {         final XContentBuilder xContentBuilder.         try {             xContentBuilder = mapping.toXContent(jsonBuilder(), ToXContent.EMPTY_PARAMS, true).         } catch (IOException e) {             listener.onFailure(e).             return.         }         executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareIndex(SECURITY_INDEX_NAME, SECURITY_GENERIC_TYPE, getIdForName(mapping.getName())).setSource(xContentBuilder).setRefreshPolicy(request.getRefreshPolicy()).request(), new ActionListener<IndexResponse>() {              @Override             public void onResponse(IndexResponse indexResponse) {                 boolean created = indexResponse.getResult() == CREATED.                 listener.onResponse(created).             }              @Override             public void onFailure(Exception e) {                 logger.error(new ParameterizedMessage("failed to put role-mapping [{}]", mapping.getName()), e).                 listener.onFailure(e).             }         }, client::index).     }). }
false;public;1;5;;@Override public void onResponse(DeleteResponse deleteResponse) {     boolean deleted = deleteResponse.getResult() == DELETED.     listener.onResponse(deleted). }
false;public;1;6;;@Override public void onFailure(Exception e) {     logger.error(new ParameterizedMessage("failed to delete role-mapping [{}]", request.getName()), e).     listener.onFailure(e). }
false;private;2;30;;private void innerDeleteMapping(DeleteRoleMappingRequest request, ActionListener<Boolean> listener) {     final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze().     if (frozenSecurityIndex.indexExists() == false) {         listener.onResponse(false).     } else if (securityIndex.isAvailable() == false) {         listener.onFailure(frozenSecurityIndex.getUnavailableReason()).     } else {         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {             executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, client.prepareDelete(SECURITY_INDEX_NAME, SECURITY_GENERIC_TYPE, getIdForName(request.getName())).setRefreshPolicy(request.getRefreshPolicy()).request(), new ActionListener<DeleteResponse>() {                  @Override                 public void onResponse(DeleteResponse deleteResponse) {                     boolean deleted = deleteResponse.getResult() == DELETED.                     listener.onResponse(deleted).                 }                  @Override                 public void onFailure(Exception e) {                     logger.error(new ParameterizedMessage("failed to delete role-mapping [{}]", request.getName()), e).                     listener.onFailure(e).                 }             }, client::delete).         }).     } }
false;public;1;7;;@Override public void onResponse(List<ExpressionRoleMapping> mappings) {     final List<ExpressionRoleMapping> filtered = mappings.stream().filter(m -> names.contains(m.getName())).collect(Collectors.toList()).     listener.onResponse(filtered). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
true;public;2;20;/**  * Retrieves one or more mappings from the index.  * If <code>names</code> is <code>null</code> or {@link Set#isEmpty empty}, then this retrieves all mappings.  * Otherwise it retrieves the specified mappings by name.  */ ;/**  * Retrieves one or more mappings from the index.  * If <code>names</code> is <code>null</code> or {@link Set#isEmpty empty}, then this retrieves all mappings.  * Otherwise it retrieves the specified mappings by name.  */ public void getRoleMappings(Set<String> names, ActionListener<List<ExpressionRoleMapping>> listener) {     if (names == null || names.isEmpty()) {         getMappings(listener).     } else {         getMappings(new ActionListener<List<ExpressionRoleMapping>>() {              @Override             public void onResponse(List<ExpressionRoleMapping> mappings) {                 final List<ExpressionRoleMapping> filtered = mappings.stream().filter(m -> names.contains(m.getName())).collect(Collectors.toList()).                 listener.onResponse(filtered).             }              @Override             public void onFailure(Exception e) {                 listener.onFailure(e).             }         }).     } }
false;private;1;16;;private void getMappings(ActionListener<List<ExpressionRoleMapping>> listener) {     if (securityIndex.isAvailable()) {         loadMappings(listener).     } else {         logger.info("The security index is not yet available - no role mappings can be loaded").         if (logger.isDebugEnabled()) {             logger.debug("Security Index [{}] [exists: {}] [available: {}] [mapping up to date: {}]", SECURITY_INDEX_NAME, securityIndex.indexExists(), securityIndex.isAvailable(), securityIndex.isMappingUpToDate()).         }         listener.onResponse(Collections.emptyList()).     } }
true;public;1;7;/**  * Provides usage statistics for this store.  * The resulting map contains the keys  * <ul>  * <li><code>size</code> - The total number of mappings stored in the index</li>  * <li><code>enabled</code> - The number of mappings that are  * {@link ExpressionRoleMapping#isEnabled() enabled}</li>  * </ul>  */ ;/**  * Provides usage statistics for this store.  * The resulting map contains the keys  * <ul>  * <li><code>size</code> - The total number of mappings stored in the index</li>  * <li><code>enabled</code> - The number of mappings that are  * {@link ExpressionRoleMapping#isEnabled() enabled}</li>  * </ul>  */ public void usageStats(ActionListener<Map<String, Object>> listener) {     if (securityIndex.isAvailable() == false) {         reportStats(listener, Collections.emptyList()).     } else {         getMappings(ActionListener.wrap(mappings -> reportStats(listener, mappings), listener::onFailure)).     } }
false;private;2;6;;private void reportStats(ActionListener<Map<String, Object>> listener, List<ExpressionRoleMapping> mappings) {     Map<String, Object> usageStats = new HashMap<>().     usageStats.put("size", mappings.size()).     usageStats.put("enabled", mappings.stream().filter(ExpressionRoleMapping::isEnabled).count()).     listener.onResponse(usageStats). }
false;public;2;6;;public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {     if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState) || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {         refreshRealms(NO_OP_ACTION_LISTENER, null).     } }
false;private;2;17;;private <Result> void refreshRealms(ActionListener<Result> listener, Result result) {     String[] realmNames = this.realmsToRefresh.toArray(new String[realmsToRefresh.size()]).     final SecurityClient securityClient = new SecurityClient(client).     executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, securityClient.prepareClearRealmCache().realms(realmNames).request(), ActionListener.<ClearRealmCacheResponse>wrap(response -> {         logger.debug((org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage("Cleared cached in realms [{}] due to role mapping change", Arrays.toString(realmNames))).         listener.onResponse(result).     }, ex -> {         logger.warn("Failed to clear cache for realms [{}]", Arrays.toString(realmNames)).         listener.onFailure(ex).     }), securityClient::clearRealmCache). }
false;public;2;21;;@Override public void resolveRoles(UserData user, ActionListener<Set<String>> listener) {     getRoleMappings(null, ActionListener.wrap(mappings -> {         final ExpressionModel model = user.asModel().         Stream<ExpressionRoleMapping> stream = mappings.stream().filter(ExpressionRoleMapping::isEnabled).filter(m -> m.getExpression().match(model)).         if (logger.isTraceEnabled()) {             stream = stream.map(m -> {                 logger.trace("User [{}] matches role-mapping [{}] with roles [{}]", user.getUsername(), m.getName(), m.getRoles()).                 return m.             }).         }         final Set<String> roles = stream.flatMap(m -> m.getRoles().stream()).collect(Collectors.toSet()).         logger.debug("Mapping user [{}] to roles [{}]", user, roles).         listener.onResponse(roles).     }, listener::onFailure)). }
true;public;1;4;/**  * Indicates that the provided realm should have its cache cleared if this store is updated  * (that is, {@link #putRoleMapping(PutRoleMappingRequest, ActionListener)} or  * {@link #deleteRoleMapping(DeleteRoleMappingRequest, ActionListener)} are called).  * @see ClearRealmCacheAction  */ ;/**  * Indicates that the provided realm should have its cache cleared if this store is updated  * (that is, {@link #putRoleMapping(PutRoleMappingRequest, ActionListener)} or  * {@link #deleteRoleMapping(DeleteRoleMappingRequest, ActionListener)} are called).  * @see ClearRealmCacheAction  */ @Override public void refreshRealmOnChange(CachingRealm realm) {     realmsToRefresh.add(realm.name()). }
