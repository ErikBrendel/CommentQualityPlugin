commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;public void init() throws SSLException {     engine.setUseClientMode(isClientMode).     if (currentMode.isHandshake()) {         engine.beginHandshake().         ((HandshakeMode) currentMode).startHandshake().     } else {         throw new AssertionError("Attempted to init outside from non-handshaking mode: " + currentMode.modeName()).     } }
true;public;0;9;/**  * Requests a TLS renegotiation. This means the we will request that the peer performs another handshake  * prior to the continued exchange of application data. This can only be requested if we are currently in  * APPLICATION mode.  *  * @throws SSLException if the handshake cannot be initiated  */ ;/**  * Requests a TLS renegotiation. This means the we will request that the peer performs another handshake  * prior to the continued exchange of application data. This can only be requested if we are currently in  * APPLICATION mode.  *  * @throws SSLException if the handshake cannot be initiated  */ public void renegotiate() throws SSLException {     if (currentMode.isApplication()) {         currentMode = new HandshakeMode().         engine.beginHandshake().         ((HandshakeMode) currentMode).startHandshake().     } else {         throw new IllegalStateException("Attempted to renegotiate while in invalid mode: " + currentMode.modeName()).     } }
false;public;0;3;;public SSLEngine getSSLEngine() {     return engine. }
false;public;0;3;;public boolean hasFlushPending() {     return networkWriteBuffer.hasRemaining(). }
false;public;0;3;;public boolean isHandshaking() {     return currentMode.isHandshake(). }
false;public;0;3;;public ByteBuffer getNetworkWriteBuffer() {     return networkWriteBuffer. }
false;public;0;3;;public ByteBuffer getNetworkReadBuffer() {     return networkReadBuffer. }
false;public;1;9;;public void read(InboundChannelBuffer buffer) throws SSLException {     Mode modePriorToRead.     do {         modePriorToRead = currentMode.         currentMode.read(buffer).     // If we switched modes we want to read again as there might be unhandled bytes that need to be     // handled by the new mode.     } while (modePriorToRead != currentMode). }
false;public;0;3;;public boolean readyForApplicationWrites() {     return currentMode.isApplication(). }
false;public;0;3;;public boolean needsNonApplicationWrite() {     return currentMode.needsNonApplicationWrite(). }
false;public;1;4;;public int applicationWrite(ByteBuffer[] buffers) throws SSLException {     assert readyForApplicationWrites() : "Should not be called if driver is not ready for application writes".     return currentMode.write(buffers). }
false;public;0;8;;public void nonApplicationWrite() throws SSLException {     assert currentMode.isApplication() == false : "Should not be called if driver is in application mode".     if (currentMode.isApplication() == false) {         currentMode.write(EMPTY_BUFFER_ARRAY).     } else {         throw new AssertionError("Attempted to non-application write from invalid mode: " + currentMode.modeName()).     } }
false;public;0;3;;public void initiateClose() {     closingInternal(). }
false;public;0;3;;public boolean isClosed() {     return currentMode.isClose() && ((CloseMode) currentMode).isCloseDone(). }
false;public;0;16;;@Override public void close() throws SSLException {     ArrayList<SSLException> closingExceptions = new ArrayList<>(2).     closingInternal().     CloseMode closeMode = (CloseMode) this.currentMode.     if (closeMode.needToSendClose) {         closingExceptions.add(new SSLException("Closed engine without completely sending the close alert message.")).         engine.closeOutbound().     }     if (closeMode.needToReceiveClose) {         closingExceptions.add(new SSLException("Closed engine without receiving the close alert message.")).         closeMode.closeInboundAndSwallowPeerDidNotCloseException().     }     ExceptionsHelper.rethrowAndSuppress(closingExceptions). }
false;private;1;31;;private SSLEngineResult unwrap(InboundChannelBuffer buffer) throws SSLException {     while (true) {         SSLEngineResult result = engine.unwrap(networkReadBuffer, buffer.sliceBuffersFrom(buffer.getIndex())).         buffer.incrementIndex(result.bytesProduced()).         switch(result.getStatus()) {             case OK:                 networkReadBuffer.compact().                 return result.             case BUFFER_UNDERFLOW:                 // There is not enough space in the network buffer for an entire SSL packet. Compact the                 // current data and expand the buffer if necessary.                 int currentCapacity = networkReadBuffer.capacity().                 ensureNetworkReadBufferSize().                 if (currentCapacity == networkReadBuffer.capacity()) {                     networkReadBuffer.compact().                 }                 return result.             case BUFFER_OVERFLOW:                 // There is not enough space in the application buffer for the decrypted message. Expand                 // the application buffer to ensure that it has enough space.                 ensureApplicationBufferSize(buffer).                 break.             case CLOSED:                 assert engine.isInboundDone() : "We received close_notify so read should be done".                 closingInternal().                 return result.             default:                 throw new IllegalStateException("Unexpected UNWRAP result: " + result.getStatus()).         }     } }
false;private;1;45;;private SSLEngineResult wrap(ByteBuffer[] buffers) throws SSLException {     assert hasFlushPending() == false : "Should never called with pending writes".     networkWriteBuffer.clear().     while (true) {         SSLEngineResult result.         try {             if (buffers.length == 1) {                 result = engine.wrap(buffers[0], networkWriteBuffer).             } else {                 result = engine.wrap(buffers, networkWriteBuffer).             }         } catch (SSLException e) {             networkWriteBuffer.position(networkWriteBuffer.limit()).             throw e.         }         switch(result.getStatus()) {             case OK:                 networkWriteBuffer.flip().                 return result.             case BUFFER_UNDERFLOW:                 throw new IllegalStateException("Should not receive BUFFER_UNDERFLOW on WRAP").             case BUFFER_OVERFLOW:                 // There is not enough space in the network buffer for an entire SSL packet. Expand the                 // buffer if it's smaller than the current session packet size. Otherwise return and wait                 // for existing data to be flushed.                 int currentCapacity = networkWriteBuffer.capacity().                 ensureNetworkWriteBufferSize().                 if (currentCapacity == networkWriteBuffer.capacity()) {                     return result.                 }                 break.             case CLOSED:                 if (result.bytesProduced() > 0) {                     networkWriteBuffer.flip().                 } else {                     assert false : "WRAP during close processing should produce close message.".                 }                 return result.             default:                 throw new IllegalStateException("Unexpected WRAP result: " + result.getStatus()).         }     } }
false;private;0;6;;private void closingInternal() {     // This check prevents us from attempting to send close_notify twice     if (currentMode.isClose() == false) {         currentMode = new CloseMode(currentMode.isHandshake()).     } }
false;private;1;6;;private void ensureApplicationBufferSize(InboundChannelBuffer applicationBuffer) {     int applicationBufferSize = engine.getSession().getApplicationBufferSize().     if (applicationBuffer.getRemaining() < applicationBufferSize) {         applicationBuffer.ensureCapacity(applicationBuffer.getIndex() + engine.getSession().getApplicationBufferSize()).     } }
false;private;0;3;;private void ensureNetworkWriteBufferSize() {     networkWriteBuffer = ensureNetBufferSize(networkWriteBuffer). }
false;private;0;3;;private void ensureNetworkReadBufferSize() {     networkReadBuffer = ensureNetBufferSize(networkReadBuffer). }
false;private;1;11;;private ByteBuffer ensureNetBufferSize(ByteBuffer current) {     int networkPacketSize = engine.getSession().getPacketBufferSize().     if (current.capacity() < networkPacketSize) {         ByteBuffer newBuffer = ByteBuffer.allocate(networkPacketSize).         current.flip().         newBuffer.put(current).         return newBuffer.     } else {         return current.     } }
false;;1;1;;void read(InboundChannelBuffer buffer) throws SSLException.
false;;1;1;;int write(ByteBuffer[] buffers) throws SSLException.
false;;0;1;;boolean needsNonApplicationWrite().
false;;0;1;;boolean isHandshake().
false;;0;1;;boolean isApplication().
false;;0;1;;boolean isClose().
false;;0;1;;String modeName().
false;private;0;12;;private void startHandshake() throws SSLException {     handshakeStatus = engine.getHandshakeStatus().     if (handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_UNWRAP && handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_WRAP) {         try {             handshake().         } catch (SSLException e) {             closingInternal().             throw e.         }     } }
false;private;0;32;;private void handshake() throws SSLException {     boolean continueHandshaking = true.     while (continueHandshaking) {         switch(handshakeStatus) {             case NEED_UNWRAP:                 // We UNWRAP as much as possible immediately after a read. Do not need to do it here.                 continueHandshaking = false.                 break.             case NEED_WRAP:                 if (hasFlushPending() == false) {                     handshakeStatus = wrap(EMPTY_BUFFER_ARRAY).getHandshakeStatus().                 }                 // If we need NEED_TASK we should run the tasks immediately                 if (handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_TASK) {                     continueHandshaking = false.                 }                 break.             case NEED_TASK:                 runTasks().                 handshakeStatus = engine.getHandshakeStatus().                 break.             case NOT_HANDSHAKING:                 maybeFinishHandshake().                 continueHandshaking = false.                 break.             case FINISHED:                 maybeFinishHandshake().                 continueHandshaking = false.                 break.         }     } }
false;public;1;18;;@Override public void read(InboundChannelBuffer buffer) throws SSLException {     ensureApplicationBufferSize(buffer).     boolean continueUnwrap = true.     while (continueUnwrap && networkReadBuffer.position() > 0) {         networkReadBuffer.flip().         try {             SSLEngineResult result = unwrap(buffer).             handshakeStatus = result.getHandshakeStatus().             handshake().             // If we are done handshaking we should exit the handshake read             continueUnwrap = result.bytesConsumed() > 0 && currentMode.isHandshake().         } catch (SSLException e) {             closingInternal().             throw e.         }     } }
false;public;1;10;;@Override public int write(ByteBuffer[] buffers) throws SSLException {     try {         handshake().     } catch (SSLException e) {         closingInternal().         throw e.     }     return 0. }
false;public;0;6;;@Override public boolean needsNonApplicationWrite() {     return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED. }
false;public;0;4;;@Override public boolean isHandshake() {     return true. }
false;public;0;4;;@Override public boolean isApplication() {     return false. }
false;public;0;4;;@Override public boolean isClose() {     return false. }
false;public;0;4;;@Override public String modeName() {     return "HANDSHAKE". }
false;private;0;6;;private void runTasks() {     Runnable delegatedTask.     while ((delegatedTask = engine.getDelegatedTask()) != null) {         delegatedTask.run().     } }
false;private;0;19;;private void maybeFinishHandshake() {     if (engine.isOutboundDone() || engine.isInboundDone()) {         // If the engine is partially closed, immediate transition to close mode.         if (currentMode.isHandshake()) {             currentMode = new CloseMode(true).         } else {             String message = "Expected to be in handshaking mode. Instead in non-handshaking mode: " + currentMode.             throw new AssertionError(message).         }     } else if (hasFlushPending() == false) {         // We only acknowledge that we are done handshaking if there are no bytes that need to be written         if (currentMode.isHandshake()) {             currentMode = new ApplicationMode().         } else {             String message = "Attempted to transition to application mode from non-handshaking mode: " + currentMode.             throw new AssertionError(message).         }     } }
false;public;1;12;;@Override public void read(InboundChannelBuffer buffer) throws SSLException {     ensureApplicationBufferSize(buffer).     boolean continueUnwrap = true.     while (continueUnwrap && networkReadBuffer.position() > 0) {         networkReadBuffer.flip().         SSLEngineResult result = unwrap(buffer).         boolean renegotiationRequested = result.getStatus() != SSLEngineResult.Status.CLOSED && maybeRenegotiation(result.getHandshakeStatus()).         continueUnwrap = result.bytesProduced() > 0 && renegotiationRequested == false.     } }
false;public;1;6;;@Override public int write(ByteBuffer[] buffers) throws SSLException {     SSLEngineResult result = wrap(buffers).     maybeRenegotiation(result.getHandshakeStatus()).     return result.bytesConsumed(). }
false;private;1;8;;private boolean maybeRenegotiation(SSLEngineResult.HandshakeStatus newStatus) throws SSLException {     if (newStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING && newStatus != SSLEngineResult.HandshakeStatus.FINISHED) {         renegotiate().         return true.     } else {         return false.     } }
false;public;0;4;;@Override public boolean needsNonApplicationWrite() {     return false. }
false;public;0;4;;@Override public boolean isHandshake() {     return false. }
false;public;0;4;;@Override public boolean isApplication() {     return true. }
false;public;0;4;;@Override public boolean isClose() {     return false. }
false;public;0;4;;@Override public String modeName() {     return "APPLICATION". }
false;public;1;21;;@Override public void read(InboundChannelBuffer buffer) throws SSLException {     if (needToReceiveClose == false) {         // receive close, we will not handle reads.         return.     }     ensureApplicationBufferSize(buffer).     boolean continueUnwrap = true.     while (continueUnwrap && networkReadBuffer.position() > 0) {         networkReadBuffer.flip().         SSLEngineResult result = unwrap(buffer).         continueUnwrap = result.bytesProduced() > 0 || result.bytesConsumed() > 0.     }     if (engine.isInboundDone()) {         needToReceiveClose = false.     } }
false;public;1;14;;@Override public int write(ByteBuffer[] buffers) throws SSLException {     if (hasFlushPending() == false && engine.isOutboundDone()) {         needToSendClose = false.         // Close inbound if it is still open and we have decided not to wait for response.         if (needToReceiveClose == false && engine.isInboundDone() == false) {             closeInboundAndSwallowPeerDidNotCloseException().         }     } else {         wrap(EMPTY_BUFFER_ARRAY).         assert hasFlushPending() : "Should have produced close message".     }     return 0. }
false;public;0;4;;@Override public boolean needsNonApplicationWrite() {     return needToSendClose. }
false;public;0;4;;@Override public boolean isHandshake() {     return false. }
false;public;0;4;;@Override public boolean isApplication() {     return false. }
false;public;0;4;;@Override public boolean isClose() {     return true. }
false;public;0;4;;@Override public String modeName() {     return "CLOSE". }
false;private;0;3;;private boolean isCloseDone() {     return needToSendClose == false && needToReceiveClose == false. }
false;private;0;9;;private void closeInboundAndSwallowPeerDidNotCloseException() throws SSLException {     try {         engine.closeInbound().     } catch (SSLException e) {         if (e.getMessage().contains("before receiving peer's close_notify") == false) {             throw e.         }     } }
