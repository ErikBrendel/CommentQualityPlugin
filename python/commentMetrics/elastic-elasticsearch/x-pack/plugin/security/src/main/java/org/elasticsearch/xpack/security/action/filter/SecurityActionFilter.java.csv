commented;modifiers;parameterAmount;loc;comment;code
false;public;5;58;;@Override public <Request extends ActionRequest, Response extends ActionResponse> void apply(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> chain) {     /*          A functional requirement - when the license of security is disabled (invalid/expires), security will continue          to operate normally, except all read operations will be blocked.          */     if (licenseState.isStatsAndHealthAllowed() == false && LICENSE_EXPIRATION_ACTION_MATCHER.test(action)) {         logger.error("blocking [{}] operation due to expired license. Cluster health, cluster stats and indices stats \n" + "operations are blocked on license expiration. All data operations (read and write) continue to work. \n" + "If you have a new license, please update it. Otherwise, please reach out to your support contact.", action).         throw LicenseUtils.newComplianceException(XPackField.SECURITY).     }     if (licenseState.isAuthAllowed()) {         final ActionListener<Response> contextPreservingListener = ContextPreservingActionListener.wrapPreservingContext(listener, threadContext).         ActionListener<Void> authenticatedListener = ActionListener.wrap((aVoid) -> chain.proceed(task, action, request, contextPreservingListener), contextPreservingListener::onFailure).         final boolean useSystemUser = AuthorizationUtils.shouldReplaceUserWithSystem(threadContext, action).         try {             if (useSystemUser) {                 securityContext.executeAsUser(SystemUser.INSTANCE, (original) -> {                     try {                         applyInternal(action, request, authenticatedListener).                     } catch (IOException e) {                         listener.onFailure(e).                     }                 }, Version.CURRENT).             } else if (AuthorizationUtils.shouldSetUserBasedOnActionOrigin(threadContext)) {                 AuthorizationUtils.switchUserBasedOnActionOriginAndExecute(threadContext, securityContext, (original) -> {                     try {                         applyInternal(action, request, authenticatedListener).                     } catch (IOException e) {                         listener.onFailure(e).                     }                 }).             } else {                 try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(true)) {                     applyInternal(action, request, authenticatedListener).                 }             }         } catch (Exception e) {             listener.onFailure(e).         }     } else if (SECURITY_ACTION_MATCHER.test(action)) {         if (licenseState.isSecurityDisabledByTrialLicense()) {             listener.onFailure(new ElasticsearchException("Security must be explicitly enabled when using a trial license. " + "Enable security by setting [xpack.security.enabled] to [true] in the elasticsearch.yml file " + "and restart the node.")).         } else {             listener.onFailure(LicenseUtils.newComplianceException(XPackField.SECURITY)).         }     } else {         chain.proceed(task, action, request, listener).     } }
false;public;0;4;;@Override public int order() {     return Integer.MIN_VALUE. }
false;private;3;34;;private <Request extends ActionRequest> void applyInternal(String action, Request request, ActionListener<Void> listener) throws IOException {     if (CloseIndexAction.NAME.equals(action) || OpenIndexAction.NAME.equals(action) || DeleteIndexAction.NAME.equals(action)) {         IndicesRequest indicesRequest = (IndicesRequest) request.         try {             destructiveOperations.failDestructive(indicesRequest.indices()).         } catch (IllegalArgumentException e) {             listener.onFailure(e).             return.         }     }     /*          here we fallback on the system user. Internal system requests are requests that are triggered by          the system itself (e.g. pings, update mappings, share relocation, etc...) and were not originated          by user interaction. Since these requests are triggered by es core modules, they are security          agnostic and therefore not associated with any user. When these requests execute locally, they          are executed directly on their relevant action. Since there is no other way a request can make          it to the action without an associated user (not via REST or transport - this is taken care of by          the {@link Rest} filter and the {@link ServerTransport} filter respectively), it's safe to assume a system user          here if a request is not associated with any other user.          */     final String securityAction = actionMapper.action(action, request).     authcService.authenticate(securityAction, request, SystemUser.INSTANCE, ActionListener.wrap((authc) -> {         if (authc != null) {             authorizeRequest(authc, securityAction, request, listener).         } else if (licenseState.isAuthAllowed() == false) {             listener.onResponse(null).         } else {             listener.onFailure(new IllegalStateException("no authentication present but auth is allowed")).         }     }, listener::onFailure)). }
false;private;4;9;;private <Request extends ActionRequest> void authorizeRequest(Authentication authentication, String securityAction, Request request, ActionListener<Void> listener) {     if (authentication == null) {         listener.onFailure(new IllegalArgumentException("authentication must be non null for authorization")).     } else {         authzService.authorize(authentication, securityAction, request, ActionListener.wrap(ignore -> listener.onResponse(null), listener::onFailure)).     } }
