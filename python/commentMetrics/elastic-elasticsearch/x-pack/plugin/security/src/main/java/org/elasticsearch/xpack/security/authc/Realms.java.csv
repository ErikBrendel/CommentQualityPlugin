commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Override public Iterator<Realm> iterator() {     if (licenseState.isAuthAllowed() == false) {         return Collections.emptyIterator().     }     AllowedRealmType allowedRealmType = licenseState.allowedRealmType().     switch(allowedRealmType) {         case ALL:             return realms.iterator().         case DEFAULT:             return standardRealmsOnly.iterator().         case NATIVE:             return nativeRealmsOnly.iterator().         default:             throw new IllegalStateException("authentication should not be enabled").     } }
false;public;0;3;;public Stream<Realm> stream() {     return StreamSupport.stream(this.spliterator(), false). }
false;public;0;17;;public List<Realm> asList() {     if (licenseState.isAuthAllowed() == false) {         return Collections.emptyList().     }     AllowedRealmType allowedRealmType = licenseState.allowedRealmType().     switch(allowedRealmType) {         case ALL:             return Collections.unmodifiableList(realms).         case DEFAULT:             return Collections.unmodifiableList(standardRealmsOnly).         case NATIVE:             return Collections.unmodifiableList(nativeRealmsOnly).         default:             throw new IllegalStateException("authentication should not be enabled").     } }
false;public;1;8;;public Realm realm(String name) {     for (Realm realm : realms) {         if (name.equals(realm.name())) {             return realm.         }     }     return null. }
false;public;1;3;;public Realm.Factory realmFactory(String type) {     return factories.get(type). }
false;protected;0;47;;protected List<Realm> initRealms() throws Exception {     Map<RealmConfig.RealmIdentifier, Settings> realmsSettings = RealmSettings.getRealmSettings(settings).     Set<String> internalTypes = new HashSet<>().     List<Realm> realms = new ArrayList<>().     List<String> kerberosRealmNames = new ArrayList<>().     for (RealmConfig.RealmIdentifier identifier : realmsSettings.keySet()) {         Realm.Factory factory = factories.get(identifier.getType()).         if (factory == null) {             throw new IllegalArgumentException("unknown realm type [" + identifier.getType() + "] for realm [" + identifier + "]").         }         RealmConfig config = new RealmConfig(identifier, settings, env, threadContext).         if (!config.enabled()) {             if (logger.isDebugEnabled()) {                 logger.debug("realm [{}] is disabled", identifier).             }             continue.         }         if (FileRealmSettings.TYPE.equals(identifier.getType()) || NativeRealmSettings.TYPE.equals(identifier.getType())) {             // (there can only be one instance of an internal realm)             if (internalTypes.contains(identifier.getType())) {                 throw new IllegalArgumentException("multiple [" + identifier.getType() + "] realms are configured. [" + identifier.getType() + "] is an internal realm and therefore there can only be one such realm configured").             }             internalTypes.add(identifier.getType()).         }         if (KerberosRealmSettings.TYPE.equals(identifier.getType())) {             kerberosRealmNames.add(identifier.getName()).             if (kerberosRealmNames.size() > 1) {                 throw new IllegalArgumentException("multiple realms " + kerberosRealmNames.toString() + " configured of type [" + identifier.getType() + "], [" + identifier.getType() + "] can only have one such realm " + "configured").             }         }         realms.add(factory.create(config)).     }     if (!realms.isEmpty()) {         Collections.sort(realms).     } else {         // there is no "realms" configuration, add the defaults         addNativeRealms(realms).     }     // always add built in first!     realms.add(0, reservedRealm).     return realms. }
false;public;1;62;;public void usageStats(ActionListener<Map<String, Object>> listener) {     Map<String, Object> realmMap = new HashMap<>().     final AtomicBoolean failed = new AtomicBoolean(false).     final List<Realm> realmList = asList().stream().filter(r -> ReservedRealm.TYPE.equals(r.type()) == false).collect(Collectors.toList()).     final CountDown countDown = new CountDown(realmList.size()).     final Runnable doCountDown = () -> {         if ((realmList.isEmpty() || countDown.countDown()) && failed.get() == false) {             final AllowedRealmType allowedRealmType = licenseState.allowedRealmType().             // iterate over the factories so we can add enabled & available info             for (String type : factories.keySet()) {                 assert ReservedRealm.TYPE.equals(type) == false.                 realmMap.compute(type, (key, value) -> {                     if (value == null) {                         return MapBuilder.<String, Object>newMapBuilder().put("enabled", false).put("available", isRealmTypeAvailable(allowedRealmType, type)).map().                     }                     assert value instanceof Map.                     Map<String, Object> realmTypeUsage = (Map<String, Object>) value.                     realmTypeUsage.put("enabled", true).                     // the realms iterator returned this type so it must be enabled                     assert isRealmTypeAvailable(allowedRealmType, type).                     realmTypeUsage.put("available", true).                     return value.                 }).             }             listener.onResponse(realmMap).         }     }.     if (realmList.isEmpty()) {         doCountDown.run().     } else {         for (Realm realm : realmList) {             realm.usageStats(ActionListener.wrap(stats -> {                 if (failed.get() == false) {                     synchronized (realmMap) {                         realmMap.compute(realm.type(), (key, value) -> {                             if (value == null) {                                 Object realmTypeUsage = convertToMapOfLists(stats).                                 return realmTypeUsage.                             }                             assert value instanceof Map.                             combineMaps((Map<String, Object>) value, stats).                             return value.                         }).                     }                     doCountDown.run().                 }             }, e -> {                 if (failed.compareAndSet(false, true)) {                     listener.onFailure(e).                 }             })).         }     } }
false;private;1;14;;private void addNativeRealms(List<Realm> realms) throws Exception {     Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE).     if (fileRealm != null) {         realms.add(fileRealm.create(new RealmConfig(new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, "default_" + FileRealmSettings.TYPE), settings, env, threadContext))).     }     Realm.Factory indexRealmFactory = factories.get(NativeRealmSettings.TYPE).     if (indexRealmFactory != null) {         realms.add(indexRealmFactory.create(new RealmConfig(new RealmConfig.RealmIdentifier(NativeRealmSettings.TYPE, "default_" + NativeRealmSettings.TYPE), settings, env, threadContext))).     } }
false;private,static;2;13;;private static void combineMaps(Map<String, Object> mapA, Map<String, Object> mapB) {     for (Entry<String, Object> entry : mapB.entrySet()) {         mapA.compute(entry.getKey(), (key, value) -> {             if (value == null) {                 return new ArrayList<>(Collections.singletonList(entry.getValue())).             }             assert value instanceof List.             ((List) value).add(entry.getValue()).             return value.         }).     } }
false;private,static;1;7;;private static Map<String, Object> convertToMapOfLists(Map<String, Object> map) {     Map<String, Object> converted = new HashMap<>(map.size()).     for (Entry<String, Object> entry : map.entrySet()) {         converted.put(entry.getKey(), new ArrayList<>(Collections.singletonList(entry.getValue()))).     }     return converted. }
false;public,static;2;14;;public static boolean isRealmTypeAvailable(AllowedRealmType enabledRealmType, String type) {     switch(enabledRealmType) {         case ALL:             return true.         case NONE:             return false.         case NATIVE:             return FileRealmSettings.TYPE.equals(type) || NativeRealmSettings.TYPE.equals(type).         case DEFAULT:             return InternalRealms.isStandardRealm(type) || ReservedRealm.TYPE.equals(type).         default:             throw new IllegalStateException("unknown enabled realm type [" + enabledRealmType + "]").     } }
