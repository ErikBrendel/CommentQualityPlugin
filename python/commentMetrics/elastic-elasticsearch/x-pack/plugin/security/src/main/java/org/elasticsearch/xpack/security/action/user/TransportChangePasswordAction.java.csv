commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(Void v) {     listener.onResponse(new ChangePasswordResponse()). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;3;29;;@Override protected void doExecute(Task task, ChangePasswordRequest request, ActionListener<ChangePasswordResponse> listener) {     final String username = request.username().     if (AnonymousUser.isAnonymousUsername(username, settings)) {         listener.onFailure(new IllegalArgumentException("user [" + username + "] is anonymous and cannot be modified via the API")).         return.     } else if (SystemUser.NAME.equals(username) || XPackUser.NAME.equals(username)) {         listener.onFailure(new IllegalArgumentException("user [" + username + "] is internal")).         return.     }     final String requestPwdHashAlgo = Hasher.resolveFromHash(request.passwordHash()).name().     final String configPwdHashAlgo = Hasher.resolve(XPackSettings.PASSWORD_HASHING_ALGORITHM.get(settings)).name().     if (requestPwdHashAlgo.equalsIgnoreCase(configPwdHashAlgo) == false) {         listener.onFailure(new IllegalArgumentException("incorrect password hashing algorithm [" + requestPwdHashAlgo + "] used while" + " [" + configPwdHashAlgo + "] is configured.")).         return.     }     nativeUsersStore.changePassword(request, new ActionListener<Void>() {          @Override         public void onResponse(Void v) {             listener.onResponse(new ChangePasswordResponse()).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
