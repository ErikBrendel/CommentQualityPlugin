commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;3;;private static void runStartupChecks(Settings settings) {     validateRealmSettings(settings). }
false;public;0;42;;@Override public Collection<Module> createGuiceModules() {     List<Module> modules = new ArrayList<>().     if (enabled == false || transportClientMode) {         modules.add(b -> b.bind(IPFilter.class).toProvider(Providers.of(null))).     }     if (transportClientMode) {         if (enabled == false) {             return modules.         }         modules.add(b -> {             // for transport client we still must inject these ssl classes with guice             b.bind(SSLService.class).toInstance(getSslService()).         }).         return modules.     }     modules.add(b -> XPackPlugin.bindFeatureSet(b, SecurityFeatureSet.class)).     if (enabled == false) {         modules.add(b -> {             // for SecurityFeatureSet             b.bind(Realms.class).toProvider(Providers.of(null)).             // for SecurityFeatureSet             b.bind(CompositeRolesStore.class).toProvider(Providers.of(null)).             // for SecurityFeatureSet             b.bind(NativeRoleMappingStore.class).toProvider(Providers.of(null)).             b.bind(AuditTrailService.class).toInstance(new AuditTrailService(Collections.emptyList(), getLicenseState())).         }).         return modules.     }     // we can't load that at construction time since the license plugin might not have been loaded at that point     // which might not be the case during Plugin class instantiation. Once nodeModules are pulled     // everything should have been loaded     modules.add(b -> {         if (XPackSettings.AUDIT_ENABLED.get(settings)) {             // interface used by some actions...             b.bind(AuditTrail.class).to(AuditTrailService.class).         }     }).     return modules. }
true;protected;0;3;// overridable by tests ;// overridable by tests protected Clock getClock() {     return Clock.systemUTC(). }
false;protected;0;1;;protected SSLService getSslService() {     return XPackPlugin.getSharedSslService(). }
false;protected;0;1;;protected XPackLicenseState getLicenseState() {     return XPackPlugin.getSharedLicenseState(). }
false;public;9;11;;@Override public Collection<Object> createComponents(Client client, ClusterService clusterService, ThreadPool threadPool, ResourceWatcherService resourceWatcherService, ScriptService scriptService, NamedXContentRegistry xContentRegistry, Environment environment, NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry) {     try {         return createComponents(client, threadPool, clusterService, resourceWatcherService).     } catch (final Exception e) {         throw new IllegalStateException("security initialization failed", e).     } }
true;;4;109;// pkg private for testing - tests want to pass in their set of extensions hence we are not using the extension service directly ;// pkg private for testing - tests want to pass in their set of extensions hence we are not using the extension service directly Collection<Object> createComponents(Client client, ThreadPool threadPool, ClusterService clusterService, ResourceWatcherService resourceWatcherService) throws Exception {     if (enabled == false) {         return Collections.emptyList().     }     threadContext.set(threadPool.getThreadContext()).     List<Object> components = new ArrayList<>().     securityContext.set(new SecurityContext(settings, threadPool.getThreadContext())).     components.add(securityContext.get()).     // audit trail service construction     final List<AuditTrail> auditTrails = XPackSettings.AUDIT_ENABLED.get(settings) ? Collections.singletonList(new LoggingAuditTrail(settings, clusterService, threadPool)) : Collections.emptyList().     final AuditTrailService auditTrailService = new AuditTrailService(auditTrails, getLicenseState()).     components.add(auditTrailService).     this.auditTrailService.set(auditTrailService).     securityIndex.set(new SecurityIndexManager(client, SecurityIndexManager.SECURITY_INDEX_NAME, clusterService)).     final TokenService tokenService = new TokenService(settings, Clock.systemUTC(), client, securityIndex.get(), clusterService).     this.tokenService.set(tokenService).     components.add(tokenService).     // realms construction     final NativeUsersStore nativeUsersStore = new NativeUsersStore(settings, client, securityIndex.get()).     final NativeRoleMappingStore nativeRoleMappingStore = new NativeRoleMappingStore(settings, client, securityIndex.get()).     final AnonymousUser anonymousUser = new AnonymousUser(settings).     final ReservedRealm reservedRealm = new ReservedRealm(env, settings, nativeUsersStore, anonymousUser, securityIndex.get(), threadPool).     Map<String, Realm.Factory> realmFactories = new HashMap<>(InternalRealms.getFactories(threadPool, resourceWatcherService, getSslService(), nativeUsersStore, nativeRoleMappingStore, securityIndex.get())).     for (SecurityExtension extension : securityExtensions) {         Map<String, Realm.Factory> newRealms = extension.getRealms(resourceWatcherService).         for (Map.Entry<String, Realm.Factory> entry : newRealms.entrySet()) {             if (realmFactories.put(entry.getKey(), entry.getValue()) != null) {                 throw new IllegalArgumentException("Realm type [" + entry.getKey() + "] is already registered").             }         }     }     final Realms realms = new Realms(settings, env, realmFactories, getLicenseState(), threadPool.getThreadContext(), reservedRealm).     components.add(nativeUsersStore).     components.add(nativeRoleMappingStore).     components.add(realms).     components.add(reservedRealm).     securityIndex.get().addIndexStateListener(nativeRoleMappingStore::onSecurityIndexStateChange).     final NativePrivilegeStore privilegeStore = new NativePrivilegeStore(settings, client, securityIndex.get()).     components.add(privilegeStore).     final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(settings).     final FileRolesStore fileRolesStore = new FileRolesStore(settings, env, resourceWatcherService, getLicenseState()).     final NativeRolesStore nativeRolesStore = new NativeRolesStore(settings, client, getLicenseState(), securityIndex.get()).     final ReservedRolesStore reservedRolesStore = new ReservedRolesStore().     List<BiConsumer<Set<String>, ActionListener<RoleRetrievalResult>>> rolesProviders = new ArrayList<>().     for (SecurityExtension extension : securityExtensions) {         rolesProviders.addAll(extension.getRolesProviders(settings, resourceWatcherService)).     }     final ApiKeyService apiKeyService = new ApiKeyService(settings, Clock.systemUTC(), client, securityIndex.get(), clusterService, threadPool).     components.add(apiKeyService).     final CompositeRolesStore allRolesStore = new CompositeRolesStore(settings, fileRolesStore, nativeRolesStore, reservedRolesStore, privilegeStore, rolesProviders, threadPool.getThreadContext(), getLicenseState(), fieldPermissionsCache, apiKeyService).     securityIndex.get().addIndexStateListener(allRolesStore::onSecurityIndexStateChange).     // to keep things simple, just invalidate all cached entries on license change. this happens so rarely that the impact should be     // minimal     getLicenseState().addListener(allRolesStore::invalidateAll).     final AuthenticationFailureHandler failureHandler = createAuthenticationFailureHandler(realms).     authcService.set(new AuthenticationService(settings, realms, auditTrailService, failureHandler, threadPool, anonymousUser, tokenService, apiKeyService)).     components.add(authcService.get()).     securityIndex.get().addIndexStateListener(authcService.get()::onSecurityIndexStateChange).     Set<RequestInterceptor> requestInterceptors = Sets.newHashSet(new ResizeRequestInterceptor(threadPool, getLicenseState(), auditTrailService), new IndicesAliasesRequestInterceptor(threadPool.getThreadContext(), getLicenseState(), auditTrailService)).     if (XPackSettings.DLS_FLS_ENABLED.get(settings)) {         requestInterceptors.addAll(Arrays.asList(new SearchRequestInterceptor(threadPool, getLicenseState()), new UpdateRequestInterceptor(threadPool, getLicenseState()), new BulkShardRequestInterceptor(threadPool, getLicenseState()))).     }     requestInterceptors = Collections.unmodifiableSet(requestInterceptors).     final AuthorizationService authzService = new AuthorizationService(settings, allRolesStore, clusterService, auditTrailService, failureHandler, threadPool, anonymousUser, getAuthorizationEngine(), requestInterceptors, getLicenseState()).     // used by roles actions     components.add(nativeRolesStore).     // used by roles actions     components.add(reservedRolesStore).     // for SecurityFeatureSet and clear roles cache     components.add(allRolesStore).     components.add(authzService).     ipFilter.set(new IPFilter(settings, auditTrailService, clusterService.getClusterSettings(), getLicenseState())).     components.add(ipFilter.get()).     DestructiveOperations destructiveOperations = new DestructiveOperations(settings, clusterService.getClusterSettings()).     securityInterceptor.set(new SecurityServerTransportInterceptor(settings, threadPool, authcService.get(), authzService, getLicenseState(), getSslService(), securityContext.get(), destructiveOperations, clusterService)).     securityActionFilter.set(new SecurityActionFilter(authcService.get(), authzService, getLicenseState(), threadPool, securityContext.get(), destructiveOperations)).     return components. }
false;private;0;18;;private AuthorizationEngine getAuthorizationEngine() {     AuthorizationEngine authorizationEngine = null.     String extensionName = null.     for (SecurityExtension extension : securityExtensions) {         final AuthorizationEngine extensionEngine = extension.getAuthorizationEngine(settings).         if (extensionEngine != null && authorizationEngine != null) {             throw new IllegalStateException("Extensions [" + extensionName + "] and [" + extension.toString() + "] " + "both set an authorization engine").         }         authorizationEngine = extensionEngine.         extensionName = extension.toString().     }     if (authorizationEngine != null) {         logger.debug("Using authorization engine from extension [" + extensionName + "]").     }     return authorizationEngine. }
false;private;1;45;;private AuthenticationFailureHandler createAuthenticationFailureHandler(final Realms realms) {     AuthenticationFailureHandler failureHandler = null.     String extensionName = null.     for (SecurityExtension extension : securityExtensions) {         AuthenticationFailureHandler extensionFailureHandler = extension.getAuthenticationFailureHandler().         if (extensionFailureHandler != null && failureHandler != null) {             throw new IllegalStateException("Extensions [" + extensionName + "] and [" + extension.toString() + "] " + "both set an authentication failure handler").         }         failureHandler = extensionFailureHandler.         extensionName = extension.toString().     }     if (failureHandler == null) {         logger.debug("Using default authentication failure handler").         final Map<String, List<String>> defaultFailureResponseHeaders = new HashMap<>().         realms.asList().stream().forEach((realm) -> {             Map<String, List<String>> realmFailureHeaders = realm.getAuthenticationFailureHeaders().             realmFailureHeaders.entrySet().stream().forEach((e) -> {                 String key = e.getKey().                 e.getValue().stream().filter(v -> defaultFailureResponseHeaders.computeIfAbsent(key, x -> new ArrayList<>()).contains(v) == false).forEach(v -> defaultFailureResponseHeaders.get(key).add(v)).             }).         }).         if (TokenService.isTokenServiceEnabled(settings)) {             String bearerScheme = "Bearer realm=\"" + XPackField.SECURITY + "\"".             if (defaultFailureResponseHeaders.computeIfAbsent("WWW-Authenticate", x -> new ArrayList<>()).contains(bearerScheme) == false) {                 defaultFailureResponseHeaders.get("WWW-Authenticate").add(bearerScheme).             }         }         if (API_KEY_SERVICE_ENABLED_SETTING.get(settings)) {             final String apiKeyScheme = "ApiKey".             if (defaultFailureResponseHeaders.computeIfAbsent("WWW-Authenticate", x -> new ArrayList<>()).contains(apiKeyScheme) == false) {                 defaultFailureResponseHeaders.get("WWW-Authenticate").add(apiKeyScheme).             }         }         failureHandler = new DefaultAuthenticationFailureHandler(defaultFailureResponseHeaders).     } else {         logger.debug("Using authentication failure handler from extension [" + extensionName + "]").     }     return failureHandler. }
false;public;0;4;;@Override public Settings additionalSettings() {     return additionalSettings(settings, enabled, transportClientMode). }
true;static;3;31;// visible for tests ;// visible for tests static Settings additionalSettings(final Settings settings, final boolean enabled, final boolean transportClientMode) {     if (enabled && transportClientMode == false) {         final Settings.Builder builder = Settings.builder().         builder.put(SecuritySettings.addTransportSettings(settings)).         if (NetworkModule.HTTP_TYPE_SETTING.exists(settings)) {             final String httpType = NetworkModule.HTTP_TYPE_SETTING.get(settings).             if (httpType.equals(SecurityField.NAME4) || httpType.equals(SecurityField.NIO)) {                 SecurityHttpSettings.overrideSettings(builder, settings).             } else {                 final String message = String.format(Locale.ROOT, "http type setting [%s] must be [%s] or [%s] but is [%s]", NetworkModule.HTTP_TYPE_KEY, SecurityField.NAME4, SecurityField.NIO, httpType).                 throw new IllegalArgumentException(message).             }         } else {             // default to security4             builder.put(NetworkModule.HTTP_TYPE_KEY, SecurityField.NAME4).             SecurityHttpSettings.overrideSettings(builder, settings).         }         builder.put(SecuritySettings.addUserSettings(settings)).         return builder.build().     } else {         return Settings.EMPTY.     } }
false;public;0;4;;@Override public List<Setting<?>> getSettings() {     return getSettings(transportClientMode, securityExtensions). }
true;public,static;2;43;/**  * Get the {@link Setting setting configuration} for all security components, including those defined in extensions.  */ ;/**  * Get the {@link Setting setting configuration} for all security components, including those defined in extensions.  */ public static List<Setting<?>> getSettings(boolean transportClientMode, List<SecurityExtension> securityExtensions) {     List<Setting<?>> settingsList = new ArrayList<>().     if (transportClientMode) {         return settingsList.     }     // The following just apply in node mode     settingsList.add(XPackSettings.FIPS_MODE_ENABLED).     // IP Filter settings     IPFilter.addSettings(settingsList).     // audit settings     LoggingAuditTrail.registerSettings(settingsList).     // authentication and authorization settings     AnonymousUser.addSettings(settingsList).     settingsList.addAll(InternalRealmsSettings.getSettings()).     NativeRolesStore.addSettings(settingsList).     ReservedRealm.addSettings(settingsList).     AuthenticationService.addSettings(settingsList).     AuthorizationService.addSettings(settingsList).     Automatons.addSettings(settingsList).     settingsList.addAll(CompositeRolesStore.getSettings()).     settingsList.add(FieldPermissionsCache.CACHE_SIZE_SETTING).     settingsList.add(TokenService.TOKEN_EXPIRATION).     settingsList.add(TokenService.DELETE_INTERVAL).     settingsList.add(TokenService.DELETE_TIMEOUT).     settingsList.add(SecurityServerTransportInterceptor.TRANSPORT_TYPE_PROFILE_SETTING).     settingsList.addAll(SSLConfigurationSettings.getProfileSettings()).     settingsList.add(ApiKeyService.PASSWORD_HASHING_ALGORITHM).     settingsList.add(ApiKeyService.DELETE_TIMEOUT).     settingsList.add(ApiKeyService.DELETE_INTERVAL).     settingsList.add(ApiKeyService.CACHE_HASH_ALGO_SETTING).     settingsList.add(ApiKeyService.CACHE_MAX_KEYS_SETTING).     settingsList.add(ApiKeyService.CACHE_TTL_SETTING).     // hide settings     settingsList.add(Setting.listSetting(SecurityField.setting("hide_settings"), Collections.emptyList(), Function.identity(), Property.NodeScope, Property.Filtered)).     return settingsList. }
false;public;0;15;;@Override public Collection<String> getRestHeaders() {     if (transportClientMode) {         return Collections.emptyList().     }     Set<String> headers = new HashSet<>().     headers.add(UsernamePasswordToken.BASIC_AUTH_HEADER).     if (XPackSettings.AUDIT_ENABLED.get(settings)) {         headers.add(AuditTrail.X_FORWARDED_FOR_HEADER).     }     if (AuthenticationServiceField.RUN_AS_ENABLED.get(settings)) {         headers.add(AuthenticationServiceField.RUN_AS_USER_HEADER).     }     return headers. }
false;public;0;8;;@Override public List<String> getSettingsFilter() {     List<String> asArray = settings.getAsList(SecurityField.setting("hide_settings")).     ArrayList<String> settingsFilter = new ArrayList<>(asArray).     // hide settings where we don't define them - they are part of a group...     settingsFilter.add("transport.profiles.*." + SecurityField.setting("*")).     return settingsFilter. }
false;public;0;4;;@Override public List<BootstrapCheck> getBootstrapChecks() {     return bootstrapChecks. }
false;public;1;33;;@Override public void onIndexModule(IndexModule module) {     if (enabled) {         assert getLicenseState() != null.         if (XPackSettings.DLS_FLS_ENABLED.get(settings)) {             module.setSearcherWrapper(indexService -> new SecurityIndexSearcherWrapper(shardId -> indexService.newQueryShardContext(shardId.id(), // based on index statistics, which is probably safer...             null, () -> {                 throw new IllegalArgumentException("permission filters are not allowed to use the current timestamp").             }, null), indexService.cache().bitsetFilterCache(), indexService.getThreadPool().getThreadContext(), getLicenseState(), indexService.getScriptService())).             /*  We need to forcefully overwrite the query cache implementation to use security's opt out query cache implementation.                 *  This impl. disabled the query cache if field level security is used for a particular request. If we wouldn't do                 *  forcefully overwrite the query cache implementation then we leave the system vulnerable to leakages of data to                 *  unauthorized users. */             module.forceQueryCacheProvider((settings, cache) -> new OptOutQueryCache(settings, cache, threadContext.get(), getLicenseState())).         }         // in order to prevent scroll ids from being maliciously crafted and/or guessed, a listener is added that         // attaches information to the scroll context so that we can validate the user that created the scroll against         // the user that is executing a scroll operation         module.addSearchOperationListener(new SecuritySearchOperationListener(threadContext.get(), getLicenseState(), auditTrailService.get())).     } }
false;public;0;38;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     if (enabled == false) {         return emptyList().     }     return Arrays.asList(new ActionHandler<>(ClearRealmCacheAction.INSTANCE, TransportClearRealmCacheAction.class), new ActionHandler<>(ClearRolesCacheAction.INSTANCE, TransportClearRolesCacheAction.class), new ActionHandler<>(GetUsersAction.INSTANCE, TransportGetUsersAction.class), new ActionHandler<>(PutUserAction.INSTANCE, TransportPutUserAction.class), new ActionHandler<>(DeleteUserAction.INSTANCE, TransportDeleteUserAction.class), new ActionHandler<>(GetRolesAction.INSTANCE, TransportGetRolesAction.class), new ActionHandler<>(PutRoleAction.INSTANCE, TransportPutRoleAction.class), new ActionHandler<>(DeleteRoleAction.INSTANCE, TransportDeleteRoleAction.class), new ActionHandler<>(ChangePasswordAction.INSTANCE, TransportChangePasswordAction.class), new ActionHandler<>(AuthenticateAction.INSTANCE, TransportAuthenticateAction.class), new ActionHandler<>(SetEnabledAction.INSTANCE, TransportSetEnabledAction.class), new ActionHandler<>(HasPrivilegesAction.INSTANCE, TransportHasPrivilegesAction.class), new ActionHandler<>(GetUserPrivilegesAction.INSTANCE, TransportGetUserPrivilegesAction.class), new ActionHandler<>(GetRoleMappingsAction.INSTANCE, TransportGetRoleMappingsAction.class), new ActionHandler<>(PutRoleMappingAction.INSTANCE, TransportPutRoleMappingAction.class), new ActionHandler<>(DeleteRoleMappingAction.INSTANCE, TransportDeleteRoleMappingAction.class), new ActionHandler<>(CreateTokenAction.INSTANCE, TransportCreateTokenAction.class), new ActionHandler<>(InvalidateTokenAction.INSTANCE, TransportInvalidateTokenAction.class), new ActionHandler<>(GetCertificateInfoAction.INSTANCE, TransportGetCertificateInfoAction.class), new ActionHandler<>(RefreshTokenAction.INSTANCE, TransportRefreshTokenAction.class), new ActionHandler<>(SamlPrepareAuthenticationAction.INSTANCE, TransportSamlPrepareAuthenticationAction.class), new ActionHandler<>(SamlAuthenticateAction.INSTANCE, TransportSamlAuthenticateAction.class), new ActionHandler<>(SamlLogoutAction.INSTANCE, TransportSamlLogoutAction.class), new ActionHandler<>(SamlInvalidateSessionAction.INSTANCE, TransportSamlInvalidateSessionAction.class), new ActionHandler<>(GetPrivilegesAction.INSTANCE, TransportGetPrivilegesAction.class), new ActionHandler<>(PutPrivilegesAction.INSTANCE, TransportPutPrivilegesAction.class), new ActionHandler<>(DeletePrivilegesAction.INSTANCE, TransportDeletePrivilegesAction.class), new ActionHandler<>(CreateApiKeyAction.INSTANCE, TransportCreateApiKeyAction.class), new ActionHandler<>(InvalidateApiKeyAction.INSTANCE, TransportInvalidateApiKeyAction.class), new ActionHandler<>(GetApiKeyAction.INSTANCE, TransportGetApiKeyAction.class)). }
false;public;0;11;;@Override public List<ActionFilter> getActionFilters() {     if (enabled == false) {         return emptyList().     }     // registering the security filter only for nodes     if (transportClientMode == false) {         return singletonList(securityActionFilter.get()).     }     return emptyList(). }
false;public;7;39;;@Override public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {     if (enabled == false) {         return emptyList().     }     return Arrays.asList(new RestAuthenticateAction(settings, restController, securityContext.get(), getLicenseState()), new RestClearRealmCacheAction(settings, restController, getLicenseState()), new RestClearRolesCacheAction(settings, restController, getLicenseState()), new RestGetUsersAction(settings, restController, getLicenseState()), new RestPutUserAction(settings, restController, getLicenseState()), new RestDeleteUserAction(settings, restController, getLicenseState()), new RestGetRolesAction(settings, restController, getLicenseState()), new RestPutRoleAction(settings, restController, getLicenseState()), new RestDeleteRoleAction(settings, restController, getLicenseState()), new RestChangePasswordAction(settings, restController, securityContext.get(), getLicenseState()), new RestSetEnabledAction(settings, restController, getLicenseState()), new RestHasPrivilegesAction(settings, restController, securityContext.get(), getLicenseState()), new RestGetUserPrivilegesAction(settings, restController, securityContext.get(), getLicenseState()), new RestGetRoleMappingsAction(settings, restController, getLicenseState()), new RestPutRoleMappingAction(settings, restController, getLicenseState()), new RestDeleteRoleMappingAction(settings, restController, getLicenseState()), new RestGetTokenAction(settings, restController, getLicenseState()), new RestInvalidateTokenAction(settings, restController, getLicenseState()), new RestGetCertificateInfoAction(settings, restController), new RestSamlPrepareAuthenticationAction(settings, restController, getLicenseState()), new RestSamlAuthenticateAction(settings, restController, getLicenseState()), new RestSamlLogoutAction(settings, restController, getLicenseState()), new RestSamlInvalidateSessionAction(settings, restController, getLicenseState()), new RestGetPrivilegesAction(settings, restController, getLicenseState()), new RestPutPrivilegesAction(settings, restController, getLicenseState()), new RestDeletePrivilegesAction(settings, restController, getLicenseState()), new RestCreateApiKeyAction(settings, restController, getLicenseState()), new RestInvalidateApiKeyAction(settings, restController, getLicenseState()), new RestGetApiKeyAction(settings, restController, getLicenseState())). }
false;public;1;4;;@Override public Map<String, Processor.Factory> getProcessors(Processor.Parameters parameters) {     return Collections.singletonMap(SetSecurityUserProcessor.TYPE, new SetSecurityUserProcessor.Factory(parameters.threadContext)). }
true;static;1;19;/**  * Realm settings were changed in 7.0. This method validates that the settings in use on this node match the new style of setting.  * In 6.x a realm config would be  * <pre>  *   xpack.security.authc.realms.file1.type: file  *   xpack.security.authc.realms.file1.order: 0  * </pre>  * In 7.x this realm should be  * <pre>  *   xpack.security.authc.realms.file.file1.order: 0  * </pre>  * If confronted with an old style config, the ES Settings validation would simply fail with an error such as  * <em>unknown setting [xpack.security.authc.realms.file1.order]</em>. This validation method provides an error that is easier to  * understand and take action on.  */ ;/**  * Realm settings were changed in 7.0. This method validates that the settings in use on this node match the new style of setting.  * In 6.x a realm config would be  * <pre>  *   xpack.security.authc.realms.file1.type: file  *   xpack.security.authc.realms.file1.order: 0  * </pre>  * In 7.x this realm should be  * <pre>  *   xpack.security.authc.realms.file.file1.order: 0  * </pre>  * If confronted with an old style config, the ES Settings validation would simply fail with an error such as  * <em>unknown setting [xpack.security.authc.realms.file1.order]</em>. This validation method provides an error that is easier to  * understand and take action on.  */ static void validateRealmSettings(Settings settings) {     final Set<String> badRealmSettings = settings.keySet().stream().filter(k -> k.startsWith(RealmSettings.PREFIX)).filter(key -> {         final String suffix = key.substring(RealmSettings.PREFIX.length()).         // suffix-part, only contains a single '.'         return suffix.indexOf('.') == suffix.lastIndexOf('.').     }).collect(Collectors.toSet()).     if (badRealmSettings.isEmpty() == false) {         String sampleRealmSetting = RealmSettings.realmSettingPrefix(new RealmConfig.RealmIdentifier("file", "my_file")) + "order".         throw new IllegalArgumentException("Incorrect realm settings found. " + "Realm settings have been changed to include the type as part of the setting key.\n" + "For example '" + sampleRealmSetting + "'\n" + "Found invalid config: " + Strings.collectionToDelimitedString(badRealmSettings, ", ") + "\n" + "Please see the breaking changes documentation.").     } }
false;public;4;7;;@Override public <T extends TransportRequest> TransportRequestHandler<T> interceptHandler(String action, String executor, boolean forceExecution, TransportRequestHandler<T> actualHandler) {     assert securityInterceptor.get() != null.     return securityInterceptor.get().interceptHandler(action, executor, forceExecution, actualHandler). }
false;public;1;5;;@Override public AsyncSender interceptSender(AsyncSender sender) {     assert securityInterceptor.get() != null.     return securityInterceptor.get().interceptSender(sender). }
false;public;2;22;;@Override public List<TransportInterceptor> getTransportInterceptors(NamedWriteableRegistry namedWriteableRegistry, ThreadContext threadContext) {     if (transportClientMode || enabled == false) {         // interceptors are not installed if we are running on the transport client         return Collections.emptyList().     }     return Collections.singletonList(new TransportInterceptor() {          @Override         public <T extends TransportRequest> TransportRequestHandler<T> interceptHandler(String action, String executor, boolean forceExecution, TransportRequestHandler<T> actualHandler) {             assert securityInterceptor.get() != null.             return securityInterceptor.get().interceptHandler(action, executor, forceExecution, actualHandler).         }          @Override         public AsyncSender interceptSender(AsyncSender sender) {             assert securityInterceptor.get() != null.             return securityInterceptor.get().interceptSender(sender).         }     }). }
false;public;6;17;;@Override public Map<String, Supplier<Transport>> getTransports(Settings settings, ThreadPool threadPool, PageCacheRecycler pageCacheRecycler, CircuitBreakerService circuitBreakerService, NamedWriteableRegistry namedWriteableRegistry, NetworkService networkService) {     if (transportClientMode || enabled == false) {         // don't register anything if we are not enabled, or in transport client mode         return Collections.emptyMap().     }     IPFilter ipFilter = this.ipFilter.get().     Map<String, Supplier<Transport>> transports = new HashMap<>().     transports.put(SecurityField.NAME4, () -> new SecurityNetty4ServerTransport(settings, Version.CURRENT, threadPool, networkService, pageCacheRecycler, namedWriteableRegistry, circuitBreakerService, ipFilter, getSslService())).     transports.put(SecurityField.NIO, () -> new SecurityNioTransport(settings, Version.CURRENT, threadPool, networkService, pageCacheRecycler, namedWriteableRegistry, circuitBreakerService, ipFilter, getSslService(), getNioGroupFactory(settings))).     return Collections.unmodifiableMap(transports). }
false;public;8;19;;@Override public Map<String, Supplier<HttpServerTransport>> getHttpTransports(Settings settings, ThreadPool threadPool, BigArrays bigArrays, PageCacheRecycler pageCacheRecycler, CircuitBreakerService circuitBreakerService, NamedXContentRegistry xContentRegistry, NetworkService networkService, HttpServerTransport.Dispatcher dispatcher) {     if (enabled == false) {         // don't register anything if we are not enabled         return Collections.emptyMap().     }     Map<String, Supplier<HttpServerTransport>> httpTransports = new HashMap<>().     httpTransports.put(SecurityField.NAME4, () -> new SecurityNetty4HttpServerTransport(settings, networkService, bigArrays, ipFilter.get(), getSslService(), threadPool, xContentRegistry, dispatcher)).     httpTransports.put(SecurityField.NIO, () -> new SecurityNioHttpServerTransport(settings, networkService, bigArrays, pageCacheRecycler, threadPool, xContentRegistry, dispatcher, ipFilter.get(), getSslService(), getNioGroupFactory(settings))).     return httpTransports. }
false;public;1;10;;@Override public UnaryOperator<RestHandler> getRestHandlerWrapper(ThreadContext threadContext) {     if (enabled == false || transportClientMode) {         return null.     }     final boolean ssl = HTTP_SSL_ENABLED.get(settings).     final SSLConfiguration httpSSLConfig = getSslService().getHttpTransportSSLConfiguration().     boolean extractClientCertificate = ssl && getSslService().isSSLClientAuthEnabled(httpSSLConfig).     return handler -> new SecurityRestFilter(getLicenseState(), threadContext, authcService.get(), handler, extractClientCertificate). }
false;public;1;8;;@Override public List<ExecutorBuilder<?>> getExecutorBuilders(final Settings settings) {     if (enabled && transportClientMode == false) {         return Collections.singletonList(new FixedExecutorBuilder(settings, TokenService.THREAD_POOL_NAME, 1, 1000, "xpack.security.authc.token.thread_pool")).     }     return Collections.emptyList(). }
false;public;0;9;;@Override public UnaryOperator<Map<String, IndexTemplateMetaData>> getIndexTemplateMetaDataUpgrader() {     return templates -> {         // .security index is not managed by using templates anymore         templates.remove(SECURITY_TEMPLATE_NAME).         templates.remove("security_audit_log").         return templates.     }. }
false;public;0;25;;@Override public Function<String, Predicate<String>> getFieldFilter() {     if (enabled) {         return index -> {             if (getLicenseState().isDocumentAndFieldLevelSecurityAllowed() == false) {                 return MapperPlugin.NOOP_FIELD_PREDICATE.             }             IndicesAccessControl indicesAccessControl = threadContext.get().getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY).             IndicesAccessControl.IndexAccessControl indexPermissions = indicesAccessControl.getIndexPermissions(index).             if (indexPermissions == null) {                 return MapperPlugin.NOOP_FIELD_PREDICATE.             }             if (indexPermissions.isGranted() == false) {                 throw new IllegalStateException("unexpected call to getFieldFilter for index [" + index + "] which is not granted").             }             FieldPermissions fieldPermissions = indexPermissions.getFieldPermissions().             if (fieldPermissions.hasFieldLevelSecurity() == false) {                 return MapperPlugin.NOOP_FIELD_PREDICATE.             }             return fieldPermissions::grantsAccessTo.         }.     }     return MapperPlugin.super.getFieldFilter(). }
false;public;0;11;;@Override public BiConsumer<DiscoveryNode, ClusterState> getJoinValidator() {     if (enabled) {         return new ValidateTLSOnJoin(XPackSettings.TRANSPORT_SSL_ENABLED.get(settings), DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings)).andThen(new ValidateUpgradedSecurityIndex()).andThen(new ValidateLicenseCanBeDeserialized()).andThen(new ValidateLicenseForFIPS(XPackSettings.FIPS_MODE_ENABLED.get(settings))).     }     return null. }
false;public;2;8;;@Override public void accept(DiscoveryNode node, ClusterState state) {     License license = LicenseService.getLicense(state.metaData()).     if (license != null && license.isProductionLicense() && isTLSEnabled == false && "single-node".equals(discoveryType) == false) {         throw new IllegalStateException("TLS setup is required for license type [" + license.operationMode().name() + "]").     } }
false;public;2;10;;@Override public void accept(DiscoveryNode node, ClusterState state) {     if (state.getNodes().getMinNodeVersion().before(Version.V_7_0_0)) {         IndexMetaData indexMetaData = state.getMetaData().getIndices().get(SECURITY_INDEX_NAME).         if (indexMetaData != null && INDEX_FORMAT_SETTING.get(indexMetaData.getSettings()) < INTERNAL_INDEX_FORMAT) {             throw new IllegalStateException("Security index is not on the current version [" + INTERNAL_INDEX_FORMAT + "] - " + "The Upgrade API must be run for 7.x nodes to join the cluster").         }     } }
false;public;2;8;;@Override public void accept(DiscoveryNode node, ClusterState state) {     License license = LicenseService.getLicense(state.metaData()).     if (license != null && license.version() >= License.VERSION_CRYPTO_ALGORITHMS && node.getVersion().before(Version.V_6_4_0)) {         throw new IllegalStateException("node " + node + " is on version [" + node.getVersion() + "] that cannot deserialize the license format [" + license.version() + "], upgrade node to at least 6.4.0").     } }
false;public;2;12;;@Override public void accept(DiscoveryNode node, ClusterState state) {     if (inFipsMode) {         License license = LicenseService.getLicense(state.metaData()).         if (license != null && FIPS140LicenseBootstrapCheck.ALLOWED_LICENSE_OPERATION_MODES.contains(license.operationMode()) == false) {             throw new IllegalStateException("FIPS mode cannot be used with a [" + license.operationMode() + "] license. It is only allowed with a Platinum or Trial license.").         }     } }
false;public;1;4;;@Override public void reloadSPI(ClassLoader loader) {     securityExtensions.addAll(SecurityExtension.loadExtensions(loader)). }
false;private,synchronized;1;9;;private synchronized NioGroupFactory getNioGroupFactory(Settings settings) {     if (groupFactory.get() != null) {         assert groupFactory.get().getSettings().equals(settings) : "Different settings than originally provided".         return groupFactory.get().     } else {         groupFactory.set(new NioGroupFactory(settings, logger)).         return groupFactory.get().     } }
