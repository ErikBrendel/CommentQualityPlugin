# id;timestamp;commentText;codeText;commentWords;codeWords
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1524684173;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(":")__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1526029249;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(":")__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1531179852;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(':')__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1533295538;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(':')__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1535552903;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(':')__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1538170812;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(':')__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings);1541642262;Parses the users file.__Returns {@code null}, if the {@code users} file does not exist.;public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {_        if (logger == null) {_            logger = NoOpLogger.INSTANCE__        }_        logger.trace("reading users file [{}]...", path.toAbsolutePath())___        if (Files.exists(path) == false) {_            return null__        }__        List<String> lines__        try {_            lines = Files.readAllLines(path, StandardCharsets.UTF_8)__        } catch (IOException ioe) {_            throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe)__        }__        Map<String, char[]> users = new HashMap<>()___        final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false__        int lineNr = 0__        for (String line : lines) {_            lineNr++__            if (line.startsWith("#")) { _                continue__            }__            _            _            line = line.trim()__            int i = line.indexOf(':')__            if (i <= 0 || i == line.length() - 1) {_                logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr)__                continue__            }_            String username = line.substring(0, i)__            Validation.Error validationError = Users.validateUsername(username, allowReserved, settings)__            if (validationError != null) {_                logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(),_                        validationError)__                continue__            }_            String hash = line.substring(i + 1)__            users.put(username, hash.toCharArray())__        }__        logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath())__        return unmodifiableMap(users)__    };parses,the,users,file,returns,code,null,if,the,code,users,file,does,not,exist;public,static,map,string,char,parse,file,path,path,nullable,logger,logger,settings,settings,if,logger,null,logger,no,op,logger,instance,logger,trace,reading,users,file,path,to,absolute,path,if,files,exists,path,false,return,null,list,string,lines,try,lines,files,read,all,lines,path,standard,charsets,catch,ioexception,ioe,throw,new,illegal,state,exception,could,not,read,users,file,path,to,absolute,path,ioe,map,string,char,users,new,hash,map,final,boolean,allow,reserved,xpack,settings,get,settings,false,int,line,nr,0,for,string,line,lines,line,nr,if,line,starts,with,continue,line,line,trim,int,i,line,index,of,if,i,0,i,line,length,1,logger,error,invalid,entry,in,users,file,line,skipping,path,to,absolute,path,line,nr,continue,string,username,line,substring,0,i,validation,error,validation,error,users,validate,username,username,allow,reserved,settings,if,validation,error,null,logger,error,invalid,username,in,users,file,skipping,username,path,to,absolute,path,validation,error,continue,string,hash,line,substring,i,1,users,put,username,hash,to,char,array,logger,debug,parsed,users,from,file,users,size,path,to,absolute,path,return,unmodifiable,map,users
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1524684173;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1526029249;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1531179852;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1533295538;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1535552903;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1538170812;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
FileUserPasswdStore -> static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings);1541642262;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.;static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {_        try {_            Map<String, char[]> map = parseFile(path, logger, settings)__            return map == null ? emptyMap() : map__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,all,users,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;static,map,string,char,parse,file,lenient,path,path,logger,logger,settings,settings,try,map,string,char,map,parse,file,path,logger,settings,return,map,null,empty,map,map,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,users,file,skipping,removing,all,users,path,to,absolute,path,e,return,empty,map
