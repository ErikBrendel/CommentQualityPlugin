commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void addListener(Runnable listener) {     listeners.add(listener). }
false;public;0;3;;public int usersCount() {     return users.size(). }
false;public;3;10;;public AuthenticationResult verifyPassword(String username, SecureString password, java.util.function.Supplier<User> user) {     final char[] hash = users.get(username).     if (hash == null) {         return AuthenticationResult.notHandled().     }     if (Hasher.verifyHash(password, hash) == false) {         return AuthenticationResult.unsuccessful("Password authentication failed for " + username, null).     }     return AuthenticationResult.success(user.get()). }
false;public;1;3;;public boolean userExists(String username) {     return users.containsKey(username). }
false;public,static;1;3;;public static Path resolveFile(Environment env) {     return XPackPlugin.resolveConfigFile(env, "users"). }
true;static;3;11;/**  * Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by  * logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.  */ ;/**  * Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by  * logging the error and skipping all users. This is aligned with how we handle other auto-loaded files in security.  */ static Map<String, char[]> parseFileLenient(Path path, Logger logger, Settings settings) {     try {         Map<String, char[]> map = parseFile(path, logger, settings).         return map == null ? emptyMap() : map.     } catch (Exception e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to parse users file [{}]. skipping/removing all users...", path.toAbsolutePath()), e).         return emptyMap().     } }
true;public,static;3;49;/**  * Parses the users file.  *  * Returns {@code null}, if the {@code users} file does not exist.  */ ;/**  * Parses the users file.  *  * Returns {@code null}, if the {@code users} file does not exist.  */ public static Map<String, char[]> parseFile(Path path, @Nullable Logger logger, Settings settings) {     if (logger == null) {         logger = NoOpLogger.INSTANCE.     }     logger.trace("reading users file [{}]...", path.toAbsolutePath()).     if (Files.exists(path) == false) {         return null.     }     List<String> lines.     try {         lines = Files.readAllLines(path, StandardCharsets.UTF_8).     } catch (IOException ioe) {         throw new IllegalStateException("could not read users file [" + path.toAbsolutePath() + "]", ioe).     }     Map<String, char[]> users = new HashMap<>().     final boolean allowReserved = XPackSettings.RESERVED_REALM_ENABLED_SETTING.get(settings) == false.     int lineNr = 0.     for (String line : lines) {         lineNr++.         if (line.startsWith("#")) {             // comment             continue.         }         // only trim the line because we have a format, our tool generates the formatted text and we shouldn't be lenient         // and allow spaces in the format         line = line.trim().         int i = line.indexOf(':').         if (i <= 0 || i == line.length() - 1) {             logger.error("invalid entry in users file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr).             continue.         }         String username = line.substring(0, i).         Validation.Error validationError = Users.validateUsername(username, allowReserved, settings).         if (validationError != null) {             logger.error("invalid username [{}] in users file [{}], skipping... ({})", username, path.toAbsolutePath(), validationError).             continue.         }         String hash = line.substring(i + 1).         users.put(username, hash.toCharArray()).     }     logger.debug("parsed [{}] users from file [{}]", users.size(), path.toAbsolutePath()).     return unmodifiableMap(users). }
false;public,static;2;6;;public static void writeFile(Map<String, char[]> users, Path path) {     SecurityFiles.writeFileAtomically(path, users, e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), new String(e.getValue()))). }
false;;0;3;;void notifyRefresh() {     listeners.forEach(Runnable::run). }
false;public;1;4;;@Override public void onFileCreated(Path file) {     onFileChanged(file). }
false;public;1;4;;@Override public void onFileDeleted(Path file) {     onFileChanged(file). }
false;public;1;8;;@Override public void onFileChanged(Path file) {     if (file.equals(FileUserPasswdStore.this.file)) {         logger.info("users file [{}] changed. updating users... )", file.toAbsolutePath()).         users = parseFileLenient(file, logger, settings).         notifyRefresh().     } }
