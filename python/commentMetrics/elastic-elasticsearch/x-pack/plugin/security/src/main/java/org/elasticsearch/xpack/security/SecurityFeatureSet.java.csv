commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String name() {     return XPackField.SECURITY. }
false;public;0;4;;@Override public String description() {     return "Security for the Elastic Stack". }
false;public;0;4;;@Override public boolean available() {     return licenseState != null && licenseState.isSecurityAvailable(). }
false;public;0;8;;@Override public boolean enabled() {     if (licenseState != null) {         return XPackSettings.SECURITY_ENABLED.get(settings) && licenseState.isSecurityDisabledByTrialLicense() == false.     }     return false. }
false;public;0;4;;@Override public Map<String, Object> nativeCodeInfo() {     return null. }
false;public;1;56;;@Override public void usage(ActionListener<XPackFeatureSet.Usage> listener) {     Map<String, Object> sslUsage = sslUsage(settings).     Map<String, Object> tokenServiceUsage = tokenServiceUsage(settings).     Map<String, Object> apiKeyServiceUsage = apiKeyServiceUsage(settings).     Map<String, Object> auditUsage = auditUsage(settings).     Map<String, Object> ipFilterUsage = ipFilterUsage(ipFilter).     Map<String, Object> anonymousUsage = singletonMap("enabled", AnonymousUser.isAnonymousEnabled(settings)).     final AtomicReference<Map<String, Object>> rolesUsageRef = new AtomicReference<>().     final AtomicReference<Map<String, Object>> roleMappingUsageRef = new AtomicReference<>().     final AtomicReference<Map<String, Object>> realmsUsageRef = new AtomicReference<>().     final CountDown countDown = new CountDown(3).     final Runnable doCountDown = () -> {         if (countDown.countDown()) {             listener.onResponse(new SecurityFeatureSetUsage(available(), enabled(), realmsUsageRef.get(), rolesUsageRef.get(), roleMappingUsageRef.get(), sslUsage, auditUsage, ipFilterUsage, anonymousUsage, tokenServiceUsage, apiKeyServiceUsage)).         }     }.     final ActionListener<Map<String, Object>> rolesStoreUsageListener = ActionListener.wrap(rolesStoreUsage -> {         rolesUsageRef.set(rolesStoreUsage).         doCountDown.run().     }, listener::onFailure).     final ActionListener<Map<String, Object>> roleMappingStoreUsageListener = ActionListener.wrap(nativeRoleMappingStoreUsage -> {         Map<String, Object> usage = singletonMap("native", nativeRoleMappingStoreUsage).         roleMappingUsageRef.set(usage).         doCountDown.run().     }, listener::onFailure).     final ActionListener<Map<String, Object>> realmsUsageListener = ActionListener.wrap(realmsUsage -> {         realmsUsageRef.set(realmsUsage).         doCountDown.run().     }, listener::onFailure).     if (rolesStore == null) {         rolesStoreUsageListener.onResponse(Collections.emptyMap()).     } else {         rolesStore.usageStats(rolesStoreUsageListener).     }     if (roleMappingStore == null) {         roleMappingStoreUsageListener.onResponse(Collections.emptyMap()).     } else {         roleMappingStore.usageStats(roleMappingStoreUsageListener).     }     if (realms == null) {         realmsUsageListener.onResponse(Collections.emptyMap()).     } else {         realms.usageStats(realmsUsageListener).     } }
false;static;1;6;;static Map<String, Object> sslUsage(Settings settings) {     Map<String, Object> map = new HashMap<>(2).     map.put("http", singletonMap("enabled", HTTP_SSL_ENABLED.get(settings))).     map.put("transport", singletonMap("enabled", TRANSPORT_SSL_ENABLED.get(settings))).     return map. }
false;static;1;3;;static Map<String, Object> tokenServiceUsage(Settings settings) {     return singletonMap("enabled", TOKEN_SERVICE_ENABLED_SETTING.get(settings)). }
false;static;1;3;;static Map<String, Object> apiKeyServiceUsage(Settings settings) {     return singletonMap("enabled", API_KEY_SERVICE_ENABLED_SETTING.get(settings)). }
false;static;1;9;;static Map<String, Object> auditUsage(Settings settings) {     Map<String, Object> map = new HashMap<>(2).     map.put("enabled", XPackSettings.AUDIT_ENABLED.get(settings)).     if (XPackSettings.AUDIT_ENABLED.get(settings)) {         // the only available output type is "logfile", but the optputs=<list> is to keep compatibility with previous reporting format         map.put("outputs", Arrays.asList(LoggingAuditTrail.NAME)).     }     return map. }
false;static;1;6;;static Map<String, Object> ipFilterUsage(@Nullable IPFilter ipFilter) {     if (ipFilter == null) {         return IPFilter.DISABLED_USAGE_STATS.     }     return ipFilter.usageStats(). }
