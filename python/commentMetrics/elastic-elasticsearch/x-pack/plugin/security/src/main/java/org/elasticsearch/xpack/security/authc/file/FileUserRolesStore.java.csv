commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void addListener(Runnable listener) {     listeners.add(listener). }
false;;0;3;;int entriesCount() {     return userRoles.size(). }
false;public;1;4;;public String[] roles(String username) {     final String[] roles = userRoles.get(username).     return roles == null ? Strings.EMPTY_ARRAY : roles. }
false;public,static;1;3;;public static Path resolveFile(Environment env) {     return XPackPlugin.resolveConfigFile(env, "users_roles"). }
true;static;2;12;/**  * Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by  * logging the error and skipping all enries. This is aligned with how we handle other auto-loaded files in security.  */ ;/**  * Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by  * logging the error and skipping all enries. This is aligned with how we handle other auto-loaded files in security.  */ static Map<String, String[]> parseFileLenient(Path path, Logger logger) {     try {         Map<String, String[]> map = parseFile(path, logger).         return map == null ? emptyMap() : map.     } catch (Exception e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to parse users_roles file [{}]. skipping/removing all entries...", path.toAbsolutePath()), e).         return emptyMap().     } }
true;public,static;2;64;/**  * Parses the users_roles file.  *  * Returns @{code null} if the {@code users_roles} file does not exist. The read file holds a mapping per  * line of the form "role -&gt. users" while the returned map holds entries of the form  "user -&gt. roles".  */ ;/**  * Parses the users_roles file.  *  * Returns @{code null} if the {@code users_roles} file does not exist. The read file holds a mapping per  * line of the form "role -&gt. users" while the returned map holds entries of the form  "user -&gt. roles".  */ public static Map<String, String[]> parseFile(Path path, @Nullable Logger logger) {     if (logger == null) {         logger = NoOpLogger.INSTANCE.     }     logger.trace("reading users_roles file [{}]...", path.toAbsolutePath()).     if (Files.exists(path) == false) {         return null.     }     List<String> lines.     try {         lines = Files.readAllLines(path, StandardCharsets.UTF_8).     } catch (IOException ioe) {         throw new ElasticsearchException("could not read users file [" + path.toAbsolutePath() + "]", ioe).     }     Map<String, List<String>> userToRoles = new HashMap<>().     int lineNr = 0.     for (String line : lines) {         lineNr++.         if (line.startsWith("#")) {             // comment             continue.         }         int i = line.indexOf(":").         if (i <= 0 || i == line.length() - 1) {             logger.error("invalid entry in users_roles file [{}], line [{}]. skipping...", path.toAbsolutePath(), lineNr).             continue.         }         String role = line.substring(0, i).trim().         Validation.Error validationError = Validation.Roles.validateRoleName(role, true).         if (validationError != null) {             logger.error("invalid role entry in users_roles file [{}], line [{}] - {}. skipping...", path.toAbsolutePath(), lineNr, validationError).             continue.         }         String usersStr = line.substring(i + 1).trim().         if (Strings.isEmpty(usersStr)) {             logger.error("invalid entry for role [{}] in users_roles file [{}], line [{}]. no users found. skipping...", role, path.toAbsolutePath(), lineNr).             continue.         }         String[] roleUsers = USERS_DELIM.split(usersStr).         if (roleUsers.length == 0) {             logger.error("invalid entry for role [{}] in users_roles file [{}], line [{}]. no users found. skipping...", role, path.toAbsolutePath(), lineNr).             continue.         }         for (String user : roleUsers) {             List<String> roles = userToRoles.computeIfAbsent(user, k -> new ArrayList<>()).             roles.add(role).         }     }     Map<String, String[]> usersRoles = new HashMap<>().     for (Map.Entry<String, List<String>> entry : userToRoles.entrySet()) {         usersRoles.put(entry.getKey(), entry.getValue().toArray(new String[entry.getValue().size()])).     }     logger.debug("parsed [{}] user to role mappings from file [{}]", usersRoles.size(), path.toAbsolutePath()).     return unmodifiableMap(usersRoles). }
true;public,static;2;14;/**  * Accepts a mapping of user -&gt. list of roles  */ ;/**  * Accepts a mapping of user -&gt. list of roles  */ public static void writeFile(Map<String, String[]> userToRoles, Path path) {     HashMap<String, List<String>> roleToUsers = new HashMap<>().     for (Map.Entry<String, String[]> entry : userToRoles.entrySet()) {         for (String role : entry.getValue()) {             List<String> users = roleToUsers.computeIfAbsent(role, k -> new ArrayList<>()).             users.add(entry.getKey()).         }     }     SecurityFiles.writeFileAtomically(path, roleToUsers, e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), collectionToCommaDelimitedString(e.getValue()))). }
false;;0;3;;void notifyRefresh() {     listeners.forEach(Runnable::run). }
false;public;1;4;;@Override public void onFileCreated(Path file) {     onFileChanged(file). }
false;public;1;4;;@Override public void onFileDeleted(Path file) {     onFileChanged(file). }
false;public;1;8;;@Override public void onFileChanged(Path file) {     if (file.equals(FileUserRolesStore.this.file)) {         logger.info("users roles file [{}] changed. updating users roles...", file.toAbsolutePath()).         userRoles = parseFileLenient(file, logger).         notifyRefresh().     } }
