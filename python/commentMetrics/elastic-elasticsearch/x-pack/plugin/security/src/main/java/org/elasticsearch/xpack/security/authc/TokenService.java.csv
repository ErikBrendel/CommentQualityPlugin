# id;timestamp;commentText;codeText;commentWords;codeWords
TokenService -> void clearActiveKeyCache();1524684173;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1525859433;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1526449283;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1527096592;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1529658035;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1535405719;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1538067637;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1539723533;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1539796943;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1540238977;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1541008027;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1541092382;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1541169206;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1545120350;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1545995382;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1547011415;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1549290341;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1549328556;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1549336917;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1549396415;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> void clearActiveKeyCache();1550828001;For testing;void clearActiveKeyCache() {_        this.keyCache.activeKeyCache.keyCache.invalidateAll()__    };for,testing;void,clear,active,key,cache,this,key,cache,active,key,cache,key,cache,invalidate,all
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityLifecycleService lifecycleService, ClusterService clusterService) throws GeneralSecurityException;1524684173;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityLifecycleService lifecycleService, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.lifecycleService = lifecycleService__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,lifecycle,service,lifecycle,service,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,lifecycle,service,lifecycle,service,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityLifecycleService lifecycleService, ClusterService clusterService) throws GeneralSecurityException;1525859433;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityLifecycleService lifecycleService, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.lifecycleService = lifecycleService__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,lifecycle,service,lifecycle,service,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,lifecycle,service,lifecycle,service,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1526449283;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1527096592;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1529658035;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1535405719;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1538067637;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1539723533;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1539796943;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1540238977;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1541008027;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        super(settings)__        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,super,settings,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1541092382;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1541169206;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1545120350;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1545995382;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1547011415;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1549290341;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1549328556;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1549336917;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1549396415;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public TokenService(Settings settings, Clock clock, Client client,                         SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException;1550828001;Creates a new token service__@param settings the node settings_@param clock    the clock that will be used for comparing timestamps_@param client   the client to use when checking for revocations;public TokenService(Settings settings, Clock clock, Client client,_                        SecurityIndexManager securityIndex, ClusterService clusterService) throws GeneralSecurityException {_        byte[] saltArr = new byte[SALT_BYTES]__        secureRandom.nextBytes(saltArr)___        final SecureString tokenPassphrase = generateTokenKey()__        this.settings = settings__        this.clock = clock.withZone(ZoneOffset.UTC)__        this.expirationDelay = TOKEN_EXPIRATION.get(settings)__        this.client = client__        this.securityIndex = securityIndex__        this.lastExpirationRunMs = client.threadPool().relativeTimeInMillis()__        this.deleteInterval = DELETE_INTERVAL.get(settings)__        this.enabled = isTokenServiceEnabled(settings)__        this.expiredTokenRemover = new ExpiredTokenRemover(settings, client)__        ensureEncryptionCiphersSupported()__        KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenPassphrase, createdTimeStamps.incrementAndGet()),_                new BytesKey(saltArr))__        keyCache = new TokenKeys(Collections.singletonMap(keyAndCache.getKeyHash(), keyAndCache), keyAndCache.getKeyHash())__        this.clusterService = clusterService__        initialize(clusterService)__        getTokenMetaData()__    };creates,a,new,token,service,param,settings,the,node,settings,param,clock,the,clock,that,will,be,used,for,comparing,timestamps,param,client,the,client,to,use,when,checking,for,revocations;public,token,service,settings,settings,clock,clock,client,client,security,index,manager,security,index,cluster,service,cluster,service,throws,general,security,exception,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,final,secure,string,token,passphrase,generate,token,key,this,settings,settings,this,clock,clock,with,zone,zone,offset,utc,this,expiration,delay,get,settings,this,client,client,this,security,index,security,index,this,last,expiration,run,ms,client,thread,pool,relative,time,in,millis,this,delete,interval,get,settings,this,enabled,is,token,service,enabled,settings,this,expired,token,remover,new,expired,token,remover,settings,client,ensure,encryption,ciphers,supported,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,passphrase,created,time,stamps,increment,and,get,new,bytes,key,salt,arr,key,cache,new,token,keys,collections,singleton,map,key,and,cache,get,key,hash,key,and,cache,key,and,cache,get,key,hash,this,cluster,service,cluster,service,initialize,cluster,service,get,token,meta,data
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1524684173;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1525859433;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1526449283;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1527096592;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1529658035;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1535405719;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1538067637;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1539723533;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(malformedTokenException())__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1539796943;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1540238977;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1541008027;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1541092382;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener);1541169206;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,boolean,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1524684173;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (lifecycleService.isSecurityIndexExisting() == false) {_            _            listener.onResponse(userToken)__        } else {_            lifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,lifecycle,service,is,security,index,existing,false,listener,on,response,user,token,else,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,lifecycle,service,type,get,invalidated,token,document,id,user,token,add,security,lifecycle,service,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1525859433;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (lifecycleService.securityIndex().indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            lifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,lifecycle,service,security,index,index,exists,false,listener,on,response,user,token,else,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,lifecycle,service,type,get,invalidated,token,document,id,user,token,add,security,lifecycle,service,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1526449283;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1527096592;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1529658035;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1535405719;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1538067637;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1539723533;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            _            _            listener.onResponse(userToken)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    listener.onFailure(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        listener.onFailure(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            listener.onFailure(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            listener.onFailure(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    listener.onFailure(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,check,index,version,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,listener,on,failure,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,listener,on,failure,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,listener,on,failure,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1539796943;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(userToken)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    onFailure.accept(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            onFailure.accept(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,on,failure,accept,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1540238977;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            _            _            listener.onResponse(userToken)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    onFailure.accept(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            onFailure.accept(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,check,index,version,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,on,failure,accept,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1541008027;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            _            _            listener.onResponse(userToken)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    onFailure.accept(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            onFailure.accept(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,check,index,version,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,on,failure,accept,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1541092382;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            _            _            listener.onResponse(userToken)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    onFailure.accept(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            onFailure.accept(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,check,index,version,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,on,failure,accept,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1541169206;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            _            _            listener.onResponse(userToken)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    onFailure.accept(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            onFailure.accept(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,check,index,version,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,on,failure,accept,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener);1545120350;Checks if the token has been stored as a revoked token to ensure we do not allow tokens that_have been explicitly cleared.;private void checkIfTokenIsRevoked(UserToken userToken, ActionListener<UserToken> listener) {_        if (securityIndex.indexExists() == false) {_            _            _            _            listener.onResponse(userToken)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                MultiGetRequest mGetRequest = client.prepareMultiGet()_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getInvalidatedTokenDocumentId(userToken))_                        .add(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                        .request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                        mGetRequest,_                        new ActionListener<MultiGetResponse>() {__                            @Override_                            public void onResponse(MultiGetResponse response) {_                                MultiGetItemResponse[] itemResponse = response.getResponses()__                                if (itemResponse[0].isFailed()) {_                                    onFailure(itemResponse[0].getFailure().getFailure())__                                } else if (itemResponse[0].getResponse().isExists()) {_                                    onFailure.accept(expiredTokenException())__                                } else if (itemResponse[1].isFailed()) {_                                    onFailure(itemResponse[1].getFailure().getFailure())__                                } else if (itemResponse[1].getResponse().isExists()) {_                                    Map<String, Object> source = itemResponse[1].getResponse().getSource()__                                    Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                    if (accessTokenSource == null) {_                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                                    } else {_                                        Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                        if (invalidated == null) {_                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                        } else if (invalidated) {_                                            onFailure.accept(expiredTokenException())__                                        } else {_                                            listener.onResponse(userToken)__                                        }_                                    }_                                } else if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }__                            @Override_                            public void onFailure(Exception e) {_                                _                                _                                if (isShardNotAvailableException(e)) {_                                    logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                                    listener.onResponse(null)__                                } else {_                                    logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                                    listener.onFailure(e)__                                }_                            }_                        }, client::multiGet)__            })__        }_    };checks,if,the,token,has,been,stored,as,a,revoked,token,to,ensure,we,do,not,allow,tokens,that,have,been,explicitly,cleared;private,void,check,if,token,is,revoked,user,token,user,token,action,listener,user,token,listener,if,security,index,index,exists,false,listener,on,response,user,token,else,security,index,check,index,version,then,execute,listener,on,failure,multi,get,request,m,get,request,client,prepare,multi,get,add,security,index,manager,type,get,invalidated,token,document,id,user,token,add,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,m,get,request,new,action,listener,multi,get,response,override,public,void,on,response,multi,get,response,response,multi,get,item,response,item,response,response,get,responses,if,item,response,0,is,failed,on,failure,item,response,0,get,failure,get,failure,else,if,item,response,0,get,response,is,exists,on,failure,accept,expired,token,exception,else,if,item,response,1,is,failed,on,failure,item,response,1,get,failure,get,failure,else,if,item,response,1,get,response,is,exists,map,string,object,source,item,response,1,get,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,if,user,token,get,version,on,or,after,version,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,else,listener,on,response,user,token,override,public,void,on,failure,exception,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,multi,get
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1545120350;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), expirationEpochMilli, null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,expiration,epoch,milli,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1545995382;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1547011415;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1549290341;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1549328556;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1549336917;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1549396415;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener);1550828001;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1524684173;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityLifecycleService.SECURITY_INDEX_NAME)_                .setScroll(TimeValue.timeValueSeconds(10L))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        lifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,lifecycle,service,set,scroll,time,value,time,value,seconds,10l,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1525859433;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityLifecycleService.SECURITY_INDEX_NAME)_                .setScroll(TimeValue.timeValueSeconds(10L))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        lifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,lifecycle,service,set,scroll,time,value,time,value,seconds,10l,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1526449283;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(TimeValue.timeValueSeconds(10L))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,time,value,time,value,seconds,10l,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1527096592;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(TimeValue.timeValueSeconds(10L))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,time,value,time,value,seconds,10l,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1529658035;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(TimeValue.timeValueSeconds(10L))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,time,value,time,value,seconds,10l,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1535405719;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(TimeValue.timeValueSeconds(10L))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,time,value,time,value,seconds,10l,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1538067637;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1539723533;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (securityIndex.isAvailable() == false) {_            listener.onResponse(Collections.emptyList())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___            final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__        }_    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,security,index,is,available,false,listener,on,response,collections,empty,list,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1539796943;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__            return__        }__        final Instant now = clock.instant()__        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                        .should(QueryBuilders.boolQuery()_                                .must(QueryBuilders.termQuery("access_token.invalidated", false))_                                .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                        )_                        .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit))__    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,return,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,security,index,prepare,index,if,needed,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1540238977;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, this::parseHit))__        }_    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1541008027;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, this::parseHit))__        }_    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1541092382;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, this::parseHit))__        }_    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,this,parse,hit
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener);1541169206;Find all stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.termQuery("refresh_token.invalidated", false))_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()___            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, this::parseHit))__        }_    };find,all,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,term,query,invalidated,false,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,this,parse,hit
TokenService -> synchronized TokenMetaData generateSpareKey();1524684173;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1525859433;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1526449283;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1527096592;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1529658035;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1535405719;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1538067637;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1539723533;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1539796943;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1540238977;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1541008027;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1541092382;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1541169206;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1545120350;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1545995382;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1547011415;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1549290341;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1549328556;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1549336917;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1549396415;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData generateSpareKey();1550828001;Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:_this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)};synchronized TokenMetaData generateSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        KeyAndCache currentKey = keyCache.activeKeyCache__        if (currentKey == maxKey) {_            long timestamp = createdTimeStamps.incrementAndGet()__            while (true) {_                byte[] saltArr = new byte[SALT_BYTES]__                secureRandom.nextBytes(saltArr)__                SecureString tokenKey = generateTokenKey()__                KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr))__                if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {_                    continue_ _                }_                return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(),_                        Collections.singletonList(keyAndCache)))__            }_        }_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };creates,a,new,key,unless,present,that,is,newer,than,the,current,active,key,and,returns,the,corresponding,metadata,note,this,method,doesn,t,modify,the,metadata,used,in,this,token,service,see,link,refresh,meta,data,token,meta,data;synchronized,token,meta,data,generate,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,key,and,cache,current,key,key,cache,active,key,cache,if,current,key,max,key,long,timestamp,created,time,stamps,increment,and,get,while,true,byte,salt,arr,new,byte,secure,random,next,bytes,salt,arr,secure,string,token,key,generate,token,key,key,and,cache,key,and,cache,new,key,and,cache,new,key,and,timestamp,token,key,timestamp,new,bytes,key,salt,arr,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,continue,return,new,token,meta,data,key,cache,current,token,key,hash,iterables,concat,key,cache,cache,values,collections,singleton,list,key,and,cache,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1535405719;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,index,manager,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1538067637;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,index,manager,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1539723533;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,index,manager,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1539796943;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", null, new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token", null,_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1540238977;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", null, new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token", null,_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1541008027;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", null, new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token", null,_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1541092382;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", null, new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token", null,_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1541169206;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", null, new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token", null,_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,null,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1545120350;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1545995382;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1547011415;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1549290341;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1549328556;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1549336917;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication tokenAuth = new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),_                authentication.getLookedUpBy(), version, AuthenticationType.TOKEN, authentication.getMetadata())__            final UserToken userToken = new UserToken(version, tokenAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,token,auth,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,authentication,type,token,authentication,get,metadata,final,user,token,user,token,new,user,token,version,token,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1549396415;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication tokenAuth = new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),_                authentication.getLookedUpBy(), version, AuthenticationType.TOKEN, authentication.getMetadata())__            final UserToken userToken = new UserToken(version, tokenAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,token,auth,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,authentication,type,token,authentication,get,metadata,final,user,token,user,token,new,user,token,version,token,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,                                 boolean includeRefreshToken) throws IOException;1550828001;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata,_                                boolean includeRefreshToken) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided")))__        } else if (originatingClientAuth == null) {_            listener.onFailure(traceLog("create token",_                new IllegalArgumentException("originating client authentication must be provided")))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication tokenAuth = new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),_                authentication.getLookedUpBy(), version, AuthenticationType.TOKEN, authentication.getMetadata())__            final UserToken userToken = new UserToken(version, tokenAuth, expiration, metadata)__            final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", TOKEN_DOC_TYPE)__                builder.field("creation_time", created.toEpochMilli())__                if (includeRefreshToken) {_                    builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                }_                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                final String documentId = getTokenDocumentId(userToken)__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId)_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),_                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                        ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                            listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,boolean,include,refresh,token,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,trace,log,create,token,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,token,auth,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,authentication,type,token,authentication,get,metadata,final,user,token,user,token,new,user,token,version,token,auth,expiration,metadata,final,string,refresh,token,include,refresh,token,uuids,random,base64uuid,null,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,builder,field,created,to,epoch,milli,if,include,refresh,token,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,final,string,document,id,get,token,document,id,user,token,index,request,request,client,prepare,index,security,index,manager,type,document,id,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,document,id,ex,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1545120350;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexBwcInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    expirationEpochMilli, result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,invalidation,access,token,ids,action,listener,wrap,result,index,bwc,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,expiration,epoch,milli,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1545995382;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1547011415;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1549290341;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1549328556;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1549336917;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1549396415;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener);1550828001;Invalidates a collection of access_token and refresh_token that were retrieved by_{@link TokenService#invalidateActiveTokensForRealmAndUser}__@param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)_@param listener  the listener to notify upon completion;private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {_        maybeStartTokenRemover()__        _        _        indexInvalidation(accessTokenIds, ActionListener.wrap(result ->_                indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()),_                    "access_token", result),_            listener::onFailure), new AtomicInteger(0), "refresh_token", null)__    };invalidates,a,collection,of,and,that,were,retrieved,by,link,token,service,invalidate,active,tokens,for,realm,and,user,param,access,token,ids,the,ids,of,the,access,tokens,which,should,be,invalidated,along,with,the,respective,param,listener,the,listener,to,notify,upon,completion;private,void,invalidate,all,tokens,collection,string,access,token,ids,action,listener,tokens,invalidation,result,listener,maybe,start,token,remover,index,invalidation,access,token,ids,action,listener,wrap,result,index,invalidation,access,token,ids,listener,new,atomic,integer,result,get,attempt,count,result,listener,on,failure,new,atomic,integer,0,null
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1545120350;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1545995382;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1547011415;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1549290341;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1549328556;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1549336917;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1549396415;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener);1550828001;Find stored refresh and access tokens that have not been invalidated or expired, and were issued for_the specified user.__@param username The user for which to get the tokens_@param listener The listener to notify upon completion;public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {_        ensureEnabled()___        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(username)) {_            listener.onFailure(new IllegalArgumentException("username is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener,_                    (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username))))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,for,the,specified,user,param,username,the,user,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion;public,void,find,active,tokens,for,user,string,username,action,listener,collection,tuple,user,token,string,listener,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,username,listener,on,failure,new,illegal,argument,exception,username,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,is,of,user,username
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1524684173;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1525859433;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1526449283;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1527096592;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1529658035;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1535405719;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1538067637;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1539723533;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1539796943;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1540238977;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1541008027;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1541092382;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1541169206;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1545120350;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1545995382;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1547011415;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1549290341;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1549328556;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1549336917;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1549396415;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> synchronized void refreshMetaData(TokenMetaData metaData);1550828001;Refreshes the current in-use metadata.;synchronized void refreshMetaData(TokenMetaData metaData) {_        BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash())__        byte[] saltArr = new byte[SALT_BYTES]__        Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size())__        long maxTimestamp = createdTimeStamps.get()__        for (KeyAndTimestamp key : metaData.getKeys()) {_            secureRandom.nextBytes(saltArr)__            KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr))__            maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp)__            if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {_                map.put(keyAndCache.getKeyHash(), keyAndCache)__            } else {_                map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash()))_ _            }_        }_        if (map.containsKey(currentUsedKeyHash) == false) {_            _            throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash)__        }_        createdTimeStamps.set(maxTimestamp)__        keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash)__        logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet())__    };refreshes,the,current,in,use,metadata;synchronized,void,refresh,meta,data,token,meta,data,meta,data,bytes,key,current,used,key,hash,new,bytes,key,meta,data,get,current,key,hash,byte,salt,arr,new,byte,map,bytes,key,key,and,cache,map,new,hash,map,meta,data,get,keys,size,long,max,timestamp,created,time,stamps,get,for,key,and,timestamp,key,meta,data,get,keys,secure,random,next,bytes,salt,arr,key,and,cache,key,and,cache,new,key,and,cache,key,new,bytes,key,salt,arr,max,timestamp,math,max,key,and,cache,key,and,timestamp,get,timestamp,max,timestamp,if,key,cache,cache,contains,key,key,and,cache,get,key,hash,false,map,put,key,and,cache,get,key,hash,key,and,cache,else,map,put,key,and,cache,get,key,hash,key,cache,get,key,and,cache,get,key,hash,if,map,contains,key,current,used,key,hash,false,throw,new,illegal,state,exception,current,key,is,not,in,the,map,map,key,set,key,current,used,key,hash,created,time,stamps,set,max,timestamp,key,cache,new,token,keys,collections,unmodifiable,map,map,current,used,key,hash,logger,debug,refreshed,keys,current,keys,current,used,key,hash,key,cache,cache,key,set
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1524684173;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1525859433;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1526449283;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1527096592;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1529658035;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1535405719;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1538067637;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1539723533;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1539796943;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1540238977;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1541008027;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1541092382;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1541169206;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1545120350;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1545995382;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1547011415;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1549290341;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1549328556;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1549336917;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1549396415;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)             throws IOException;1550828001;Reads the authentication and metadata from the given token._This method does not validate whether the token is expired or not.;public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener)_            throws IOException {_        decodeToken(token, ActionListener.wrap(_                userToken -> {_                    if (userToken == null) {_                        listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid"))__                    } else {_                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()))__                    }_                },_                listener::onFailure_        ))__    };reads,the,authentication,and,metadata,from,the,given,token,this,method,does,not,validate,whether,the,token,is,expired,or,not;public,void,get,authentication,and,meta,data,string,token,action,listener,tuple,authentication,map,string,object,listener,throws,ioexception,decode,token,token,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,new,elasticsearch,security,exception,supplied,token,is,not,valid,else,listener,on,response,new,tuple,user,token,get,authentication,user,token,get,metadata,listener,on,failure
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1524684173;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            lifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,lifecycle,service,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,lifecycle,service,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1525859433;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            lifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,lifecycle,service,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,lifecycle,service,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1526449283;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1527096592;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1529658035;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1535405719;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1538067637;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1539723533;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                        ActionListener.<UpdateResponse>wrap(updateResponse -> {_                            if (updateResponse.getGetResult() != null_                                    && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                                    && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                        .containsKey("invalidated")) {_                                final boolean prevInvalidated = (boolean)_                                        ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                                .get("invalidated")__                                listener.onResponse(prevInvalidated == false)__                            } else {_                                listener.onResponse(true)__                            }_                        }, e -> {_                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof DocumentMissingException) {_                                if (version.onOrAfter(Version.V_6_2_0)) {_                                    _                                    listener.onFailure(e)__                                } else {_                                    listener.onResponse(false)__                                }_                            } else if (cause instanceof VersionConflictEngineException_                                    || isShardNotAvailableException(cause)) {_                                attemptCount.incrementAndGet()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                        client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                        ActionListener.<GetResponse>wrap(getResult -> {_                                                    if (getResult.isExists()) {_                                                        Map<String, Object> source = getResult.getSource()__                                                        Map<String, Object> accessTokenSource =_                                                                (Map<String, Object>) source.get("access_token")__                                                        if (accessTokenSource == null) {_                                                            listener.onFailure(new IllegalArgumentException("token document is " +_                                                                    "missing access_token field"))__                                                        } else {_                                                            Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                            if (invalidated == null) {_                                                                listener.onFailure(new IllegalStateException(_                                                                        "token document missing invalidated value"))__                                                            } else if (invalidated) {_                                                                listener.onResponse(false)__                                                            } else {_                                                                indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                        getResult.getVersion())__                                                            }_                                                        }_                                                    } else if (version.onOrAfter(Version.V_6_2_0)) {_                                                        logger.warn("could not find token document [{}] but there should " +_                                                                        "be one as token has version [{}]", tokenDocId, version)__                                                        listener.onFailure(invalidGrantException("could not invalidate the token"))__                                                    } else {_                                                        listener.onResponse(false)__                                                    }_                                                },_                                                e1 -> {_                                                    if (isShardNotAvailableException(e1)) {_                                                        _                                                        indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                                documentVersion)__                                                    } else {_                                                        listener.onFailure(e1)__                                                    }_                                                }), client::get)__                            } else {_                                listener.onFailure(e)__                            }_                        }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,listener,on,failure,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,listener,on,failure,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1539796943;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<UpdateResponse>wrap(updateResponse -> {_                        logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, tokenDocId)__                        if (updateResponse.getGetResult() != null_                            && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                            && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                            .containsKey("invalidated")) {_                            final boolean prevInvalidated = (boolean)_                                ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                    .get("invalidated")__                            listener.onResponse(prevInvalidated == false)__                        } else {_                            listener.onResponse(true)__                        }_                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate token", tokenDocId, cause)__                        if (cause instanceof DocumentMissingException) {_                            if (version.onOrAfter(Version.V_6_2_0)) {_                                _                                listener.onFailure(e)__                            } else {_                                listener.onResponse(false)__                            }_                        } else if (cause instanceof VersionConflictEngineException_                            || isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                ActionListener.<GetResponse>wrap(getResult -> {_                                        if (getResult.isExists()) {_                                            Map<String, Object> source = getResult.getSource()__                                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("get token", tokenDocId, ex))__                                            if (accessTokenSource == null) {_                                                onFailure.accept(new IllegalArgumentException(_                                                    "token document is missing access_token field"))__                                            } else {_                                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                if (invalidated == null) {_                                                    onFailure.accept(new IllegalStateException(_                                                        "token document missing invalidated value"))__                                                } else if (invalidated) {_                                                    logger.trace("Token [{}] is already invalidated", tokenDocId)__                                                    listener.onResponse(false)__                                                } else {_                                                    indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                        getResult.getVersion())__                                                }_                                            }_                                        } else if (version.onOrAfter(Version.V_6_2_0)) {_                                            logger.warn("could not find token document [{}] but there should " +_                                                "be one as token has version [{}]", tokenDocId, version)__                                            listener.onFailure(invalidGrantException("could not invalidate the token"))__                                        } else {_                                            listener.onResponse(false)__                                        }_                                    },_                                    e1 -> {_                                        traceLog("get token", tokenDocId, e1)__                                        if (isShardNotAvailableException(e1)) {_                                            _                                            indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                documentVersion)__                                        } else {_                                            listener.onFailure(e1)__                                        }_                                    }), client::get)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,logger,debug,invalidated,for,doc,src,prefix,token,doc,id,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,token,token,doc,id,cause,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,consumer,exception,on,failure,ex,listener,on,failure,trace,log,get,token,token,doc,id,ex,if,access,token,source,null,on,failure,accept,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,logger,trace,token,is,already,invalidated,token,doc,id,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,trace,log,get,token,token,doc,id,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1540238977;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<UpdateResponse>wrap(updateResponse -> {_                        logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, tokenDocId)__                        if (updateResponse.getGetResult() != null_                            && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                            && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                            .containsKey("invalidated")) {_                            final boolean prevInvalidated = (boolean)_                                ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                    .get("invalidated")__                            listener.onResponse(prevInvalidated == false)__                        } else {_                            listener.onResponse(true)__                        }_                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate token", tokenDocId, cause)__                        if (cause instanceof DocumentMissingException) {_                            if (version.onOrAfter(Version.V_6_2_0)) {_                                _                                listener.onFailure(e)__                            } else {_                                listener.onResponse(false)__                            }_                        } else if (cause instanceof VersionConflictEngineException_                            || isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                ActionListener.<GetResponse>wrap(getResult -> {_                                        if (getResult.isExists()) {_                                            Map<String, Object> source = getResult.getSource()__                                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("get token", tokenDocId, ex))__                                            if (accessTokenSource == null) {_                                                onFailure.accept(new IllegalArgumentException(_                                                    "token document is missing access_token field"))__                                            } else {_                                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                if (invalidated == null) {_                                                    onFailure.accept(new IllegalStateException(_                                                        "token document missing invalidated value"))__                                                } else if (invalidated) {_                                                    logger.trace("Token [{}] is already invalidated", tokenDocId)__                                                    listener.onResponse(false)__                                                } else {_                                                    indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                        getResult.getVersion())__                                                }_                                            }_                                        } else if (version.onOrAfter(Version.V_6_2_0)) {_                                            logger.warn("could not find token document [{}] but there should " +_                                                "be one as token has version [{}]", tokenDocId, version)__                                            listener.onFailure(invalidGrantException("could not invalidate the token"))__                                        } else {_                                            listener.onResponse(false)__                                        }_                                    },_                                    e1 -> {_                                        traceLog("get token", tokenDocId, e1)__                                        if (isShardNotAvailableException(e1)) {_                                            _                                            indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                documentVersion)__                                        } else {_                                            listener.onFailure(e1)__                                        }_                                    }), client::get)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,logger,debug,invalidated,for,doc,src,prefix,token,doc,id,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,token,token,doc,id,cause,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,consumer,exception,on,failure,ex,listener,on,failure,trace,log,get,token,token,doc,id,ex,if,access,token,source,null,on,failure,accept,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,logger,trace,token,is,already,invalidated,token,doc,id,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,trace,log,get,token,token,doc,id,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1541008027;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<UpdateResponse>wrap(updateResponse -> {_                        logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, tokenDocId)__                        if (updateResponse.getGetResult() != null_                            && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                            && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                            .containsKey("invalidated")) {_                            final boolean prevInvalidated = (boolean)_                                ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                    .get("invalidated")__                            listener.onResponse(prevInvalidated == false)__                        } else {_                            listener.onResponse(true)__                        }_                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate token", tokenDocId, cause)__                        if (cause instanceof DocumentMissingException) {_                            if (version.onOrAfter(Version.V_6_2_0)) {_                                _                                listener.onFailure(e)__                            } else {_                                listener.onResponse(false)__                            }_                        } else if (cause instanceof VersionConflictEngineException_                            || isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                ActionListener.<GetResponse>wrap(getResult -> {_                                        if (getResult.isExists()) {_                                            Map<String, Object> source = getResult.getSource()__                                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("get token", tokenDocId, ex))__                                            if (accessTokenSource == null) {_                                                onFailure.accept(new IllegalArgumentException(_                                                    "token document is missing access_token field"))__                                            } else {_                                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                if (invalidated == null) {_                                                    onFailure.accept(new IllegalStateException(_                                                        "token document missing invalidated value"))__                                                } else if (invalidated) {_                                                    logger.trace("Token [{}] is already invalidated", tokenDocId)__                                                    listener.onResponse(false)__                                                } else {_                                                    indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                        getResult.getVersion())__                                                }_                                            }_                                        } else if (version.onOrAfter(Version.V_6_2_0)) {_                                            logger.warn("could not find token document [{}] but there should " +_                                                "be one as token has version [{}]", tokenDocId, version)__                                            listener.onFailure(invalidGrantException("could not invalidate the token"))__                                        } else {_                                            listener.onResponse(false)__                                        }_                                    },_                                    e1 -> {_                                        traceLog("get token", tokenDocId, e1)__                                        if (isShardNotAvailableException(e1)) {_                                            _                                            indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                documentVersion)__                                        } else {_                                            listener.onFailure(e1)__                                        }_                                    }), client::get)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,logger,debug,invalidated,for,doc,src,prefix,token,doc,id,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,token,token,doc,id,cause,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,consumer,exception,on,failure,ex,listener,on,failure,trace,log,get,token,token,doc,id,ex,if,access,token,source,null,on,failure,accept,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,logger,trace,token,is,already,invalidated,token,doc,id,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,trace,log,get,token,token,doc,id,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1541092382;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<UpdateResponse>wrap(updateResponse -> {_                        logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, tokenDocId)__                        if (updateResponse.getGetResult() != null_                            && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                            && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                            .containsKey("invalidated")) {_                            final boolean prevInvalidated = (boolean)_                                ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                    .get("invalidated")__                            listener.onResponse(prevInvalidated == false)__                        } else {_                            listener.onResponse(true)__                        }_                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate token", tokenDocId, cause)__                        if (cause instanceof DocumentMissingException) {_                            if (version.onOrAfter(Version.V_6_2_0)) {_                                _                                listener.onFailure(e)__                            } else {_                                listener.onResponse(false)__                            }_                        } else if (cause instanceof VersionConflictEngineException_                            || isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                ActionListener.<GetResponse>wrap(getResult -> {_                                        if (getResult.isExists()) {_                                            Map<String, Object> source = getResult.getSource()__                                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("get token", tokenDocId, ex))__                                            if (accessTokenSource == null) {_                                                onFailure.accept(new IllegalArgumentException(_                                                    "token document is missing access_token field"))__                                            } else {_                                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                if (invalidated == null) {_                                                    onFailure.accept(new IllegalStateException(_                                                        "token document missing invalidated value"))__                                                } else if (invalidated) {_                                                    logger.trace("Token [{}] is already invalidated", tokenDocId)__                                                    listener.onResponse(false)__                                                } else {_                                                    indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                        getResult.getVersion())__                                                }_                                            }_                                        } else if (version.onOrAfter(Version.V_6_2_0)) {_                                            logger.warn("could not find token document [{}] but there should " +_                                                "be one as token has version [{}]", tokenDocId, version)__                                            listener.onFailure(invalidGrantException("could not invalidate the token"))__                                        } else {_                                            listener.onResponse(false)__                                        }_                                    },_                                    e1 -> {_                                        traceLog("get token", tokenDocId, e1)__                                        if (isShardNotAvailableException(e1)) {_                                            _                                            indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                documentVersion)__                                        } else {_                                            listener.onFailure(e1)__                                        }_                                    }), client::get)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,logger,debug,invalidated,for,doc,src,prefix,token,doc,id,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,token,token,doc,id,cause,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,consumer,exception,on,failure,ex,listener,on,failure,trace,log,get,token,token,doc,id,ex,if,access,token,source,null,on,failure,accept,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,logger,trace,token,is,already,invalidated,token,doc,id,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,trace,log,get,token,token,doc,id,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                    String srcPrefix, long documentVersion);1541169206;Performs the actual invalidation of a token__@param tokenDocId      the id of the token doc to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update_@param documentVersion the expected version of the document we will update;private void indexInvalidation(String tokenDocId, Version version, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                   String srcPrefix, long documentVersion) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setVersion(documentVersion)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<UpdateResponse>wrap(updateResponse -> {_                        logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, tokenDocId)__                        if (updateResponse.getGetResult() != null_                            && updateResponse.getGetResult().sourceAsMap().containsKey(srcPrefix)_                            && ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                            .containsKey("invalidated")) {_                            final boolean prevInvalidated = (boolean)_                                ((Map<String, Object>) updateResponse.getGetResult().sourceAsMap().get(srcPrefix))_                                    .get("invalidated")__                            listener.onResponse(prevInvalidated == false)__                        } else {_                            listener.onResponse(true)__                        }_                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate token", tokenDocId, cause)__                        if (cause instanceof DocumentMissingException) {_                            if (version.onOrAfter(Version.V_6_2_0)) {_                                _                                listener.onFailure(e)__                            } else {_                                listener.onResponse(false)__                            }_                        } else if (cause instanceof VersionConflictEngineException_                            || isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                                client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request(),_                                ActionListener.<GetResponse>wrap(getResult -> {_                                        if (getResult.isExists()) {_                                            Map<String, Object> source = getResult.getSource()__                                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("get token", tokenDocId, ex))__                                            if (accessTokenSource == null) {_                                                onFailure.accept(new IllegalArgumentException(_                                                    "token document is missing access_token field"))__                                            } else {_                                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                                if (invalidated == null) {_                                                    onFailure.accept(new IllegalStateException(_                                                        "token document missing invalidated value"))__                                                } else if (invalidated) {_                                                    logger.trace("Token [{}] is already invalidated", tokenDocId)__                                                    listener.onResponse(false)__                                                } else {_                                                    indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                        getResult.getVersion())__                                                }_                                            }_                                        } else if (version.onOrAfter(Version.V_6_2_0)) {_                                            logger.warn("could not find token document [{}] but there should " +_                                                "be one as token has version [{}]", tokenDocId, version)__                                            listener.onFailure(invalidGrantException("could not invalidate the token"))__                                        } else {_                                            listener.onResponse(false)__                                        }_                                    },_                                    e1 -> {_                                        traceLog("get token", tokenDocId, e1)__                                        if (isShardNotAvailableException(e1)) {_                                            _                                            indexInvalidation(tokenDocId, version, listener, attemptCount, srcPrefix,_                                                documentVersion)__                                        } else {_                                            listener.onFailure(e1)__                                        }_                                    }), client::get)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::update))__        }_    };performs,the,actual,invalidation,of,a,token,param,token,doc,id,the,id,of,the,token,doc,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,param,document,version,the,expected,version,of,the,document,we,will,update;private,void,index,invalidation,string,token,doc,id,version,version,action,listener,boolean,listener,atomic,integer,attempt,count,string,src,prefix,long,document,version,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,update,request,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,version,document,version,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,update,response,wrap,update,response,logger,debug,invalidated,for,doc,src,prefix,token,doc,id,if,update,response,get,get,result,null,update,response,get,get,result,source,as,map,contains,key,src,prefix,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,contains,key,invalidated,final,boolean,prev,invalidated,boolean,map,string,object,update,response,get,get,result,source,as,map,get,src,prefix,get,invalidated,listener,on,response,prev,invalidated,false,else,listener,on,response,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,token,token,doc,id,cause,if,cause,instanceof,document,missing,exception,if,version,on,or,after,version,listener,on,failure,e,else,listener,on,response,false,else,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,cause,attempt,count,increment,and,get,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,security,index,manager,type,token,doc,id,request,action,listener,get,response,wrap,get,result,if,get,result,is,exists,map,string,object,source,get,result,get,source,map,string,object,access,token,source,map,string,object,source,get,consumer,exception,on,failure,ex,listener,on,failure,trace,log,get,token,token,doc,id,ex,if,access,token,source,null,on,failure,accept,new,illegal,argument,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,missing,invalidated,value,else,if,invalidated,logger,trace,token,is,already,invalidated,token,doc,id,listener,on,response,false,else,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,get,result,get,version,else,if,version,on,or,after,version,logger,warn,could,not,find,token,document,but,there,should,be,one,as,token,has,version,token,doc,id,version,listener,on,failure,invalid,grant,exception,could,not,invalidate,the,token,else,listener,on,response,false,e1,trace,log,get,token,token,doc,id,e1,if,is,shard,not,available,exception,e1,index,invalidation,token,doc,id,version,listener,attempt,count,src,prefix,document,version,else,listener,on,failure,e1,client,get,else,listener,on,failure,e,client,update
TokenService -> private String getFromHeader(ThreadContext threadContext);1524684173;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasLength(header) && header.startsWith("Bearer ")_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,length,header,header,starts,with,bearer,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1525859433;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasLength(header) && header.startsWith("Bearer ")_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,length,header,header,starts,with,bearer,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1526449283;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasLength(header) && header.startsWith("Bearer ")_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,length,header,header,starts,with,bearer,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1527096592;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasLength(header) && header.startsWith("Bearer ")_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,length,header,header,starts,with,bearer,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1529658035;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1535405719;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1538067637;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1539723533;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1539796943;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1540238977;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1541008027;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1541092382;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1541169206;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1545120350;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1545995382;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1547011415;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1549290341;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1549328556;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1549336917;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1549396415;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private String getFromHeader(ThreadContext threadContext);1550828001;Gets the token from the <code>Authorization</code> header if the header begins with_<code>Bearer </code>;private String getFromHeader(ThreadContext threadContext) {_        String header = threadContext.getHeader("Authorization")__        if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length())_                && header.length() > "Bearer ".length()) {_            return header.substring("Bearer ".length())__        }_        return null__    };gets,the,token,from,the,code,authorization,code,header,if,the,header,begins,with,code,bearer,code;private,string,get,from,header,thread,context,thread,context,string,header,thread,context,get,header,authorization,if,strings,has,text,header,header,region,matches,true,0,bearer,0,bearer,length,header,length,bearer,length,return,header,substring,bearer,length,return,null
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1524684173;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1525859433;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1526449283;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1527096592;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1529658035;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1535405719;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1538067637;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1539723533;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1539796943;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1540238977;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1541008027;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1541092382;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1541169206;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1545120350;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1545995382;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1547011415;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1549290341;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1549328556;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1549336917;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1549396415;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> private static ElasticsearchSecurityException invalidGrantException(String detail);1550828001;Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant;private static ElasticsearchSecurityException invalidGrantException(String detail) {_        ElasticsearchSecurityException e =_            new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST)__        e.addHeader("error_description", detail)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,request,contained,an,invalid,grant;private,static,elasticsearch,security,exception,invalid,grant,exception,string,detail,elasticsearch,security,exception,e,new,elasticsearch,security,exception,rest,status,e,add,header,detail,return,e
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1545120350;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1545995382;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1547011415;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1549290341;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1549328556;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1549336917;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1549396415;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener);1550828001;This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.__@param refreshToken The string representation of the refresh token_@param listener  the listener to notify upon completion;public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(refreshToken)) {_            logger.trace("No refresh token provided")__            listener.onFailure(new IllegalArgumentException("refresh token must be provided"))__        } else {_            maybeStartTokenRemover()__            findTokenFromRefreshToken(refreshToken,_                    ActionListener.wrap(tuple -> {_                        final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId())__                        indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null)__                    }, listener::onFailure), new AtomicInteger(0))__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,refresh,token,so,that,it,may,no,longer,be,used,param,refresh,token,the,string,representation,of,the,refresh,token,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,refresh,token,string,refresh,token,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,refresh,token,logger,trace,no,refresh,token,provided,listener,on,failure,new,illegal,argument,exception,refresh,token,must,be,provided,else,maybe,start,token,remover,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,string,doc,id,get,token,id,from,document,id,tuple,v1,get,hits,get,at,0,get,id,index,invalidation,collections,singleton,list,doc,id,listener,tuple,v2,null,listener,on,failure,new,atomic,integer,0
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1524684173;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1525859433;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1526449283;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1527096592;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1529658035;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1535405719;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1538067637;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1539723533;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1539796943;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1540238977;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1541008027;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1541092382;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener);1541169206;This method performs the steps necessary to invalidate a token so that it may no longer be used.__@see #invalidateAccessToken(String, ActionListener);public void invalidateAccessToken(UserToken userToken, ActionListener<Boolean> listener) {_        ensureEnabled()__        if (userToken == null) {_            logger.trace("No access token provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            final long expirationEpochMilli = getExpirationTime().toEpochMilli()__            indexBwcInvalidation(userToken, listener, new AtomicInteger(0), expirationEpochMilli)__        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,see,invalidate,access,token,string,action,listener;public,void,invalidate,access,token,user,token,user,token,action,listener,boolean,listener,ensure,enabled,if,user,token,null,logger,trace,no,access,token,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,user,token,listener,new,atomic,integer,0,expiration,epoch,milli
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1524684173;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1525859433;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1526449283;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1527096592;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1529658035;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1535405719;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1538067637;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1539723533;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1539796943;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1540238977;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1541008027;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1541092382;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1541169206;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1545120350;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1545995382;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1547011415;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1549290341;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1549328556;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1549336917;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1549396415;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException malformedTokenException();1550828001;Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException malformedTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,malformed,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,malformed,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,malformed,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> void decodeToken(String token, ActionListener<UserToken> listener) throws IOException;1549336917;Asynchronously decodes the string representation of a {@link UserToken}. The process for_this is asynchronous as we may need to compute a key, which can be computationally expensive_so this should not block the current thread, which is typically a network thread. A second_reason for being asynchronous is that we can restrain the amount of resources consumed by_the key computation to a single thread.;void decodeToken(String token, ActionListener<UserToken> listener) throws IOException {_        _        byte[] bytes = token.getBytes(StandardCharsets.UTF_8)__        StreamInput in = new InputStreamStreamInput(Base64.getDecoder().wrap(new ByteArrayInputStream(bytes)), bytes.length)__        if (in.available() < MINIMUM_BASE64_BYTES) {_            logger.debug("invalid token")__            listener.onResponse(null)__        } else {_            _            final Version version = Version.readVersion(in)__            in.setVersion(version)__            final BytesKey decodedSalt = new BytesKey(in.readByteArray())__            final BytesKey passphraseHash = new BytesKey(in.readByteArray())__            KeyAndCache keyAndCache = keyCache.get(passphraseHash)__            if (keyAndCache != null) {_                getKeyAsync(decodedSalt, keyAndCache, ActionListener.wrap(decodeKey -> {_                    try {_                        final byte[] iv = in.readByteArray()__                        final Cipher cipher = getDecryptionCipher(iv, decodeKey, version, decodedSalt)__                        decryptTokenId(in, cipher, version, ActionListener.wrap(tokenId -> {_                            if (securityIndex.isAvailable() == false) {_                                logger.warn("failed to get token [{}] since index is not available", tokenId)__                                listener.onResponse(null)__                            } else {_                                securityIndex.checkIndexVersionThenExecute(_                                    ex -> listener.onFailure(traceLog("prepare security index", tokenId, ex)),_                                    () -> {_                                        final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                                            getTokenDocumentId(tokenId)).request()__                                        Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("decode token", tokenId, ex))__                                        executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                                            ActionListener.<GetResponse>wrap(response -> {_                                                if (response.isExists()) {_                                                    Map<String, Object> accessTokenSource =_                                                        (Map<String, Object>) response.getSource().get("access_token")__                                                    if (accessTokenSource == null) {_                                                        onFailure.accept(new IllegalStateException(_                                                            "token document is missing the access_token field"))__                                                    } else if (accessTokenSource.containsKey("user_token") == false) {_                                                        onFailure.accept(new IllegalStateException(_                                                            "token document is missing the user_token field"))__                                                    } else {_                                                        Map<String, Object> userTokenSource =_                                                            (Map<String, Object>) accessTokenSource.get("user_token")__                                                        listener.onResponse(UserToken.fromSourceMap(userTokenSource))__                                                    }_                                                } else {_                                                    onFailure.accept(_                                                        new IllegalStateException("token document is missing and must be present"))__                                                }_                                            }, e -> {_                                                _                                                _                                                if (isShardNotAvailableException(e)) {_                                                    logger.warn("failed to get token [{}] since index is not available", tokenId)__                                                    listener.onResponse(null)__                                                } else {_                                                    logger.error(new ParameterizedMessage("failed to get token [{}]", tokenId), e)__                                                    listener.onFailure(e)__                                                }_                                            }), client::get)__                                    })__                            }_                        }, listener::onFailure))__                    } catch (GeneralSecurityException e) {_                        _                        logger.warn("invalid token", e)__                        listener.onResponse(null)__                    } finally {_                        in.close()__                    }_                }, e -> {_                    IOUtils.closeWhileHandlingException(in)__                    listener.onFailure(e)__                }))__            } else {_                IOUtils.closeWhileHandlingException(in)__                logger.debug("invalid key {} key: {}", passphraseHash, keyCache.cache.keySet())__                listener.onResponse(null)__            }_        }_    };asynchronously,decodes,the,string,representation,of,a,link,user,token,the,process,for,this,is,asynchronous,as,we,may,need,to,compute,a,key,which,can,be,computationally,expensive,so,this,should,not,block,the,current,thread,which,is,typically,a,network,thread,a,second,reason,for,being,asynchronous,is,that,we,can,restrain,the,amount,of,resources,consumed,by,the,key,computation,to,a,single,thread;void,decode,token,string,token,action,listener,user,token,listener,throws,ioexception,byte,bytes,token,get,bytes,standard,charsets,stream,input,in,new,input,stream,stream,input,base64,get,decoder,wrap,new,byte,array,input,stream,bytes,bytes,length,if,in,available,logger,debug,invalid,token,listener,on,response,null,else,final,version,version,version,read,version,in,in,set,version,version,final,bytes,key,decoded,salt,new,bytes,key,in,read,byte,array,final,bytes,key,passphrase,hash,new,bytes,key,in,read,byte,array,key,and,cache,key,and,cache,key,cache,get,passphrase,hash,if,key,and,cache,null,get,key,async,decoded,salt,key,and,cache,action,listener,wrap,decode,key,try,final,byte,iv,in,read,byte,array,final,cipher,cipher,get,decryption,cipher,iv,decode,key,version,decoded,salt,decrypt,token,id,in,cipher,version,action,listener,wrap,token,id,if,security,index,is,available,false,logger,warn,failed,to,get,token,since,index,is,not,available,token,id,listener,on,response,null,else,security,index,check,index,version,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,id,ex,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,token,id,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,decode,token,token,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,access,token,source,map,string,object,response,get,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,the,field,else,if,access,token,source,contains,key,false,on,failure,accept,new,illegal,state,exception,token,document,is,missing,the,field,else,map,string,object,user,token,source,map,string,object,access,token,source,get,listener,on,response,user,token,from,source,map,user,token,source,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,token,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,token,id,e,listener,on,failure,e,client,get,listener,on,failure,catch,general,security,exception,e,logger,warn,invalid,token,e,listener,on,response,null,finally,in,close,e,ioutils,close,while,handling,exception,in,listener,on,failure,e,else,ioutils,close,while,handling,exception,in,logger,debug,invalid,key,key,passphrase,hash,key,cache,cache,key,set,listener,on,response,null
TokenService -> void decodeToken(String token, ActionListener<UserToken> listener) throws IOException;1549396415;Asynchronously decodes the string representation of a {@link UserToken}. The process for_this is asynchronous as we may need to compute a key, which can be computationally expensive_so this should not block the current thread, which is typically a network thread. A second_reason for being asynchronous is that we can restrain the amount of resources consumed by_the key computation to a single thread.;void decodeToken(String token, ActionListener<UserToken> listener) throws IOException {_        _        byte[] bytes = token.getBytes(StandardCharsets.UTF_8)__        StreamInput in = new InputStreamStreamInput(Base64.getDecoder().wrap(new ByteArrayInputStream(bytes)), bytes.length)__        if (in.available() < MINIMUM_BASE64_BYTES) {_            logger.debug("invalid token")__            listener.onResponse(null)__        } else {_            _            final Version version = Version.readVersion(in)__            in.setVersion(version)__            final BytesKey decodedSalt = new BytesKey(in.readByteArray())__            final BytesKey passphraseHash = new BytesKey(in.readByteArray())__            KeyAndCache keyAndCache = keyCache.get(passphraseHash)__            if (keyAndCache != null) {_                getKeyAsync(decodedSalt, keyAndCache, ActionListener.wrap(decodeKey -> {_                    try {_                        final byte[] iv = in.readByteArray()__                        final Cipher cipher = getDecryptionCipher(iv, decodeKey, version, decodedSalt)__                        decryptTokenId(in, cipher, version, ActionListener.wrap(tokenId -> {_                            if (securityIndex.isAvailable() == false) {_                                logger.warn("failed to get token [{}] since index is not available", tokenId)__                                listener.onResponse(null)__                            } else {_                                securityIndex.checkIndexVersionThenExecute(_                                    ex -> listener.onFailure(traceLog("prepare security index", tokenId, ex)),_                                    () -> {_                                        final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                                            getTokenDocumentId(tokenId)).request()__                                        Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("decode token", tokenId, ex))__                                        executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                                            ActionListener.<GetResponse>wrap(response -> {_                                                if (response.isExists()) {_                                                    Map<String, Object> accessTokenSource =_                                                        (Map<String, Object>) response.getSource().get("access_token")__                                                    if (accessTokenSource == null) {_                                                        onFailure.accept(new IllegalStateException(_                                                            "token document is missing the access_token field"))__                                                    } else if (accessTokenSource.containsKey("user_token") == false) {_                                                        onFailure.accept(new IllegalStateException(_                                                            "token document is missing the user_token field"))__                                                    } else {_                                                        Map<String, Object> userTokenSource =_                                                            (Map<String, Object>) accessTokenSource.get("user_token")__                                                        listener.onResponse(UserToken.fromSourceMap(userTokenSource))__                                                    }_                                                } else {_                                                    onFailure.accept(_                                                        new IllegalStateException("token document is missing and must be present"))__                                                }_                                            }, e -> {_                                                _                                                _                                                if (isShardNotAvailableException(e)) {_                                                    logger.warn("failed to get token [{}] since index is not available", tokenId)__                                                    listener.onResponse(null)__                                                } else {_                                                    logger.error(new ParameterizedMessage("failed to get token [{}]", tokenId), e)__                                                    listener.onFailure(e)__                                                }_                                            }), client::get)__                                    })__                            }_                        }, listener::onFailure))__                    } catch (GeneralSecurityException e) {_                        _                        logger.warn("invalid token", e)__                        listener.onResponse(null)__                    } finally {_                        in.close()__                    }_                }, e -> {_                    IOUtils.closeWhileHandlingException(in)__                    listener.onFailure(e)__                }))__            } else {_                IOUtils.closeWhileHandlingException(in)__                logger.debug("invalid key {} key: {}", passphraseHash, keyCache.cache.keySet())__                listener.onResponse(null)__            }_        }_    };asynchronously,decodes,the,string,representation,of,a,link,user,token,the,process,for,this,is,asynchronous,as,we,may,need,to,compute,a,key,which,can,be,computationally,expensive,so,this,should,not,block,the,current,thread,which,is,typically,a,network,thread,a,second,reason,for,being,asynchronous,is,that,we,can,restrain,the,amount,of,resources,consumed,by,the,key,computation,to,a,single,thread;void,decode,token,string,token,action,listener,user,token,listener,throws,ioexception,byte,bytes,token,get,bytes,standard,charsets,stream,input,in,new,input,stream,stream,input,base64,get,decoder,wrap,new,byte,array,input,stream,bytes,bytes,length,if,in,available,logger,debug,invalid,token,listener,on,response,null,else,final,version,version,version,read,version,in,in,set,version,version,final,bytes,key,decoded,salt,new,bytes,key,in,read,byte,array,final,bytes,key,passphrase,hash,new,bytes,key,in,read,byte,array,key,and,cache,key,and,cache,key,cache,get,passphrase,hash,if,key,and,cache,null,get,key,async,decoded,salt,key,and,cache,action,listener,wrap,decode,key,try,final,byte,iv,in,read,byte,array,final,cipher,cipher,get,decryption,cipher,iv,decode,key,version,decoded,salt,decrypt,token,id,in,cipher,version,action,listener,wrap,token,id,if,security,index,is,available,false,logger,warn,failed,to,get,token,since,index,is,not,available,token,id,listener,on,response,null,else,security,index,check,index,version,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,id,ex,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,token,id,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,decode,token,token,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,access,token,source,map,string,object,response,get,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,the,field,else,if,access,token,source,contains,key,false,on,failure,accept,new,illegal,state,exception,token,document,is,missing,the,field,else,map,string,object,user,token,source,map,string,object,access,token,source,get,listener,on,response,user,token,from,source,map,user,token,source,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,token,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,token,id,e,listener,on,failure,e,client,get,listener,on,failure,catch,general,security,exception,e,logger,warn,invalid,token,e,listener,on,response,null,finally,in,close,e,ioutils,close,while,handling,exception,in,listener,on,failure,e,else,ioutils,close,while,handling,exception,in,logger,debug,invalid,key,key,passphrase,hash,key,cache,cache,key,set,listener,on,response,null
TokenService -> void decodeToken(String token, ActionListener<UserToken> listener) throws IOException;1550828001;Asynchronously decodes the string representation of a {@link UserToken}. The process for_this is asynchronous as we may need to compute a key, which can be computationally expensive_so this should not block the current thread, which is typically a network thread. A second_reason for being asynchronous is that we can restrain the amount of resources consumed by_the key computation to a single thread.;void decodeToken(String token, ActionListener<UserToken> listener) throws IOException {_        _        byte[] bytes = token.getBytes(StandardCharsets.UTF_8)__        StreamInput in = new InputStreamStreamInput(Base64.getDecoder().wrap(new ByteArrayInputStream(bytes)), bytes.length)__        if (in.available() < MINIMUM_BASE64_BYTES) {_            logger.debug("invalid token")__            listener.onResponse(null)__        } else {_            _            final Version version = Version.readVersion(in)__            in.setVersion(version)__            final BytesKey decodedSalt = new BytesKey(in.readByteArray())__            final BytesKey passphraseHash = new BytesKey(in.readByteArray())__            KeyAndCache keyAndCache = keyCache.get(passphraseHash)__            if (keyAndCache != null) {_                getKeyAsync(decodedSalt, keyAndCache, ActionListener.wrap(decodeKey -> {_                    try {_                        final byte[] iv = in.readByteArray()__                        final Cipher cipher = getDecryptionCipher(iv, decodeKey, version, decodedSalt)__                        decryptTokenId(in, cipher, version, ActionListener.wrap(tokenId -> {_                            if (securityIndex.isAvailable() == false) {_                                logger.warn("failed to get token [{}] since index is not available", tokenId)__                                listener.onResponse(null)__                            } else {_                                securityIndex.checkIndexVersionThenExecute(_                                    ex -> listener.onFailure(traceLog("prepare security index", tokenId, ex)),_                                    () -> {_                                        final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                                            getTokenDocumentId(tokenId)).request()__                                        Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("decode token", tokenId, ex))__                                        executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                                            ActionListener.<GetResponse>wrap(response -> {_                                                if (response.isExists()) {_                                                    Map<String, Object> accessTokenSource =_                                                        (Map<String, Object>) response.getSource().get("access_token")__                                                    if (accessTokenSource == null) {_                                                        onFailure.accept(new IllegalStateException(_                                                            "token document is missing the access_token field"))__                                                    } else if (accessTokenSource.containsKey("user_token") == false) {_                                                        onFailure.accept(new IllegalStateException(_                                                            "token document is missing the user_token field"))__                                                    } else {_                                                        Map<String, Object> userTokenSource =_                                                            (Map<String, Object>) accessTokenSource.get("user_token")__                                                        listener.onResponse(UserToken.fromSourceMap(userTokenSource))__                                                    }_                                                } else {_                                                    onFailure.accept(_                                                        new IllegalStateException("token document is missing and must be present"))__                                                }_                                            }, e -> {_                                                _                                                _                                                if (isShardNotAvailableException(e)) {_                                                    logger.warn("failed to get token [{}] since index is not available", tokenId)__                                                    listener.onResponse(null)__                                                } else {_                                                    logger.error(new ParameterizedMessage("failed to get token [{}]", tokenId), e)__                                                    listener.onFailure(e)__                                                }_                                            }), client::get)__                                    })__                            }_                        }, listener::onFailure))__                    } catch (GeneralSecurityException e) {_                        _                        logger.warn("invalid token", e)__                        listener.onResponse(null)__                    } finally {_                        in.close()__                    }_                }, e -> {_                    IOUtils.closeWhileHandlingException(in)__                    listener.onFailure(e)__                }))__            } else {_                IOUtils.closeWhileHandlingException(in)__                logger.debug("invalid key {} key: {}", passphraseHash, keyCache.cache.keySet())__                listener.onResponse(null)__            }_        }_    };asynchronously,decodes,the,string,representation,of,a,link,user,token,the,process,for,this,is,asynchronous,as,we,may,need,to,compute,a,key,which,can,be,computationally,expensive,so,this,should,not,block,the,current,thread,which,is,typically,a,network,thread,a,second,reason,for,being,asynchronous,is,that,we,can,restrain,the,amount,of,resources,consumed,by,the,key,computation,to,a,single,thread;void,decode,token,string,token,action,listener,user,token,listener,throws,ioexception,byte,bytes,token,get,bytes,standard,charsets,stream,input,in,new,input,stream,stream,input,base64,get,decoder,wrap,new,byte,array,input,stream,bytes,bytes,length,if,in,available,logger,debug,invalid,token,listener,on,response,null,else,final,version,version,version,read,version,in,in,set,version,version,final,bytes,key,decoded,salt,new,bytes,key,in,read,byte,array,final,bytes,key,passphrase,hash,new,bytes,key,in,read,byte,array,key,and,cache,key,and,cache,key,cache,get,passphrase,hash,if,key,and,cache,null,get,key,async,decoded,salt,key,and,cache,action,listener,wrap,decode,key,try,final,byte,iv,in,read,byte,array,final,cipher,cipher,get,decryption,cipher,iv,decode,key,version,decoded,salt,decrypt,token,id,in,cipher,version,action,listener,wrap,token,id,if,security,index,is,available,false,logger,warn,failed,to,get,token,since,index,is,not,available,token,id,listener,on,response,null,else,security,index,check,index,version,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,id,ex,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,token,id,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,decode,token,token,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,access,token,source,map,string,object,response,get,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,the,field,else,if,access,token,source,contains,key,false,on,failure,accept,new,illegal,state,exception,token,document,is,missing,the,field,else,map,string,object,user,token,source,map,string,object,access,token,source,get,listener,on,response,user,token,from,source,map,user,token,source,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,token,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,token,id,e,listener,on,failure,e,client,get,listener,on,failure,catch,general,security,exception,e,logger,warn,invalid,token,e,listener,on,response,null,finally,in,close,e,ioutils,close,while,handling,exception,in,listener,on,failure,e,else,ioutils,close,while,handling,exception,in,logger,debug,invalid,key,key,passphrase,hash,key,cache,cache,key,set,listener,on,response,null
TokenService -> synchronized TokenMetaData rotateToSpareKey();1524684173;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1525859433;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1526449283;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1527096592;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1529658035;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1535405719;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1538067637;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1539723533;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1539796943;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1540238977;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1541008027;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1541092382;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1541169206;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1545120350;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1545995382;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1547011415;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1549290341;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1549328556;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1549336917;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1549396415;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> synchronized TokenMetaData rotateToSpareKey();1550828001;Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.;synchronized TokenMetaData rotateToSpareKey() {_        KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get()__        if (maxKey == keyCache.activeKeyCache) {_            throw new IllegalStateException("call generateSpareKey first")__        }_        return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values())__    };rotate,the,current,active,key,to,the,spare,key,created,in,the,previous,link,generate,spare,key,call;synchronized,token,meta,data,rotate,to,spare,key,key,and,cache,max,key,key,cache,cache,values,stream,max,comparator,comparing,long,v,v,key,and,timestamp,get,timestamp,get,if,max,key,key,cache,active,key,cache,throw,new,illegal,state,exception,call,generate,spare,key,first,return,new,token,meta,data,max,key,get,key,hash,key,cache,cache,values
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1524684173;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1525859433;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1526449283;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1527096592;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1529658035;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1535405719;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1538067637;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1539723533;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1539796943;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1540238977;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1541008027;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1541092382;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1541169206;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_                ActionListener.wrap(tuple -> {_                    final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                    final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                    innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__                }, listener::onFailure),_                new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1545120350;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1545995382;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1547011415;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1549290341;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1549328556;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1549336917;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1549396415;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication userAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, userAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,user,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,user,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener);1550828001;Uses the refresh token to refresh its associated token and returns the new token with an_updated expiration date to the listener;public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {_        ensureEnabled()__        findTokenFromRefreshToken(refreshToken,_            ActionListener.wrap(tuple -> {_                final Authentication clientAuth = Authentication.readFromContext(client.threadPool().getThreadContext())__                final String tokenDocId = tuple.v1().getHits().getHits()[0].getId()__                innerRefresh(tokenDocId, clientAuth, listener, tuple.v2())__            }, listener::onFailure),_            new AtomicInteger(0))__    };uses,the,refresh,token,to,refresh,its,associated,token,and,returns,the,new,token,with,an,updated,expiration,date,to,the,listener;public,void,refresh,token,string,refresh,token,action,listener,tuple,user,token,string,listener,ensure,enabled,find,token,from,refresh,token,refresh,token,action,listener,wrap,tuple,final,authentication,client,auth,authentication,read,from,context,client,thread,pool,get,thread,context,final,string,token,doc,id,tuple,v1,get,hits,get,hits,0,get,id,inner,refresh,token,doc,id,client,auth,listener,tuple,v2,listener,on,failure,new,atomic,integer,0
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1545120350;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1545995382;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1547011415;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1549290341;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1549328556;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1549336917;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1549396415;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)         throws IOException;1550828001;Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token__@param source The token document source as retrieved_@param filter an optional Predicate to test the source of the UserToken against_@return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't_satisfy it;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter)_        throws IOException {__        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")__        final Map<String, Object> userTokenSource = (Map<String, Object>)_            ((Map<String, Object>) source.get("access_token")).get("user_token")__        if (null != filter && filter.test(userTokenSource) == false) {_            return null__        }_        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };parses,a,token,document,into,a,tuple,of,a,link,user,token,and,a,string,representing,the,corresponding,param,source,the,token,document,source,as,retrieved,param,filter,an,optional,predicate,to,test,the,source,of,the,user,token,against,return,a,link,tuple,of,access,token,and,refresh,token,id,or,null,if,a,predicate,is,defined,and,the,user,token,source,doesn,t,satisfy,it;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,nullable,predicate,map,string,object,filter,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,if,null,filter,filter,test,user,token,source,false,return,null,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1545120350;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1545995382;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1547011415;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1549290341;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1549328556;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1549336917;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1549396415;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,                                    AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult);1550828001;Performs the actual invalidation of a collection of tokens__@param tokenIds        the tokens to invalidate_@param listener        the listener to notify upon completion_@param attemptCount    the number of attempts to invalidate that have already been tried_@param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on_what type of tokens should be invalidated_@param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating_tokens up to the point of the retry. This result is added to the result of the current attempt;private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener,_                                   AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {_        if (tokenIds.isEmpty()) {_            logger.warn("No [{}] tokens provided for invalidation", srcPrefix)__            listener.onFailure(invalidGrantException("No tokens provided for invalidation"))__        } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(),_                attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate tokens"))__        } else {_            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk()__            for (String tokenId : tokenIds) {_                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId))_                    .setDoc(srcPrefix, Collections.singletonMap("invalidated", true))_                    .setFetchSource(srcPrefix, null)_                    .request()__                bulkRequestBuilder.add(request)__            }_            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),_                    ActionListener.<BulkResponse>wrap(bulkResponse -> {_                        ArrayList<String> retryTokenDocIds = new ArrayList<>()__                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>()__                        ArrayList<String> previouslyInvalidated = new ArrayList<>()__                        ArrayList<String> invalidated = new ArrayList<>()__                        if (null != previousResult) {_                            failedRequestResponses.addAll((previousResult.getErrors()))__                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens())__                            invalidated.addAll(previousResult.getInvalidatedTokens())__                        }_                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {_                            if (bulkItemResponse.isFailed()) {_                                Throwable cause = bulkItemResponse.getFailure().getCause()__                                final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId())__                                if (isShardNotAvailableException(cause)) {_                                    retryTokenDocIds.add(failedTokenDocId)__                                }_                                else {_                                    traceLog("invalidate access token", failedTokenDocId, cause)__                                    failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause))__                                }_                            } else {_                                UpdateResponse updateResponse = bulkItemResponse.getResponse()__                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {_                                    logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId())__                                    invalidated.add(updateResponse.getGetResult().getId())__                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {_                                    previouslyInvalidated.add(updateResponse.getGetResult().getId())__                                }_                            }_                        }_                        if (retryTokenDocIds.isEmpty() == false) {_                            TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                                failedRequestResponses, attemptCount.get())__                            attemptCount.incrementAndGet()__                            indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult)__                        }_                        TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,_                            failedRequestResponses, attemptCount.get())__                        listener.onResponse(result)__                    }, e -> {_                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                        traceLog("invalidate tokens", cause)__                        if (isShardNotAvailableException(cause)) {_                            attemptCount.incrementAndGet()__                            indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::bulk))__        }_    };performs,the,actual,invalidation,of,a,collection,of,tokens,param,token,ids,the,tokens,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,src,prefix,the,prefix,to,use,when,constructing,the,doc,to,update,either,or,depending,on,what,type,of,tokens,should,be,invalidated,param,previous,result,if,this,not,the,initial,attempt,for,invalidation,it,contains,the,result,of,invalidating,tokens,up,to,the,point,of,the,retry,this,result,is,added,to,the,result,of,the,current,attempt;private,void,index,invalidation,collection,string,token,ids,action,listener,tokens,invalidation,result,listener,atomic,integer,attempt,count,string,src,prefix,nullable,tokens,invalidation,result,previous,result,if,token,ids,is,empty,logger,warn,no,tokens,provided,for,invalidation,src,prefix,listener,on,failure,invalid,grant,exception,no,tokens,provided,for,invalidation,else,if,attempt,count,get,logger,warn,failed,to,invalidate,tokens,after,attempts,token,ids,size,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,tokens,else,bulk,request,builder,bulk,request,builder,client,prepare,bulk,for,string,token,id,token,ids,update,request,request,client,prepare,update,security,index,manager,type,get,token,document,id,token,id,set,doc,src,prefix,collections,singleton,map,invalidated,true,set,fetch,source,src,prefix,null,request,bulk,request,builder,add,request,bulk,request,builder,set,refresh,policy,refresh,policy,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,ex,execute,async,with,origin,client,thread,pool,get,thread,context,bulk,request,builder,request,action,listener,bulk,response,wrap,bulk,response,array,list,string,retry,token,doc,ids,new,array,list,array,list,elasticsearch,exception,failed,request,responses,new,array,list,array,list,string,previously,invalidated,new,array,list,array,list,string,invalidated,new,array,list,if,null,previous,result,failed,request,responses,add,all,previous,result,get,errors,previously,invalidated,add,all,previous,result,get,previously,invalidated,tokens,invalidated,add,all,previous,result,get,invalidated,tokens,for,bulk,item,response,bulk,item,response,bulk,response,get,items,if,bulk,item,response,is,failed,throwable,cause,bulk,item,response,get,failure,get,cause,final,string,failed,token,doc,id,get,token,id,from,document,id,bulk,item,response,get,failure,get,id,if,is,shard,not,available,exception,cause,retry,token,doc,ids,add,failed,token,doc,id,else,trace,log,invalidate,access,token,failed,token,doc,id,cause,failed,request,responses,add,new,elasticsearch,exception,error,invalidating,src,prefix,cause,else,update,response,update,response,bulk,item,response,get,response,if,update,response,get,result,doc,write,response,result,updated,logger,debug,invalidated,for,doc,src,prefix,update,response,get,get,result,get,id,invalidated,add,update,response,get,get,result,get,id,else,if,update,response,get,result,doc,write,response,result,noop,previously,invalidated,add,update,response,get,get,result,get,id,if,retry,token,doc,ids,is,empty,false,tokens,invalidation,result,incomplete,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,attempt,count,increment,and,get,index,invalidation,retry,token,doc,ids,listener,attempt,count,src,prefix,incomplete,result,tokens,invalidation,result,result,new,tokens,invalidation,result,invalidated,previously,invalidated,failed,request,responses,attempt,count,get,listener,on,response,result,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,invalidate,tokens,cause,if,is,shard,not,available,exception,cause,attempt,count,increment,and,get,index,invalidation,token,ids,listener,attempt,count,src,prefix,previous,result,else,listener,on,failure,e,client,bulk
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1524684173;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1525859433;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1526449283;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1527096592;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1529658035;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1535405719;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1538067637;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1539723533;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1539796943;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1540238977;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1541008027;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1541092382;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1541169206;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1545120350;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1545995382;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1547011415;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1549290341;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1549328556;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1549336917;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1549396415;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)             throws NoSuchAlgorithmException, InvalidKeySpecException;1550828001;Generates a secret key based off of the provided password and salt._This method is computationally expensive.;static SecretKey computeSecretKey(char[] rawPassword, byte[] salt)_            throws NoSuchAlgorithmException, InvalidKeySpecException {_        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM)__        PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128)__        SecretKey tmp = secretKeyFactory.generateSecret(keySpec)__        return new SecretKeySpec(tmp.getEncoded(), "AES")__    };generates,a,secret,key,based,off,of,the,provided,password,and,salt,this,method,is,computationally,expensive;static,secret,key,compute,secret,key,char,raw,password,byte,salt,throws,no,such,algorithm,exception,invalid,key,spec,exception,secret,key,factory,secret,key,factory,secret,key,factory,get,instance,pbekey,spec,key,spec,new,pbekey,spec,raw,password,salt,iterations,128,secret,key,tmp,secret,key,factory,generate,secret,key,spec,return,new,secret,key,spec,tmp,get,encoded,aes
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1524684173;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1525859433;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1526449283;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1527096592;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1529658035;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1535405719;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1538067637;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1539723533;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1539796943;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1540238977;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1541008027;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1541092382;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1541169206;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1545120350;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1545995382;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1547011415;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1549290341;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1549328556;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1549336917;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1549396415;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> synchronized TokenMetaData pruneKeys(int numKeysToKeep);1550828001;Prunes the keys and keeps up to the latest N keys around__@param numKeysToKeep the number of keys to keep.;synchronized TokenMetaData pruneKeys(int numKeysToKeep) {_        if (keyCache.cache.size() <= numKeysToKeep) {_            return getTokenMetaData()_ _        }_        Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1)__        KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash)__        ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values())__        Collections.sort(entries,_                (left, right) ->  Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp()))__        for (KeyAndCache value : entries) {_            if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey_                    .keyAndTimestamp.getTimestamp()) {_                logger.debug("keeping key {} ", value.getKeyHash())__                map.put(value.getKeyHash(), value)__            } else {_                logger.debug("prune key {} ", value.getKeyHash())__            }_        }_        assert map.isEmpty() == false__        assert map.containsKey(keyCache.currentTokenKeyHash)__        return newTokenMetaData(keyCache.currentTokenKeyHash, map.values())__    };prunes,the,keys,and,keeps,up,to,the,latest,n,keys,around,param,num,keys,to,keep,the,number,of,keys,to,keep;synchronized,token,meta,data,prune,keys,int,num,keys,to,keep,if,key,cache,cache,size,num,keys,to,keep,return,get,token,meta,data,map,bytes,key,key,and,cache,map,new,hash,map,key,cache,cache,size,1,key,and,cache,current,key,key,cache,get,key,cache,current,token,key,hash,array,list,key,and,cache,entries,new,array,list,key,cache,cache,values,collections,sort,entries,left,right,long,compare,right,key,and,timestamp,get,timestamp,left,key,and,timestamp,get,timestamp,for,key,and,cache,value,entries,if,map,size,num,keys,to,keep,value,key,and,timestamp,get,timestamp,current,key,key,and,timestamp,get,timestamp,logger,debug,keeping,key,value,get,key,hash,map,put,value,get,key,hash,value,else,logger,debug,prune,key,value,get,key,hash,assert,map,is,empty,false,assert,map,contains,key,key,cache,current,token,key,hash,return,new,token,meta,data,key,cache,current,token,key,hash,map,values
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1524684173;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1525859433;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1526449283;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1527096592;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1529658035;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1535405719;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1538067637;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1539723533;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1539796943;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1540238977;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1541008027;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1541092382;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1541169206;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1545120350;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1545995382;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1547011415;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1549290341;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1549328556;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1549336917;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1549396415;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private static ElasticsearchSecurityException expiredTokenException();1550828001;Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It_is up to the client to re-authenticate and obtain a new token. The format for this response_is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>;private static ElasticsearchSecurityException expiredTokenException() {_        ElasticsearchSecurityException e =_                new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED)__        e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE)__        return e__    };creates,an,link,elasticsearch,security,exception,that,indicates,the,token,was,expired,it,is,up,to,the,client,to,re,authenticate,and,obtain,a,new,token,the,format,for,this,response,is,defined,in,a,href,https,tools,ietf,org,html,rfc6750,section,3,1,a;private,static,elasticsearch,security,exception,expired,token,exception,elasticsearch,security,exception,e,new,elasticsearch,security,exception,token,expired,rest,status,unauthorized,e,add,header,www,authenticate,return,e
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1539796943;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace("Failure in [{}] for id [{}] - [{}] [{}]", action, identifier, detail, esEx.getDetailedMessage())__                } else {_                    logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, esEx.getDetailedMessage())__                }_            } else {_                logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, exception.toString())__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,failure,in,for,id,action,identifier,detail,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,exception,to,string,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1540238977;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace("Failure in [{}] for id [{}] - [{}] [{}]", action, identifier, detail, esEx.getDetailedMessage())__                } else {_                    logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, esEx.getDetailedMessage())__                }_            } else {_                logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, exception.toString())__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,failure,in,for,id,action,identifier,detail,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,exception,to,string,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1541008027;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace("Failure in [{}] for id [{}] - [{}] [{}]", action, identifier, detail, esEx.getDetailedMessage())__                } else {_                    logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, esEx.getDetailedMessage())__                }_            } else {_                logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, exception.toString())__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,failure,in,for,id,action,identifier,detail,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,exception,to,string,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1541092382;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace("Failure in [{}] for id [{}] - [{}] [{}]", action, identifier, detail, esEx.getDetailedMessage())__                } else {_                    logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, esEx.getDetailedMessage())__                }_            } else {_                logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, exception.toString())__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,failure,in,for,id,action,identifier,detail,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,exception,to,string,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1541169206;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace("Failure in [{}] for id [{}] - [{}] [{}]", action, identifier, detail, esEx.getDetailedMessage())__                } else {_                    logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, esEx.getDetailedMessage())__                }_            } else {_                logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, exception.toString())__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,failure,in,for,id,action,identifier,detail,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,es,ex,get,detailed,message,else,logger,trace,failure,in,for,id,action,identifier,exception,to,string,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1545120350;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1545995382;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1547011415;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1549290341;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1549328556;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1549336917;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1549396415;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, String identifier, E exception);1550828001;Logs an exception concerning a specific Token at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, String identifier, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail),_                        esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier),_                        esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception)__            }_        }_        return exception__    };logs,an,exception,concerning,a,specific,token,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,string,identifier,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,es,ex,else,logger,trace,new,parameterized,message,failure,in,for,id,action,identifier,exception,return,exception
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1524684173;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1525859433;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1526449283;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1527096592;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1529658035;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1535405719;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1538067637;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1539723533;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1539796943;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1540238977;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1541008027;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1541092382;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1541169206;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1545120350;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1545995382;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1547011415;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1549290341;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1549328556;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1549336917;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth);1549396415;Performs checks on the retrieved source and returns an {@link Optional} with the exception_if there is an issue;private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication userAuth) {_        final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token")__        final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token")__        if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the refresh_token object"))__        } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {_            return Optional.of(invalidGrantException("token document is missing the access_token object"))__        } else {_            final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed")__            final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated")__            final Long creationEpochMilli = (Long) source.get("creation_time")__            final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli)__            final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token")__            if (refreshed == null) {_                return Optional.of(invalidGrantException("token document is missing refreshed value"))__            } else if (invalidated == null) {_                return Optional.of(invalidGrantException("token document is missing invalidated value"))__            } else if (creationEpochMilli == null) {_                return Optional.of(invalidGrantException("token document is missing creation time value"))__            } else if (refreshed) {_                return Optional.of(invalidGrantException("token has already been refreshed"))__            } else if (invalidated) {_                return Optional.of(invalidGrantException("token has been invalidated"))__            } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {_                return Optional.of(invalidGrantException("refresh token is expired"))__            } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {_                return Optional.of(invalidGrantException("token document is missing the user token info"))__            } else if (userTokenSrc.get("authentication") == null) {_                return Optional.of(invalidGrantException("token is missing authentication info"))__            } else if (userTokenSrc.get("version") == null) {_                return Optional.of(invalidGrantException("token is missing version value"))__            } else if (userTokenSrc.get("metadata") == null) {_                return Optional.of(invalidGrantException("token is missing metadata"))__            } else {_                return checkClient(refreshTokenSrc, userAuth)__            }_        }_    };performs,checks,on,the,retrieved,source,and,returns,an,link,optional,with,the,exception,if,there,is,an,issue;private,optional,elasticsearch,security,exception,check,token,doc,for,refresh,map,string,object,source,authentication,user,auth,final,map,string,object,refresh,token,src,map,string,object,source,get,final,map,string,object,access,token,src,map,string,object,source,get,if,refresh,token,src,null,refresh,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,if,access,token,src,null,access,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,object,else,final,boolean,refreshed,boolean,refresh,token,src,get,refreshed,final,boolean,invalidated,boolean,refresh,token,src,get,invalidated,final,long,creation,epoch,milli,long,source,get,final,instant,creation,time,creation,epoch,milli,null,null,instant,of,epoch,milli,creation,epoch,milli,final,map,string,object,user,token,src,map,string,object,access,token,src,get,if,refreshed,null,return,optional,of,invalid,grant,exception,token,document,is,missing,refreshed,value,else,if,invalidated,null,return,optional,of,invalid,grant,exception,token,document,is,missing,invalidated,value,else,if,creation,epoch,milli,null,return,optional,of,invalid,grant,exception,token,document,is,missing,creation,time,value,else,if,refreshed,return,optional,of,invalid,grant,exception,token,has,already,been,refreshed,else,if,invalidated,return,optional,of,invalid,grant,exception,token,has,been,invalidated,else,if,clock,instant,is,after,creation,time,plus,24l,chrono,unit,hours,return,optional,of,invalid,grant,exception,refresh,token,is,expired,else,if,user,token,src,null,user,token,src,is,empty,return,optional,of,invalid,grant,exception,token,document,is,missing,the,user,token,info,else,if,user,token,src,get,authentication,null,return,optional,of,invalid,grant,exception,token,is,missing,authentication,info,else,if,user,token,src,get,version,null,return,optional,of,invalid,grant,exception,token,is,missing,version,value,else,if,user,token,src,get,metadata,null,return,optional,of,invalid,grant,exception,token,is,missing,metadata,else,return,check,client,refresh,token,src,user,auth
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1524684173;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1525859433;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1526449283;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1527096592;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1529658035;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1535405719;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1538067637;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1539723533;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1539796943;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1540238977;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1541008027;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1541092382;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException;1541169206;@return A {@link Tuple} of access-token and refresh-token-id;private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source) throws IOException {_        final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token")___        final Map<String, Object> userTokenSource = (Map<String, Object>)_                ((Map<String, Object>) source.get("access_token")).get("user_token")__        final String id = (String) userTokenSource.get("id")__        final Integer version = (Integer) userTokenSource.get("version")__        final String authString = (String) userTokenSource.get("authentication")__        final Long expiration = (Long) userTokenSource.get("expiration_time")__        final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___        Version authVersion = Version.fromId(version)__        try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_            in.setVersion(authVersion)__            Authentication authentication = new Authentication(in)__            return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata),_                    refreshToken)__        }_    };return,a,link,tuple,of,access,token,and,refresh,token,id;private,tuple,user,token,string,parse,tokens,from,document,map,string,object,source,throws,ioexception,final,string,refresh,token,string,map,string,object,source,get,get,token,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,id,string,user,token,source,get,id,final,integer,version,integer,user,token,source,get,version,final,string,auth,string,string,user,token,source,get,authentication,final,long,expiration,long,user,token,source,get,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,return,new,tuple,new,user,token,id,version,from,id,version,authentication,instant,of,epoch,milli,expiration,metadata,refresh,token
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1545120350;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1545995382;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1547011415;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1549290341;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1549328556;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1549336917;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1549396415;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,                                                       ActionListener<TokensInvalidationResult> listener);1550828001;Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given_{@code username} so that they may no longer be used__@param realmName the realm of which the tokens should be invalidated_@param username the username for which the tokens should be invalidated_@param listener  the listener to notify upon completion;public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username,_                                                      ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {_            logger.trace("No realm name or username provided")__            listener.onFailure(new IllegalArgumentException("realm name or username must be provided"))__        } else {_            if (Strings.isNullOrEmpty(realmName)) {_                findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure))__            } else {_                Predicate filter = null__                if (Strings.hasText(username)) {_                    filter = isOfUser(username)__                }_                findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {_                    if (tokenTuples.isEmpty()) {_                        logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username)__                        listener.onResponse(TokensInvalidationResult.emptyResult())__                    } else {_                        invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener)__                    }_                }, listener::onFailure), filter)__            }_        }_    };invalidate,all,access,tokens,and,all,refresh,tokens,of,a,given,code,realm,name,and,or,of,a,given,code,username,so,that,they,may,no,longer,be,used,param,realm,name,the,realm,of,which,the,tokens,should,be,invalidated,param,username,the,username,for,which,the,tokens,should,be,invalidated,param,listener,the,listener,to,notify,upon,completion;public,void,invalidate,active,tokens,for,realm,and,user,nullable,string,realm,name,nullable,string,username,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,realm,name,strings,is,null,or,empty,username,logger,trace,no,realm,name,or,username,provided,listener,on,failure,new,illegal,argument,exception,realm,name,or,username,must,be,provided,else,if,strings,is,null,or,empty,realm,name,find,active,tokens,for,user,username,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,else,predicate,filter,null,if,strings,has,text,username,filter,is,of,user,username,find,active,tokens,for,realm,realm,name,action,listener,wrap,token,tuples,if,token,tuples,is,empty,logger,warn,no,tokens,to,invalidate,for,realm,and,username,realm,name,username,listener,on,response,tokens,invalidation,result,empty,result,else,invalidate,all,tokens,token,tuples,stream,map,t,t,v1,get,id,collect,collectors,to,list,listener,listener,on,failure,filter
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1524684173;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1525859433;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1526449283;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1527096592;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1529658035;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1535405719;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1538067637;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1539723533;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1539796943;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1540238977;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1541008027;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1541092382;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1541169206;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1545120350;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                if (userToken.getVersion().onOrAfter(Version.V_6_2_0)) {_                    encryptedStreamOutput.writeString(userToken.getId())__                } else {_                    userToken.writeTo(encryptedStreamOutput)__                }_                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,if,user,token,get,version,on,or,after,version,encrypted,stream,output,write,string,user,token,get,id,else,user,token,write,to,encrypted,stream,output,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1545995382;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1547011415;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1549290341;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1549328556;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1549336917;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1549396415;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException;1550828001;Serializes a token to a String containing an encrypted representation of the token;public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {_        _        try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES)__             OutputStream base64 = Base64.getEncoder().wrap(os)__             StreamOutput out = new OutputStreamStreamOutput(base64)) {_            out.setVersion(userToken.getVersion())__            KeyAndCache keyAndCache = keyCache.activeKeyCache__            Version.writeVersion(userToken.getVersion(), out)__            out.writeByteArray(keyAndCache.getSalt().bytes)__            out.writeByteArray(keyAndCache.getKeyHash().bytes)__            final byte[] initializationVector = getNewInitializationVector()__            out.writeByteArray(initializationVector)__            try (CipherOutputStream encryptedOutput =_                         new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion()))__                 StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {_                encryptedStreamOutput.setVersion(userToken.getVersion())__                encryptedStreamOutput.writeString(userToken.getId())__                encryptedStreamOutput.close()__                return new String(os.toByteArray(), StandardCharsets.UTF_8)__            }_        }_    };serializes,a,token,to,a,string,containing,an,encrypted,representation,of,the,token;public,string,get,user,token,string,user,token,user,token,throws,ioexception,general,security,exception,try,byte,array,output,stream,os,new,byte,array,output,stream,output,stream,base64,base64,get,encoder,wrap,os,stream,output,out,new,output,stream,stream,output,base64,out,set,version,user,token,get,version,key,and,cache,key,and,cache,key,cache,active,key,cache,version,write,version,user,token,get,version,out,out,write,byte,array,key,and,cache,get,salt,bytes,out,write,byte,array,key,and,cache,get,key,hash,bytes,final,byte,initialization,vector,get,new,initialization,vector,out,write,byte,array,initialization,vector,try,cipher,output,stream,encrypted,output,new,cipher,output,stream,out,get,encryption,cipher,initialization,vector,key,and,cache,user,token,get,version,stream,output,encrypted,stream,output,new,output,stream,stream,output,encrypted,output,encrypted,stream,output,set,version,user,token,get,version,encrypted,stream,output,write,string,user,token,get,id,encrypted,stream,output,close,return,new,string,os,to,byte,array,standard,charsets
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1545120350;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves a step that is needed for backwards compatibility_with versions prior to 6.2.0_ this step records an entry to indicate that a token with a_given id has been expired. The second step is to record the invalidation for tokens that_have been created on versions on or after 6.2_ this step involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        final long expirationEpochMilli = getExpirationTime().toEpochMilli()__                        indexBwcInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            expirationEpochMilli, null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,a,step,that,is,needed,for,backwards,compatibility,with,versions,prior,to,6,2,0,this,step,records,an,entry,to,indicate,that,a,token,with,a,given,id,has,been,expired,the,second,step,is,to,record,the,invalidation,for,tokens,that,have,been,created,on,versions,on,or,after,6,2,this,step,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,final,long,expiration,epoch,milli,get,expiration,time,to,epoch,milli,index,bwc,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,expiration,epoch,milli,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1545995382;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1547011415;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1549290341;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1549328556;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1549336917;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1549396415;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener);1550828001;This method performs the steps necessary to invalidate a token so that it may no longer be_used. The process of invalidation involves performing an update to_the token document and setting the <code>invalidated</code> field to <code>true</code>;public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {_        ensureEnabled()__        if (Strings.isNullOrEmpty(tokenString)) {_            logger.trace("No token-string provided")__            listener.onFailure(new IllegalArgumentException("token must be provided"))__        } else {_            maybeStartTokenRemover()__            try {_                decodeToken(tokenString, ActionListener.wrap(userToken -> {_                    if (userToken == null) {_                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()))__                    } else {_                        indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0),_                            "access_token", null)__                    }_                }, listener::onFailure))__            } catch (IOException e) {_                logger.error("received a malformed token as part of a invalidation request", e)__                listener.onFailure(malformedTokenException())__            }_        }_    };this,method,performs,the,steps,necessary,to,invalidate,a,token,so,that,it,may,no,longer,be,used,the,process,of,invalidation,involves,performing,an,update,to,the,token,document,and,setting,the,code,invalidated,code,field,to,code,true,code;public,void,invalidate,access,token,string,token,string,action,listener,tokens,invalidation,result,listener,ensure,enabled,if,strings,is,null,or,empty,token,string,logger,trace,no,token,string,provided,listener,on,failure,new,illegal,argument,exception,token,must,be,provided,else,maybe,start,token,remover,try,decode,token,token,string,action,listener,wrap,user,token,if,user,token,null,listener,on,failure,trace,log,invalidate,token,token,string,malformed,token,exception,else,index,invalidation,collections,singleton,user,token,get,id,listener,new,atomic,integer,0,null,listener,on,failure,catch,ioexception,e,logger,error,received,a,malformed,token,as,part,of,a,invalidation,request,e,listener,on,failure,malformed,token,exception
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException;1524684173;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = UUIDs.randomBase64UUID()___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                lifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,uuids,random,base64uuid,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,lifecycle,service,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException;1525859433;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = UUIDs.randomBase64UUID()___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                lifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,uuids,random,base64uuid,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,lifecycle,service,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException;1526449283;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = UUIDs.randomBase64UUID()___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,uuids,random,base64uuid,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,index,manager,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException;1527096592;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = UUIDs.randomBase64UUID()___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,uuids,random,base64uuid,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,index,manager,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> public void createUserToken(Authentication authentication, Authentication originatingClientAuth,                                 ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException;1529658035;Create a token based on the provided authentication and metadata._The created token will be stored in the security index.;public void createUserToken(Authentication authentication, Authentication originatingClientAuth,_                                ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata) throws IOException {_        ensureEnabled()__        if (authentication == null) {_            listener.onFailure(new IllegalArgumentException("authentication must be provided"))__        } else if (originatingClientAuth == null) {_            listener.onFailure(new IllegalArgumentException("originating client authentication must be provided"))__        } else {_            final Instant created = clock.instant()__            final Instant expiration = getExpirationTime(created)__            final Version version = clusterService.state().nodes().getMinNodeVersion()__            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :_                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),_                            version)__            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata)__            final String refreshToken = UUIDs.randomBase64UUID()___            try (XContentBuilder builder = XContentFactory.jsonBuilder()) {_                builder.startObject()__                builder.field("doc_type", "token")__                builder.field("creation_time", created.toEpochMilli())__                builder.startObject("refresh_token")_                        .field("token", refreshToken)_                        .field("invalidated", false)_                        .field("refreshed", false)_                        .startObject("client")_                            .field("type", "unassociated_client")_                            .field("user", originatingClientAuth.getUser().principal())_                            .field("realm", originatingClientAuth.getAuthenticatedBy().getName())_                        .endObject()_                        .endObject()__                builder.startObject("access_token")_                        .field("invalidated", false)_                        .field("user_token", userToken)_                        .field("realm", authentication.getAuthenticatedBy().getName())_                        .endObject()__                builder.endObject()__                IndexRequest request =_                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken))_                                .setOpType(OpType.CREATE)_                                .setSource(builder)_                                .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                .request()__                securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,_                                ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)),_                                        listener::onFailure))_                )__            }_        }_    };create,a,token,based,on,the,provided,authentication,and,metadata,the,created,token,will,be,stored,in,the,security,index;public,void,create,user,token,authentication,authentication,authentication,originating,client,auth,action,listener,tuple,user,token,string,listener,map,string,object,metadata,throws,ioexception,ensure,enabled,if,authentication,null,listener,on,failure,new,illegal,argument,exception,authentication,must,be,provided,else,if,originating,client,auth,null,listener,on,failure,new,illegal,argument,exception,originating,client,authentication,must,be,provided,else,final,instant,created,clock,instant,final,instant,expiration,get,expiration,time,created,final,version,version,cluster,service,state,nodes,get,min,node,version,final,authentication,matching,version,auth,version,equals,authentication,get,version,authentication,new,authentication,authentication,get,user,authentication,get,authenticated,by,authentication,get,looked,up,by,version,final,user,token,user,token,new,user,token,version,matching,version,auth,expiration,metadata,final,string,refresh,token,uuids,random,base64uuid,try,xcontent,builder,builder,xcontent,factory,json,builder,builder,start,object,builder,field,token,builder,field,created,to,epoch,milli,builder,start,object,field,token,refresh,token,field,invalidated,false,field,refreshed,false,start,object,client,field,type,field,user,originating,client,auth,get,user,principal,field,realm,originating,client,auth,get,authenticated,by,get,name,end,object,end,object,builder,start,object,field,invalidated,false,field,user,token,field,realm,authentication,get,authenticated,by,get,name,end,object,builder,end,object,index,request,request,client,prepare,index,security,index,manager,type,get,token,document,id,user,token,set,op,type,op,type,create,set,source,builder,set,refresh,policy,refresh,policy,request,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,index,action,instance,request,action,listener,wrap,index,response,listener,on,response,new,tuple,user,token,refresh,token,listener,on,failure
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1524684173;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,lifecycle,service,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,lifecycle,service,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1525859433;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,lifecycle,service,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,lifecycle,service,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1526449283;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1527096592;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1529658035;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1535405719;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1538067637;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1539723533;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > 5) {_            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            final Map<String, Object> source = response.getSource()__                            final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                            if (invalidSource.isPresent()) {_                                listener.onFailure(invalidSource.get())__                            } else {_                                final Map<String, Object> userTokenSource = (Map<String, Object>)_                                        ((Map<String, Object>) source.get("access_token")).get("user_token")__                                final String authString = (String) userTokenSource.get("authentication")__                                final Integer version = (Integer) userTokenSource.get("version")__                                final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                                Version authVersion = Version.fromId(version)__                                try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                    in.setVersion(authVersion)__                                    Authentication authentication = new Authentication(in)__                                    UpdateRequest updateRequest =_                                            client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                                    .setVersion(response.getVersion())_                                                    .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                                    .request()__                                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                            ActionListener.<UpdateResponse>wrap(_                                                    updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                                    e -> {_                                                        Throwable cause = ExceptionsHelper.unwrapCause(e)__                                                        if (cause instanceof VersionConflictEngineException ||_                                                                isShardNotAvailableException(e)) {_                                                            innerRefresh(tokenDocId, userAuth,_                                                                    listener, attemptCount)__                                                        } else {_                                                            listener.onFailure(e)__                                                        }_                                                    }),_                                            client::update)__                                }_                            }_                        } else {_                            logger.info("could not find token document [{}] for refresh", tokenDocId)__                            listener.onFailure(invalidGrantException("could not refresh the requested token"))__                        }_                    }, e -> {_                        if (isShardNotAvailableException(e)) {_                            innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                        } else {_                            listener.onFailure(e)__                        }_                    }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,5,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,listener,on,failure,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1539796943;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1540238977;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1541008027;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1541092382;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1541169206;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1545120350;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1545995382;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1547011415;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequest updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setVersion(response.getVersion())_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                                        .request()__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest,_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,version,response,get,version,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,request,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1549290341;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequestBuilder updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__                                if (clusterService.state().nodes().getMinNodeVersion().onOrAfter(Version.V_6_7_0)) {_                                    updateRequest.setIfSeqNo(response.getSeqNo())__                                    updateRequest.setIfPrimaryTerm(response.getPrimaryTerm())__                                } else {_                                    updateRequest.setVersion(response.getVersion())__                                }_                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest.request(),_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,builder,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,if,cluster,service,state,nodes,get,min,node,version,on,or,after,version,update,request,set,if,seq,no,response,get,seq,no,update,request,set,if,primary,term,response,get,primary,term,else,update,request,set,version,response,get,version,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1549328556;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequestBuilder updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__                                if (clusterService.state().nodes().getMinNodeVersion().onOrAfter(Version.V_6_7_0)) {_                                    updateRequest.setIfSeqNo(response.getSeqNo())__                                    updateRequest.setIfPrimaryTerm(response.getPrimaryTerm())__                                } else {_                                    updateRequest.setVersion(response.getVersion())__                                }_                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest.request(),_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,builder,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,if,cluster,service,state,nodes,get,min,node,version,on,or,after,version,update,request,set,if,seq,no,response,get,seq,no,update,request,set,if,primary,term,response,get,primary,term,else,update,request,set,version,response,get,version,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1549336917;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequestBuilder updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__                                if (clusterService.state().nodes().getMinNodeVersion().onOrAfter(Version.V_6_7_0)) {_                                    updateRequest.setIfSeqNo(response.getSeqNo())__                                    updateRequest.setIfPrimaryTerm(response.getPrimaryTerm())__                                } else {_                                    updateRequest.setVersion(response.getVersion())__                                }_                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest.request(),_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,builder,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,if,cluster,service,state,nodes,get,min,node,version,on,or,after,version,update,request,set,if,seq,no,response,get,seq,no,update,request,set,if,primary,term,response,get,primary,term,else,update,request,set,version,response,get,version,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,                               AtomicInteger attemptCount);1549396415;Performs the actual refresh of the token with retries in case of certain exceptions that_may be recoverable. The refresh involves retrieval of the token document and then_updating the token document to indicate that the document has been refreshed.;private void innerRefresh(String tokenDocId, Authentication userAuth, ActionListener<Tuple<UserToken, String>> listener,_                              AtomicInteger attemptCount) {_        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get())__            listener.onFailure(invalidGrantException("could not refresh the requested token"))__        } else {_            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex))__            GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request()__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                ActionListener.<GetResponse>wrap(response -> {_                    if (response.isExists()) {_                        final Map<String, Object> source = response.getSource()__                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, userAuth)___                        if (invalidSource.isPresent()) {_                            onFailure.accept(invalidSource.get())__                        } else {_                            final Map<String, Object> userTokenSource = (Map<String, Object>)_                                ((Map<String, Object>) source.get("access_token")).get("user_token")__                            final String authString = (String) userTokenSource.get("authentication")__                            final Integer version = (Integer) userTokenSource.get("version")__                            final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata")___                            Version authVersion = Version.fromId(version)__                            try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {_                                in.setVersion(authVersion)__                                Authentication authentication = new Authentication(in)__                                UpdateRequestBuilder updateRequest =_                                    client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId)_                                        .setDoc("refresh_token", Collections.singletonMap("refreshed", true))_                                        .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)__                                updateRequest.setIfSeqNo(response.getSeqNo())__                                updateRequest.setIfPrimaryTerm(response.getPrimaryTerm())__                                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest.request(),_                                    ActionListener.<UpdateResponse>wrap(_                                        updateResponse -> createUserToken(authentication, userAuth, listener, metadata, true),_                                        e -> {_                                            Throwable cause = ExceptionsHelper.unwrapCause(e)__                                            if (cause instanceof VersionConflictEngineException ||_                                                isShardNotAvailableException(e)) {_                                                innerRefresh(tokenDocId, userAuth,_                                                    listener, attemptCount)__                                            } else {_                                                onFailure.accept(e)__                                            }_                                        }),_                                    client::update)__                            }_                        }_                    } else {_                        logger.info("could not find token document [{}] for refresh", tokenDocId)__                        onFailure.accept(invalidGrantException("could not refresh the requested token"))__                    }_                }, e -> {_                    if (isShardNotAvailableException(e)) {_                        innerRefresh(tokenDocId, userAuth, listener, attemptCount)__                    } else {_                        listener.onFailure(e)__                    }_                }), client::get)__        }_    };performs,the,actual,refresh,of,the,token,with,retries,in,case,of,certain,exceptions,that,may,be,recoverable,the,refresh,involves,retrieval,of,the,token,document,and,then,updating,the,token,document,to,indicate,that,the,document,has,been,refreshed;private,void,inner,refresh,string,token,doc,id,authentication,user,auth,action,listener,tuple,user,token,string,listener,atomic,integer,attempt,count,if,attempt,count,get,and,increment,logger,warn,failed,to,refresh,token,for,doc,after,attempts,token,doc,id,attempt,count,get,listener,on,failure,invalid,grant,exception,could,not,refresh,the,requested,token,else,consumer,exception,on,failure,ex,listener,on,failure,trace,log,refresh,token,token,doc,id,ex,get,request,get,request,client,prepare,get,security,index,manager,type,token,doc,id,request,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,final,map,string,object,source,response,get,source,final,optional,elasticsearch,security,exception,invalid,source,check,token,doc,for,refresh,source,user,auth,if,invalid,source,is,present,on,failure,accept,invalid,source,get,else,final,map,string,object,user,token,source,map,string,object,map,string,object,source,get,get,final,string,auth,string,string,user,token,source,get,authentication,final,integer,version,integer,user,token,source,get,version,final,map,string,object,metadata,map,string,object,user,token,source,get,metadata,version,auth,version,version,from,id,version,try,stream,input,in,stream,input,wrap,base64,get,decoder,decode,auth,string,in,set,version,auth,version,authentication,authentication,new,authentication,in,update,request,builder,update,request,client,prepare,update,security,index,manager,type,token,doc,id,set,doc,collections,singleton,map,refreshed,true,set,refresh,policy,refresh,policy,update,request,set,if,seq,no,response,get,seq,no,update,request,set,if,primary,term,response,get,primary,term,execute,async,with,origin,client,thread,pool,get,thread,context,update,request,request,action,listener,update,response,wrap,update,response,create,user,token,authentication,user,auth,listener,metadata,true,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,on,failure,accept,e,client,update,else,logger,info,could,not,find,token,document,for,refresh,token,doc,id,on,failure,accept,invalid,grant,exception,could,not,refresh,the,requested,token,e,if,is,shard,not,available,exception,e,inner,refresh,token,doc,id,user,auth,listener,attempt,count,else,listener,on,failure,e,client,get
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1524684173;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1525859433;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1526449283;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1527096592;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1529658035;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1535405719;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1538067637;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1539723533;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1539796943;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1540238977;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1541008027;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1541092382;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1541169206;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1545120350;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeAndValidateToken(token, ActionListener.wrap(listener::onResponse, e -> {_                        if (e instanceof IOException) {_                            _                            logger.debug("invalid token", e)__                            listener.onResponse(null)__                        } else {_                            listener.onFailure(e)__                        }_                    }))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,and,validate,token,token,action,listener,wrap,listener,on,response,e,if,e,instanceof,ioexception,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,failure,e,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1545995382;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1547011415;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1549290341;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1549328556;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1549336917;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1549396415;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener);1550828001;Looks in the context to see if the request provided a header with a user token and if so the_token is validated, which includes authenticated decryption and verification that the token_has not been revoked or is expired.;void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {_        if (enabled) {_            final String token = getFromHeader(ctx)__            if (token == null) {_                listener.onResponse(null)__            } else {_                try {_                    decodeToken(token, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            checkIfTokenIsValid(userToken, listener)__                        } else {_                            listener.onResponse(null)__                        }_                    }, listener::onFailure))__                } catch (IOException e) {_                    _                    logger.debug("invalid token", e)__                    listener.onResponse(null)__                }_            }_        } else {_            listener.onResponse(null)__        }_    };looks,in,the,context,to,see,if,the,request,provided,a,header,with,a,user,token,and,if,so,the,token,is,validated,which,includes,authenticated,decryption,and,verification,that,the,token,has,not,been,revoked,or,is,expired;void,get,and,validate,token,thread,context,ctx,action,listener,user,token,listener,if,enabled,final,string,token,get,from,header,ctx,if,token,null,listener,on,response,null,else,try,decode,token,token,action,listener,wrap,user,token,if,user,token,null,check,if,token,is,valid,user,token,listener,else,listener,on,response,null,listener,on,failure,catch,ioexception,e,logger,debug,invalid,token,e,listener,on,response,null,else,listener,on,response,null
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1545995382;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        }_        if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1547011415;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        } else if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,else,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1549290341;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        } else if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,else,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1549328556;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        } else if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,else,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1549336917;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        } else if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,else,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1549396415;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        } else if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,else,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener);1550828001;Checks if the access token has been explicitly invalidated;private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {_        Instant currentTime = clock.instant()__        if (currentTime.isAfter(userToken.getExpirationTime())) {_            listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException()))__        } else if (securityIndex.indexExists() == false) {_            _            logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId())__            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,_                    getTokenDocumentId(userToken)).request()__                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex))__                executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest,_                    ActionListener.<GetResponse>wrap(response -> {_                        if (response.isExists()) {_                            Map<String, Object> source = response.getSource()__                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token")__                            if (accessTokenSource == null) {_                                onFailure.accept(new IllegalStateException("token document is missing access_token field"))__                            } else {_                                Boolean invalidated = (Boolean) accessTokenSource.get("invalidated")__                                if (invalidated == null) {_                                    onFailure.accept(new IllegalStateException("token document is missing invalidated field"))__                                } else if (invalidated) {_                                    onFailure.accept(expiredTokenException())__                                } else {_                                    listener.onResponse(userToken)__                                }_                            }_                        } else {_                            onFailure.accept(new IllegalStateException("token document is missing and must be present"))__                        }_                    }, e -> {_                        _                        _                        if (isShardNotAvailableException(e)) {_                            logger.warn("failed to get token [{}] since index is not available", userToken.getId())__                            listener.onResponse(null)__                        } else {_                            logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e)__                            listener.onFailure(e)__                        }_                    }), client::get)__            })__        }_    };checks,if,the,access,token,has,been,explicitly,invalidated;private,void,check,if,token,is,valid,user,token,user,token,action,listener,user,token,listener,instant,current,time,clock,instant,if,current,time,is,after,user,token,get,expiration,time,listener,on,failure,trace,log,validate,token,user,token,get,id,expired,token,exception,else,if,security,index,index,exists,false,logger,warn,failed,to,validate,token,since,the,security,index,doesn,t,exist,user,token,get,id,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,final,get,request,get,request,client,prepare,get,security,index,manager,type,get,token,document,id,user,token,request,consumer,exception,on,failure,ex,listener,on,failure,trace,log,check,token,state,user,token,get,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,get,request,action,listener,get,response,wrap,response,if,response,is,exists,map,string,object,source,response,get,source,map,string,object,access,token,source,map,string,object,source,get,if,access,token,source,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,field,else,boolean,invalidated,boolean,access,token,source,get,invalidated,if,invalidated,null,on,failure,accept,new,illegal,state,exception,token,document,is,missing,invalidated,field,else,if,invalidated,on,failure,accept,expired,token,exception,else,listener,on,response,user,token,else,on,failure,accept,new,illegal,state,exception,token,document,is,missing,and,must,be,present,e,if,is,shard,not,available,exception,e,logger,warn,failed,to,get,token,since,index,is,not,available,user,token,get,id,listener,on,response,null,else,logger,error,new,parameterized,message,failed,to,get,token,user,token,get,id,e,listener,on,failure,e,client,get
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1545120350;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1545995382;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1547011415;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1549290341;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1549328556;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1549336917;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1549396415;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private <E extends Throwable> E traceLog(String action, E exception);1550828001;Logs an exception at TRACE level (if enabled);private <E extends Throwable> E traceLog(String action, E exception) {_        if (logger.isTraceEnabled()) {_            if (exception instanceof ElasticsearchException) {_                final ElasticsearchException esEx = (ElasticsearchException) exception__                final Object detail = esEx.getHeader("error_description")__                if (detail != null) {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx)__                } else {_                    logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx)__                }_            } else {_                logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception)__            }_        }_        return exception__    };logs,an,exception,at,trace,level,if,enabled;private,e,extends,throwable,e,trace,log,string,action,e,exception,if,logger,is,trace,enabled,if,exception,instanceof,elasticsearch,exception,final,elasticsearch,exception,es,ex,elasticsearch,exception,exception,final,object,detail,es,ex,get,header,if,detail,null,logger,trace,new,parameterized,message,failure,in,action,detail,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,es,ex,else,logger,trace,new,parameterized,message,failure,in,action,exception,return,exception
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1524684173;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            lifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,lifecycle,service,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1525859433;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityLifecycleService.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            lifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,lifecycle,service,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1526449283;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1527096592;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1529658035;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1535405719;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1538067637;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1539723533;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > 5) {_            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,5,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1539796943;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", userToken.getId(), attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                traceLog("(bwc) invalidate token", tokenDocId, cause)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,user,token,get,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,bwc,invalidate,token,token,doc,id,cause,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1540238977;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", userToken.getId(), attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                traceLog("(bwc) invalidate token", tokenDocId, cause)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,user,token,get,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,bwc,invalidate,token,token,doc,id,cause,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1541008027;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", userToken.getId(), attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                traceLog("(bwc) invalidate token", tokenDocId, cause)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,user,token,get,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,bwc,invalidate,token,token,doc,id,cause,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1541092382;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", userToken.getId(), attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                traceLog("(bwc) invalidate token", tokenDocId, cause)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,user,token,get,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,bwc,invalidate,token,token,doc,id,cause,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,                                       long expirationEpochMilli);1541169206;Performs the actual bwc invalidation of a token and then kicks off the new invalidation method__@param userToken            the token to invalidate_@param listener             the listener to notify upon completion_@param attemptCount         the number of attempts to invalidate that have already been tried_@param expirationEpochMilli the expiration time as milliseconds since the epoch;private void indexBwcInvalidation(UserToken userToken, ActionListener<Boolean> listener, AtomicInteger attemptCount,_                                      long expirationEpochMilli) {_        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {_            logger.warn("Failed to invalidate token [{}] after [{}] attempts", userToken.getId(), attemptCount.get())__            listener.onFailure(invalidGrantException("failed to invalidate token"))__        } else {_            final String invalidatedTokenId = getInvalidatedTokenDocumentId(userToken)__            IndexRequest indexRequest = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, invalidatedTokenId)_                    .setOpType(OpType.CREATE)_                    .setSource("doc_type", INVALIDATED_TOKEN_DOC_TYPE, "expiration_time", expirationEpochMilli)_                    .setRefreshPolicy(RefreshPolicy.WAIT_UNTIL)_                    .request()__            final String tokenDocId = getTokenDocumentId(userToken)__            final Version version = userToken.getVersion()__            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),_                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,_                            ActionListener.<IndexResponse>wrap(indexResponse -> {_                                ActionListener<Boolean> wrappedListener =_                                        ActionListener.wrap(ignore -> listener.onResponse(true), listener::onFailure)__                                indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                            }, e -> {_                                Throwable cause = ExceptionsHelper.unwrapCause(e)__                                traceLog("(bwc) invalidate token", tokenDocId, cause)__                                if (cause instanceof VersionConflictEngineException) {_                                    _                                    ActionListener<Boolean> wrappedListener =_                                            ActionListener.wrap(ignore -> listener.onResponse(false), listener::onFailure)__                                    indexInvalidation(tokenDocId, version, wrappedListener, attemptCount, "access_token", 1L)__                                } else if (isShardNotAvailableException(e)) {_                                    attemptCount.incrementAndGet()__                                    indexBwcInvalidation(userToken, listener, attemptCount, expirationEpochMilli)__                                } else {_                                    listener.onFailure(e)__                                }_                            }), client::index))__        }_    };performs,the,actual,bwc,invalidation,of,a,token,and,then,kicks,off,the,new,invalidation,method,param,user,token,the,token,to,invalidate,param,listener,the,listener,to,notify,upon,completion,param,attempt,count,the,number,of,attempts,to,invalidate,that,have,already,been,tried,param,expiration,epoch,milli,the,expiration,time,as,milliseconds,since,the,epoch;private,void,index,bwc,invalidation,user,token,user,token,action,listener,boolean,listener,atomic,integer,attempt,count,long,expiration,epoch,milli,if,attempt,count,get,logger,warn,failed,to,invalidate,token,after,attempts,user,token,get,id,attempt,count,get,listener,on,failure,invalid,grant,exception,failed,to,invalidate,token,else,final,string,invalidated,token,id,get,invalidated,token,document,id,user,token,index,request,index,request,client,prepare,index,security,index,manager,type,invalidated,token,id,set,op,type,op,type,create,set,source,expiration,epoch,milli,set,refresh,policy,refresh,policy,request,final,string,token,doc,id,get,token,document,id,user,token,final,version,version,user,token,get,version,security,index,prepare,index,if,needed,then,execute,ex,listener,on,failure,trace,log,prepare,security,index,token,doc,id,ex,execute,async,with,origin,client,thread,pool,get,thread,context,index,request,action,listener,index,response,wrap,index,response,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,true,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,e,throwable,cause,exceptions,helper,unwrap,cause,e,trace,log,bwc,invalidate,token,token,doc,id,cause,if,cause,instanceof,version,conflict,engine,exception,action,listener,boolean,wrapped,listener,action,listener,wrap,ignore,listener,on,response,false,listener,on,failure,index,invalidation,token,doc,id,version,wrapped,listener,attempt,count,1l,else,if,is,shard,not,available,exception,e,attempt,count,increment,and,get,index,bwc,invalidation,user,token,listener,attempt,count,expiration,epoch,milli,else,listener,on,failure,e,client,index
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1545120350;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", "token"))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,token,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1545995382;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1547011415;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1549290341;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1549328556;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1549336917;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1549396415;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,                                          @Nullable Predicate<Map<String, Object>> filter);1550828001;Find stored refresh and access tokens that have not been invalidated or expired, and were issued against_the specified realm.__@param realmName The name of the realm for which to get the tokens_@param listener The listener to notify upon completion_@param filter an optional Predicate to test the source of the found documents against;public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener,_                                         @Nullable Predicate<Map<String, Object>> filter) {_        ensureEnabled()__        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (Strings.isNullOrEmpty(realmName)) {_            listener.onFailure(new IllegalArgumentException("Realm name is required"))__        } else if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else {_            final Instant now = clock.instant()__            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()_                .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE))_                .filter(QueryBuilders.termQuery("access_token.realm", realmName))_                .filter(QueryBuilders.boolQuery()_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("access_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))_                    )_                    .should(QueryBuilders.boolQuery()_                        .must(QueryBuilders.termQuery("refresh_token.invalidated", false))_                        .must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis()))_                    )_                )___            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)_                .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                .setQuery(boolQuery)_                .setVersion(false)_                .setSize(1000)_                .setFetchSource(true)_                .request()__            securityIndex.checkIndexVersionThenExecute(listener::onFailure,_                () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter)))__        }_    };find,stored,refresh,and,access,tokens,that,have,not,been,invalidated,or,expired,and,were,issued,against,the,specified,realm,param,realm,name,the,name,of,the,realm,for,which,to,get,the,tokens,param,listener,the,listener,to,notify,upon,completion,param,filter,an,optional,predicate,to,test,the,source,of,the,found,documents,against;public,void,find,active,tokens,for,realm,string,realm,name,action,listener,collection,tuple,user,token,string,listener,nullable,predicate,map,string,object,filter,ensure,enabled,final,security,index,manager,frozen,security,index,security,index,freeze,if,strings,is,null,or,empty,realm,name,listener,on,failure,new,illegal,argument,exception,realm,name,is,required,else,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,final,instant,now,clock,instant,final,bool,query,builder,bool,query,query,builders,bool,query,filter,query,builders,term,query,filter,query,builders,term,query,realm,realm,name,filter,query,builders,bool,query,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,should,query,builders,bool,query,must,query,builders,term,query,invalidated,false,must,query,builders,range,query,gte,now,to,epoch,milli,time,value,time,value,hours,24,millis,final,search,request,request,client,prepare,search,security,index,manager,set,scroll,get,settings,set,query,bool,query,set,version,false,set,size,1000,set,fetch,source,true,request,security,index,check,index,version,then,execute,listener,on,failure,scroll,helper,fetch,all,by,entity,client,request,listener,search,hit,hit,filter,and,parse,hit,hit,filter
TokenService -> public synchronized TokenMetaData getTokenMetaData();1524684173;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1525859433;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1526449283;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1527096592;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1529658035;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1535405719;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1538067637;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1539723533;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1539796943;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1540238977;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1541008027;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1541092382;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1541169206;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1545120350;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1545995382;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1547011415;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1549290341;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1549328556;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1549336917;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1549396415;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
TokenService -> public synchronized TokenMetaData getTokenMetaData();1550828001;Returns the current in-use metdata of this {@link TokenService};public synchronized TokenMetaData getTokenMetaData() {_        return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values())__    };returns,the,current,in,use,metdata,of,this,link,token,service;public,synchronized,token,meta,data,get,token,meta,data,return,new,token,meta,data,key,cache,current,token,key,hash,key,cache,cache,values
