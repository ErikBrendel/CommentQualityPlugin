commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static Boolean isTokenServiceEnabled(Settings settings) {     return XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.get(settings). }
true;public;5;55;/**  * Create a token based on the provided authentication and metadata.  * The created token will be stored in the security index.  */ ;/**  * Create a token based on the provided authentication and metadata.  * The created token will be stored in the security index.  */ public void createUserToken(Authentication authentication, Authentication originatingClientAuth, ActionListener<Tuple<UserToken, String>> listener, Map<String, Object> metadata, boolean includeRefreshToken) throws IOException {     ensureEnabled().     if (authentication == null) {         listener.onFailure(traceLog("create token", new IllegalArgumentException("authentication must be provided"))).     } else if (originatingClientAuth == null) {         listener.onFailure(traceLog("create token", new IllegalArgumentException("originating client authentication must be provided"))).     } else {         final Instant created = clock.instant().         final Instant expiration = getExpirationTime(created).         final Version version = clusterService.state().nodes().getMinNodeVersion().         final Authentication tokenAuth = new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(), version, AuthenticationType.TOKEN, authentication.getMetadata()).         final UserToken userToken = new UserToken(version, tokenAuth, expiration, metadata).         final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null.         try (XContentBuilder builder = XContentFactory.jsonBuilder()) {             builder.startObject().             builder.field("doc_type", TOKEN_DOC_TYPE).             builder.field("creation_time", created.toEpochMilli()).             if (includeRefreshToken) {                 builder.startObject("refresh_token").field("token", refreshToken).field("invalidated", false).field("refreshed", false).startObject("client").field("type", "unassociated_client").field("user", originatingClientAuth.getUser().principal()).field("realm", originatingClientAuth.getAuthenticatedBy().getName()).endObject().endObject().             }             builder.startObject("access_token").field("invalidated", false).field("user_token", userToken).field("realm", authentication.getAuthenticatedBy().getName()).endObject().             builder.endObject().             final String documentId = getTokenDocumentId(userToken).             IndexRequest request = client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId).setOpType(OpType.CREATE).setSource(builder).setRefreshPolicy(RefreshPolicy.WAIT_UNTIL).request().             securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)), () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request, ActionListener.wrap(indexResponse -> listener.onResponse(new Tuple<>(userToken, refreshToken)), listener::onFailure))).         }     } }
true;;2;24;/**  * Looks in the context to see if the request provided a header with a user token and if so the  * token is validated, which includes authenticated decryption and verification that the token  * has not been revoked or is expired.  */ ;/**  * Looks in the context to see if the request provided a header with a user token and if so the  * token is validated, which includes authenticated decryption and verification that the token  * has not been revoked or is expired.  */ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener) {     if (enabled) {         final String token = getFromHeader(ctx).         if (token == null) {             listener.onResponse(null).         } else {             try {                 decodeToken(token, ActionListener.wrap(userToken -> {                     if (userToken != null) {                         checkIfTokenIsValid(userToken, listener).                     } else {                         listener.onResponse(null).                     }                 }, listener::onFailure)).             } catch (IOException e) {                 // could happen with a token that is not ours                 logger.debug("invalid token", e).                 listener.onResponse(null).             }         }     } else {         listener.onResponse(null).     } }
true;public;2;13;/**  * Reads the authentication and metadata from the given token.  * This method does not validate whether the token is expired or not.  */ ;/**  * Reads the authentication and metadata from the given token.  * This method does not validate whether the token is expired or not.  */ public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener) throws IOException {     decodeToken(token, ActionListener.wrap(userToken -> {         if (userToken == null) {             listener.onFailure(new ElasticsearchSecurityException("supplied token is not valid")).         } else {             listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata())).         }     }, listener::onFailure)). }
true;;2;82;/**  * Asynchronously decodes the string representation of a {@link UserToken}. The process for  * this is asynchronous as we may need to compute a key, which can be computationally expensive  * so this should not block the current thread, which is typically a network thread. A second  * reason for being asynchronous is that we can restrain the amount of resources consumed by  * the key computation to a single thread.  */ ;/**  * Asynchronously decodes the string representation of a {@link UserToken}. The process for  * this is asynchronous as we may need to compute a key, which can be computationally expensive  * so this should not block the current thread, which is typically a network thread. A second  * reason for being asynchronous is that we can restrain the amount of resources consumed by  * the key computation to a single thread.  */ void decodeToken(String token, ActionListener<UserToken> listener) throws IOException {     // We intentionally do not use try-with resources since we need to keep the stream open if we need to compute a key!     byte[] bytes = token.getBytes(StandardCharsets.UTF_8).     StreamInput in = new InputStreamStreamInput(Base64.getDecoder().wrap(new ByteArrayInputStream(bytes)), bytes.length).     if (in.available() < MINIMUM_BASE64_BYTES) {         logger.debug("invalid token").         listener.onResponse(null).     } else {         // the token exists and the value is at least as long as we'd expect         final Version version = Version.readVersion(in).         in.setVersion(version).         final BytesKey decodedSalt = new BytesKey(in.readByteArray()).         final BytesKey passphraseHash = new BytesKey(in.readByteArray()).         KeyAndCache keyAndCache = keyCache.get(passphraseHash).         if (keyAndCache != null) {             getKeyAsync(decodedSalt, keyAndCache, ActionListener.wrap(decodeKey -> {                 try {                     final byte[] iv = in.readByteArray().                     final Cipher cipher = getDecryptionCipher(iv, decodeKey, version, decodedSalt).                     decryptTokenId(in, cipher, version, ActionListener.wrap(tokenId -> {                         if (securityIndex.isAvailable() == false) {                             logger.warn("failed to get token [{}] since index is not available", tokenId).                             listener.onResponse(null).                         } else {                             securityIndex.checkIndexVersionThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenId, ex)), () -> {                                 final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId)).request().                                 Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("decode token", tokenId, ex)).                                 executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {                                     if (response.isExists()) {                                         Map<String, Object> accessTokenSource = (Map<String, Object>) response.getSource().get("access_token").                                         if (accessTokenSource == null) {                                             onFailure.accept(new IllegalStateException("token document is missing the access_token field")).                                         } else if (accessTokenSource.containsKey("user_token") == false) {                                             onFailure.accept(new IllegalStateException("token document is missing the user_token field")).                                         } else {                                             Map<String, Object> userTokenSource = (Map<String, Object>) accessTokenSource.get("user_token").                                             listener.onResponse(UserToken.fromSourceMap(userTokenSource)).                                         }                                     } else {                                         onFailure.accept(new IllegalStateException("token document is missing and must be present")).                                     }                                 }, e -> {                                     // the token is not valid                                     if (isShardNotAvailableException(e)) {                                         logger.warn("failed to get token [{}] since index is not available", tokenId).                                         listener.onResponse(null).                                     } else {                                         logger.error(new ParameterizedMessage("failed to get token [{}]", tokenId), e).                                         listener.onFailure(e).                                     }                                 }), client::get).                             }).                         }                     }, listener::onFailure)).                 } catch (GeneralSecurityException e) {                     // could happen with a token that is not ours                     logger.warn("invalid token", e).                     listener.onResponse(null).                 } finally {                     in.close().                 }             }, e -> {                 IOUtils.closeWhileHandlingException(in).                 listener.onFailure(e).             })).         } else {             IOUtils.closeWhileHandlingException(in).             logger.debug("invalid key {} key: {}", passphraseHash, keyCache.cache.keySet()).             listener.onResponse(null).         }     } }
false;private;3;14;;private void getKeyAsync(BytesKey decodedSalt, KeyAndCache keyAndCache, ActionListener<SecretKey> listener) {     final SecretKey decodeKey = keyAndCache.getKey(decodedSalt).     if (decodeKey != null) {         listener.onResponse(decodeKey).     } else {         /* As a measure of protected against DOS, we can pass requests requiring a key              * computation off to a single thread executor. For normal usage, the initial              * request(s) that require a key computation will be delayed and there will be              * some additional latency.              */         client.threadPool().executor(THREAD_POOL_NAME).submit(new KeyComputingRunnable(decodedSalt, listener, keyAndCache)).     } }
false;private,static;4;6;;private static void decryptTokenId(StreamInput in, Cipher cipher, Version version, ActionListener<String> listener) throws IOException {     try (CipherInputStream cis = new CipherInputStream(in, cipher).         StreamInput decryptedInput = new InputStreamStreamInput(cis)) {         decryptedInput.setVersion(version).         listener.onResponse(decryptedInput.readString()).     } }
true;public;2;22;/**  * This method performs the steps necessary to invalidate a token so that it may no longer be  * used. The process of invalidation involves performing an update to  * the token document and setting the <code>invalidated</code> field to <code>true</code>  */ ;/**  * This method performs the steps necessary to invalidate a token so that it may no longer be  * used. The process of invalidation involves performing an update to  * the token document and setting the <code>invalidated</code> field to <code>true</code>  */ public void invalidateAccessToken(String tokenString, ActionListener<TokensInvalidationResult> listener) {     ensureEnabled().     if (Strings.isNullOrEmpty(tokenString)) {         logger.trace("No token-string provided").         listener.onFailure(new IllegalArgumentException("token must be provided")).     } else {         maybeStartTokenRemover().         try {             decodeToken(tokenString, ActionListener.wrap(userToken -> {                 if (userToken == null) {                     listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException())).                 } else {                     indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null).                 }             }, listener::onFailure)).         } catch (IOException e) {             logger.error("received a malformed token as part of a invalidation request", e).             listener.onFailure(malformedTokenException()).         }     } }
true;public;2;10;/**  * This method performs the steps necessary to invalidate a token so that it may no longer be used.  *  * @see #invalidateAccessToken(String, ActionListener)  */ ;/**  * This method performs the steps necessary to invalidate a token so that it may no longer be used.  *  * @see #invalidateAccessToken(String, ActionListener)  */ public void invalidateAccessToken(UserToken userToken, ActionListener<TokensInvalidationResult> listener) {     ensureEnabled().     if (userToken == null) {         logger.trace("No access token provided").         listener.onFailure(new IllegalArgumentException("token must be provided")).     } else {         maybeStartTokenRemover().         indexInvalidation(Collections.singleton(userToken.getId()), listener, new AtomicInteger(0), "access_token", null).     } }
true;public;2;14;/**  * This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.  *  * @param refreshToken The string representation of the refresh token  * @param listener  the listener to notify upon completion  */ ;/**  * This method performs the steps necessary to invalidate a refresh token so that it may no longer be used.  *  * @param refreshToken The string representation of the refresh token  * @param listener  the listener to notify upon completion  */ public void invalidateRefreshToken(String refreshToken, ActionListener<TokensInvalidationResult> listener) {     ensureEnabled().     if (Strings.isNullOrEmpty(refreshToken)) {         logger.trace("No refresh token provided").         listener.onFailure(new IllegalArgumentException("refresh token must be provided")).     } else {         maybeStartTokenRemover().         findTokenFromRefreshToken(refreshToken, ActionListener.wrap(tuple -> {             final String docId = getTokenIdFromDocumentId(tuple.v1().getHits().getAt(0).getId()).             indexInvalidation(Collections.singletonList(docId), listener, tuple.v2(), "refresh_token", null).         }, listener::onFailure), new AtomicInteger(0)).     } }
true;public;3;32;/**  * Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given  * {@code username} so that they may no longer be used  *  * @param realmName the realm of which the tokens should be invalidated  * @param username the username for which the tokens should be invalidated  * @param listener  the listener to notify upon completion  */ ;/**  * Invalidate all access tokens and all refresh tokens of a given {@code realmName} and/or of a given  * {@code username} so that they may no longer be used  *  * @param realmName the realm of which the tokens should be invalidated  * @param username the username for which the tokens should be invalidated  * @param listener  the listener to notify upon completion  */ public void invalidateActiveTokensForRealmAndUser(@Nullable String realmName, @Nullable String username, ActionListener<TokensInvalidationResult> listener) {     ensureEnabled().     if (Strings.isNullOrEmpty(realmName) && Strings.isNullOrEmpty(username)) {         logger.trace("No realm name or username provided").         listener.onFailure(new IllegalArgumentException("realm name or username must be provided")).     } else {         if (Strings.isNullOrEmpty(realmName)) {             findActiveTokensForUser(username, ActionListener.wrap(tokenTuples -> {                 if (tokenTuples.isEmpty()) {                     logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username).                     listener.onResponse(TokensInvalidationResult.emptyResult()).                 } else {                     invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener).                 }             }, listener::onFailure)).         } else {             Predicate filter = null.             if (Strings.hasText(username)) {                 filter = isOfUser(username).             }             findActiveTokensForRealm(realmName, ActionListener.wrap(tokenTuples -> {                 if (tokenTuples.isEmpty()) {                     logger.warn("No tokens to invalidate for realm [{}] and username [{}]", realmName, username).                     listener.onResponse(TokensInvalidationResult.emptyResult()).                 } else {                     invalidateAllTokens(tokenTuples.stream().map(t -> t.v1().getId()).collect(Collectors.toList()), listener).                 }             }, listener::onFailure), filter).         }     } }
true;private;2;9;/**  * Invalidates a collection of access_token and refresh_token that were retrieved by  * {@link TokenService#invalidateActiveTokensForRealmAndUser}  *  * @param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)  * @param listener  the listener to notify upon completion  */ ;/**  * Invalidates a collection of access_token and refresh_token that were retrieved by  * {@link TokenService#invalidateActiveTokensForRealmAndUser}  *  * @param accessTokenIds The ids of the access tokens which should be invalidated (along with the respective refresh_token)  * @param listener  the listener to notify upon completion  */ private void invalidateAllTokens(Collection<String> accessTokenIds, ActionListener<TokensInvalidationResult> listener) {     maybeStartTokenRemover().     // Invalidate the refresh tokens first so that they cannot be used to get new     // access tokens while we invalidate the access tokens we currently know about     indexInvalidation(accessTokenIds, ActionListener.wrap(result -> indexInvalidation(accessTokenIds, listener, new AtomicInteger(result.getAttemptCount()), "access_token", result), listener::onFailure), new AtomicInteger(0), "refresh_token", null). }
true;private;5;73;/**  * Performs the actual invalidation of a collection of tokens  *  * @param tokenIds        the tokens to invalidate  * @param listener        the listener to notify upon completion  * @param attemptCount    the number of attempts to invalidate that have already been tried  * @param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on  *                        what type of tokens should be invalidated  * @param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating  *                        tokens up to the point of the retry. This result is added to the result of the current attempt  */ ;/**  * Performs the actual invalidation of a collection of tokens  *  * @param tokenIds        the tokens to invalidate  * @param listener        the listener to notify upon completion  * @param attemptCount    the number of attempts to invalidate that have already been tried  * @param srcPrefix       the prefix to use when constructing the doc to update, either refresh_token or access_token depending on  *                        what type of tokens should be invalidated  * @param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating  *                        tokens up to the point of the retry. This result is added to the result of the current attempt  */ private void indexInvalidation(Collection<String> tokenIds, ActionListener<TokensInvalidationResult> listener, AtomicInteger attemptCount, String srcPrefix, @Nullable TokensInvalidationResult previousResult) {     if (tokenIds.isEmpty()) {         logger.warn("No [{}] tokens provided for invalidation", srcPrefix).         listener.onFailure(invalidGrantException("No tokens provided for invalidation")).     } else if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {         logger.warn("Failed to invalidate [{}] tokens after [{}] attempts", tokenIds.size(), attemptCount.get()).         listener.onFailure(invalidGrantException("failed to invalidate tokens")).     } else {         BulkRequestBuilder bulkRequestBuilder = client.prepareBulk().         for (String tokenId : tokenIds) {             UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(tokenId)).setDoc(srcPrefix, Collections.singletonMap("invalidated", true)).setFetchSource(srcPrefix, null).request().             bulkRequestBuilder.add(request).         }         bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL).         securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", ex)), () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(), ActionListener.<BulkResponse>wrap(bulkResponse -> {             ArrayList<String> retryTokenDocIds = new ArrayList<>().             ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>().             ArrayList<String> previouslyInvalidated = new ArrayList<>().             ArrayList<String> invalidated = new ArrayList<>().             if (null != previousResult) {                 failedRequestResponses.addAll((previousResult.getErrors())).                 previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedTokens()).                 invalidated.addAll(previousResult.getInvalidatedTokens()).             }             for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {                 if (bulkItemResponse.isFailed()) {                     Throwable cause = bulkItemResponse.getFailure().getCause().                     final String failedTokenDocId = getTokenIdFromDocumentId(bulkItemResponse.getFailure().getId()).                     if (isShardNotAvailableException(cause)) {                         retryTokenDocIds.add(failedTokenDocId).                     } else {                         traceLog("invalidate access token", failedTokenDocId, cause).                         failedRequestResponses.add(new ElasticsearchException("Error invalidating " + srcPrefix + ": ", cause)).                     }                 } else {                     UpdateResponse updateResponse = bulkItemResponse.getResponse().                     if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {                         logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, updateResponse.getGetResult().getId()).                         invalidated.add(updateResponse.getGetResult().getId()).                     } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {                         previouslyInvalidated.add(updateResponse.getGetResult().getId()).                     }                 }             }             if (retryTokenDocIds.isEmpty() == false) {                 TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated, previouslyInvalidated, failedRequestResponses, attemptCount.get()).                 attemptCount.incrementAndGet().                 indexInvalidation(retryTokenDocIds, listener, attemptCount, srcPrefix, incompleteResult).             }             TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated, failedRequestResponses, attemptCount.get()).             listener.onResponse(result).         }, e -> {             Throwable cause = ExceptionsHelper.unwrapCause(e).             traceLog("invalidate tokens", cause).             if (isShardNotAvailableException(cause)) {                 attemptCount.incrementAndGet().                 indexInvalidation(tokenIds, listener, attemptCount, srcPrefix, previousResult).             } else {                 listener.onFailure(e).             }         }), client::bulk)).     } }
true;public;2;10;/**  * Uses the refresh token to refresh its associated token and returns the new token with an  * updated expiration date to the listener  */ ;/**  * Uses the refresh token to refresh its associated token and returns the new token with an  * updated expiration date to the listener  */ public void refreshToken(String refreshToken, ActionListener<Tuple<UserToken, String>> listener) {     ensureEnabled().     findTokenFromRefreshToken(refreshToken, ActionListener.wrap(tuple -> {         final Authentication clientAuth = Authentication.readFromContext(client.threadPool().getThreadContext()).         final String tokenDocId = tuple.v1().getHits().getHits()[0].getId().         innerRefresh(tokenDocId, clientAuth, listener, tuple.v2()).     }, listener::onFailure), new AtomicInteger(0)). }
false;private;3;50;;private void findTokenFromRefreshToken(String refreshToken, ActionListener<Tuple<SearchResponse, AtomicInteger>> listener, AtomicInteger attemptCount) {     if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {         logger.warn("Failed to find token for refresh token [{}] after [{}] attempts", refreshToken, attemptCount.get()).         listener.onFailure(invalidGrantException("could not refresh the requested token")).     } else {         SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setQuery(QueryBuilders.boolQuery().filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE)).filter(QueryBuilders.termQuery("refresh_token.token", refreshToken))).setVersion(true).request().         final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze().         if (frozenSecurityIndex.indexExists() == false) {             logger.warn("security index does not exist therefore refresh token [{}] cannot be validated", refreshToken).             listener.onFailure(invalidGrantException("could not refresh the requested token")).         } else if (frozenSecurityIndex.isAvailable() == false) {             logger.debug("security index is not available to find token from refresh token, retrying").             attemptCount.incrementAndGet().             findTokenFromRefreshToken(refreshToken, listener, attemptCount).         } else {             Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("find by refresh token", refreshToken, ex)).             securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request, ActionListener.<SearchResponse>wrap(searchResponse -> {                 if (searchResponse.isTimedOut()) {                     attemptCount.incrementAndGet().                     findTokenFromRefreshToken(refreshToken, listener, attemptCount).                 } else if (searchResponse.getHits().getHits().length < 1) {                     logger.info("could not find token document with refresh_token [{}]", refreshToken).                     onFailure.accept(invalidGrantException("could not refresh the requested token")).                 } else if (searchResponse.getHits().getHits().length > 1) {                     onFailure.accept(new IllegalStateException("multiple tokens share the same refresh token")).                 } else {                     listener.onResponse(new Tuple<>(searchResponse, attemptCount)).                 }             }, e -> {                 if (isShardNotAvailableException(e)) {                     logger.debug("failed to search for token document, retrying", e).                     attemptCount.incrementAndGet().                     findTokenFromRefreshToken(refreshToken, listener, attemptCount).                 } else {                     onFailure.accept(e).                 }             }), client::search)).         }     } }
true;private;4;62;/**  * Performs the actual refresh of the token with retries in case of certain exceptions that  * may be recoverable. The refresh involves retrieval of the token document and then  * updating the token document to indicate that the document has been refreshed.  */ ;/**  * Performs the actual refresh of the token with retries in case of certain exceptions that  * may be recoverable. The refresh involves retrieval of the token document and then  * updating the token document to indicate that the document has been refreshed.  */ private void innerRefresh(String tokenDocId, Authentication clientAuth, ActionListener<Tuple<UserToken, String>> listener, AtomicInteger attemptCount) {     if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {         logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get()).         listener.onFailure(invalidGrantException("could not refresh the requested token")).     } else {         Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex)).         GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).request().         executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {             if (response.isExists()) {                 final Map<String, Object> source = response.getSource().                 final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, clientAuth).                 if (invalidSource.isPresent()) {                     onFailure.accept(invalidSource.get()).                 } else {                     final Map<String, Object> userTokenSource = (Map<String, Object>) ((Map<String, Object>) source.get("access_token")).get("user_token").                     final String authString = (String) userTokenSource.get("authentication").                     final Integer version = (Integer) userTokenSource.get("version").                     final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata").                     Version authVersion = Version.fromId(version).                     try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {                         in.setVersion(authVersion).                         Authentication authentication = new Authentication(in).                         UpdateRequestBuilder updateRequest = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, tokenDocId).setDoc("refresh_token", Collections.singletonMap("refreshed", true)).setRefreshPolicy(RefreshPolicy.WAIT_UNTIL).                         updateRequest.setIfSeqNo(response.getSeqNo()).                         updateRequest.setIfPrimaryTerm(response.getPrimaryTerm()).                         executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, updateRequest.request(), ActionListener.<UpdateResponse>wrap(updateResponse -> createUserToken(authentication, clientAuth, listener, metadata, true), e -> {                             Throwable cause = ExceptionsHelper.unwrapCause(e).                             if (cause instanceof VersionConflictEngineException || isShardNotAvailableException(e)) {                                 innerRefresh(tokenDocId, clientAuth, listener, attemptCount).                             } else {                                 onFailure.accept(e).                             }                         }), client::update).                     }                 }             } else {                 logger.info("could not find token document [{}] for refresh", tokenDocId).                 onFailure.accept(invalidGrantException("could not refresh the requested token")).             }         }, e -> {             if (isShardNotAvailableException(e)) {                 innerRefresh(tokenDocId, clientAuth, listener, attemptCount).             } else {                 listener.onFailure(e).             }         }), client::get).     } }
true;private;2;38;/**  * Performs checks on the retrieved source and returns an {@link Optional} with the exception  * if there is an issue  */ ;/**  * Performs checks on the retrieved source and returns an {@link Optional} with the exception  * if there is an issue  */ private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication clientAuth) {     final Map<String, Object> refreshTokenSrc = (Map<String, Object>) source.get("refresh_token").     final Map<String, Object> accessTokenSrc = (Map<String, Object>) source.get("access_token").     if (refreshTokenSrc == null || refreshTokenSrc.isEmpty()) {         return Optional.of(invalidGrantException("token document is missing the refresh_token object")).     } else if (accessTokenSrc == null || accessTokenSrc.isEmpty()) {         return Optional.of(invalidGrantException("token document is missing the access_token object")).     } else {         final Boolean refreshed = (Boolean) refreshTokenSrc.get("refreshed").         final Boolean invalidated = (Boolean) refreshTokenSrc.get("invalidated").         final Long creationEpochMilli = (Long) source.get("creation_time").         final Instant creationTime = creationEpochMilli == null ? null : Instant.ofEpochMilli(creationEpochMilli).         final Map<String, Object> userTokenSrc = (Map<String, Object>) accessTokenSrc.get("user_token").         if (refreshed == null) {             return Optional.of(invalidGrantException("token document is missing refreshed value")).         } else if (invalidated == null) {             return Optional.of(invalidGrantException("token document is missing invalidated value")).         } else if (creationEpochMilli == null) {             return Optional.of(invalidGrantException("token document is missing creation time value")).         } else if (refreshed) {             return Optional.of(invalidGrantException("token has already been refreshed")).         } else if (invalidated) {             return Optional.of(invalidGrantException("token has been invalidated")).         } else if (clock.instant().isAfter(creationTime.plus(24L, ChronoUnit.HOURS))) {             return Optional.of(invalidGrantException("refresh token is expired")).         } else if (userTokenSrc == null || userTokenSrc.isEmpty()) {             return Optional.of(invalidGrantException("token document is missing the user token info")).         } else if (userTokenSrc.get("authentication") == null) {             return Optional.of(invalidGrantException("token is missing authentication info")).         } else if (userTokenSrc.get("version") == null) {             return Optional.of(invalidGrantException("token is missing version value")).         } else if (userTokenSrc.get("metadata") == null) {             return Optional.of(invalidGrantException("token is missing metadata")).         } else {             return checkClient(refreshTokenSrc, clientAuth).         }     } }
false;private;2;12;;private Optional<ElasticsearchSecurityException> checkClient(Map<String, Object> refreshTokenSource, Authentication clientAuth) {     Map<String, Object> clientInfo = (Map<String, Object>) refreshTokenSource.get("client").     if (clientInfo == null) {         return Optional.of(invalidGrantException("token is missing client information")).     } else if (clientAuth.getUser().principal().equals(clientInfo.get("user")) == false) {         return Optional.of(invalidGrantException("tokens must be refreshed by the creating client")).     } else if (clientAuth.getAuthenticatedBy().getName().equals(clientInfo.get("realm")) == false) {         return Optional.of(invalidGrantException("tokens must be refreshed by the creating client")).     } else {         return Optional.empty().     } }
true;public;3;37;/**  * Find stored refresh and access tokens that have not been invalidated or expired, and were issued against  *  the specified realm.  *  * @param realmName The name of the realm for which to get the tokens  * @param listener The listener to notify upon completion  * @param filter an optional Predicate to test the source of the found documents against  */ ;/**  * Find stored refresh and access tokens that have not been invalidated or expired, and were issued against  *  the specified realm.  *  * @param realmName The name of the realm for which to get the tokens  * @param listener The listener to notify upon completion  * @param filter an optional Predicate to test the source of the found documents against  */ public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener, @Nullable Predicate<Map<String, Object>> filter) {     ensureEnabled().     final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze().     if (Strings.isNullOrEmpty(realmName)) {         listener.onFailure(new IllegalArgumentException("Realm name is required")).     } else if (frozenSecurityIndex.indexExists() == false) {         listener.onResponse(Collections.emptyList()).     } else if (frozenSecurityIndex.isAvailable() == false) {         listener.onFailure(frozenSecurityIndex.getUnavailableReason()).     } else {         final Instant now = clock.instant().         final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE)).filter(QueryBuilders.termQuery("access_token.realm", realmName)).filter(QueryBuilders.boolQuery().should(QueryBuilders.boolQuery().must(QueryBuilders.termQuery("access_token.invalidated", false)).must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))).should(QueryBuilders.boolQuery().must(QueryBuilders.termQuery("refresh_token.invalidated", false)).must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis())))).         final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)).setQuery(boolQuery).setVersion(false).setSize(1000).setFetchSource(true).request().         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, filter))).     } }
true;public;2;37;/**  * Find stored refresh and access tokens that have not been invalidated or expired, and were issued for  * the specified user.  *  * @param username The user for which to get the tokens  * @param listener The listener to notify upon completion  */ ;/**  * Find stored refresh and access tokens that have not been invalidated or expired, and were issued for  * the specified user.  *  * @param username The user for which to get the tokens  * @param listener The listener to notify upon completion  */ public void findActiveTokensForUser(String username, ActionListener<Collection<Tuple<UserToken, String>>> listener) {     ensureEnabled().     final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze().     if (Strings.isNullOrEmpty(username)) {         listener.onFailure(new IllegalArgumentException("username is required")).     } else if (frozenSecurityIndex.indexExists() == false) {         listener.onResponse(Collections.emptyList()).     } else if (frozenSecurityIndex.isAvailable() == false) {         listener.onFailure(frozenSecurityIndex.getUnavailableReason()).     } else {         final Instant now = clock.instant().         final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE)).filter(QueryBuilders.boolQuery().should(QueryBuilders.boolQuery().must(QueryBuilders.termQuery("access_token.invalidated", false)).must(QueryBuilders.rangeQuery("access_token.user_token.expiration_time").gte(now.toEpochMilli()))).should(QueryBuilders.boolQuery().must(QueryBuilders.termQuery("refresh_token.invalidated", false)).must(QueryBuilders.rangeQuery("creation_time").gte(now.toEpochMilli() - TimeValue.timeValueHours(24).millis())))).         final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME).setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)).setQuery(boolQuery).setVersion(false).setSize(1000).setFetchSource(true).request().         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> ScrollHelper.fetchAllByEntity(client, request, listener, (SearchHit hit) -> filterAndParseHit(hit, isOfUser(username)))).     } }
false;private,static;1;14;;private static Predicate<Map<String, Object>> isOfUser(String username) {     return source -> {         String auth = (String) source.get("authentication").         Integer version = (Integer) source.get("version").         Version authVersion = Version.fromId(version).         try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(auth))) {             in.setVersion(authVersion).             Authentication authentication = new Authentication(in).             return authentication.getUser().principal().equals(username).         } catch (IOException e) {             throw new UncheckedIOException(e).         }     }. }
false;private;2;11;;private Tuple<UserToken, String> filterAndParseHit(SearchHit hit, @Nullable Predicate<Map<String, Object>> filter) {     final Map<String, Object> source = hit.getSourceAsMap().     if (source == null) {         throw new IllegalStateException("token document did not have source but source should have been fetched").     }     try {         return parseTokensFromDocument(source, filter).     } catch (IOException e) {         throw invalidGrantException("cannot read token from document").     } }
true;private;2;23;/**  * Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token  *  * @param source The token document source as retrieved  * @param filter an optional Predicate to test the source of the UserToken against  * @return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't  *         satisfy it  */ ;/**  * Parses a token document into a Tuple of a {@link UserToken} and a String representing the corresponding refresh_token  *  * @param source The token document source as retrieved  * @param filter an optional Predicate to test the source of the UserToken against  * @return A {@link Tuple} of access-token and refresh-token-id or null if a Predicate is defined and the userToken source doesn't  *         satisfy it  */ private Tuple<UserToken, String> parseTokensFromDocument(Map<String, Object> source, @Nullable Predicate<Map<String, Object>> filter) throws IOException {     final String refreshToken = (String) ((Map<String, Object>) source.get("refresh_token")).get("token").     final Map<String, Object> userTokenSource = (Map<String, Object>) ((Map<String, Object>) source.get("access_token")).get("user_token").     if (null != filter && filter.test(userTokenSource) == false) {         return null.     }     final String id = (String) userTokenSource.get("id").     final Integer version = (Integer) userTokenSource.get("version").     final String authString = (String) userTokenSource.get("authentication").     final Long expiration = (Long) userTokenSource.get("expiration_time").     final Map<String, Object> metadata = (Map<String, Object>) userTokenSource.get("metadata").     Version authVersion = Version.fromId(version).     try (StreamInput in = StreamInput.wrap(Base64.getDecoder().decode(authString))) {         in.setVersion(authVersion).         Authentication authentication = new Authentication(in).         return new Tuple<>(new UserToken(id, Version.fromId(version), authentication, Instant.ofEpochMilli(expiration), metadata), refreshToken).     } }
false;private,static;1;3;;private static String getTokenDocumentId(UserToken userToken) {     return getTokenDocumentId(userToken.getId()). }
false;private,static;1;3;;private static String getTokenDocumentId(String id) {     return TOKEN_DOC_ID_PREFIX + id. }
false;private,static;1;7;;private static String getTokenIdFromDocumentId(String docId) {     if (docId.startsWith(TOKEN_DOC_ID_PREFIX) == false) {         throw new IllegalStateException("TokenDocument ID [" + docId + "] has unexpected value").     } else {         return docId.substring(TOKEN_DOC_ID_PREFIX.length()).     } }
false;private;0;5;;private void ensureEnabled() {     if (enabled == false) {         throw new IllegalStateException("tokens are not enabled").     } }
true;private;2;47;/**  * Checks if the access token has been explicitly invalidated  */ ;/**  * Checks if the access token has been explicitly invalidated  */ private void checkIfTokenIsValid(UserToken userToken, ActionListener<UserToken> listener) {     Instant currentTime = clock.instant().     if (currentTime.isAfter(userToken.getExpirationTime())) {         listener.onFailure(traceLog("validate token", userToken.getId(), expiredTokenException())).     } else if (securityIndex.indexExists() == false) {         // index doesn't exist so the token is considered invalid as we cannot verify its validity         logger.warn("failed to validate token [{}] since the security index doesn't exist", userToken.getId()).         listener.onResponse(null).     } else {         securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {             final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, getTokenDocumentId(userToken)).request().             Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex)).             executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {                 if (response.isExists()) {                     Map<String, Object> source = response.getSource().                     Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token").                     if (accessTokenSource == null) {                         onFailure.accept(new IllegalStateException("token document is missing access_token field")).                     } else {                         Boolean invalidated = (Boolean) accessTokenSource.get("invalidated").                         if (invalidated == null) {                             onFailure.accept(new IllegalStateException("token document is missing invalidated field")).                         } else if (invalidated) {                             onFailure.accept(expiredTokenException()).                         } else {                             listener.onResponse(userToken).                         }                     }                 } else {                     onFailure.accept(new IllegalStateException("token document is missing and must be present")).                 }             }, e -> {                 // the token is not valid                 if (isShardNotAvailableException(e)) {                     logger.warn("failed to get token [{}] since index is not available", userToken.getId()).                     listener.onResponse(null).                 } else {                     logger.error(new ParameterizedMessage("failed to get token [{}]", userToken.getId()), e).                     listener.onFailure(e).                 }             }), client::get).         }).     } }
false;public;0;3;;public TimeValue getExpirationDelay() {     return expirationDelay. }
false;private;1;3;;private Instant getExpirationTime(Instant now) {     return now.plusSeconds(expirationDelay.getSeconds()). }
false;private;0;8;;private void maybeStartTokenRemover() {     if (securityIndex.isAvailable()) {         if (client.threadPool().relativeTimeInMillis() - lastExpirationRunMs > deleteInterval.getMillis()) {             expiredTokenRemover.submit(client.threadPool()).             lastExpirationRunMs = client.threadPool().relativeTimeInMillis().         }     } }
true;private;1;8;/**  * Gets the token from the <code>Authorization</code> header if the header begins with  * <code>Bearer </code>  */ ;/**  * Gets the token from the <code>Authorization</code> header if the header begins with  * <code>Bearer </code>  */ private String getFromHeader(ThreadContext threadContext) {     String header = threadContext.getHeader("Authorization").     if (Strings.hasText(header) && header.regionMatches(true, 0, "Bearer ", 0, "Bearer ".length()) && header.length() > "Bearer ".length()) {         return header.substring("Bearer ".length()).     }     return null. }
true;public;1;22;/**  * Serializes a token to a String containing an encrypted representation of the token  */ ;/**  * Serializes a token to a String containing an encrypted representation of the token  */ public String getUserTokenString(UserToken userToken) throws IOException, GeneralSecurityException {     // we know that the minimum length is larger than the default of the ByteArrayOutputStream so set the size to this explicitly     try (ByteArrayOutputStream os = new ByteArrayOutputStream(MINIMUM_BASE64_BYTES).         OutputStream base64 = Base64.getEncoder().wrap(os).         StreamOutput out = new OutputStreamStreamOutput(base64)) {         out.setVersion(userToken.getVersion()).         KeyAndCache keyAndCache = keyCache.activeKeyCache.         Version.writeVersion(userToken.getVersion(), out).         out.writeByteArray(keyAndCache.getSalt().bytes).         out.writeByteArray(keyAndCache.getKeyHash().bytes).         final byte[] initializationVector = getNewInitializationVector().         out.writeByteArray(initializationVector).         try (CipherOutputStream encryptedOutput = new CipherOutputStream(out, getEncryptionCipher(initializationVector, keyAndCache, userToken.getVersion())).             StreamOutput encryptedStreamOutput = new OutputStreamStreamOutput(encryptedOutput)) {             encryptedStreamOutput.setVersion(userToken.getVersion()).             encryptedStreamOutput.writeString(userToken.getId()).             encryptedStreamOutput.close().             return new String(os.toByteArray(), StandardCharsets.UTF_8).         }     } }
false;private;0;4;;private void ensureEncryptionCiphersSupported() throws NoSuchPaddingException, NoSuchAlgorithmException {     Cipher.getInstance(ENCRYPTION_CIPHER).     SecretKeyFactory.getInstance(KDF_ALGORITHM). }
false;private;3;12;;private Cipher getEncryptionCipher(byte[] iv, KeyAndCache keyAndCache, Version version) throws GeneralSecurityException {     Cipher cipher = Cipher.getInstance(ENCRYPTION_CIPHER).     BytesKey salt = keyAndCache.getSalt().     try {         cipher.init(Cipher.ENCRYPT_MODE, keyAndCache.getOrComputeKey(salt), new GCMParameterSpec(128, iv), secureRandom).     } catch (ExecutionException e) {         throw new ElasticsearchSecurityException("Failed to compute secret key for active salt", e).     }     cipher.updateAAD(ByteBuffer.allocate(4).putInt(version.id).array()).     cipher.updateAAD(salt.bytes).     return cipher. }
false;private;4;8;;private Cipher getDecryptionCipher(byte[] iv, SecretKey key, Version version, BytesKey salt) throws GeneralSecurityException {     Cipher cipher = Cipher.getInstance(ENCRYPTION_CIPHER).     cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(128, iv), secureRandom).     cipher.updateAAD(ByteBuffer.allocate(4).putInt(version.id).array()).     cipher.updateAAD(salt.bytes).     return cipher. }
false;private;0;5;;private byte[] getNewInitializationVector() {     final byte[] initializationVector = new byte[IV_BYTES].     secureRandom.nextBytes(initializationVector).     return initializationVector. }
true;static;2;7;/**  * Generates a secret key based off of the provided password and salt.  * This method is computationally expensive.  */ ;/**  * Generates a secret key based off of the provided password and salt.  * This method is computationally expensive.  */ static SecretKey computeSecretKey(char[] rawPassword, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(KDF_ALGORITHM).     PBEKeySpec keySpec = new PBEKeySpec(rawPassword, salt, ITERATIONS, 128).     SecretKey tmp = secretKeyFactory.generateSecret(keySpec).     return new SecretKeySpec(tmp.getEncoded(), "AES"). }
true;private,static;0;6;/**  * Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It  * is up to the client to re-authenticate and obtain a new token. The format for this response  * is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>  */ ;/**  * Creates an {@link ElasticsearchSecurityException} that indicates the token was expired. It  * is up to the client to re-authenticate and obtain a new token. The format for this response  * is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>  */ private static ElasticsearchSecurityException expiredTokenException() {     ElasticsearchSecurityException e = new ElasticsearchSecurityException("token expired", RestStatus.UNAUTHORIZED).     e.addHeader("WWW-Authenticate", EXPIRED_TOKEN_WWW_AUTH_VALUE).     return e. }
true;private,static;0;6;/**  * Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It  * is up to the client to re-authenticate and obtain a new token. The format for this response  * is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>  */ ;/**  * Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It  * is up to the client to re-authenticate and obtain a new token. The format for this response  * is defined in <a href="https://tools.ietf.org/html/rfc6750#section-3.1"></a>  */ private static ElasticsearchSecurityException malformedTokenException() {     ElasticsearchSecurityException e = new ElasticsearchSecurityException("token malformed", RestStatus.UNAUTHORIZED).     e.addHeader("WWW-Authenticate", MALFORMED_TOKEN_WWW_AUTH_VALUE).     return e. }
true;private,static;1;6;/**  * Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant  */ ;/**  * Creates an {@link ElasticsearchSecurityException} that indicates the request contained an invalid grant  */ private static ElasticsearchSecurityException invalidGrantException(String detail) {     ElasticsearchSecurityException e = new ElasticsearchSecurityException("invalid_grant", RestStatus.BAD_REQUEST).     e.addHeader("error_description", detail).     return e. }
true;private;3;18;/**  * Logs an exception concerning a specific Token at TRACE level (if enabled)  */ ;/**  * Logs an exception concerning a specific Token at TRACE level (if enabled)  */ private <E extends Throwable> E traceLog(String action, String identifier, E exception) {     if (logger.isTraceEnabled()) {         if (exception instanceof ElasticsearchException) {             final ElasticsearchException esEx = (ElasticsearchException) exception.             final Object detail = esEx.getHeader("error_description").             if (detail != null) {                 logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}] - [{}]", action, identifier, detail), esEx).             } else {                 logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), esEx).             }         } else {             logger.trace(() -> new ParameterizedMessage("Failure in [{}] for id [{}]", action, identifier), exception).         }     }     return exception. }
true;private;2;16;/**  * Logs an exception at TRACE level (if enabled)  */ ;/**  * Logs an exception at TRACE level (if enabled)  */ private <E extends Throwable> E traceLog(String action, E exception) {     if (logger.isTraceEnabled()) {         if (exception instanceof ElasticsearchException) {             final ElasticsearchException esEx = (ElasticsearchException) exception.             final Object detail = esEx.getHeader("error_description").             if (detail != null) {                 logger.trace(() -> new ParameterizedMessage("Failure in [{}] - [{}]", action, detail), esEx).             } else {                 logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), esEx).             }         } else {             logger.trace(() -> new ParameterizedMessage("Failure in [{}]", action), exception).         }     }     return exception. }
false;;1;4;;boolean isExpiredTokenException(ElasticsearchSecurityException e) {     final List<String> headers = e.getHeader("WWW-Authenticate").     return headers != null && headers.stream().anyMatch(EXPIRED_TOKEN_WWW_AUTH_VALUE::equals). }
false;;0;3;;boolean isExpirationInProgress() {     return expiredTokenRemover.isExpirationInProgress(). }
false;protected;0;18;;@Override protected void doRun() {     try {         final SecretKey computedKey = keyAndCache.getOrComputeKey(decodedSalt).         listener.onResponse(computedKey).     } catch (ExecutionException e) {         if (e.getCause() != null && (e.getCause() instanceof GeneralSecurityException || e.getCause() instanceof IOException || e.getCause() instanceof IllegalArgumentException)) {             // this could happen if another realm supports the Bearer token so we should             // see if another realm can use this token!             logger.debug("unable to decode bearer token", e).             listener.onResponse(null).         } else {             listener.onFailure(e).         }     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
true;synchronized;0;19;/**  * Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:  * this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)}  */ ;/**  * Creates a new key unless present that is newer than the current active key and returns the corresponding metadata. Note:  * this method doesn't modify the metadata used in this token service. See {@link #refreshMetaData(TokenMetaData)}  */ synchronized TokenMetaData generateSpareKey() {     KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get().     KeyAndCache currentKey = keyCache.activeKeyCache.     if (currentKey == maxKey) {         long timestamp = createdTimeStamps.incrementAndGet().         while (true) {             byte[] saltArr = new byte[SALT_BYTES].             secureRandom.nextBytes(saltArr).             SecureString tokenKey = generateTokenKey().             KeyAndCache keyAndCache = new KeyAndCache(new KeyAndTimestamp(tokenKey, timestamp), new BytesKey(saltArr)).             if (keyCache.cache.containsKey(keyAndCache.getKeyHash())) {                 // collision -- generate a new key                 continue.             }             return newTokenMetaData(keyCache.currentTokenKeyHash, Iterables.concat(keyCache.cache.values(), Collections.singletonList(keyAndCache))).         }     }     return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values()). }
true;synchronized;0;7;/**  * Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.  */ ;/**  * Rotate the current active key to the spare key created in the previous {@link #generateSpareKey()} call.  */ synchronized TokenMetaData rotateToSpareKey() {     KeyAndCache maxKey = keyCache.cache.values().stream().max(Comparator.comparingLong(v -> v.keyAndTimestamp.getTimestamp())).get().     if (maxKey == keyCache.activeKeyCache) {         throw new IllegalStateException("call generateSpareKey first").     }     return newTokenMetaData(maxKey.getKeyHash(), keyCache.cache.values()). }
true;synchronized;1;22;/**  * Prunes the keys and keeps up to the latest N keys around  *  * @param numKeysToKeep the number of keys to keep.  */ ;/**  * Prunes the keys and keeps up to the latest N keys around  *  * @param numKeysToKeep the number of keys to keep.  */ synchronized TokenMetaData pruneKeys(int numKeysToKeep) {     if (keyCache.cache.size() <= numKeysToKeep) {         // nothing to do         return getTokenMetaData().     }     Map<BytesKey, KeyAndCache> map = new HashMap<>(keyCache.cache.size() + 1).     KeyAndCache currentKey = keyCache.get(keyCache.currentTokenKeyHash).     ArrayList<KeyAndCache> entries = new ArrayList<>(keyCache.cache.values()).     Collections.sort(entries, (left, right) -> Long.compare(right.keyAndTimestamp.getTimestamp(), left.keyAndTimestamp.getTimestamp())).     for (KeyAndCache value : entries) {         if (map.size() < numKeysToKeep || value.keyAndTimestamp.getTimestamp() >= currentKey.keyAndTimestamp.getTimestamp()) {             logger.debug("keeping key {} ", value.getKeyHash()).             map.put(value.getKeyHash(), value).         } else {             logger.debug("prune key {} ", value.getKeyHash()).         }     }     assert map.isEmpty() == false.     assert map.containsKey(keyCache.currentTokenKeyHash).     return newTokenMetaData(keyCache.currentTokenKeyHash, map.values()). }
true;public,synchronized;0;3;/**  * Returns the current in-use metdata of this {@link TokenService}  */ ;/**  * Returns the current in-use metdata of this {@link TokenService}  */ public synchronized TokenMetaData getTokenMetaData() {     return newTokenMetaData(keyCache.currentTokenKeyHash, keyCache.cache.values()). }
false;private;2;7;;private TokenMetaData newTokenMetaData(BytesKey activeTokenKey, Iterable<KeyAndCache> iterable) {     List<KeyAndTimestamp> list = new ArrayList<>().     for (KeyAndCache v : iterable) {         list.add(v.keyAndTimestamp).     }     return new TokenMetaData(list, activeTokenKey.bytes). }
true;synchronized;1;23;/**  * Refreshes the current in-use metadata.  */ ;/**  * Refreshes the current in-use metadata.  */ synchronized void refreshMetaData(TokenMetaData metaData) {     BytesKey currentUsedKeyHash = new BytesKey(metaData.getCurrentKeyHash()).     byte[] saltArr = new byte[SALT_BYTES].     Map<BytesKey, KeyAndCache> map = new HashMap<>(metaData.getKeys().size()).     long maxTimestamp = createdTimeStamps.get().     for (KeyAndTimestamp key : metaData.getKeys()) {         secureRandom.nextBytes(saltArr).         KeyAndCache keyAndCache = new KeyAndCache(key, new BytesKey(saltArr)).         maxTimestamp = Math.max(keyAndCache.keyAndTimestamp.getTimestamp(), maxTimestamp).         if (keyCache.cache.containsKey(keyAndCache.getKeyHash()) == false) {             map.put(keyAndCache.getKeyHash(), keyAndCache).         } else {             // maintain the cache we already have             map.put(keyAndCache.getKeyHash(), keyCache.get(keyAndCache.getKeyHash())).         }     }     if (map.containsKey(currentUsedKeyHash) == false) {         // this won't leak any secrets it's only exposing the current set of hashes         throw new IllegalStateException("Current key is not in the map: " + map.keySet() + " key: " + currentUsedKeyHash).     }     createdTimeStamps.set(maxTimestamp).     keyCache = new TokenKeys(Collections.unmodifiableMap(map), currentUsedKeyHash).     logger.debug("refreshed keys current: {}, keys: {}", currentUsedKeyHash, keyCache.cache.keySet()). }
false;private;0;16;;private SecureString generateTokenKey() {     byte[] keyBytes = new byte[KEY_BYTES].     byte[] encode = new byte[0].     char[] ref = new char[0].     try {         secureRandom.nextBytes(keyBytes).         encode = Base64.getUrlEncoder().withoutPadding().encode(keyBytes).         ref = new char[encode.length].         int len = UnicodeUtil.UTF8toUTF16(encode, 0, encode.length, ref).         return new SecureString(Arrays.copyOfRange(ref, 0, len)).     } finally {         Arrays.fill(keyBytes, (byte) 0x00).         Arrays.fill(encode, (byte) 0x00).         Arrays.fill(ref, (char) 0x00).     } }
false;synchronized;0;3;;synchronized String getActiveKeyHash() {     return new BytesRef(Base64.getUrlEncoder().withoutPadding().encode(this.keyCache.currentTokenKeyHash.bytes)).utf8ToString(). }
false;;1;15;;void rotateKeysOnMaster(ActionListener<ClusterStateUpdateResponse> listener) {     logger.info("rotate keys on master").     TokenMetaData tokenMetaData = generateSpareKey().     clusterService.submitStateUpdateTask("publish next key to prepare key rotation", new TokenMetadataPublishAction(ActionListener.wrap((res) -> {         if (res.isAcknowledged()) {             TokenMetaData metaData = rotateToSpareKey().             clusterService.submitStateUpdateTask("publish next key to prepare key rotation", new TokenMetadataPublishAction(listener, metaData)).         } else {             listener.onFailure(new IllegalStateException("not acked")).         }     }, listener::onFailure), tokenMetaData)). }
false;public;0;4;;@Override public TimeValue ackTimeout() {     return AcknowledgedRequest.DEFAULT_ACK_TIMEOUT. }
false;public;0;4;;@Override public TimeValue masterNodeTimeout() {     return AcknowledgedRequest.DEFAULT_MASTER_NODE_TIMEOUT. }
false;public;1;9;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     XPackPlugin.checkReadyForXPackCustomMetadata(currentState).     if (tokenMetaData.equals(currentState.custom(TokenMetaData.TYPE))) {         return currentState.     }     return ClusterState.builder(currentState).putCustom(TokenMetaData.TYPE, tokenMetaData).build(). }
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;private;1;28;;private void initialize(ClusterService clusterService) {     clusterService.addListener(event -> {         ClusterState state = event.state().         if (state.getBlocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {             return.         }         if (state.nodes().isLocalNodeElectedMaster()) {             if (XPackPlugin.isReadyForXPackCustomMetadata(state)) {                 installTokenMetadata(state.metaData()).             } else {                 logger.debug("cannot add token metadata to cluster as the following nodes might not understand the metadata: {}", () -> XPackPlugin.nodesNotReadyForXPackCustomMetadata(state)).             }         }         TokenMetaData custom = event.state().custom(TokenMetaData.TYPE).         if (custom != null && custom.equals(getTokenMetaData()) == false) {             logger.info("refresh keys").             try {                 refreshMetaData(custom).             } catch (Exception e) {                 logger.warn("refreshing metadata failed", e).             }             logger.info("refreshed keys").         }     }). }
false;public;1;10;;@Override public ClusterState execute(ClusterState currentState) {     XPackPlugin.checkReadyForXPackCustomMetadata(currentState).     if (currentState.custom(TokenMetaData.TYPE) == null) {         return ClusterState.builder(currentState).putCustom(TokenMetaData.TYPE, getTokenMetaData()).build().     } else {         return currentState.     } }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     installTokenMetadataInProgress.set(false).     logger.error("unable to install token metadata", e). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     installTokenMetadataInProgress.set(false). }
false;private;1;29;;private void installTokenMetadata(MetaData metaData) {     if (metaData.custom(TokenMetaData.TYPE) == null) {         if (installTokenMetadataInProgress.compareAndSet(false, true)) {             clusterService.submitStateUpdateTask("install-token-metadata", new ClusterStateUpdateTask(Priority.URGENT) {                  @Override                 public ClusterState execute(ClusterState currentState) {                     XPackPlugin.checkReadyForXPackCustomMetadata(currentState).                     if (currentState.custom(TokenMetaData.TYPE) == null) {                         return ClusterState.builder(currentState).putCustom(TokenMetaData.TYPE, getTokenMetaData()).build().                     } else {                         return currentState.                     }                 }                  @Override                 public void onFailure(String source, Exception e) {                     installTokenMetadataInProgress.set(false).                     logger.error("unable to install token metadata", e).                 }                  @Override                 public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {                     installTokenMetadataInProgress.set(false).                 }             }).         }     } }
true;;0;3;/**  * For testing  */ ;/**  * For testing  */ void clearActiveKeyCache() {     this.keyCache.activeKeyCache.keyCache.invalidateAll(). }
false;private;1;3;;private SecretKey getKey(BytesKey salt) {     return keyCache.get(salt). }
false;public;1;7;;public SecretKey getOrComputeKey(BytesKey decodedSalt) throws ExecutionException {     return keyCache.computeIfAbsent(decodedSalt, (salt) -> {         try (SecureString closeableChars = keyAndTimestamp.getKey().clone()) {             return computeSecretKey(closeableChars.getChars(), salt.bytes).         }     }). }
false;public;0;4;;@Override public void close() throws IOException {     keyAndTimestamp.getKey().close(). }
false;;0;3;;BytesKey getKeyHash() {     return keyHash. }
false;private,static;1;16;;private static BytesKey calculateKeyHash(SecureString key) {     MessageDigest messageDigest = MessageDigests.sha256().     BytesRefBuilder b = new BytesRefBuilder().     try {         b.copyChars(key).         BytesRef bytesRef = b.toBytesRef().         try {             messageDigest.update(bytesRef.bytes, bytesRef.offset, bytesRef.length).             return new BytesKey(Arrays.copyOfRange(messageDigest.digest(), 0, 8)).         } finally {             Arrays.fill(bytesRef.bytes, (byte) 0x00).         }     } finally {         Arrays.fill(b.bytes(), (byte) 0x00).     } }
false;;0;3;;BytesKey getSalt() {     return salt. }
false;;1;3;;KeyAndCache get(BytesKey passphraseHash) {     return cache.get(passphraseHash). }
