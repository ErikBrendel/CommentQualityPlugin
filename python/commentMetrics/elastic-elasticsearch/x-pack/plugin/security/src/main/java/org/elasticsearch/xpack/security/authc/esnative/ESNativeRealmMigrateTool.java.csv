commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static void main(String[] args) throws Exception {     exit(new ESNativeRealmMigrateTool().main(args, Terminal.DEFAULT)). }
false;protected;0;3;;protected MigrateUserOrRoles newMigrateUserOrRoles() {     return new MigrateUserOrRoles(). }
true;public;0;3;// Visible for testing ;// Visible for testing public OptionParser getParser() {     return this.parser. }
false;protected;1;6;;@Override protected void printAdditionalHelp(Terminal terminal) {     terminal.println("This tool migrates file based users[1] and roles[2] to the native realm in").     terminal.println("elasticsearch, saving the administrator from needing to manually transition").     terminal.println("them from the file."). }
true;public;3;7;// Visible for testing ;// Visible for testing @Override public void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {     terminal.println("starting migration of users and roles...").     importUsers(terminal, env, options).     importRoles(terminal, env, options).     terminal.println("users and roles imported."). }
false;private;6;61;;@SuppressForbidden(reason = "We call connect in doPrivileged and provide SocketPermission") private String postURL(Settings settings, Environment env, String method, String urlString, OptionSet options, @Nullable String bodyString) throws Exception {     URI uri = new URI(urlString).     URL url = uri.toURL().     HttpURLConnection conn.     // If using SSL, need a custom service because it's likely a self-signed certificate     if ("https".equalsIgnoreCase(uri.getScheme())) {         final SSLService sslService = new SSLService(settings, env).         final SSLConfiguration sslConfiguration = sslService.getSSLConfiguration("xpack.security.http.ssl").         final HttpsURLConnection httpsConn = (HttpsURLConnection) url.openConnection().         AccessController.doPrivileged((PrivilegedAction<Void>) () -> {             // Requires permission java.lang.RuntimePermission "setFactory".             httpsConn.setSSLSocketFactory(sslService.sslSocketFactory(sslConfiguration)).             return null.         }).         conn = httpsConn.     } else {         conn = (HttpURLConnection) url.openConnection().     }     conn.setRequestMethod(method).     // 30 second timeout     conn.setReadTimeout(30 * 1000).     // Add basic-auth header     conn.setRequestProperty("Authorization", UsernamePasswordToken.basicAuthHeaderValue(username.value(options), new SecureString(password.value(options).toCharArray()))).     conn.setRequestProperty("Content-Type", XContentType.JSON.mediaType()).     // we'll be sending a body     conn.setDoOutput(true).     SocketAccess.doPrivileged(conn::connect).     if (bodyString != null) {         try (OutputStream out = conn.getOutputStream()) {             out.write(bodyString.getBytes(StandardCharsets.UTF_8)).         } catch (Exception e) {             try {                 conn.disconnect().             } catch (Exception e2) {             // Ignore exceptions if we weren't able to close the connection after an error             }             throw e.         }     }     try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {         StringBuilder sb = new StringBuilder().         String line = null.         while ((line = reader.readLine()) != null) {             sb.append(line).         }         return sb.toString().     } catch (IOException e) {         try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getErrorStream(), StandardCharsets.UTF_8))) {             StringBuilder sb = new StringBuilder().             String line = null.             while ((line = reader.readLine()) != null) {                 sb.append(line).             }             throw new IOException(sb.toString(), e).         }     } finally {         conn.disconnect().     } }
false;;4;22;;Set<String> getUsersThatExist(Terminal terminal, Settings settings, Environment env, OptionSet options) throws Exception {     Set<String> existingUsers = new HashSet<>().     String allUsersJson = postURL(settings, env, "GET", this.url.value(options) + "/_security/user/", options, null).     // EMPTY is safe here because we never use namedObject     try (XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, allUsersJson)) {         XContentParser.Token token = parser.nextToken().         String userName.         if (token == XContentParser.Token.START_OBJECT) {             while ((token = parser.nextToken()) == XContentParser.Token.FIELD_NAME) {                 userName = parser.currentName().                 existingUsers.add(userName).                 parser.nextToken().                 parser.skipChildren().             }         } else {             throw new ElasticsearchException("failed to retrieve users, expecting an object but got: " + token).         }     }     terminal.println("found existing users: " + existingUsers).     return existingUsers. }
false;static;2;14;;static String createUserJson(String[] roles, char[] password) throws IOException {     XContentBuilder builder = jsonBuilder().     builder.startObject().     {         builder.field("password_hash", new String(password)).         builder.startArray("roles").         for (String role : roles) {             builder.value(role).         }         builder.endArray().     }     builder.endObject().     return Strings.toString(builder). }
false;;3;44;;void importUsers(Terminal terminal, Environment env, OptionSet options) throws FileNotFoundException {     String usersCsv = usersToMigrateCsv.value(options).     String[] usersToMigrate = (usersCsv != null) ? usersCsv.split(",") : Strings.EMPTY_ARRAY.     Path usersFile = FileUserPasswdStore.resolveFile(env).     Path usersRolesFile = FileUserRolesStore.resolveFile(env).     if (Files.exists(usersFile) == false) {         throw new FileNotFoundException("users file [" + usersFile + "] does not exist").     } else if (Files.exists(usersRolesFile) == false) {         throw new FileNotFoundException("users_roles file [" + usersRolesFile + "] does not exist").     }     terminal.println("importing users from [" + usersFile + "]...").     final Logger logger = getTerminalLogger(terminal).     Map<String, char[]> userToHashedPW = FileUserPasswdStore.parseFile(usersFile, logger, env.settings()).     Map<String, String[]> userToRoles = FileUserRolesStore.parseFile(usersRolesFile, logger).     Set<String> existingUsers.     try {         existingUsers = getUsersThatExist(terminal, env.settings(), env, options).     } catch (Exception e) {         throw new ElasticsearchException("failed to get users that already exist, skipping user import", e).     }     if (usersToMigrate.length == 0) {         usersToMigrate = userToHashedPW.keySet().toArray(new String[userToHashedPW.size()]).     }     for (String user : usersToMigrate) {         if (userToHashedPW.containsKey(user) == false) {             terminal.println("user [" + user + "] was not found in files, skipping").             continue.         } else if (existingUsers.contains(user)) {             terminal.println("user [" + user + "] already exists, skipping").             continue.         }         terminal.println("migrating user [" + user + "]").         String reqBody = "n/a".         try {             reqBody = createUserJson(userToRoles.get(user), userToHashedPW.get(user)).             String resp = postURL(env.settings(), env, "POST", this.url.value(options) + "/_security/user/" + user, options, reqBody).             terminal.println(resp).         } catch (Exception e) {             throw new ElasticsearchException("failed to migrate user [" + user + "] with body: " + reqBody, e).         }     } }
false;;4;22;;Set<String> getRolesThatExist(Terminal terminal, Settings settings, Environment env, OptionSet options) throws Exception {     Set<String> existingRoles = new HashSet<>().     String allRolesJson = postURL(settings, env, "GET", this.url.value(options) + "/_security/role/", options, null).     // EMPTY is safe here because we never use namedObject     try (XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, allRolesJson)) {         XContentParser.Token token = parser.nextToken().         String roleName.         if (token == XContentParser.Token.START_OBJECT) {             while ((token = parser.nextToken()) == XContentParser.Token.FIELD_NAME) {                 roleName = parser.currentName().                 existingRoles.add(roleName).                 parser.nextToken().                 parser.skipChildren().             }         } else {             throw new ElasticsearchException("failed to retrieve roles, expecting an object but got: " + token).         }     }     terminal.println("found existing roles: " + existingRoles).     return existingRoles. }
false;static;1;5;;static String createRoleJson(RoleDescriptor rd) throws IOException {     XContentBuilder builder = jsonBuilder().     rd.toXContent(builder, ToXContent.EMPTY_PARAMS, true).     return Strings.toString(builder). }
false;;3;39;;void importRoles(Terminal terminal, Environment env, OptionSet options) throws FileNotFoundException {     String rolesCsv = rolesToMigrateCsv.value(options).     String[] rolesToMigrate = (rolesCsv != null) ? rolesCsv.split(",") : Strings.EMPTY_ARRAY.     Path rolesFile = FileRolesStore.resolveFile(env).toAbsolutePath().     if (Files.exists(rolesFile) == false) {         throw new FileNotFoundException("roles.yml file [" + rolesFile + "] does not exist").     }     terminal.println("importing roles from [" + rolesFile + "]...").     Logger logger = getTerminalLogger(terminal).     Map<String, RoleDescriptor> roles = FileRolesStore.parseRoleDescriptors(rolesFile, logger, true, Settings.EMPTY).     Set<String> existingRoles.     try {         existingRoles = getRolesThatExist(terminal, env.settings(), env, options).     } catch (Exception e) {         throw new ElasticsearchException("failed to get roles that already exist, skipping role import", e).     }     if (rolesToMigrate.length == 0) {         rolesToMigrate = roles.keySet().toArray(new String[roles.size()]).     }     for (String roleName : rolesToMigrate) {         if (roles.containsKey(roleName) == false) {             terminal.println("no role [" + roleName + "] found, skipping").             continue.         } else if (existingRoles.contains(roleName)) {             terminal.println("role [" + roleName + "] already exists, skipping").             continue.         }         terminal.println("migrating role [" + roleName + "]").         String reqBody = "n/a".         try {             reqBody = createRoleJson(roles.get(roleName)).             String resp = postURL(env.settings(), env, "POST", this.url.value(options) + "/_security/role/" + roleName, options, reqBody).             terminal.println(resp).         } catch (Exception e) {             throw new ElasticsearchException("failed to migrate role [" + roleName + "] with body: " + reqBody, e).         }     } }
false;public;1;14;;@Override public void append(LogEvent event) {     switch(event.getLevel().getStandardLevel()) {         case FATAL:         case ERROR:             terminal.println(Verbosity.NORMAL, event.getMessage().getFormattedMessage()).             break.         case OFF:             break.         default:             terminal.println(Verbosity.VERBOSE, event.getMessage().getFormattedMessage()).             break.     } }
true;static;1;38;/**  * Creates a new Logger that is detached from the ROOT logger and only has an appender that will output log messages to the terminal  */ ;/**  * Creates a new Logger that is detached from the ROOT logger and only has an appender that will output log messages to the terminal  */ static Logger getTerminalLogger(final Terminal terminal) {     final Logger logger = LogManager.getLogger(ESNativeRealmMigrateTool.class).     Loggers.setLevel(logger, Level.ALL).     final LoggerContext ctx = (LoggerContext) LogManager.getContext(false).     final Configuration config = ctx.getConfiguration().     // create appender     final Appender appender = new AbstractAppender(ESNativeRealmMigrateTool.class.getName(), null, PatternLayout.newBuilder().withConfiguration(config).withPattern("%m").build()) {          @Override         public void append(LogEvent event) {             switch(event.getLevel().getStandardLevel()) {                 case FATAL:                 case ERROR:                     terminal.println(Verbosity.NORMAL, event.getMessage().getFormattedMessage()).                     break.                 case OFF:                     break.                 default:                     terminal.println(Verbosity.VERBOSE, event.getMessage().getFormattedMessage()).                     break.             }         }     }.     appender.start().     // get the config, detach from parent, remove appenders, add custom appender     final LoggerConfig loggerConfig = config.getLoggerConfig(ESNativeRealmMigrateTool.class.getName()).     loggerConfig.setParent(null).     loggerConfig.getAppenders().forEach((s, a) -> Loggers.removeAppender(logger, a)).     Loggers.addAppender(logger, appender).     return logger. }
