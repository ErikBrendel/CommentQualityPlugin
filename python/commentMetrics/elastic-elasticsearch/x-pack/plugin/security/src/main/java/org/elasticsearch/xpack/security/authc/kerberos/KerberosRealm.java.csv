commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public void initialize(Iterable<Realm> realms, XPackLicenseState licenseState) {     if (delegatedRealms != null) {         throw new IllegalStateException("Realm has already been initialized").     }     delegatedRealms = new DelegatedAuthorizationSupport(realms, config, licenseState). }
false;public;0;4;;@Override public Map<String, List<String>> getAuthenticationFailureHeaders() {     return Collections.singletonMap(WWW_AUTHENTICATE, Collections.singletonList(NEGOTIATE_SCHEME_NAME)). }
false;public;1;6;;@Override public void expire(final String username) {     if (userPrincipalNameToUserCache != null) {         userPrincipalNameToUserCache.invalidate(username).     } }
false;public;0;6;;@Override public void expireAll() {     if (userPrincipalNameToUserCache != null) {         userPrincipalNameToUserCache.invalidateAll().     } }
false;public;1;4;;@Override public boolean supports(final AuthenticationToken token) {     return token instanceof KerberosAuthenticationToken. }
false;public;1;4;;@Override public AuthenticationToken token(final ThreadContext context) {     return KerberosAuthenticationToken.extractToken(context.getHeader(AUTH_HEADER)). }
false;public;2;26;;@Override public void authenticate(final AuthenticationToken token, final ActionListener<AuthenticationResult> listener) {     assert delegatedRealms != null : "Realm has not been initialized correctly".     assert token instanceof KerberosAuthenticationToken.     final KerberosAuthenticationToken kerbAuthnToken = (KerberosAuthenticationToken) token.     kerberosTicketValidator.validateTicket((byte[]) kerbAuthnToken.credentials(), keytabPath, enableKerberosDebug, ActionListener.wrap(userPrincipalNameOutToken -> {         if (userPrincipalNameOutToken.v1() != null) {             resolveUser(userPrincipalNameOutToken.v1(), userPrincipalNameOutToken.v2(), listener).         } else {             /**              * This is when security context could not be established may be due to ongoing              * negotiation and requires token to be sent back to peer for continuing              * further. We are terminating the authentication process as this is spengo              * negotiation and no other realm can handle this. We can have only one Kerberos              * realm in the system so terminating with RestStatus Unauthorized (401) and              * with 'WWW-Authenticate' header populated with value with token in the form              * 'Negotiate oYH1MIHyoAMK...'              */             String errorMessage = "failed to authenticate user, gss context negotiation not complete".             ElasticsearchSecurityException ese = unauthorized(errorMessage, null).             ese = unauthorizedWithOutputToken(ese, userPrincipalNameOutToken.v2()).             listener.onResponse(AuthenticationResult.terminate(errorMessage, ese)).         }     }, e -> handleException(e, listener))). }
false;private;1;3;;private String[] splitUserPrincipalName(final String userPrincipalName) {     return userPrincipalName.split("@"). }
false;private;2;14;;private void handleException(Exception e, final ActionListener<AuthenticationResult> listener) {     if (e instanceof LoginException) {         logger.debug("failed to authenticate user, service login failure", e).         listener.onResponse(AuthenticationResult.terminate("failed to authenticate user, service login failure", unauthorized(e.getLocalizedMessage(), e))).     } else if (e instanceof GSSException) {         logger.debug("failed to authenticate user, gss context negotiation failure", e).         listener.onResponse(AuthenticationResult.terminate("failed to authenticate user, gss context negotiation failure", unauthorized(e.getLocalizedMessage(), e))).     } else {         logger.debug("failed to authenticate user", e).         listener.onFailure(e).     } }
false;private;3;30;;private void resolveUser(final String userPrincipalName, final String outToken, final ActionListener<AuthenticationResult> listener) {     // response header in thread context.     if (Strings.hasText(outToken)) {         threadPool.getThreadContext().addResponseHeader(WWW_AUTHENTICATE, NEGOTIATE_AUTH_HEADER_PREFIX + outToken).     }     final String[] userAndRealmName = splitUserPrincipalName(userPrincipalName).     /*          * Usually principal names are in the form 'user/instance@REALM'. If          * KerberosRealmSettings#SETTING_REMOVE_REALM_NAME is true then remove          * '@REALM' part from the user principal name to get username.          */     final String username = (this.removeRealmName) ? userAndRealmName[0] : userPrincipalName.     if (delegatedRealms.hasDelegation()) {         delegatedRealms.resolve(username, listener).     } else {         final User user = (userPrincipalNameToUserCache != null) ? userPrincipalNameToUserCache.get(username) : null.         if (user != null) {             listener.onResponse(AuthenticationResult.success(user)).         } else {             final String realmName = (userAndRealmName.length > 1) ? userAndRealmName[1] : null.             final Map<String, Object> metadata = new HashMap<>().             metadata.put(KRB_METADATA_REALM_NAME_KEY, realmName).             metadata.put(KRB_METADATA_UPN_KEY, userPrincipalName).             buildUser(username, metadata, listener).         }     } }
false;private;3;10;;private void buildUser(final String username, final Map<String, Object> metadata, final ActionListener<AuthenticationResult> listener) {     final UserRoleMapper.UserData userData = new UserRoleMapper.UserData(username, null, Collections.emptySet(), metadata, this.config).     userRoleMapper.resolveRoles(userData, ActionListener.wrap(roles -> {         final User computedUser = new User(username, roles.toArray(new String[roles.size()]), null, null, userData.getMetadata(), true).         if (userPrincipalNameToUserCache != null) {             userPrincipalNameToUserCache.put(username, computedUser).         }         listener.onResponse(AuthenticationResult.success(computedUser)).     }, listener::onFailure)). }
false;public;2;4;;@Override public void lookupUser(final String username, final ActionListener<User> listener) {     listener.onResponse(null). }
