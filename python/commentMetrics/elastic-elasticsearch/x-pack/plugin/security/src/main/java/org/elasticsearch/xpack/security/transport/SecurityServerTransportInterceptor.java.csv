commented;modifiers;parameterAmount;loc;comment;code
false;public;5;38;;@Override public <T extends TransportResponse> void sendRequest(Transport.Connection connection, String action, TransportRequest request, TransportRequestOptions options, TransportResponseHandler<T> handler) {     // make a local copy of isStateNotRecovered as this is a volatile variable and it     // is used multiple times in the method. The copy to a local variable allows us to     // guarantee we use the same value wherever we would check the value for the state     // being recovered     final boolean stateNotRecovered = isStateNotRecovered.     final boolean sendWithAuth = licenseState.isAuthAllowed() || stateNotRecovered.     if (sendWithAuth) {         // the transport in core normally does this check, BUT since we are serializing to a string header we need to do it         // ourselves otherwise we wind up using a version newer than what we can actually send         final Version minVersion = Version.min(connection.getVersion(), Version.CURRENT).         // which means that the user is copied over to system actions so we need to change the user         if (AuthorizationUtils.shouldReplaceUserWithSystem(threadPool.getThreadContext(), action)) {             securityContext.executeAsUser(SystemUser.INSTANCE, (original) -> sendWithUser(connection, action, request, options, new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender, stateNotRecovered), minVersion).         } else if (AuthorizationUtils.shouldSetUserBasedOnActionOrigin(threadPool.getThreadContext())) {             AuthorizationUtils.switchUserBasedOnActionOriginAndExecute(threadPool.getThreadContext(), securityContext, (original) -> sendWithUser(connection, action, request, options, new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender, stateNotRecovered)).         } else if (securityContext.getAuthentication() != null && securityContext.getAuthentication().getVersion().equals(minVersion) == false) {             // re-write the authentication since we want the authentication version to match the version of the connection             securityContext.executeAfterRewritingAuthentication(original -> sendWithUser(connection, action, request, options, new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender, stateNotRecovered), minVersion).         } else {             sendWithUser(connection, action, request, options, handler, sender, stateNotRecovered).         }     } else {         sender.sendRequest(connection, action, request, options, handler).     } }
false;public;1;43;;@Override public AsyncSender interceptSender(AsyncSender sender) {     return new AsyncSender() {          @Override         public <T extends TransportResponse> void sendRequest(Transport.Connection connection, String action, TransportRequest request, TransportRequestOptions options, TransportResponseHandler<T> handler) {             // make a local copy of isStateNotRecovered as this is a volatile variable and it             // is used multiple times in the method. The copy to a local variable allows us to             // guarantee we use the same value wherever we would check the value for the state             // being recovered             final boolean stateNotRecovered = isStateNotRecovered.             final boolean sendWithAuth = licenseState.isAuthAllowed() || stateNotRecovered.             if (sendWithAuth) {                 // the transport in core normally does this check, BUT since we are serializing to a string header we need to do it                 // ourselves otherwise we wind up using a version newer than what we can actually send                 final Version minVersion = Version.min(connection.getVersion(), Version.CURRENT).                 // which means that the user is copied over to system actions so we need to change the user                 if (AuthorizationUtils.shouldReplaceUserWithSystem(threadPool.getThreadContext(), action)) {                     securityContext.executeAsUser(SystemUser.INSTANCE, (original) -> sendWithUser(connection, action, request, options, new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender, stateNotRecovered), minVersion).                 } else if (AuthorizationUtils.shouldSetUserBasedOnActionOrigin(threadPool.getThreadContext())) {                     AuthorizationUtils.switchUserBasedOnActionOriginAndExecute(threadPool.getThreadContext(), securityContext, (original) -> sendWithUser(connection, action, request, options, new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender, stateNotRecovered)).                 } else if (securityContext.getAuthentication() != null && securityContext.getAuthentication().getVersion().equals(minVersion) == false) {                     // re-write the authentication since we want the authentication version to match the version of the connection                     securityContext.executeAfterRewritingAuthentication(original -> sendWithUser(connection, action, request, options, new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender, stateNotRecovered), minVersion).                 } else {                     sendWithUser(connection, action, request, options, handler, sender, stateNotRecovered).                 }             } else {                 sender.sendRequest(connection, action, request, options, handler).             }         }     }. }
false;private;7;18;;private <T extends TransportResponse> void sendWithUser(Transport.Connection connection, String action, TransportRequest request, TransportRequestOptions options, TransportResponseHandler<T> handler, AsyncSender sender, final boolean stateNotRecovered) {     // unless we do not know the actual license of the cluster     if (securityContext.getAuthentication() == null && stateNotRecovered == false) {         // we use an assertion here to ensure we catch this in our testing infrastructure, but leave the ISE for cases we do not catch         // in tests and may be hit by a user         assertNoAuthentication(action).         throw new IllegalStateException("there should always be a user when sending a message for action [" + action + "]").     }     try {         sender.sendRequest(connection, action, request, options, handler).     } catch (Exception e) {         handler.handleException(new TransportException("failed sending request", e)).     } }
true;;1;3;// pkg-private method to allow overriding for tests ;// pkg-private method to allow overriding for tests void assertNoAuthentication(String action) {     assert false : "there should always be a user when sending a message for action [" + action + "]". }
false;public;4;7;;@Override public <T extends TransportRequest> TransportRequestHandler<T> interceptHandler(String action, String executor, boolean forceExecution, TransportRequestHandler<T> actualHandler) {     return new ProfileSecuredRequestHandler<>(logger, action, forceExecution, executor, actualHandler, profileFilters, licenseState, threadPool). }
false;private;1;29;;private Map<String, ServerTransportFilter> initializeProfileFilters(DestructiveOperations destructiveOperations) {     final SSLConfiguration sslConfiguration = sslService.getSSLConfiguration(setting("transport.ssl")).     final Map<String, SSLConfiguration> profileConfigurations = ProfileConfigurations.get(settings, sslService, sslConfiguration).     Map<String, ServerTransportFilter> profileFilters = new HashMap<>(profileConfigurations.size() + 1).     final boolean transportSSLEnabled = XPackSettings.TRANSPORT_SSL_ENABLED.get(settings).     for (Map.Entry<String, SSLConfiguration> entry : profileConfigurations.entrySet()) {         final SSLConfiguration profileConfiguration = entry.getValue().         final boolean extractClientCert = transportSSLEnabled && sslService.isSSLClientAuthEnabled(profileConfiguration).         final String type = TRANSPORT_TYPE_PROFILE_SETTING.getConcreteSettingForNamespace(entry.getKey()).get(settings).         switch(type) {             case "client":                 profileFilters.put(entry.getKey(), new ServerTransportFilter.ClientProfile(authcService, authzService, threadPool.getThreadContext(), extractClientCert, destructiveOperations, reservedRealmEnabled, securityContext, licenseState)).                 break.             case "node":                 profileFilters.put(entry.getKey(), new ServerTransportFilter.NodeProfile(authcService, authzService, threadPool.getThreadContext(), extractClientCert, destructiveOperations, reservedRealmEnabled, securityContext, licenseState)).                 break.             default:                 throw new IllegalStateException("unknown profile type: " + type).         }     }     return Collections.unmodifiableMap(profileFilters). }
false;public;0;4;;@Override public boolean isForceExecution() {     return forceExecution. }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (Exception e1) {         e1.addSuppressed(e).         logger.warn("failed to send exception response for action [" + action + "]", e1).     } }
false;protected;0;4;;@Override protected void doRun() throws Exception {     handler.messageReceived(request, channel, task). }
false;;3;23;;AbstractRunnable getReceiveRunnable(T request, TransportChannel channel, Task task) {     return new AbstractRunnable() {          @Override         public boolean isForceExecution() {             return forceExecution.         }          @Override         public void onFailure(Exception e) {             try {                 channel.sendResponse(e).             } catch (Exception e1) {                 e1.addSuppressed(e).                 logger.warn("failed to send exception response for action [" + action + "]", e1).             }         }          @Override         protected void doRun() throws Exception {             handler.messageReceived(request, channel, task).         }     }. }
false;public;0;8;;@Override public String toString() {     return "ProfileSecuredRequestHandler{" + "action='" + action + '\'' + ", executorName='" + executorName + '\'' + ", forceExecution=" + forceExecution + '}'. }
false;public;3;48;;@Override public void messageReceived(T request, TransportChannel channel, Task task) throws Exception {     final AbstractRunnable receiveMessage = getReceiveRunnable(request, channel, task).     try (ThreadContext.StoredContext ctx = threadContext.newStoredContext(true)) {         if (licenseState.isAuthAllowed()) {             String profile = channel.getProfileName().             ServerTransportFilter filter = profileFilters.get(profile).             if (filter == null) {                 if (TransportService.DIRECT_RESPONSE_PROFILE.equals(profile)) {                     // apply the default filter to local requests. We never know what the request is or who sent it...                     filter = profileFilters.get("default").                 } else {                     String msg = "transport profile [" + profile + "] is not associated with a transport filter".                     throw new IllegalStateException(msg).                 }             }             assert filter != null.             final Thread executingThread = Thread.currentThread().             CheckedConsumer<Void, Exception> consumer = (x) -> {                 final Executor executor.                 if (executingThread == Thread.currentThread()) {                     // only fork off if we get called on another thread this means we moved to                     // an async execution and in this case we need to go back to the thread pool                     // that was actually executing it. it's also possible that the                     // thread-pool we are supposed to execute on is `SAME` in that case                     // the handler is OK with executing on a network thread and we can just continue even if                     // we are on another thread due to async operations                     executor = threadPool.executor(ThreadPool.Names.SAME).                 } else {                     executor = threadPool.executor(executorName).                 }                 try {                     executor.execute(receiveMessage).                 } catch (Exception e) {                     receiveMessage.onFailure(e).                 }             }.             ActionListener<Void> filterListener = ActionListener.wrap(consumer, receiveMessage::onFailure).             filter.inbound(action, request, channel, filterListener).         } else {             receiveMessage.run().         }     } }
