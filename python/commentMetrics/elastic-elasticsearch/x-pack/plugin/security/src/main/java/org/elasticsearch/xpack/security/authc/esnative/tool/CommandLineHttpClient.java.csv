commented;modifiers;parameterAmount;loc;comment;code
true;public;6;56;/**  * General purpose HTTP(S) call with JSON Content-Type and Authorization Header.  * SSL settings are read from the settings file, if any.  *  * @param user  *            user in the authorization header.  * @param password  *            password in the authorization header.  * @param requestBodySupplier  *            supplier for the JSON string body of the request.  * @param responseHandler  *            handler of the response Input Stream.  * @return HTTP protocol response code.  */ ;/**  * General purpose HTTP(S) call with JSON Content-Type and Authorization Header.  * SSL settings are read from the settings file, if any.  *  * @param user  *            user in the authorization header.  * @param password  *            password in the authorization header.  * @param requestBodySupplier  *            supplier for the JSON string body of the request.  * @param responseHandler  *            handler of the response Input Stream.  * @return HTTP protocol response code.  */ @SuppressForbidden(reason = "We call connect in doPrivileged and provide SocketPermission") public HttpResponse execute(String method, URL url, String user, SecureString password, CheckedSupplier<String, Exception> requestBodySupplier, CheckedFunction<InputStream, HttpResponseBuilder, Exception> responseHandler) throws Exception {     final HttpURLConnection conn.     // If using SSL, need a custom service because it's likely a self-signed certificate     if ("https".equalsIgnoreCase(url.getProtocol())) {         final SSLService sslService = new SSLService(settings, env).         final HttpsURLConnection httpsConn = (HttpsURLConnection) url.openConnection().         AccessController.doPrivileged((PrivilegedAction<Void>) () -> {             final SSLConfiguration sslConfiguration = sslService.getHttpTransportSSLConfiguration().             // Requires permission java.lang.RuntimePermission "setFactory".             httpsConn.setSSLSocketFactory(sslService.sslSocketFactory(sslConfiguration)).             final boolean isHostnameVerificationEnabled = sslConfiguration.verificationMode().isHostnameVerificationEnabled().             if (isHostnameVerificationEnabled == false) {                 httpsConn.setHostnameVerifier((hostname, session) -> true).             }             return null.         }).         conn = httpsConn.     } else {         conn = (HttpURLConnection) url.openConnection().     }     conn.setRequestMethod(method).     conn.setReadTimeout(READ_TIMEOUT).     // Add basic-auth header     String token = UsernamePasswordToken.basicAuthHeaderValue(user, password).     conn.setRequestProperty("Authorization", token).     conn.setRequestProperty("Content-Type", XContentType.JSON.mediaType()).     String bodyString = requestBodySupplier.get().     // set true if we are sending a body     conn.setDoOutput(bodyString != null).     SocketAccess.doPrivileged(conn::connect).     if (bodyString != null) {         try (OutputStream out = conn.getOutputStream()) {             out.write(bodyString.getBytes(StandardCharsets.UTF_8)).         } catch (Exception e) {             Releasables.closeWhileHandlingException(conn::disconnect).             throw e.         }     }     // this throws IOException if there is a network problem     final int responseCode = conn.getResponseCode().     HttpResponseBuilder responseBuilder = null.     try (InputStream inputStream = conn.getInputStream()) {         responseBuilder = responseHandler.apply(inputStream).     } catch (IOException e) {         // this IOException is if the HTTP response code is 'BAD' (>= 400)         try (InputStream errorStream = conn.getErrorStream()) {             responseBuilder = responseHandler.apply(errorStream).         }     } finally {         Releasables.closeWhileHandlingException(conn::disconnect).     }     responseBuilder.withHttpStatus(responseCode).     return responseBuilder.build(). }
false;;0;30;;String getDefaultURL() {     final String scheme = XPackSettings.HTTP_SSL_ENABLED.get(settings) ? "https" : "http".     List<String> httpPublishHost = SETTING_HTTP_PUBLISH_HOST.get(settings).     if (httpPublishHost.isEmpty()) {         httpPublishHost = NetworkService.GLOBAL_NETWORK_PUBLISH_HOST_SETTING.get(settings).     }     // we cannot do custom name resolution here...     NetworkService networkService = new NetworkService(Collections.emptyList()).     try {         InetAddress publishAddress = networkService.resolvePublishHostAddresses(httpPublishHost.toArray(Strings.EMPTY_ARRAY)).         int port = SETTING_HTTP_PUBLISH_PORT.get(settings).         if (port <= 0) {             int[] ports = SETTING_HTTP_PORT.get(settings).ports().             if (ports.length > 0) {                 port = ports[0].             }             // what we know             if (port <= 0) {                 throw new IllegalStateException("unable to determine http port from settings, please use the -u option to provide the" + " url").             }         }         return scheme + "://" + InetAddresses.toUriString(publishAddress) + ":" + port.     } catch (IOException e) {         throw new UncheckedIOException("failed to resolve default URL", e).     } }
