commented;modifiers;parameterAmount;loc;comment;code
true;public;1;21;/**  * If a PKI realm is enabled, checks to see if SSL and Client authentication are enabled on at  * least one network communication layer.  */ ;/**  * If a PKI realm is enabled, checks to see if SSL and Client authentication are enabled on at  * least one network communication layer.  */ @Override public BootstrapCheckResult check(BootstrapContext context) {     final Settings settings = context.settings().     final Map<RealmIdentifier, Settings> realms = RealmSettings.getRealmSettings(settings).     final boolean pkiRealmEnabled = realms.entrySet().stream().filter(e -> PkiRealmSettings.TYPE.equals(e.getKey().getType())).map(Map.Entry::getValue).anyMatch(s -> s.getAsBoolean("enabled", true)).     if (pkiRealmEnabled) {         for (String contextName : getSslContextNames(settings)) {             final SSLConfiguration configuration = sslService.getSSLConfiguration(contextName).             if (sslService.isSSLClientAuthEnabled(configuration)) {                 return BootstrapCheckResult.success().             }         }         return BootstrapCheckResult.failure("a PKI realm is enabled but cannot be used as neither HTTP or Transport have SSL and client authentication enabled").     } else {         return BootstrapCheckResult.success().     } }
false;private;1;13;;private List<String> getSslContextNames(Settings settings) {     final List<String> list = new ArrayList<>().     if (HTTP_SSL_ENABLED.get(settings)) {         list.add(setting("http.ssl")).     }     if (XPackSettings.TRANSPORT_SSL_ENABLED.get(settings)) {         list.add(setting("transport.ssl")).         list.addAll(sslService.getTransportProfileContextNames()).     }     return list. }
true;public;0;4;// FIXME this is an antipattern move this out of a bootstrap check! ;// FIXME this is an antipattern move this out of a bootstrap check! @Override public boolean alwaysEnforce() {     return true. }
