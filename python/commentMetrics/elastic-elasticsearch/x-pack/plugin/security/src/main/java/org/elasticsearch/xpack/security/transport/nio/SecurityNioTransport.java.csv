commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected void doStart() {     super.doStart().     if (authenticator != null) {         authenticator.setBoundTransportAddress(boundAddress(), profileBoundAddresses()).     } }
false;public;2;31;;@Override public void onException(TcpChannel channel, Exception e) {     if (!lifecycle.started()) {         // just close and ignore - we are already stopped and just need to make sure we release all resources         CloseableChannel.closeChannel(channel).     } else if (SSLExceptionHelper.isNotSslRecordException(e)) {         if (logger.isTraceEnabled()) {             logger.trace(new ParameterizedMessage("received plaintext traffic on an encrypted channel, closing connection {}", channel), e).         } else {             logger.warn("received plaintext traffic on an encrypted channel, closing connection {}", channel).         }         CloseableChannel.closeChannel(channel).     } else if (SSLExceptionHelper.isCloseDuringHandshakeException(e)) {         if (logger.isTraceEnabled()) {             logger.trace(new ParameterizedMessage("connection {} closed during ssl handshake", channel), e).         } else {             logger.warn("connection {} closed during handshake", channel).         }         CloseableChannel.closeChannel(channel).     } else if (SSLExceptionHelper.isReceivedCertificateUnknownException(e)) {         if (logger.isTraceEnabled()) {             logger.trace(new ParameterizedMessage("client did not trust server's certificate, closing connection {}", channel), e).         } else {             logger.warn("client did not trust this server's certificate, closing connection {}", channel).         }         CloseableChannel.closeChannel(channel).     } else {         super.onException(channel, e).     } }
false;protected;1;4;;@Override protected TcpChannelFactory serverChannelFactory(ProfileSettings profileSettings) {     return new SecurityTcpChannelFactory(profileSettings, false). }
false;protected;1;20;;@Override protected Function<DiscoveryNode, TcpChannelFactory> clientChannelFactoryFunction(ProfileSettings profileSettings) {     return (node) -> {         final ChannelFactory.RawChannelFactory rawChannelFactory = new ChannelFactory.RawChannelFactory(profileSettings.tcpNoDelay, profileSettings.tcpKeepAlive, profileSettings.reuseAddress, Math.toIntExact(profileSettings.sendBufferSize.getBytes()), Math.toIntExact(profileSettings.receiveBufferSize.getBytes())).         SNIHostName serverName.         String configuredServerName = node.getAttributes().get("server_name").         if (configuredServerName != null) {             try {                 serverName = new SNIHostName(configuredServerName).             } catch (IllegalArgumentException e) {                 throw new ConnectTransportException(node, "invalid DiscoveryNode server_name [" + configuredServerName + "]", e).             }         } else {             serverName = null.         }         return new SecurityClientTcpChannelFactory(rawChannelFactory, serverName).     }. }
false;public;2;22;;@Override public NioTcpChannel createChannel(NioSelector selector, SocketChannel channel) throws IOException {     NioTcpChannel nioChannel = new NioTcpChannel(isClient == false, profileName, channel).     Supplier<InboundChannelBuffer.Page> pageSupplier = () -> {         Recycler.V<byte[]> bytes = pageCacheRecycler.bytePage(false).         return new InboundChannelBuffer.Page(ByteBuffer.wrap(bytes.v()), bytes::close).     }.     TcpReadWriteHandler readWriteHandler = new TcpReadWriteHandler(nioChannel, SecurityNioTransport.this).     InboundChannelBuffer buffer = new InboundChannelBuffer(pageSupplier).     Consumer<Exception> exceptionHandler = (e) -> onException(nioChannel, e).     SocketChannelContext context.     if (sslEnabled) {         SSLDriver sslDriver = new SSLDriver(createSSLEngine(channel), isClient).         context = new SSLChannelContext(nioChannel, selector, exceptionHandler, sslDriver, readWriteHandler, buffer, ipFilter).     } else {         context = new BytesChannelContext(nioChannel, selector, exceptionHandler, readWriteHandler, buffer, ipFilter).     }     nioChannel.setContext(context).     return nioChannel. }
false;public;2;9;;@Override public NioTcpServerChannel createServerChannel(NioSelector selector, ServerSocketChannel channel) throws IOException {     NioTcpServerChannel nioChannel = new NioTcpServerChannel(profileName, channel).     Consumer<Exception> exceptionHandler = (e) -> onServerException(nioChannel, e).     Consumer<NioSocketChannel> acceptor = SecurityNioTransport.this::acceptChannel.     ServerChannelContext context = new ServerChannelContext(nioChannel, this, selector, acceptor, exceptionHandler).     nioChannel.setContext(context).     return nioChannel. }
false;protected;1;14;;protected SSLEngine createSSLEngine(SocketChannel channel) throws IOException {     SSLEngine sslEngine.     SSLConfiguration defaultConfig = profileConfiguration.get(TransportSettings.DEFAULT_PROFILE).     SSLConfiguration sslConfig = profileConfiguration.getOrDefault(profileName, defaultConfig).     boolean hostnameVerificationEnabled = sslConfig.verificationMode().isHostnameVerificationEnabled().     if (hostnameVerificationEnabled) {         InetSocketAddress inetSocketAddress = (InetSocketAddress) channel.getRemoteAddress().         // we create the socket based on the name given. don't reverse DNS         sslEngine = sslService.createSSLEngine(sslConfig, inetSocketAddress.getHostString(), inetSocketAddress.getPort()).     } else {         sslEngine = sslService.createSSLEngine(sslConfig, null, -1).     }     return sslEngine. }
false;public;2;4;;@Override public NioTcpServerChannel createServerChannel(NioSelector selector, ServerSocketChannel channel) {     throw new AssertionError("Cannot create TcpServerChannel with client factory"). }
false;protected;1;10;;@Override protected SSLEngine createSSLEngine(SocketChannel channel) throws IOException {     SSLEngine sslEngine = super.createSSLEngine(channel).     if (serverName != null) {         SSLParameters sslParameters = sslEngine.getSSLParameters().         sslParameters.setServerNames(Collections.singletonList(serverName)).         sslEngine.setSSLParameters(sslParameters).     }     return sslEngine. }
