commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Determines the set of roles that should be applied to <code>user</code>.  */ ;/**  * Determines the set of roles that should be applied to <code>user</code>.  */ void resolveRoles(UserData user, ActionListener<Set<String>> listener).
true;;1;1;/**  * Informs the mapper that the provided <code>realm</code> should be refreshed when  * the set of role-mappings change. The realm may be updated for the local node only, or across  * the whole cluster depending on whether this role-mapper has node-local data or cluster-wide  * data.  */ ;/**  * Informs the mapper that the provided <code>realm</code> should be refreshed when  * the set of role-mappings change. The realm may be updated for the local node only, or across  * the whole cluster depending on whether this role-mapper has node-local data or cluster-wide  * data.  */ void refreshRealmOnChange(CachingRealm realm).
true;public;0;13;/**  * Formats the user data as a {@link ExpressionModel}.  * The model does <em>not</em> have nested values - all values are simple Java values, but keys may  * contain <code>.</code>.  * For example, the {@link #metadata} values will be stored in the model with a key of  * <code>"metadata.KEY"</code> where <code>KEY</code> is the key from the metadata object.  */ ;/**  * Formats the user data as a {@link ExpressionModel}.  * The model does <em>not</em> have nested values - all values are simple Java values, but keys may  * contain <code>.</code>.  * For example, the {@link #metadata} values will be stored in the model with a key of  * <code>"metadata.KEY"</code> where <code>KEY</code> is the key from the metadata object.  */ public ExpressionModel asModel() {     final ExpressionModel model = new ExpressionModel().     model.defineField("username", username).     model.defineField("dn", dn, new DistinguishedNamePredicate(dn)).     model.defineField("groups", groups, groups.stream().<Predicate<FieldExpression.FieldValue>>map(DistinguishedNamePredicate::new).reduce(Predicate::or).orElse(fieldValue -> false)).     metadata.keySet().forEach(k -> model.defineField("metadata." + k, metadata.get(k))).     model.defineField("realm.name", realm.name()).     return model. }
false;public;0;10;;@Override public String toString() {     return "UserData{" + "username:" + username + ". dn:" + dn + ". groups:" + groups + ". metadata:" + metadata + ". realm=" + realm.name() + '}'. }
true;public;0;3;/**  * The username for the authenticated user.  */ ;/**  * The username for the authenticated user.  */ public String getUsername() {     return username. }
true;public;0;4;/**  * The <em>distinguished name</em> of the authenticated user, if applicable to the  * authentication method used. Otherwise, <code>null</code>.  */ ;/**  * The <em>distinguished name</em> of the authenticated user, if applicable to the  * authentication method used. Otherwise, <code>null</code>.  */ @Nullable public String getDn() {     return dn. }
true;public;0;3;/**  * The groups to which the user belongs in the originating user store. Should be empty  * if the user store or authentication method does not support groups.  */ ;/**  * The groups to which the user belongs in the originating user store. Should be empty  * if the user store or authentication method does not support groups.  */ public Set<String> getGroups() {     return groups. }
true;public;0;3;/**  * Any additional metadata that was provided at authentication time. The set of keys will  * vary according to the authenticating realm.  */ ;/**  * Any additional metadata that was provided at authentication time. The set of keys will  * vary according to the authenticating realm.  */ public Map<String, Object> getMetadata() {     return metadata. }
true;public;0;3;/**  * The realm that authenticated the user.  */ ;/**  * The realm that authenticated the user.  */ public RealmConfig getRealm() {     return realm. }
false;private,static;1;14;;private static DN parseDn(String string) {     if (string == null) {         return null.     } else {         try {             return new DN(string).         } catch (LDAPException | LDAPSDKUsageException e) {             if (LOGGER.isTraceEnabled()) {                 LOGGER.trace(new ParameterizedMessage("failed to parse [{}] as a DN", string), e).             }             return null.         }     } }
false;public;0;4;;@Override public String toString() {     return string. }
false;public;1;53;;@Override public boolean test(FieldExpression.FieldValue fieldValue) {     final CharacterRunAutomaton automaton = fieldValue.getAutomaton().     if (automaton != null) {         if (automaton.run(string)) {             return true.         }         if (dn != null && automaton.run(dn.toNormalizedString())) {             return true.         }         if (automaton.run(string.toLowerCase(Locale.ROOT)) || automaton.run(string.toUpperCase(Locale.ROOT))) {             return true.         }         if (dn == null) {             return false.         }         assert fieldValue.getValue() instanceof String : "FieldValue " + fieldValue + " has automaton but value is " + (fieldValue.getValue() == null ? "<null>" : fieldValue.getValue().getClass()).         String pattern = (String) fieldValue.getValue().         // We can use dn.isDescendantOf for that         if (pattern.startsWith("*,")) {             final String suffix = pattern.substring(2).             // if the suffix has a wildcard, then it's not a pure sub-tree match             if (suffix.indexOf('*') == -1) {                 final DN dnSuffix = parseDn(suffix).                 if (dnSuffix != null && dn.isDescendantOf(dnSuffix, false)) {                     return true.                 }             }         }         return false.     }     if (fieldValue.getValue() instanceof String) {         final String testString = (String) fieldValue.getValue().         if (testString.equalsIgnoreCase(string)) {             return true.         }         if (dn == null) {             return false.         }         final DN testDn = parseDn(testString).         if (testDn != null) {             return dn.equals(testDn).         }         return testString.equalsIgnoreCase(dn.toNormalizedString()).     }     return string == null && fieldValue.getValue() == null. }
