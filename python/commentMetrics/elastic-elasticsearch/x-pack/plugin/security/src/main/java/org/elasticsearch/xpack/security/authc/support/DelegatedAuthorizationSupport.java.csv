commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Are there any realms configured for delegated lookup  */ ;/**  * Are there any realms configured for delegated lookup  */ public boolean hasDelegation() {     return this.lookup.hasRealms(). }
true;public;2;25;/**  * Attempts to find the user specified by {@code username} in one of the delegated realms.  * The realms are searched in the order specified during construction.  * Returns a {@link AuthenticationResult#success(User) successful result} if a {@link User}  * was found, otherwise returns an  * {@link AuthenticationResult#unsuccessful(String, Exception) unsuccessful result}  * with a meaningful diagnostic message.  */ ;/**  * Attempts to find the user specified by {@code username} in one of the delegated realms.  * The realms are searched in the order specified during construction.  * Returns a {@link AuthenticationResult#success(User) successful result} if a {@link User}  * was found, otherwise returns an  * {@link AuthenticationResult#unsuccessful(String, Exception) unsuccessful result}  * with a meaningful diagnostic message.  */ public void resolve(String username, ActionListener<AuthenticationResult> resultListener) {     if (licenseState.isAuthorizationRealmAllowed() == false) {         resultListener.onResponse(AuthenticationResult.unsuccessful(DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX + " are not permitted", LicenseUtils.newComplianceException(DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX))).         return.     }     if (hasDelegation() == false) {         resultListener.onResponse(AuthenticationResult.unsuccessful("No [" + DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX + "] have been configured", null)).         return.     }     ActionListener<Tuple<User, Realm>> userListener = ActionListener.wrap(tuple -> {         if (tuple != null) {             logger.trace("Found user " + tuple.v1() + " in realm " + tuple.v2()).             resultListener.onResponse(AuthenticationResult.success(tuple.v1())).         } else {             resultListener.onResponse(AuthenticationResult.unsuccessful("the principal [" + username + "] was authenticated, but no user could be found in realms [" + collectionToDelimitedString(lookup.getRealms(), ",") + "]", null)).         }     }, resultListener::onFailure).     lookup.lookup(username, userListener). }
false;private;2;8;;private List<Realm> resolveRealms(Iterable<? extends Realm> allRealms, List<String> lookupRealms) {     final List<Realm> result = new ArrayList<>(lookupRealms.size()).     for (String name : lookupRealms) {         result.add(findRealm(name, allRealms)).     }     assert result.size() == lookupRealms.size().     return result. }
true;private;2;10;/**  * Checks for (and rejects) chains of delegation in the provided realms.  * A chain occurs when "realmA" delegates authorization to "realmB", and realmB also delegates authorization (to any realm).  * Since "realmB" does not handle its own authorization, it is not a valid target for delegated authorization.  * @param delegatedRealms The list of realms that are going to be used for authorization. If is an error if any of these realms are  *                        also configured to delegate their authorization.  * @throws IllegalArgumentException if a chain is detected  */ ;/**  * Checks for (and rejects) chains of delegation in the provided realms.  * A chain occurs when "realmA" delegates authorization to "realmB", and realmB also delegates authorization (to any realm).  * Since "realmB" does not handle its own authorization, it is not a valid target for delegated authorization.  * @param delegatedRealms The list of realms that are going to be used for authorization. If is an error if any of these realms are  *                        also configured to delegate their authorization.  * @throws IllegalArgumentException if a chain is detected  */ private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings) {     for (Realm realm : delegatedRealms) {         Setting<List<String>> realmAuthzSetting = AUTHZ_REALMS.apply(realm.type()).getConcreteSettingForNamespace(realm.name()).         if (realmAuthzSetting.exists(globalSettings)) {             throw new IllegalArgumentException("cannot use realm [" + realm + "] as an authorization realm - it is already delegating authorization to [" + realmAuthzSetting.get(globalSettings) + "]").         }     } }
false;private;2;8;;private Realm findRealm(String name, Iterable<? extends Realm> allRealms) {     for (Realm realm : allRealms) {         if (name.equals(realm.name())) {             return realm.         }     }     throw new IllegalArgumentException("configured authorization realm [" + name + "] does not exist (or is not enabled)"). }
