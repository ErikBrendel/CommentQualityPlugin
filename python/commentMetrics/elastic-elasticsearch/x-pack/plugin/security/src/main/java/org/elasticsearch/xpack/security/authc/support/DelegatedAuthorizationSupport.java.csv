# id;timestamp;commentText;codeText;commentWords;codeWords
DelegatedAuthorizationSupport -> public boolean hasDelegation();1535723122;Are there any realms configured for delegated lookup;public boolean hasDelegation() {_        return this.lookup.hasRealms()__    };are,there,any,realms,configured,for,delegated,lookup;public,boolean,has,delegation,return,this,lookup,has,realms
DelegatedAuthorizationSupport -> public boolean hasDelegation();1540847035;Are there any realms configured for delegated lookup;public boolean hasDelegation() {_        return this.lookup.hasRealms()__    };are,there,any,realms,configured,for,delegated,lookup;public,boolean,has,delegation,return,this,lookup,has,realms
DelegatedAuthorizationSupport -> public boolean hasDelegation();1541476610;Are there any realms configured for delegated lookup;public boolean hasDelegation() {_        return this.lookup.hasRealms()__    };are,there,any,realms,configured,for,delegated,lookup;public,boolean,has,delegation,return,this,lookup,has,realms
DelegatedAuthorizationSupport -> public boolean hasDelegation();1541642262;Are there any realms configured for delegated lookup;public boolean hasDelegation() {_        return this.lookup.hasRealms()__    };are,there,any,realms,configured,for,delegated,lookup;public,boolean,has,delegation,return,this,lookup,has,realms
DelegatedAuthorizationSupport -> public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState);1535723122;Resolves the {@link DelegatedAuthorizationSettings#AUTHZ_REALMS} setting from {@code config} and calls_{@link #DelegatedAuthorizationSupport(Iterable, List, Settings, ThreadContext, XPackLicenseState)};public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState) {_        this(allRealms, DelegatedAuthorizationSettings.AUTHZ_REALMS.get(config.settings()), config.globalSettings(), config.threadContext(),_            licenseState)__    };resolves,the,link,delegated,authorization,settings,setting,from,code,config,and,calls,link,delegated,authorization,support,iterable,list,settings,thread,context,xpack,license,state;public,delegated,authorization,support,iterable,extends,realm,all,realms,realm,config,config,xpack,license,state,license,state,this,all,realms,delegated,authorization,settings,get,config,settings,config,global,settings,config,thread,context,license,state
DelegatedAuthorizationSupport -> public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState);1540847035;Resolves the {@link DelegatedAuthorizationSettings#AUTHZ_REALMS} setting from {@code config} and calls_{@link #DelegatedAuthorizationSupport(Iterable, List, Settings, ThreadContext, XPackLicenseState)};public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState) {_        this(allRealms, DelegatedAuthorizationSettings.AUTHZ_REALMS.get(config.settings()), config.globalSettings(), config.threadContext(),_            licenseState)__    };resolves,the,link,delegated,authorization,settings,setting,from,code,config,and,calls,link,delegated,authorization,support,iterable,list,settings,thread,context,xpack,license,state;public,delegated,authorization,support,iterable,extends,realm,all,realms,realm,config,config,xpack,license,state,license,state,this,all,realms,delegated,authorization,settings,get,config,settings,config,global,settings,config,thread,context,license,state
DelegatedAuthorizationSupport -> public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState);1541476610;Resolves the {@link DelegatedAuthorizationSettings#AUTHZ_REALMS} setting from {@code config} and calls_{@link #DelegatedAuthorizationSupport(Iterable, List, Settings, ThreadContext, XPackLicenseState)};public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState) {_        this(allRealms, config.getSetting(AUTHZ_REALMS), config.globalSettings(), config.threadContext(),_            licenseState)__    };resolves,the,link,delegated,authorization,settings,setting,from,code,config,and,calls,link,delegated,authorization,support,iterable,list,settings,thread,context,xpack,license,state;public,delegated,authorization,support,iterable,extends,realm,all,realms,realm,config,config,xpack,license,state,license,state,this,all,realms,config,get,setting,config,global,settings,config,thread,context,license,state
DelegatedAuthorizationSupport -> public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState);1541642262;Resolves the {@link DelegatedAuthorizationSettings#AUTHZ_REALMS} setting from {@code config} and calls_{@link #DelegatedAuthorizationSupport(Iterable, List, Settings, ThreadContext, XPackLicenseState)};public DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, RealmConfig config, XPackLicenseState licenseState) {_        this(allRealms, config.getSetting(AUTHZ_REALMS), config.settings(), config.threadContext(),_            licenseState)__    };resolves,the,link,delegated,authorization,settings,setting,from,code,config,and,calls,link,delegated,authorization,support,iterable,list,settings,thread,context,xpack,license,state;public,delegated,authorization,support,iterable,extends,realm,all,realms,realm,config,config,xpack,license,state,license,state,this,all,realms,config,get,setting,config,settings,config,thread,context,license,state
DelegatedAuthorizationSupport -> private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings);1535723122;Checks for (and rejects) chains of delegation in the provided realms._A chain occurs when "realmA" delegates authorization to "realmB", and realmB also delegates authorization (to any realm)._Since "realmB" does not handle its own authorization, it is not a valid target for delegated authorization._@param delegatedRealms The list of realms that are going to be used for authorization. If is an error if any of these realms are_also configured to delegate their authorization._@throws IllegalArgumentException if a chain is detected;private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings) {_        final Map<String, Settings> settingsByRealm = RealmSettings.getRealmSettings(globalSettings)__        for (Realm realm : delegatedRealms) {_            final Settings realmSettings = settingsByRealm.get(realm.name())__            if (realmSettings != null && DelegatedAuthorizationSettings.AUTHZ_REALMS.exists(realmSettings)) {_                throw new IllegalArgumentException("cannot use realm [" + realm +_                    "] as an authorization realm - it is already delegating authorization to [" +_                    DelegatedAuthorizationSettings.AUTHZ_REALMS.get(realmSettings) + "]")__            }_        }_    };checks,for,and,rejects,chains,of,delegation,in,the,provided,realms,a,chain,occurs,when,realm,a,delegates,authorization,to,realm,b,and,realm,b,also,delegates,authorization,to,any,realm,since,realm,b,does,not,handle,its,own,authorization,it,is,not,a,valid,target,for,delegated,authorization,param,delegated,realms,the,list,of,realms,that,are,going,to,be,used,for,authorization,if,is,an,error,if,any,of,these,realms,are,also,configured,to,delegate,their,authorization,throws,illegal,argument,exception,if,a,chain,is,detected;private,void,check,for,realm,chains,iterable,realm,delegated,realms,settings,global,settings,final,map,string,settings,settings,by,realm,realm,settings,get,realm,settings,global,settings,for,realm,realm,delegated,realms,final,settings,realm,settings,settings,by,realm,get,realm,name,if,realm,settings,null,delegated,authorization,settings,exists,realm,settings,throw,new,illegal,argument,exception,cannot,use,realm,realm,as,an,authorization,realm,it,is,already,delegating,authorization,to,delegated,authorization,settings,get,realm,settings
DelegatedAuthorizationSupport -> private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings);1540847035;Checks for (and rejects) chains of delegation in the provided realms._A chain occurs when "realmA" delegates authorization to "realmB", and realmB also delegates authorization (to any realm)._Since "realmB" does not handle its own authorization, it is not a valid target for delegated authorization._@param delegatedRealms The list of realms that are going to be used for authorization. If is an error if any of these realms are_also configured to delegate their authorization._@throws IllegalArgumentException if a chain is detected;private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings) {_        final Map<String, Settings> settingsByRealm = RealmSettings.getRealmSettings(globalSettings)__        for (Realm realm : delegatedRealms) {_            final Settings realmSettings = settingsByRealm.get(realm.name())__            if (realmSettings != null && DelegatedAuthorizationSettings.AUTHZ_REALMS.exists(realmSettings)) {_                throw new IllegalArgumentException("cannot use realm [" + realm +_                    "] as an authorization realm - it is already delegating authorization to [" +_                    DelegatedAuthorizationSettings.AUTHZ_REALMS.get(realmSettings) + "]")__            }_        }_    };checks,for,and,rejects,chains,of,delegation,in,the,provided,realms,a,chain,occurs,when,realm,a,delegates,authorization,to,realm,b,and,realm,b,also,delegates,authorization,to,any,realm,since,realm,b,does,not,handle,its,own,authorization,it,is,not,a,valid,target,for,delegated,authorization,param,delegated,realms,the,list,of,realms,that,are,going,to,be,used,for,authorization,if,is,an,error,if,any,of,these,realms,are,also,configured,to,delegate,their,authorization,throws,illegal,argument,exception,if,a,chain,is,detected;private,void,check,for,realm,chains,iterable,realm,delegated,realms,settings,global,settings,final,map,string,settings,settings,by,realm,realm,settings,get,realm,settings,global,settings,for,realm,realm,delegated,realms,final,settings,realm,settings,settings,by,realm,get,realm,name,if,realm,settings,null,delegated,authorization,settings,exists,realm,settings,throw,new,illegal,argument,exception,cannot,use,realm,realm,as,an,authorization,realm,it,is,already,delegating,authorization,to,delegated,authorization,settings,get,realm,settings
DelegatedAuthorizationSupport -> private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings);1541476610;Checks for (and rejects) chains of delegation in the provided realms._A chain occurs when "realmA" delegates authorization to "realmB", and realmB also delegates authorization (to any realm)._Since "realmB" does not handle its own authorization, it is not a valid target for delegated authorization._@param delegatedRealms The list of realms that are going to be used for authorization. If is an error if any of these realms are_also configured to delegate their authorization._@throws IllegalArgumentException if a chain is detected;private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings) {_        for (Realm realm : delegatedRealms) {_            Setting<List<String>> realmAuthzSetting = AUTHZ_REALMS.apply(realm.type()).getConcreteSettingForNamespace(realm.name())__            if (realmAuthzSetting.exists(globalSettings)) {_                throw new IllegalArgumentException("cannot use realm [" + realm_                    + "] as an authorization realm - it is already delegating authorization to [" + realmAuthzSetting.get(globalSettings)_                    + "]")__            }_        }_    };checks,for,and,rejects,chains,of,delegation,in,the,provided,realms,a,chain,occurs,when,realm,a,delegates,authorization,to,realm,b,and,realm,b,also,delegates,authorization,to,any,realm,since,realm,b,does,not,handle,its,own,authorization,it,is,not,a,valid,target,for,delegated,authorization,param,delegated,realms,the,list,of,realms,that,are,going,to,be,used,for,authorization,if,is,an,error,if,any,of,these,realms,are,also,configured,to,delegate,their,authorization,throws,illegal,argument,exception,if,a,chain,is,detected;private,void,check,for,realm,chains,iterable,realm,delegated,realms,settings,global,settings,for,realm,realm,delegated,realms,setting,list,string,realm,authz,setting,apply,realm,type,get,concrete,setting,for,namespace,realm,name,if,realm,authz,setting,exists,global,settings,throw,new,illegal,argument,exception,cannot,use,realm,realm,as,an,authorization,realm,it,is,already,delegating,authorization,to,realm,authz,setting,get,global,settings
DelegatedAuthorizationSupport -> private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings);1541642262;Checks for (and rejects) chains of delegation in the provided realms._A chain occurs when "realmA" delegates authorization to "realmB", and realmB also delegates authorization (to any realm)._Since "realmB" does not handle its own authorization, it is not a valid target for delegated authorization._@param delegatedRealms The list of realms that are going to be used for authorization. If is an error if any of these realms are_also configured to delegate their authorization._@throws IllegalArgumentException if a chain is detected;private void checkForRealmChains(Iterable<Realm> delegatedRealms, Settings globalSettings) {_        for (Realm realm : delegatedRealms) {_            Setting<List<String>> realmAuthzSetting = AUTHZ_REALMS.apply(realm.type()).getConcreteSettingForNamespace(realm.name())__            if (realmAuthzSetting.exists(globalSettings)) {_                throw new IllegalArgumentException("cannot use realm [" + realm_                    + "] as an authorization realm - it is already delegating authorization to [" + realmAuthzSetting.get(globalSettings)_                    + "]")__            }_        }_    };checks,for,and,rejects,chains,of,delegation,in,the,provided,realms,a,chain,occurs,when,realm,a,delegates,authorization,to,realm,b,and,realm,b,also,delegates,authorization,to,any,realm,since,realm,b,does,not,handle,its,own,authorization,it,is,not,a,valid,target,for,delegated,authorization,param,delegated,realms,the,list,of,realms,that,are,going,to,be,used,for,authorization,if,is,an,error,if,any,of,these,realms,are,also,configured,to,delegate,their,authorization,throws,illegal,argument,exception,if,a,chain,is,detected;private,void,check,for,realm,chains,iterable,realm,delegated,realms,settings,global,settings,for,realm,realm,delegated,realms,setting,list,string,realm,authz,setting,apply,realm,type,get,concrete,setting,for,namespace,realm,name,if,realm,authz,setting,exists,global,settings,throw,new,illegal,argument,exception,cannot,use,realm,realm,as,an,authorization,realm,it,is,already,delegating,authorization,to,realm,authz,setting,get,global,settings
DelegatedAuthorizationSupport -> protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,                                             ThreadContext threadContext, XPackLicenseState licenseState);1535723122;Constructs a new object that delegates to the named realms ({@code lookupRealms}), which must exist within_{@code allRealms}._@throws IllegalArgumentException if one of the specified realms does not exist;protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,_                                            ThreadContext threadContext, XPackLicenseState licenseState) {_        final List<Realm> resolvedLookupRealms = resolveRealms(allRealms, lookupRealms)__        checkForRealmChains(resolvedLookupRealms, settings)__        this.lookup = new RealmUserLookup(resolvedLookupRealms, threadContext)__        this.logger = Loggers.getLogger(getClass())__        this.licenseState = licenseState__    };constructs,a,new,object,that,delegates,to,the,named,realms,code,lookup,realms,which,must,exist,within,code,all,realms,throws,illegal,argument,exception,if,one,of,the,specified,realms,does,not,exist;protected,delegated,authorization,support,iterable,extends,realm,all,realms,list,string,lookup,realms,settings,settings,thread,context,thread,context,xpack,license,state,license,state,final,list,realm,resolved,lookup,realms,resolve,realms,all,realms,lookup,realms,check,for,realm,chains,resolved,lookup,realms,settings,this,lookup,new,realm,user,lookup,resolved,lookup,realms,thread,context,this,logger,loggers,get,logger,get,class,this,license,state,license,state
DelegatedAuthorizationSupport -> protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,                                             ThreadContext threadContext, XPackLicenseState licenseState);1540847035;Constructs a new object that delegates to the named realms ({@code lookupRealms}), which must exist within_{@code allRealms}._@throws IllegalArgumentException if one of the specified realms does not exist;protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,_                                            ThreadContext threadContext, XPackLicenseState licenseState) {_        final List<Realm> resolvedLookupRealms = resolveRealms(allRealms, lookupRealms)__        checkForRealmChains(resolvedLookupRealms, settings)__        this.lookup = new RealmUserLookup(resolvedLookupRealms, threadContext)__        this.logger = LogManager.getLogger(getClass())__        this.licenseState = licenseState__    };constructs,a,new,object,that,delegates,to,the,named,realms,code,lookup,realms,which,must,exist,within,code,all,realms,throws,illegal,argument,exception,if,one,of,the,specified,realms,does,not,exist;protected,delegated,authorization,support,iterable,extends,realm,all,realms,list,string,lookup,realms,settings,settings,thread,context,thread,context,xpack,license,state,license,state,final,list,realm,resolved,lookup,realms,resolve,realms,all,realms,lookup,realms,check,for,realm,chains,resolved,lookup,realms,settings,this,lookup,new,realm,user,lookup,resolved,lookup,realms,thread,context,this,logger,log,manager,get,logger,get,class,this,license,state,license,state
DelegatedAuthorizationSupport -> protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,                                             ThreadContext threadContext, XPackLicenseState licenseState);1541476610;Constructs a new object that delegates to the named realms ({@code lookupRealms}), which must exist within_{@code allRealms}._@throws IllegalArgumentException if one of the specified realms does not exist;protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,_                                            ThreadContext threadContext, XPackLicenseState licenseState) {_        final List<Realm> resolvedLookupRealms = resolveRealms(allRealms, lookupRealms)__        checkForRealmChains(resolvedLookupRealms, settings)__        this.lookup = new RealmUserLookup(resolvedLookupRealms, threadContext)__        this.logger = LogManager.getLogger(getClass())__        this.licenseState = licenseState__    };constructs,a,new,object,that,delegates,to,the,named,realms,code,lookup,realms,which,must,exist,within,code,all,realms,throws,illegal,argument,exception,if,one,of,the,specified,realms,does,not,exist;protected,delegated,authorization,support,iterable,extends,realm,all,realms,list,string,lookup,realms,settings,settings,thread,context,thread,context,xpack,license,state,license,state,final,list,realm,resolved,lookup,realms,resolve,realms,all,realms,lookup,realms,check,for,realm,chains,resolved,lookup,realms,settings,this,lookup,new,realm,user,lookup,resolved,lookup,realms,thread,context,this,logger,log,manager,get,logger,get,class,this,license,state,license,state
DelegatedAuthorizationSupport -> protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,                                             ThreadContext threadContext, XPackLicenseState licenseState);1541642262;Constructs a new object that delegates to the named realms ({@code lookupRealms}), which must exist within_{@code allRealms}._@throws IllegalArgumentException if one of the specified realms does not exist;protected DelegatedAuthorizationSupport(Iterable<? extends Realm> allRealms, List<String> lookupRealms, Settings settings,_                                            ThreadContext threadContext, XPackLicenseState licenseState) {_        final List<Realm> resolvedLookupRealms = resolveRealms(allRealms, lookupRealms)__        checkForRealmChains(resolvedLookupRealms, settings)__        this.lookup = new RealmUserLookup(resolvedLookupRealms, threadContext)__        this.logger = LogManager.getLogger(getClass())__        this.licenseState = licenseState__    };constructs,a,new,object,that,delegates,to,the,named,realms,code,lookup,realms,which,must,exist,within,code,all,realms,throws,illegal,argument,exception,if,one,of,the,specified,realms,does,not,exist;protected,delegated,authorization,support,iterable,extends,realm,all,realms,list,string,lookup,realms,settings,settings,thread,context,thread,context,xpack,license,state,license,state,final,list,realm,resolved,lookup,realms,resolve,realms,all,realms,lookup,realms,check,for,realm,chains,resolved,lookup,realms,settings,this,lookup,new,realm,user,lookup,resolved,lookup,realms,thread,context,this,logger,log,manager,get,logger,get,class,this,license,state,license,state
DelegatedAuthorizationSupport -> public void resolve(String username, ActionListener<AuthenticationResult> resultListener);1535723122;Attempts to find the user specified by {@code username} in one of the delegated realms._The realms are searched in the order specified during construction._Returns a {@link AuthenticationResult#success(User) successful result} if a {@link User}_was found, otherwise returns an_{@link AuthenticationResult#unsuccessful(String, Exception) unsuccessful result}_with a meaningful diagnostic message.;public void resolve(String username, ActionListener<AuthenticationResult> resultListener) {_        if (licenseState.isAuthorizationRealmAllowed() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                DelegatedAuthorizationSettings.AUTHZ_REALMS.getKey() + " are not permitted",_                LicenseUtils.newComplianceException(DelegatedAuthorizationSettings.AUTHZ_REALMS.getKey())_            ))__            return__        }_        if (hasDelegation() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                "No [" + DelegatedAuthorizationSettings.AUTHZ_REALMS.getKey() + "] have been configured", null))__            return__        }_        ActionListener<Tuple<User, Realm>> userListener = ActionListener.wrap(tuple -> {_            if (tuple != null) {_                logger.trace("Found user " + tuple.v1() + " in realm " + tuple.v2())__                resultListener.onResponse(AuthenticationResult.success(tuple.v1()))__            } else {_                resultListener.onResponse(AuthenticationResult.unsuccessful("the principal [" + username_                    + "] was authenticated, but no user could be found in realms [" + collectionToDelimitedString(lookup.getRealms(), ",")_                    + "]", null))__            }_        }, resultListener::onFailure)__        lookup.lookup(username, userListener)__    };attempts,to,find,the,user,specified,by,code,username,in,one,of,the,delegated,realms,the,realms,are,searched,in,the,order,specified,during,construction,returns,a,link,authentication,result,success,user,successful,result,if,a,link,user,was,found,otherwise,returns,an,link,authentication,result,unsuccessful,string,exception,unsuccessful,result,with,a,meaningful,diagnostic,message;public,void,resolve,string,username,action,listener,authentication,result,result,listener,if,license,state,is,authorization,realm,allowed,false,result,listener,on,response,authentication,result,unsuccessful,delegated,authorization,settings,get,key,are,not,permitted,license,utils,new,compliance,exception,delegated,authorization,settings,get,key,return,if,has,delegation,false,result,listener,on,response,authentication,result,unsuccessful,no,delegated,authorization,settings,get,key,have,been,configured,null,return,action,listener,tuple,user,realm,user,listener,action,listener,wrap,tuple,if,tuple,null,logger,trace,found,user,tuple,v1,in,realm,tuple,v2,result,listener,on,response,authentication,result,success,tuple,v1,else,result,listener,on,response,authentication,result,unsuccessful,the,principal,username,was,authenticated,but,no,user,could,be,found,in,realms,collection,to,delimited,string,lookup,get,realms,null,result,listener,on,failure,lookup,lookup,username,user,listener
DelegatedAuthorizationSupport -> public void resolve(String username, ActionListener<AuthenticationResult> resultListener);1540847035;Attempts to find the user specified by {@code username} in one of the delegated realms._The realms are searched in the order specified during construction._Returns a {@link AuthenticationResult#success(User) successful result} if a {@link User}_was found, otherwise returns an_{@link AuthenticationResult#unsuccessful(String, Exception) unsuccessful result}_with a meaningful diagnostic message.;public void resolve(String username, ActionListener<AuthenticationResult> resultListener) {_        if (licenseState.isAuthorizationRealmAllowed() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                DelegatedAuthorizationSettings.AUTHZ_REALMS.getKey() + " are not permitted",_                LicenseUtils.newComplianceException(DelegatedAuthorizationSettings.AUTHZ_REALMS.getKey())_            ))__            return__        }_        if (hasDelegation() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                "No [" + DelegatedAuthorizationSettings.AUTHZ_REALMS.getKey() + "] have been configured", null))__            return__        }_        ActionListener<Tuple<User, Realm>> userListener = ActionListener.wrap(tuple -> {_            if (tuple != null) {_                logger.trace("Found user " + tuple.v1() + " in realm " + tuple.v2())__                resultListener.onResponse(AuthenticationResult.success(tuple.v1()))__            } else {_                resultListener.onResponse(AuthenticationResult.unsuccessful("the principal [" + username_                    + "] was authenticated, but no user could be found in realms [" + collectionToDelimitedString(lookup.getRealms(), ",")_                    + "]", null))__            }_        }, resultListener::onFailure)__        lookup.lookup(username, userListener)__    };attempts,to,find,the,user,specified,by,code,username,in,one,of,the,delegated,realms,the,realms,are,searched,in,the,order,specified,during,construction,returns,a,link,authentication,result,success,user,successful,result,if,a,link,user,was,found,otherwise,returns,an,link,authentication,result,unsuccessful,string,exception,unsuccessful,result,with,a,meaningful,diagnostic,message;public,void,resolve,string,username,action,listener,authentication,result,result,listener,if,license,state,is,authorization,realm,allowed,false,result,listener,on,response,authentication,result,unsuccessful,delegated,authorization,settings,get,key,are,not,permitted,license,utils,new,compliance,exception,delegated,authorization,settings,get,key,return,if,has,delegation,false,result,listener,on,response,authentication,result,unsuccessful,no,delegated,authorization,settings,get,key,have,been,configured,null,return,action,listener,tuple,user,realm,user,listener,action,listener,wrap,tuple,if,tuple,null,logger,trace,found,user,tuple,v1,in,realm,tuple,v2,result,listener,on,response,authentication,result,success,tuple,v1,else,result,listener,on,response,authentication,result,unsuccessful,the,principal,username,was,authenticated,but,no,user,could,be,found,in,realms,collection,to,delimited,string,lookup,get,realms,null,result,listener,on,failure,lookup,lookup,username,user,listener
DelegatedAuthorizationSupport -> public void resolve(String username, ActionListener<AuthenticationResult> resultListener);1541476610;Attempts to find the user specified by {@code username} in one of the delegated realms._The realms are searched in the order specified during construction._Returns a {@link AuthenticationResult#success(User) successful result} if a {@link User}_was found, otherwise returns an_{@link AuthenticationResult#unsuccessful(String, Exception) unsuccessful result}_with a meaningful diagnostic message.;public void resolve(String username, ActionListener<AuthenticationResult> resultListener) {_        if (licenseState.isAuthorizationRealmAllowed() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX + " are not permitted",_                LicenseUtils.newComplianceException(DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX)_            ))__            return__        }_        if (hasDelegation() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                "No [" + DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX + "] have been configured", null))__            return__        }_        ActionListener<Tuple<User, Realm>> userListener = ActionListener.wrap(tuple -> {_            if (tuple != null) {_                logger.trace("Found user " + tuple.v1() + " in realm " + tuple.v2())__                resultListener.onResponse(AuthenticationResult.success(tuple.v1()))__            } else {_                resultListener.onResponse(AuthenticationResult.unsuccessful("the principal [" + username_                    + "] was authenticated, but no user could be found in realms [" + collectionToDelimitedString(lookup.getRealms(), ",")_                    + "]", null))__            }_        }, resultListener::onFailure)__        lookup.lookup(username, userListener)__    };attempts,to,find,the,user,specified,by,code,username,in,one,of,the,delegated,realms,the,realms,are,searched,in,the,order,specified,during,construction,returns,a,link,authentication,result,success,user,successful,result,if,a,link,user,was,found,otherwise,returns,an,link,authentication,result,unsuccessful,string,exception,unsuccessful,result,with,a,meaningful,diagnostic,message;public,void,resolve,string,username,action,listener,authentication,result,result,listener,if,license,state,is,authorization,realm,allowed,false,result,listener,on,response,authentication,result,unsuccessful,delegated,authorization,settings,are,not,permitted,license,utils,new,compliance,exception,delegated,authorization,settings,return,if,has,delegation,false,result,listener,on,response,authentication,result,unsuccessful,no,delegated,authorization,settings,have,been,configured,null,return,action,listener,tuple,user,realm,user,listener,action,listener,wrap,tuple,if,tuple,null,logger,trace,found,user,tuple,v1,in,realm,tuple,v2,result,listener,on,response,authentication,result,success,tuple,v1,else,result,listener,on,response,authentication,result,unsuccessful,the,principal,username,was,authenticated,but,no,user,could,be,found,in,realms,collection,to,delimited,string,lookup,get,realms,null,result,listener,on,failure,lookup,lookup,username,user,listener
DelegatedAuthorizationSupport -> public void resolve(String username, ActionListener<AuthenticationResult> resultListener);1541642262;Attempts to find the user specified by {@code username} in one of the delegated realms._The realms are searched in the order specified during construction._Returns a {@link AuthenticationResult#success(User) successful result} if a {@link User}_was found, otherwise returns an_{@link AuthenticationResult#unsuccessful(String, Exception) unsuccessful result}_with a meaningful diagnostic message.;public void resolve(String username, ActionListener<AuthenticationResult> resultListener) {_        if (licenseState.isAuthorizationRealmAllowed() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX + " are not permitted",_                LicenseUtils.newComplianceException(DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX)_            ))__            return__        }_        if (hasDelegation() == false) {_            resultListener.onResponse(AuthenticationResult.unsuccessful(_                "No [" + DelegatedAuthorizationSettings.AUTHZ_REALMS_SUFFIX + "] have been configured", null))__            return__        }_        ActionListener<Tuple<User, Realm>> userListener = ActionListener.wrap(tuple -> {_            if (tuple != null) {_                logger.trace("Found user " + tuple.v1() + " in realm " + tuple.v2())__                resultListener.onResponse(AuthenticationResult.success(tuple.v1()))__            } else {_                resultListener.onResponse(AuthenticationResult.unsuccessful("the principal [" + username_                    + "] was authenticated, but no user could be found in realms [" + collectionToDelimitedString(lookup.getRealms(), ",")_                    + "]", null))__            }_        }, resultListener::onFailure)__        lookup.lookup(username, userListener)__    };attempts,to,find,the,user,specified,by,code,username,in,one,of,the,delegated,realms,the,realms,are,searched,in,the,order,specified,during,construction,returns,a,link,authentication,result,success,user,successful,result,if,a,link,user,was,found,otherwise,returns,an,link,authentication,result,unsuccessful,string,exception,unsuccessful,result,with,a,meaningful,diagnostic,message;public,void,resolve,string,username,action,listener,authentication,result,result,listener,if,license,state,is,authorization,realm,allowed,false,result,listener,on,response,authentication,result,unsuccessful,delegated,authorization,settings,are,not,permitted,license,utils,new,compliance,exception,delegated,authorization,settings,return,if,has,delegation,false,result,listener,on,response,authentication,result,unsuccessful,no,delegated,authorization,settings,have,been,configured,null,return,action,listener,tuple,user,realm,user,listener,action,listener,wrap,tuple,if,tuple,null,logger,trace,found,user,tuple,v1,in,realm,tuple,v2,result,listener,on,response,authentication,result,success,tuple,v1,else,result,listener,on,response,authentication,result,unsuccessful,the,principal,username,was,authenticated,but,no,user,could,be,found,in,realms,collection,to,delimited,string,lookup,get,realms,null,result,listener,on,failure,lookup,lookup,username,user,listener
