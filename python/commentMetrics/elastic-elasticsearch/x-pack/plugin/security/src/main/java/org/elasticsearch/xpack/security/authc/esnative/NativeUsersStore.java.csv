# id;timestamp;commentText;codeText;commentWords;codeWords
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1524684173;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1525859433;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1526449283;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1528304883;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1531179852;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1533295538;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1535552903;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1538067637;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1539723533;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1539796943;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1540238977;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1541008027;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1541092382;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1541169206;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1543291733;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1544035746;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public static String getIdForUser(final String docType, final String userName);1548420339;Gets the document id for the given user and user type (reserved user or regular user).;public static String getIdForUser(final String docType, final String userName) {_        return docType + "-" + userName__    };gets,the,document,id,for,the,given,user,and,user,type,reserved,user,or,regular,user;public,static,string,get,id,for,user,final,string,doc,type,final,string,user,name,return,doc,type,user,name
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1524684173;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityLifecycleService.isSecurityIndexExisting() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityLifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,lifecycle,service,is,security,index,existing,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1525859433;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityLifecycleService.securityIndex().indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityLifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,lifecycle,service,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1526449283;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1528304883;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1531179852;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1533295538;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1535552903;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(TimeValue.timeValueSeconds(10L))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,time,value,time,value,seconds,10l,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1538067637;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1539723533;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.isAvailable() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,is,available,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1539796943;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (t instanceof IndexNotFoundException) {_                logger.trace("could not retrieve users because security index does not exist")__                _                listener.onResponse(Collections.emptyList())__            } else {_                listener.onFailure(t)__            }_        }___        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(Collections.emptyList())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.asList(userNames).stream()_                            .map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,could,not,retrieve,users,because,security,index,does,not,exist,listener,on,response,collections,empty,list,else,listener,on,failure,t,if,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,as,list,user,names,stream,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1540238977;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1541008027;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1541092382;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1541169206;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1543291733;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1544035746;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener);1548420339;Retrieve a list of users, if userNames is null or empty, fetch all users;public void getUsers(String[] userNames, final ActionListener<Collection<User>> listener) {_        final Consumer<Exception> handleException = (t) -> {_            if (TransportActions.isShardNotAvailableException(t)) {_                logger.trace("could not retrieve users because of a shard not available exception", t)__                if (t instanceof IndexNotFoundException) {_                    _                    _                    listener.onResponse(Collections.emptyList())__                } else {_                    listener.onFailure(t)__                }_            }_            listener.onFailure(t)__        }___        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze()__        if (frozenSecurityIndex.indexExists() == false) {_            listener.onResponse(Collections.emptyList())__        } else if (frozenSecurityIndex.isAvailable() == false) {_            listener.onFailure(frozenSecurityIndex.getUnavailableReason())__        } else if (userNames.length == 1) { _            final String username = userNames[0]__            getUserAndPassword(username, ActionListener.wrap(_                    (uap) -> listener.onResponse(uap == null ? Collections.emptyList() : Collections.singletonList(uap.user())),_                    handleException))__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {_                final QueryBuilder query__                if (userNames == null || userNames.length == 0) {_                    query = QueryBuilders.termQuery(Fields.TYPE.getPreferredName(), USER_DOC_TYPE)__                } else {_                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new)__                    query = QueryBuilders.boolQuery().filter(QueryBuilders.idsQuery(INDEX_TYPE).addIds(users))__                }_                final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false)__                try (ThreadContext.StoredContext ignore = stashWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN)) {_                    SearchRequest request = client.prepareSearch(SECURITY_INDEX_NAME)_                            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))_                            .setQuery(query)_                            .setSize(1000)_                            .setFetchSource(true)_                            .request()__                    request.indicesOptions().ignoreUnavailable()__                    ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), (hit) -> {_                        UserAndPassword u = transformUser(hit.getId(), hit.getSourceAsMap())__                        return u != null ? u.user() : null__                    })__                }_            })__        }_    };retrieve,a,list,of,users,if,user,names,is,null,or,empty,fetch,all,users;public,void,get,users,string,user,names,final,action,listener,collection,user,listener,final,consumer,exception,handle,exception,t,if,transport,actions,is,shard,not,available,exception,t,logger,trace,could,not,retrieve,users,because,of,a,shard,not,available,exception,t,if,t,instanceof,index,not,found,exception,listener,on,response,collections,empty,list,else,listener,on,failure,t,listener,on,failure,t,final,security,index,manager,frozen,security,index,this,security,index,freeze,if,frozen,security,index,index,exists,false,listener,on,response,collections,empty,list,else,if,frozen,security,index,is,available,false,listener,on,failure,frozen,security,index,get,unavailable,reason,else,if,user,names,length,1,final,string,username,user,names,0,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,collections,empty,list,collections,singleton,list,uap,user,handle,exception,else,security,index,check,index,version,then,execute,listener,on,failure,final,query,builder,query,if,user,names,null,user,names,length,0,query,query,builders,term,query,fields,type,get,preferred,name,else,final,string,users,arrays,stream,user,names,map,s,get,id,for,user,s,to,array,string,new,query,query,builders,bool,query,filter,query,builders,ids,query,add,ids,users,final,supplier,thread,context,stored,context,supplier,client,thread,pool,get,thread,context,new,restorable,context,false,try,thread,context,stored,context,ignore,stash,with,origin,client,thread,pool,get,thread,context,search,request,request,client,prepare,search,set,scroll,get,settings,set,query,query,set,size,1000,set,fetch,source,true,request,request,indices,options,ignore,unavailable,scroll,helper,fetch,all,by,entity,client,request,new,context,preserving,action,listener,supplier,listener,hit,user,and,password,u,transform,user,hit,get,id,hit,get,source,as,map,return,u,null,u,user,null
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1524684173;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityLifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1525859433;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityLifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1526449283;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1528304883;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1531179852;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1533295538;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1535552903;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1538067637;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1539723533;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1539796943;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1540238977;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1541008027;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1541092382;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1541169206;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1543291733;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1544035746;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener);1548420339;Async method to change the password of a native or reserved user. If a reserved user does not exist, the document will be created_with a hash of the provided password.;public void changePassword(final ChangePasswordRequest request, final ActionListener<Void> listener) {_        final String username = request.username()__        assert SystemUser.NAME.equals(username) == false && XPackUser.NAME.equals(username) == false : username + "is internal!"__        final String docType__        if (ClientReservedRealm.isReserved(username, settings)) {_            docType = RESERVED_USER_TYPE__        } else {_            docType = USER_DOC_TYPE__        }__        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE, getIdForUser(docType, username))_                            .setDoc(Requests.INDEX_CONTENT_TYPE, Fields.PASSWORD.getPreferredName(),_                                    String.valueOf(request.passwordHash()))_                            .setRefreshPolicy(request.getRefreshPolicy()).request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(request.username(), listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                if (docType.equals(RESERVED_USER_TYPE)) {_                                    createReservedUser(username, request.passwordHash(), request.getRefreshPolicy(), listener)__                                } else {_                                    logger.debug((org.apache.logging.log4j.util.Supplier<?>) () ->_                                            new ParameterizedMessage("failed to change password for user [{}]", request.username()), e)__                                    ValidationException validationException = new ValidationException()__                                    validationException.addValidationError("user must exist in order to change password")__                                    listener.onFailure(validationException)__                                }_                            } else {_                                listener.onFailure(e)__                            }_                        }_                    }, client::update)__        })__    };async,method,to,change,the,password,of,a,native,or,reserved,user,if,a,reserved,user,does,not,exist,the,document,will,be,created,with,a,hash,of,the,provided,password;public,void,change,password,final,change,password,request,request,final,action,listener,void,listener,final,string,username,request,username,assert,system,user,name,equals,username,false,xpack,user,name,equals,username,false,username,is,internal,final,string,doc,type,if,client,reserved,realm,is,reserved,username,settings,doc,type,else,doc,type,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,doc,type,username,set,doc,requests,fields,password,get,preferred,name,string,value,of,request,password,hash,set,refresh,policy,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,request,username,listener,null,override,public,void,on,failure,exception,e,if,is,index,not,found,or,document,missing,e,if,doc,type,equals,create,reserved,user,username,request,password,hash,request,get,refresh,policy,listener,else,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,change,password,for,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,user,must,exist,in,order,to,change,password,listener,on,failure,validation,exception,else,listener,on,failure,e,client,update
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1524684173;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityLifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1525859433;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityLifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1526449283;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1528304883;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1531179852;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1533295538;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1535552903;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1538067637;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1539723533;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1539796943;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1540238977;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1541008027;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1541092382;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1541169206;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1543291733;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1544035746;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener);1548420339;Asynchronous method to create a reserved user with the given password hash. The cache for the user will be cleared after the document_has been indexed;private void createReservedUser(String username, char[] passwordHash, RefreshPolicy refresh, ActionListener<Void> listener) {_        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareIndex(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(RESERVED_USER_TYPE, username))_                            .setSource(Fields.PASSWORD.getPreferredName(), String.valueOf(passwordHash),_                                    Fields.ENABLED.getPreferredName(), true,_                                    Fields.TYPE.getPreferredName(), RESERVED_USER_TYPE)_                            .setRefreshPolicy(refresh).request(),_                    new ActionListener<IndexResponse>() {_                        @Override_                        public void onResponse(IndexResponse indexResponse) {_                            clearRealmCache(username, listener, null)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            listener.onFailure(e)__                        }_                    }, client::index)__        })__    };asynchronous,method,to,create,a,reserved,user,with,the,given,password,hash,the,cache,for,the,user,will,be,cleared,after,the,document,has,been,indexed;private,void,create,reserved,user,string,username,char,password,hash,refresh,policy,refresh,action,listener,void,listener,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,index,get,id,for,user,username,set,source,fields,password,get,preferred,name,string,value,of,password,hash,fields,enabled,get,preferred,name,true,fields,type,get,preferred,name,set,refresh,policy,refresh,request,new,action,listener,index,response,override,public,void,on,response,index,response,index,response,clear,realm,cache,username,listener,null,override,public,void,on,failure,exception,e,listener,on,failure,e,client,index
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1524684173;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityLifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1525859433;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityLifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1526449283;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1528304883;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1531179852;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1533295538;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1535552903;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1538067637;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1539723533;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1539796943;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1540238977;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1541008027;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1541092382;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1541169206;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1543291733;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED_                                || updateResponse.getResult() == DocWriteResponse.Result.NOOP_                                : "Expected 'UPDATED' or 'NOOP' result [" + updateResponse + "] for request [" + putUserRequest + "]"__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,update,response,get,result,doc,write,response,result,noop,expected,updated,or,noop,result,update,response,for,request,put,user,request,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1544035746;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED_                                || updateResponse.getResult() == DocWriteResponse.Result.NOOP_                                : "Expected 'UPDATED' or 'NOOP' result [" + updateResponse + "] for request [" + putUserRequest + "]"__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,update,response,get,result,doc,write,response,result,noop,expected,updated,or,noop,result,update,response,for,request,put,user,request,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener);1548420339;Handles updating a user that should already exist where their password should not change;private void updateUserWithoutPassword(final PutUserRequest putUserRequest, final ActionListener<Boolean> listener) {_        assert putUserRequest.passwordHash() == null__        _        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () -> {_            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                    client.prepareUpdate(SECURITY_INDEX_NAME, INDEX_TYPE,_                            getIdForUser(USER_DOC_TYPE, putUserRequest.username()))_                            .setDoc(Requests.INDEX_CONTENT_TYPE,_                                    Fields.USERNAME.getPreferredName(), putUserRequest.username(),_                                    Fields.ROLES.getPreferredName(), putUserRequest.roles(),_                                    Fields.FULL_NAME.getPreferredName(), putUserRequest.fullName(),_                                    Fields.EMAIL.getPreferredName(), putUserRequest.email(),_                                    Fields.METADATA.getPreferredName(), putUserRequest.metadata(),_                                    Fields.ENABLED.getPreferredName(), putUserRequest.enabled(),_                                    Fields.TYPE.getPreferredName(), USER_DOC_TYPE)_                            .setRefreshPolicy(putUserRequest.getRefreshPolicy())_                            .request(),_                    new ActionListener<UpdateResponse>() {_                        @Override_                        public void onResponse(UpdateResponse updateResponse) {_                            assert updateResponse.getResult() == DocWriteResponse.Result.UPDATED_                                || updateResponse.getResult() == DocWriteResponse.Result.NOOP_                                : "Expected 'UPDATED' or 'NOOP' result [" + updateResponse + "] for request [" + putUserRequest + "]"__                            clearRealmCache(putUserRequest.username(), listener, false)__                        }__                        @Override_                        public void onFailure(Exception e) {_                            Exception failure = e__                            if (isIndexNotFoundOrDocumentMissing(e)) {_                                _                                _                                logger.debug((org.apache.logging.log4j.util.Supplier<?>)_                                        () -> new ParameterizedMessage("failed to update user document with username [{}]",_                                                putUserRequest.username()), e)__                                ValidationException validationException = new ValidationException()__                                validationException_                                        .addValidationError("password must be specified unless you are updating an existing user")__                                failure = validationException__                            }_                            listener.onFailure(failure)__                        }_                    }, client::update)__        })__    };handles,updating,a,user,that,should,already,exist,where,their,password,should,not,change;private,void,update,user,without,password,final,put,user,request,put,user,request,final,action,listener,boolean,listener,assert,put,user,request,password,hash,null,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,update,get,id,for,user,put,user,request,username,set,doc,requests,fields,username,get,preferred,name,put,user,request,username,fields,roles,get,preferred,name,put,user,request,roles,fields,get,preferred,name,put,user,request,full,name,fields,email,get,preferred,name,put,user,request,email,fields,metadata,get,preferred,name,put,user,request,metadata,fields,enabled,get,preferred,name,put,user,request,enabled,fields,type,get,preferred,name,set,refresh,policy,put,user,request,get,refresh,policy,request,new,action,listener,update,response,override,public,void,on,response,update,response,update,response,assert,update,response,get,result,doc,write,response,result,updated,update,response,get,result,doc,write,response,result,noop,expected,updated,or,noop,result,update,response,for,request,put,user,request,clear,realm,cache,put,user,request,username,listener,false,override,public,void,on,failure,exception,e,exception,failure,e,if,is,index,not,found,or,document,missing,e,logger,debug,org,apache,logging,log4j,util,supplier,new,parameterized,message,failed,to,update,user,document,with,username,put,user,request,username,e,validation,exception,validation,exception,new,validation,exception,validation,exception,add,validation,error,password,must,be,specified,unless,you,are,updating,an,existing,user,failure,validation,exception,listener,on,failure,failure,client,update
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1524684173;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1525859433;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1526449283;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1528304883;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1531179852;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1533295538;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1535552903;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1538067637;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1539723533;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1539796943;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1540238977;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1541008027;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1541092382;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1541169206;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1543291733;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1544035746;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> public void getUser(String username, ActionListener<User> listener);1548420339;Blocking version of {@code getUser} that blocks until the User is returned;public void getUser(String username, ActionListener<User> listener) {_        getUserAndPassword(username, ActionListener.wrap((uap) -> {_            listener.onResponse(uap == null ? null : uap.user())__        }, listener::onFailure))__    };blocking,version,of,code,get,user,that,blocks,until,the,user,is,returned;public,void,get,user,string,username,action,listener,user,listener,get,user,and,password,username,action,listener,wrap,uap,listener,on,response,uap,null,null,uap,user,listener,on,failure
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1524684173;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityLifecycleService.isSecurityIndexExisting() == false) {_            _            listener.onResponse(null)__        } else {_            securityLifecycleService.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,lifecycle,service,is,security,index,existing,false,listener,on,response,null,else,security,lifecycle,service,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1525859433;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityLifecycleService.securityIndex().indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityLifecycleService.securityIndex().prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,lifecycle,service,security,index,index,exists,false,listener,on,response,null,else,security,lifecycle,service,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1526449283;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1528304883;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1531179852;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1533295538;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1535552903;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1538067637;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1539723533;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.isAvailable() == false) {_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,is,available,false,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1539796943;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        if (securityIndex.indexExists() == false) {_            _            listener.onResponse(null)__        } else {_            securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,if,security,index,index,exists,false,listener,on,response,null,else,security,index,prepare,index,if,needed,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1540238977;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1541008027;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1541092382;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1541169206;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1543291733;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1544035746;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener);1548420339;Async method to retrieve a user and their password;private void getUserAndPassword(final String user, final ActionListener<UserAndPassword> listener) {_        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze()__        if (frozenSecurityIndex.isAvailable() == false) {_            if (frozenSecurityIndex.indexExists()) {_                logger.trace("could not retrieve user [{}] because security index does not exist", user)__            } else {_                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user)__            }_            listener.onResponse(null)__        } else {_            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->_                    executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN,_                            client.prepareGet(SECURITY_INDEX_NAME,_                                    INDEX_TYPE, getIdForUser(USER_DOC_TYPE, user)).request(),_                            new ActionListener<GetResponse>() {_                                @Override_                                public void onResponse(GetResponse response) {_                                    listener.onResponse(transformUser(response.getId(), response.getSource()))__                                }__                                @Override_                                public void onFailure(Exception t) {_                                    if (t instanceof IndexNotFoundException) {_                                        logger.trace(_                                                (org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage(_                                                        "could not retrieve user [{}] because security index does not exist", user), t)__                                    } else {_                                        logger.error(new ParameterizedMessage("failed to retrieve user [{}]", user), t)__                                    }_                                    _                                    _                                    listener.onResponse(null)__                                }_                            }, client::get))__        }_    };async,method,to,retrieve,a,user,and,their,password;private,void,get,user,and,password,final,string,user,final,action,listener,user,and,password,listener,final,security,index,manager,frozen,security,index,security,index,freeze,if,frozen,security,index,is,available,false,if,frozen,security,index,index,exists,logger,trace,could,not,retrieve,user,because,security,index,does,not,exist,user,else,logger,error,security,index,is,unavailable,short,circuiting,retrieval,of,user,user,listener,on,response,null,else,security,index,check,index,version,then,execute,listener,on,failure,execute,async,with,origin,client,thread,pool,get,thread,context,client,prepare,get,get,id,for,user,user,request,new,action,listener,get,response,override,public,void,on,response,get,response,response,listener,on,response,transform,user,response,get,id,response,get,source,override,public,void,on,failure,exception,t,if,t,instanceof,index,not,found,exception,logger,trace,org,apache,logging,log4j,util,supplier,new,parameterized,message,could,not,retrieve,user,because,security,index,does,not,exist,user,t,else,logger,error,new,parameterized,message,failed,to,retrieve,user,user,t,listener,on,response,null,client,get
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1524684173;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (hasher.verify(password, userAndPassword.passwordHash())) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,hasher,verify,password,user,and,password,password,hash,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1525859433;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (hasher.verify(password, userAndPassword.passwordHash())) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,hasher,verify,password,user,and,password,password,hash,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1526449283;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (hasher.verify(password, userAndPassword.passwordHash())) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,hasher,verify,password,user,and,password,password,hash,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1528304883;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (hasher.verify(password, userAndPassword.passwordHash())) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,hasher,verify,password,user,and,password,password,hash,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1531179852;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1533295538;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1535552903;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1538067637;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1539723533;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1539796943;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1540238977;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1541008027;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1541092382;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1541169206;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1543291733;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1544035746;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener);1548420339;This method is used to verify the username and credentials against those stored in the system.__@param username username to lookup the user by_@param password the plaintext password to verify;void verifyPassword(String username, final SecureString password, ActionListener<AuthenticationResult> listener) {_        getUserAndPassword(username, ActionListener.wrap((userAndPassword) -> {_            if (userAndPassword == null || userAndPassword.passwordHash() == null) {_                listener.onResponse(AuthenticationResult.notHandled())__            } else if (userAndPassword.verifyPassword(password)) {_                listener.onResponse(AuthenticationResult.success(userAndPassword.user()))__            } else {_                listener.onResponse(AuthenticationResult.unsuccessful("Password authentication failed for " + username, null))__            }_        }, listener::onFailure))__    };this,method,is,used,to,verify,the,username,and,credentials,against,those,stored,in,the,system,param,username,username,to,lookup,the,user,by,param,password,the,plaintext,password,to,verify;void,verify,password,string,username,final,secure,string,password,action,listener,authentication,result,listener,get,user,and,password,username,action,listener,wrap,user,and,password,if,user,and,password,null,user,and,password,password,hash,null,listener,on,response,authentication,result,not,handled,else,if,user,and,password,verify,password,password,listener,on,response,authentication,result,success,user,and,password,user,else,listener,on,response,authentication,result,unsuccessful,password,authentication,failed,for,username,null,listener,on,failure
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1524684173;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1525859433;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1526449283;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1528304883;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1531179852;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1533295538;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1535552903;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1538067637;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1539723533;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1539796943;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1540238977;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1541008027;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1541092382;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1541169206;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1543291733;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1544035746;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener);1548420339;Asynchronous method to put a user. A put user request without a password hash is treated as an update and will fail with a_{@link ValidationException} if the user does not exist. If a password hash is provided, then we issue a update request with an_upsert document as well_ the upsert document sets the enabled flag of the user to true but if the document already exists, this_method will not modify the enabled value.;public void putUser(final PutUserRequest request, final ActionListener<Boolean> listener) {_        if (request.passwordHash() == null) {_            updateUserWithoutPassword(request, listener)__        } else {_            indexUser(request, listener)__        }_    };asynchronous,method,to,put,a,user,a,put,user,request,without,a,password,hash,is,treated,as,an,update,and,will,fail,with,a,link,validation,exception,if,the,user,does,not,exist,if,a,password,hash,is,provided,then,we,issue,a,update,request,with,an,upsert,document,as,well,the,upsert,document,sets,the,enabled,flag,of,the,user,to,true,but,if,the,document,already,exists,this,method,will,not,modify,the,enabled,value;public,void,put,user,final,put,user,request,request,final,action,listener,boolean,listener,if,request,password,hash,null,update,user,without,password,request,listener,else,index,user,request,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1524684173;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1525859433;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1526449283;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1528304883;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1531179852;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1533295538;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1535552903;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1538067637;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1539723533;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1539796943;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1540238977;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1541008027;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1541092382;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1541169206;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1543291733;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1544035746;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
NativeUsersStore -> public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,                            final ActionListener<Void> listener);1548420339;Asynchronous method that will update the enabled flag of a user. If the user is reserved and the document does not exist, a document_will be created. If the user is not reserved, the user must exist otherwise the operation will fail.;public void setEnabled(final String username, final boolean enabled, final RefreshPolicy refreshPolicy,_                           final ActionListener<Void> listener) {_        if (ClientReservedRealm.isReserved(username, settings)) {_            setReservedUserEnabled(username, enabled, refreshPolicy, true, listener)__        } else {_            setRegularUserEnabled(username, enabled, refreshPolicy, listener)__        }_    };asynchronous,method,that,will,update,the,enabled,flag,of,a,user,if,the,user,is,reserved,and,the,document,does,not,exist,a,document,will,be,created,if,the,user,is,not,reserved,the,user,must,exist,otherwise,the,operation,will,fail;public,void,set,enabled,final,string,username,final,boolean,enabled,final,refresh,policy,refresh,policy,final,action,listener,void,listener,if,client,reserved,realm,is,reserved,username,settings,set,reserved,user,enabled,username,enabled,refresh,policy,true,listener,else,set,regular,user,enabled,username,enabled,refresh,policy,listener
