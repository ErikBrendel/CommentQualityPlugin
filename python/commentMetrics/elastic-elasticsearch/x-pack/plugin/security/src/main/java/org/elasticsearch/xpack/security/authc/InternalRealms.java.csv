commented;modifiers;parameterAmount;loc;comment;code
true;static;1;6;/**  * Determines whether <code>type</code> is an internal realm-type that is provided by x-pack,  * including the {@link ReservedRealm}  */ ;/**  * Determines whether <code>type</code> is an internal realm-type that is provided by x-pack,  * including the {@link ReservedRealm}  */ static boolean isXPackRealm(String type) {     if (XPACK_TYPES.contains(type)) {         return true.     }     return ReservedRealm.TYPE.equals(type). }
false;static;0;3;;static Collection<String> getConfigurableRealmsTypes() {     return Collections.unmodifiableSet(XPACK_TYPES). }
true;static;1;3;/**  * Determines whether <code>type</code> is an internal realm-type that is provided by x-pack,  * excluding the {@link ReservedRealm} and realms that have extensive interaction with  * third party sources  */ ;/**  * Determines whether <code>type</code> is an internal realm-type that is provided by x-pack,  * excluding the {@link ReservedRealm} and realms that have extensive interaction with  * third party sources  */ static boolean isStandardRealm(String type) {     return STANDARD_TYPES.contains(type). }
true;public,static;6;21;/**  * Creates {@link Realm.Factory factories} for each <em>internal</em> realm type.  * This excludes the {@link ReservedRealm}, as it cannot be created dynamically.  * @return A map from <em>realm-type</em> to <code>Factory</code>  */ ;/**  * Creates {@link Realm.Factory factories} for each <em>internal</em> realm type.  * This excludes the {@link ReservedRealm}, as it cannot be created dynamically.  * @return A map from <em>realm-type</em> to <code>Factory</code>  */ public static Map<String, Realm.Factory> getFactories(ThreadPool threadPool, ResourceWatcherService resourceWatcherService, SSLService sslService, NativeUsersStore nativeUsersStore, NativeRoleMappingStore nativeRoleMappingStore, SecurityIndexManager securityIndex) {     Map<String, Realm.Factory> map = new HashMap<>().     map.put(FileRealmSettings.TYPE, config -> new FileRealm(config, resourceWatcherService, threadPool)).     map.put(NativeRealmSettings.TYPE, config -> {         final NativeRealm nativeRealm = new NativeRealm(config, nativeUsersStore, threadPool).         securityIndex.addIndexStateListener(nativeRealm::onSecurityIndexStateChange).         return nativeRealm.     }).     map.put(LdapRealmSettings.AD_TYPE, config -> new LdapRealm(config, sslService, resourceWatcherService, nativeRoleMappingStore, threadPool)).     map.put(LdapRealmSettings.LDAP_TYPE, config -> new LdapRealm(config, sslService, resourceWatcherService, nativeRoleMappingStore, threadPool)).     map.put(PkiRealmSettings.TYPE, config -> new PkiRealm(config, resourceWatcherService, nativeRoleMappingStore)).     map.put(SamlRealmSettings.TYPE, config -> SamlRealm.create(config, sslService, resourceWatcherService, nativeRoleMappingStore)).     map.put(KerberosRealmSettings.TYPE, config -> new KerberosRealm(config, nativeRoleMappingStore, threadPool)).     return Collections.unmodifiableMap(map). }
false;public,static;2;11;;public static List<BootstrapCheck> getBootstrapChecks(final Settings globalSettings, final Environment env) {     final Set<String> realmTypes = Sets.newHashSet(LdapRealmSettings.AD_TYPE, LdapRealmSettings.LDAP_TYPE, PkiRealmSettings.TYPE).     final List<BootstrapCheck> checks = RealmSettings.getRealmSettings(globalSettings).keySet().stream().filter(id -> realmTypes.contains(id.getType())).map(id -> new RealmConfig(id, globalSettings, env, null)).map(RoleMappingFileBootstrapCheck::create).filter(Objects::nonNull).collect(Collectors.toList()).     return checks. }
