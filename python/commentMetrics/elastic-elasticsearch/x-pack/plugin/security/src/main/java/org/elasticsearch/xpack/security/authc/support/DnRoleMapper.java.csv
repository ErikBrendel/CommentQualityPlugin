commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void refreshRealmOnChange(CachingRealm realm) {     addListener(realm::expireAll). }
false;synchronized;1;3;;synchronized void addListener(Runnable listener) {     listeners.add(Objects.requireNonNull(listener, "listener cannot be null")). }
false;public,static;1;4;;public static Path resolveFile(RealmConfig realmConfig) {     String location = realmConfig.getSetting(DnRoleMapperSettings.ROLE_MAPPING_FILE_SETTING).     return XPackPlugin.resolveConfigFile(realmConfig.env(), location). }
true;public,static;4;10;/**  * Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by  * logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files  * in security.  */ ;/**  * Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by  * logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files  * in security.  */ public static Map<String, List<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName) {     try {         return parseFile(path, logger, realmType, realmName, false).     } catch (Exception e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to parse role mappings file [{}]. skipping/removing all mappings...", path.toAbsolutePath()), e).         return emptyMap().     } }
false;public,static;5;60;;public static Map<String, List<String>> parseFile(Path path, Logger logger, String realmType, String realmName, boolean strict) {     logger.trace("reading realm [{}/{}] role mappings file [{}]...", realmType, realmName, path.toAbsolutePath()).     if (Files.exists(path) == false) {         final ParameterizedMessage message = new ParameterizedMessage("Role mapping file [{}] for realm [{}] does not exist.", path.toAbsolutePath(), realmName).         if (strict) {             throw new ElasticsearchException(message.getFormattedMessage()).         } else {             logger.warn(message.getFormattedMessage() + " Role mapping will be skipped.").             return emptyMap().         }     }     try {         Settings settings = Settings.builder().loadFromPath(path).build().         Map<DN, Set<String>> dnToRoles = new HashMap<>().         Set<String> roles = settings.names().         for (String role : roles) {             for (String providedDn : settings.getAsList(role)) {                 try {                     DN dn = new DN(providedDn).                     Set<String> dnRoles = dnToRoles.get(dn).                     if (dnRoles == null) {                         dnRoles = new HashSet<>().                         dnToRoles.put(dn, dnRoles).                     }                     dnRoles.add(role).                 } catch (LDAPException e) {                     ParameterizedMessage message = new ParameterizedMessage("invalid DN [{}] found in [{}] role mappings [{}] for realm [{}/{}].", providedDn, realmType, path.toAbsolutePath(), realmType, realmName).                     if (strict) {                         throw new ElasticsearchException(message.getFormattedMessage(), e).                     } else {                         logger.error(message.getFormattedMessage() + " skipping...", e).                     }                 }             }         }         logger.debug("[{}] role mappings found in file [{}] for realm [{}/{}]", dnToRoles.size(), path.toAbsolutePath(), realmType, realmName).         Map<String, List<String>> normalizedMap = dnToRoles.entrySet().stream().collect(Collectors.toMap(entry -> entry.getKey().toNormalizedString(), entry -> Collections.unmodifiableList(new ArrayList<>(entry.getValue())))).         return unmodifiableMap(normalizedMap).     } catch (IOException | SettingsException e) {         throw new ElasticsearchException("could not read realm [" + realmType + "/" + realmName + "] role mappings file [" + path.toAbsolutePath() + "]", e).     } }
false;;0;3;;int mappingsCount() {     return dnRoles.size(). }
false;public;2;8;;@Override public void resolveRoles(UserData user, ActionListener<Set<String>> listener) {     try {         listener.onResponse(resolveRoles(user.getDn(), user.getGroups())).     } catch (Exception e) {         listener.onFailure(e).     } }
true;public;2;28;/**  * This will map the groupDN's to ES Roles  */ ;/**  * This will map the groupDN's to ES Roles  */ public Set<String> resolveRoles(String userDnString, Collection<String> groupDns) {     Set<String> roles = new HashSet<>().     for (String groupDnString : groupDns) {         DN groupDn = dn(groupDnString).         String normalizedGroupDn = groupDn.toNormalizedString().         if (dnRoles.containsKey(normalizedGroupDn)) {             roles.addAll(dnRoles.get(normalizedGroupDn)).         } else if (useUnmappedGroupsAsRoles) {             roles.add(relativeName(groupDn)).         }     }     if (logger.isDebugEnabled()) {         logger.debug("the roles [{}], are mapped from these [{}] groups [{}] using file [{}] for realm [{}/{}]", roles, config.type(), groupDns, file.getFileName(), config.type(), config.name()).     }     String normalizedUserDn = dn(userDnString).toNormalizedString().     List<String> rolesMappedToUserDn = dnRoles.get(normalizedUserDn).     if (rolesMappedToUserDn != null) {         roles.addAll(rolesMappedToUserDn).     }     if (logger.isDebugEnabled()) {         logger.debug("the roles [{}], are mapped from the user [{}] using file [{}] for realm [{}/{}]", (rolesMappedToUserDn == null) ? Collections.emptySet() : rolesMappedToUserDn, normalizedUserDn, file.getFileName(), config.type(), config.name()).     }     return roles. }
false;public;0;3;;public void notifyRefresh() {     listeners.forEach(Runnable::run). }
false;public;1;4;;@Override public void onFileCreated(Path file) {     onFileChanged(file). }
false;public;1;4;;@Override public void onFileDeleted(Path file) {     onFileChanged(file). }
false;public;1;9;;@Override public void onFileChanged(Path file) {     if (file.equals(DnRoleMapper.this.file)) {         logger.info("role mappings file [{}] changed for realm [{}/{}]. updating mappings...", file.toAbsolutePath(), config.type(), config.name()).         dnRoles = parseFileLenient(file, logger, config.type(), config.name()).         notifyRefresh().     } }
