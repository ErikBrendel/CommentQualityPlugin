# id;timestamp;commentText;codeText;commentWords;codeWords
DnRoleMapper -> public static Map<String, List<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName);1539615817;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files_in security.;public static Map<String, List<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName) {_        try {_            return parseFile(path, logger, realmType, realmName, false)__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse role mappings file [{}]. skipping/removing all mappings...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,removing,all,mappings,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;public,static,map,string,list,string,parse,file,lenient,path,path,logger,logger,string,realm,type,string,realm,name,try,return,parse,file,path,logger,realm,type,realm,name,false,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,role,mappings,file,skipping,removing,all,mappings,path,to,absolute,path,e,return,empty,map
DnRoleMapper -> public static Map<String, List<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName);1541476610;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files_in security.;public static Map<String, List<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName) {_        try {_            return parseFile(path, logger, realmType, realmName, false)__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse role mappings file [{}]. skipping/removing all mappings...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,removing,all,mappings,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;public,static,map,string,list,string,parse,file,lenient,path,path,logger,logger,string,realm,type,string,realm,name,try,return,parse,file,path,logger,realm,type,realm,name,false,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,role,mappings,file,skipping,removing,all,mappings,path,to,absolute,path,e,return,empty,map
DnRoleMapper -> public static Map<DN, Set<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName);1524684173;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files_in security.;public static Map<DN, Set<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName) {_        try {_            return parseFile(path, logger, realmType, realmName, false)__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse role mappings file [{}]. skipping/removing all mappings...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,removing,all,mappings,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;public,static,map,dn,set,string,parse,file,lenient,path,path,logger,logger,string,realm,type,string,realm,name,try,return,parse,file,path,logger,realm,type,realm,name,false,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,role,mappings,file,skipping,removing,all,mappings,path,to,absolute,path,e,return,empty,map
DnRoleMapper -> public static Map<DN, Set<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName);1529658035;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files_in security.;public static Map<DN, Set<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName) {_        try {_            return parseFile(path, logger, realmType, realmName, false)__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse role mappings file [{}]. skipping/removing all mappings...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,removing,all,mappings,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;public,static,map,dn,set,string,parse,file,lenient,path,path,logger,logger,string,realm,type,string,realm,name,try,return,parse,file,path,logger,realm,type,realm,name,false,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,role,mappings,file,skipping,removing,all,mappings,path,to,absolute,path,e,return,empty,map
DnRoleMapper -> public static Map<DN, Set<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName);1538170812;Internally in this class, we try to load the file, but if for some reason we can't, we're being more lenient by_logging the error and skipping/removing all mappings. This is aligned with how we handle other auto-loaded files_in security.;public static Map<DN, Set<String>> parseFileLenient(Path path, Logger logger, String realmType, String realmName) {_        try {_            return parseFile(path, logger, realmType, realmName, false)__        } catch (Exception e) {_            logger.error(_                    (Supplier<?>) () -> new ParameterizedMessage(_                            "failed to parse role mappings file [{}]. skipping/removing all mappings...", path.toAbsolutePath()), e)__            return emptyMap()__        }_    };internally,in,this,class,we,try,to,load,the,file,but,if,for,some,reason,we,can,t,we,re,being,more,lenient,by,logging,the,error,and,skipping,removing,all,mappings,this,is,aligned,with,how,we,handle,other,auto,loaded,files,in,security;public,static,map,dn,set,string,parse,file,lenient,path,path,logger,logger,string,realm,type,string,realm,name,try,return,parse,file,path,logger,realm,type,realm,name,false,catch,exception,e,logger,error,supplier,new,parameterized,message,failed,to,parse,role,mappings,file,skipping,removing,all,mappings,path,to,absolute,path,e,return,empty,map
DnRoleMapper -> public Set<String> resolveRoles(String userDnString, Collection<String> groupDns);1524684173;This will map the groupDN's to ES Roles;public Set<String> resolveRoles(String userDnString, Collection<String> groupDns) {_        Set<String> roles = new HashSet<>()__        for (String groupDnString : groupDns) {_            DN groupDn = dn(groupDnString)__            if (dnRoles.containsKey(groupDn)) {_                roles.addAll(dnRoles.get(groupDn))__            } else if (useUnmappedGroupsAsRoles) {_                roles.add(relativeName(groupDn))__            }_        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from these [{}] groups [{}] using file [{}] for realm [{}/{}]", roles, config.type(),_                    groupDns, file.getFileName(), config.type(), config.name())__        }__        DN userDn = dn(userDnString)__        Set<String> rolesMappedToUserDn = dnRoles.get(userDn)__        if (rolesMappedToUserDn != null) {_            roles.addAll(rolesMappedToUserDn)__        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from the user [{}] using file [{}] for realm [{}/{}]",_                    (rolesMappedToUserDn == null) ? Collections.emptySet() : rolesMappedToUserDn, userDnString, file.getFileName(),_                    config.type(), config.name())__        }_        return roles__    };this,will,map,the,group,dn,s,to,es,roles;public,set,string,resolve,roles,string,user,dn,string,collection,string,group,dns,set,string,roles,new,hash,set,for,string,group,dn,string,group,dns,dn,group,dn,dn,group,dn,string,if,dn,roles,contains,key,group,dn,roles,add,all,dn,roles,get,group,dn,else,if,use,unmapped,groups,as,roles,roles,add,relative,name,group,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,these,groups,using,file,for,realm,roles,config,type,group,dns,file,get,file,name,config,type,config,name,dn,user,dn,dn,user,dn,string,set,string,roles,mapped,to,user,dn,dn,roles,get,user,dn,if,roles,mapped,to,user,dn,null,roles,add,all,roles,mapped,to,user,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,the,user,using,file,for,realm,roles,mapped,to,user,dn,null,collections,empty,set,roles,mapped,to,user,dn,user,dn,string,file,get,file,name,config,type,config,name,return,roles
DnRoleMapper -> public Set<String> resolveRoles(String userDnString, Collection<String> groupDns);1529658035;This will map the groupDN's to ES Roles;public Set<String> resolveRoles(String userDnString, Collection<String> groupDns) {_        Set<String> roles = new HashSet<>()__        for (String groupDnString : groupDns) {_            DN groupDn = dn(groupDnString)__            if (dnRoles.containsKey(groupDn)) {_                roles.addAll(dnRoles.get(groupDn))__            } else if (useUnmappedGroupsAsRoles) {_                roles.add(relativeName(groupDn))__            }_        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from these [{}] groups [{}] using file [{}] for realm [{}/{}]", roles, config.type(),_                    groupDns, file.getFileName(), config.type(), config.name())__        }__        DN userDn = dn(userDnString)__        Set<String> rolesMappedToUserDn = dnRoles.get(userDn)__        if (rolesMappedToUserDn != null) {_            roles.addAll(rolesMappedToUserDn)__        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from the user [{}] using file [{}] for realm [{}/{}]",_                    (rolesMappedToUserDn == null) ? Collections.emptySet() : rolesMappedToUserDn, userDnString, file.getFileName(),_                    config.type(), config.name())__        }_        return roles__    };this,will,map,the,group,dn,s,to,es,roles;public,set,string,resolve,roles,string,user,dn,string,collection,string,group,dns,set,string,roles,new,hash,set,for,string,group,dn,string,group,dns,dn,group,dn,dn,group,dn,string,if,dn,roles,contains,key,group,dn,roles,add,all,dn,roles,get,group,dn,else,if,use,unmapped,groups,as,roles,roles,add,relative,name,group,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,these,groups,using,file,for,realm,roles,config,type,group,dns,file,get,file,name,config,type,config,name,dn,user,dn,dn,user,dn,string,set,string,roles,mapped,to,user,dn,dn,roles,get,user,dn,if,roles,mapped,to,user,dn,null,roles,add,all,roles,mapped,to,user,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,the,user,using,file,for,realm,roles,mapped,to,user,dn,null,collections,empty,set,roles,mapped,to,user,dn,user,dn,string,file,get,file,name,config,type,config,name,return,roles
DnRoleMapper -> public Set<String> resolveRoles(String userDnString, Collection<String> groupDns);1538170812;This will map the groupDN's to ES Roles;public Set<String> resolveRoles(String userDnString, Collection<String> groupDns) {_        Set<String> roles = new HashSet<>()__        for (String groupDnString : groupDns) {_            DN groupDn = dn(groupDnString)__            if (dnRoles.containsKey(groupDn)) {_                roles.addAll(dnRoles.get(groupDn))__            } else if (useUnmappedGroupsAsRoles) {_                roles.add(relativeName(groupDn))__            }_        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from these [{}] groups [{}] using file [{}] for realm [{}/{}]", roles, config.type(),_                    groupDns, file.getFileName(), config.type(), config.name())__        }__        DN userDn = dn(userDnString)__        Set<String> rolesMappedToUserDn = dnRoles.get(userDn)__        if (rolesMappedToUserDn != null) {_            roles.addAll(rolesMappedToUserDn)__        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from the user [{}] using file [{}] for realm [{}/{}]",_                    (rolesMappedToUserDn == null) ? Collections.emptySet() : rolesMappedToUserDn, userDnString, file.getFileName(),_                    config.type(), config.name())__        }_        return roles__    };this,will,map,the,group,dn,s,to,es,roles;public,set,string,resolve,roles,string,user,dn,string,collection,string,group,dns,set,string,roles,new,hash,set,for,string,group,dn,string,group,dns,dn,group,dn,dn,group,dn,string,if,dn,roles,contains,key,group,dn,roles,add,all,dn,roles,get,group,dn,else,if,use,unmapped,groups,as,roles,roles,add,relative,name,group,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,these,groups,using,file,for,realm,roles,config,type,group,dns,file,get,file,name,config,type,config,name,dn,user,dn,dn,user,dn,string,set,string,roles,mapped,to,user,dn,dn,roles,get,user,dn,if,roles,mapped,to,user,dn,null,roles,add,all,roles,mapped,to,user,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,the,user,using,file,for,realm,roles,mapped,to,user,dn,null,collections,empty,set,roles,mapped,to,user,dn,user,dn,string,file,get,file,name,config,type,config,name,return,roles
DnRoleMapper -> public Set<String> resolveRoles(String userDnString, Collection<String> groupDns);1539615817;This will map the groupDN's to ES Roles;public Set<String> resolveRoles(String userDnString, Collection<String> groupDns) {_        Set<String> roles = new HashSet<>()__        for (String groupDnString : groupDns) {_            DN groupDn = dn(groupDnString)__            String normalizedGroupDn = groupDn.toNormalizedString()__            if (dnRoles.containsKey(normalizedGroupDn)) {_                roles.addAll(dnRoles.get(normalizedGroupDn))__            } else if (useUnmappedGroupsAsRoles) {_                roles.add(relativeName(groupDn))__            }_        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from these [{}] groups [{}] using file [{}] for realm [{}/{}]", roles, config.type(),_                    groupDns, file.getFileName(), config.type(), config.name())__        }__        String normalizedUserDn = dn(userDnString).toNormalizedString()__        List<String> rolesMappedToUserDn = dnRoles.get(normalizedUserDn)__        if (rolesMappedToUserDn != null) {_            roles.addAll(rolesMappedToUserDn)__        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from the user [{}] using file [{}] for realm [{}/{}]",_                    (rolesMappedToUserDn == null) ? Collections.emptySet() : rolesMappedToUserDn, normalizedUserDn, file.getFileName(),_                    config.type(), config.name())__        }_        return roles__    };this,will,map,the,group,dn,s,to,es,roles;public,set,string,resolve,roles,string,user,dn,string,collection,string,group,dns,set,string,roles,new,hash,set,for,string,group,dn,string,group,dns,dn,group,dn,dn,group,dn,string,string,normalized,group,dn,group,dn,to,normalized,string,if,dn,roles,contains,key,normalized,group,dn,roles,add,all,dn,roles,get,normalized,group,dn,else,if,use,unmapped,groups,as,roles,roles,add,relative,name,group,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,these,groups,using,file,for,realm,roles,config,type,group,dns,file,get,file,name,config,type,config,name,string,normalized,user,dn,dn,user,dn,string,to,normalized,string,list,string,roles,mapped,to,user,dn,dn,roles,get,normalized,user,dn,if,roles,mapped,to,user,dn,null,roles,add,all,roles,mapped,to,user,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,the,user,using,file,for,realm,roles,mapped,to,user,dn,null,collections,empty,set,roles,mapped,to,user,dn,normalized,user,dn,file,get,file,name,config,type,config,name,return,roles
DnRoleMapper -> public Set<String> resolveRoles(String userDnString, Collection<String> groupDns);1541476610;This will map the groupDN's to ES Roles;public Set<String> resolveRoles(String userDnString, Collection<String> groupDns) {_        Set<String> roles = new HashSet<>()__        for (String groupDnString : groupDns) {_            DN groupDn = dn(groupDnString)__            String normalizedGroupDn = groupDn.toNormalizedString()__            if (dnRoles.containsKey(normalizedGroupDn)) {_                roles.addAll(dnRoles.get(normalizedGroupDn))__            } else if (useUnmappedGroupsAsRoles) {_                roles.add(relativeName(groupDn))__            }_        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from these [{}] groups [{}] using file [{}] for realm [{}/{}]", roles, config.type(),_                    groupDns, file.getFileName(), config.type(), config.name())__        }__        String normalizedUserDn = dn(userDnString).toNormalizedString()__        List<String> rolesMappedToUserDn = dnRoles.get(normalizedUserDn)__        if (rolesMappedToUserDn != null) {_            roles.addAll(rolesMappedToUserDn)__        }_        if (logger.isDebugEnabled()) {_            logger.debug("the roles [{}], are mapped from the user [{}] using file [{}] for realm [{}/{}]",_                    (rolesMappedToUserDn == null) ? Collections.emptySet() : rolesMappedToUserDn, normalizedUserDn, file.getFileName(),_                    config.type(), config.name())__        }_        return roles__    };this,will,map,the,group,dn,s,to,es,roles;public,set,string,resolve,roles,string,user,dn,string,collection,string,group,dns,set,string,roles,new,hash,set,for,string,group,dn,string,group,dns,dn,group,dn,dn,group,dn,string,string,normalized,group,dn,group,dn,to,normalized,string,if,dn,roles,contains,key,normalized,group,dn,roles,add,all,dn,roles,get,normalized,group,dn,else,if,use,unmapped,groups,as,roles,roles,add,relative,name,group,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,these,groups,using,file,for,realm,roles,config,type,group,dns,file,get,file,name,config,type,config,name,string,normalized,user,dn,dn,user,dn,string,to,normalized,string,list,string,roles,mapped,to,user,dn,dn,roles,get,normalized,user,dn,if,roles,mapped,to,user,dn,null,roles,add,all,roles,mapped,to,user,dn,if,logger,is,debug,enabled,logger,debug,the,roles,are,mapped,from,the,user,using,file,for,realm,roles,mapped,to,user,dn,null,collections,empty,set,roles,mapped,to,user,dn,normalized,user,dn,file,get,file,name,config,type,config,name,return,roles
