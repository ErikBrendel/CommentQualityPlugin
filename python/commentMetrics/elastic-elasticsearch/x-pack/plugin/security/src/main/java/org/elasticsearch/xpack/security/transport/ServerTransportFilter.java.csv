commented;modifiers;parameterAmount;loc;comment;code
true;;4;2;/**  * Called just after the given request was received by the transport. Any exception  * thrown by this method will stop the request from being handled and the error will  * be sent back to the sender.  */ ;/**  * Called just after the given request was received by the transport. Any exception  * thrown by this method will stop the request from being handled and the error will  * be sent back to the sender.  */ void inbound(String action, TransportRequest request, TransportChannel transportChannel, ActionListener<Void> listener) throws IOException.
false;public;4;54;;@Override public void inbound(String action, TransportRequest request, TransportChannel transportChannel, ActionListener<Void> listener) throws IOException {     if (CloseIndexAction.NAME.equals(action) || OpenIndexAction.NAME.equals(action) || DeleteIndexAction.NAME.equals(action)) {         IndicesRequest indicesRequest = (IndicesRequest) request.         try {             destructiveOperations.failDestructive(indicesRequest.indices()).         } catch (IllegalArgumentException e) {             listener.onFailure(e).             return.         }     }     /*              here we don't have a fallback user, as all incoming request are              expected to have a user attached (either in headers or in context)              We can make this assumption because in nodes we make sure all outgoing              requests from all the nodes are attached with a user (either a serialize              user an authentication token              */     String securityAction = actionMapper.action(action, request).     TransportChannel unwrappedChannel = transportChannel.     if (unwrappedChannel instanceof TaskTransportChannel) {         unwrappedChannel = ((TaskTransportChannel) unwrappedChannel).getChannel().     }     if (extractClientCert && (unwrappedChannel instanceof TcpTransportChannel)) {         TcpChannel tcpChannel = ((TcpTransportChannel) unwrappedChannel).getChannel().         if (tcpChannel instanceof Netty4TcpChannel || tcpChannel instanceof NioTcpChannel) {             if (tcpChannel.isOpen()) {                 SSLEngineUtils.extractClientCertificates(logger, threadContext, tcpChannel).             }         }     }     final Version version = transportChannel.getVersion().     authcService.authenticate(securityAction, request, (User) null, ActionListener.wrap((authentication) -> {         if (authentication != null) {             if (securityAction.equals(TransportService.HANDSHAKE_ACTION_NAME) && SystemUser.is(authentication.getUser()) == false) {                 securityContext.executeAsUser(SystemUser.INSTANCE, (ctx) -> {                     final Authentication replaced = Authentication.getAuthentication(threadContext).                     authzService.authorize(replaced, securityAction, request, listener).                 }, version).             } else {                 authzService.authorize(authentication, securityAction, request, listener).             }         } else if (licenseState.isAuthAllowed() == false) {             listener.onResponse(null).         } else {             listener.onFailure(new IllegalStateException("no authentication present but auth is allowed")).         }     }, listener::onFailure)). }
false;public;4;10;;@Override public void inbound(String action, TransportRequest request, TransportChannel transportChannel, ActionListener<Void> listener) throws IOException {     // TODO is ']' sufficient to mark as shard action?     final boolean isInternalOrShardAction = action.startsWith("internal:") || action.endsWith("]").     if (isInternalOrShardAction && TransportService.HANDSHAKE_ACTION_NAME.equals(action) == false) {         throw authenticationError("executing internal/shard actions is considered malicious and forbidden").     }     super.inbound(action, request, transportChannel, listener). }
