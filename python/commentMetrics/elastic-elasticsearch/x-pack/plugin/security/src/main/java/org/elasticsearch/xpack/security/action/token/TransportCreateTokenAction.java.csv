commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;18;;@Override protected void doExecute(Task task, CreateTokenRequest request, ActionListener<CreateTokenResponse> listener) {     CreateTokenRequest.GrantType type = CreateTokenRequest.GrantType.fromString(request.getGrantType()).     assert type != null : "type should have been validated in the action".     switch(type) {         case PASSWORD:             authenticateAndCreateToken(request, listener).             break.         case CLIENT_CREDENTIALS:             Authentication authentication = Authentication.getAuthentication(threadPool.getThreadContext()).             createToken(request, authentication, authentication, false, listener).             break.         default:             listener.onFailure(new IllegalStateException("grant_type [" + request.getGrantType() + "] is not supported by the create token action")).             break.     } }
false;private;2;19;;private void authenticateAndCreateToken(CreateTokenRequest request, ActionListener<CreateTokenResponse> listener) {     Authentication originatingAuthentication = Authentication.getAuthentication(threadPool.getThreadContext()).     try (ThreadContext.StoredContext ignore = threadPool.getThreadContext().stashContext()) {         final UsernamePasswordToken authToken = new UsernamePasswordToken(request.getUsername(), request.getPassword()).         authenticationService.authenticate(CreateTokenAction.NAME, request, authToken, ActionListener.wrap(authentication -> {             request.getPassword().close().             if (authentication != null) {                 createToken(request, authentication, originatingAuthentication, true, listener).             } else {                 listener.onFailure(new UnsupportedOperationException("cannot create token if authentication is not allowed")).             }         }, e -> {             // clear the request password             request.getPassword().close().             listener.onFailure(e).         })).     } }
false;private;5;15;;private void createToken(CreateTokenRequest request, Authentication authentication, Authentication originatingAuth, boolean includeRefreshToken, ActionListener<CreateTokenResponse> listener) {     try {         tokenService.createUserToken(authentication, originatingAuth, ActionListener.wrap(tuple -> {             final String tokenStr = tokenService.getUserTokenString(tuple.v1()).             final String scope = getResponseScopeValue(request.getScope()).             final CreateTokenResponse response = new CreateTokenResponse(tokenStr, tokenService.getExpirationDelay(), scope, tuple.v2()).             listener.onResponse(response).         }, listener::onFailure), Collections.emptyMap(), includeRefreshToken).     } catch (IOException e) {         listener.onFailure(e).     } }
false;static;1;14;;static String getResponseScopeValue(String requestScope) {     final String scope.     // token is for must be returned     if (requestScope != null) {         // this is the only non-null value that is currently supported         scope = DEFAULT_SCOPE.     } else {         scope = null.     }     return scope. }
