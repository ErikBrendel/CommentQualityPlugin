# id;timestamp;commentText;codeText;commentWords;codeWords
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1524684173;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            ClusterPermission cluster = permission.cluster()__            if (cluster.check(action) || checkSameUserPermissions(action, request, authentication)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityLifecycleService.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,cluster,permission,cluster,permission,cluster,if,cluster,check,action,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,lifecycle,service,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1526449283;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            ClusterPermission cluster = permission.cluster()__            if (cluster.check(action) || checkSameUserPermissions(action, request, authentication)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,cluster,permission,cluster,permission,cluster,if,cluster,check,action,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1531179852;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            ClusterPermission cluster = permission.cluster()__            if (cluster.check(action) || checkSameUserPermissions(action, request, authentication)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,cluster,permission,cluster,permission,cluster,if,cluster,check,action,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1532456624;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1533295538;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1535552903;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1539615817;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1539951844;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1541092382;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1541169206;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                        + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication) ) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                        + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            }_            throw denial(authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                        + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                        "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_                && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(authentication, action, request,_                metaData, authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_                : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_                && MONITOR_INDEX_PREDICATE.test(action) == false_                && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                    authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                    : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,authentication,action,request,new,string,system,user,return,throw,denial,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,throw,denial,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,authentication,action,request,permission,names,return,else,throw,denial,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,else,audit,trail,access,granted,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1543292387;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request___        String auditId = AuditUtil.extractRequestId(threadContext)__        if (auditId == null) {_            _            _            if (isInternalUser(authentication.getUser()) != false) {_                auditId = AuditUtil.getOrGenerateRequestId(threadContext)__            } else {_                auditTrail.tamperedRequest(null, authentication.getUser(), action, request)__                final String message = "Attempt to authorize action [" + action + "] for [" + authentication.getUser().principal()_                    + "] without an existing request-id"__                assert false : message__                throw new ElasticsearchSecurityException(message)__            }_        }__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                    + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(auditId, authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(auditId, authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(auditId, authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(auditId, authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(auditId, authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                    + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                    + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                    + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(auditId, authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(auditId, authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                    "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(auditId, authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_            && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(authentication.getUser(), permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(auditId, authentication, action, request, metaData,_            authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_            : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (!indicesAccessControl.isGranted()) {_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (hasSecurityIndexAccess(indicesAccessControl)_            && MONITOR_INDEX_PREDICATE.test(action) == false_            && isSuperuser(authentication.getUser()) == false) {_            _            _            logger.debug("user [{}] attempted to directly perform [{}] against the security index [{}]",_                authentication.getUser().principal(), action, SecurityIndexManager.SECURITY_INDEX_NAME)__            throw denial(auditId, authentication, action, request, permission.names())__        } else {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(auditId, authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(auditId, authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,string,audit,id,audit,util,extract,request,id,thread,context,if,audit,id,null,if,is,internal,user,authentication,get,user,false,audit,id,audit,util,get,or,generate,request,id,thread,context,else,audit,trail,tampered,request,null,authentication,get,user,action,request,final,string,message,attempt,to,authorize,action,action,for,authentication,get,user,principal,without,an,existing,request,id,assert,false,message,throw,new,elasticsearch,security,exception,message,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,audit,id,authentication,action,request,new,string,system,user,return,throw,denial,audit,id,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,audit,id,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,audit,id,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,audit,id,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,audit,id,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,else,throw,denial,audit,id,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,audit,id,authentication,action,request,permission,names,else,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,audit,id,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,audit,id,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,authentication,get,user,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,audit,id,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,audit,id,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,audit,id,authentication,action,request,permission,names,else,if,has,security,index,access,indices,access,control,test,action,false,is,superuser,authentication,get,user,false,logger,debug,user,attempted,to,directly,perform,against,the,security,index,authentication,get,user,principal,action,security,index,manager,throw,denial,audit,id,authentication,action,request,permission,names,else,put,transient,if,non,existing,authorization,service,field,indices,access,control,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,audit,id,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,audit,id,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,audit,id,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1548019180;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request___        String auditId = AuditUtil.extractRequestId(threadContext)__        if (auditId == null) {_            _            _            if (isInternalUser(authentication.getUser()) != false) {_                auditId = AuditUtil.getOrGenerateRequestId(threadContext)__            } else {_                auditTrail.tamperedRequest(null, authentication.getUser(), action, request)__                final String message = "Attempt to authorize action [" + action + "] for [" + authentication.getUser().principal()_                    + "] without an existing request-id"__                assert false : message__                throw new ElasticsearchSecurityException(message)__            }_        }__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                    + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(auditId, authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(auditId, authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(auditId, authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(auditId, authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(auditId, authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            final ClusterPermission cluster = permission.cluster()__            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                    + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                    + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.indices().check(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                    + action + "] is a proxy action")__            }_            if (permission.indices().check(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(auditId, authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {_                    throw denial(auditId, authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                    "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(auditId, authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_            && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(auditId, authentication, action, request, metaData,_            authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_            : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (indicesAccessControl.isGranted()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        } else {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(auditId, authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(auditId, authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,string,audit,id,audit,util,extract,request,id,thread,context,if,audit,id,null,if,is,internal,user,authentication,get,user,false,audit,id,audit,util,get,or,generate,request,id,thread,context,else,audit,trail,tampered,request,null,authentication,get,user,action,request,final,string,message,attempt,to,authorize,action,action,for,authentication,get,user,principal,without,an,existing,request,id,assert,false,message,throw,new,elasticsearch,security,exception,message,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,audit,id,authentication,action,request,new,string,system,user,return,throw,denial,audit,id,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,audit,id,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,audit,id,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,audit,id,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,final,cluster,permission,cluster,permission,cluster,if,cluster,check,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,audit,id,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,indices,check,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,indices,check,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,else,throw,denial,audit,id,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,indices,check,action,false,throw,denial,audit,id,authentication,action,request,permission,names,else,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,audit,id,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,indices,check,action,false,throw,denial,audit,id,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,audit,id,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,indices,check,action,false,throw,denial,audit,id,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,put,transient,if,non,existing,authorization,service,field,indices,access,control,else,throw,denial,audit,id,authentication,action,request,permission,names,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,audit,id,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,audit,id,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,audit,id,authentication,action,request,permission,names
AuthorizationService -> public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,                           Role runAsRole) throws ElasticsearchSecurityException;1549336917;Verifies that the given user can execute the given request (and action). If the user doesn't_have the appropriate privileges for this action/request, an {@link ElasticsearchSecurityException}_will be thrown.__@param authentication The authentication information_@param action         The action_@param request        The request_@throws ElasticsearchSecurityException If the given user is no allowed to execute the given request;public void authorize(Authentication authentication, String action, TransportRequest request, Role userRole,_                          Role runAsRole) throws ElasticsearchSecurityException {_        final TransportRequest originalRequest = request___        String auditId = AuditUtil.extractRequestId(threadContext)__        if (auditId == null) {_            _            _            if (isInternalUser(authentication.getUser()) != false) {_                auditId = AuditUtil.getOrGenerateRequestId(threadContext)__            } else {_                auditTrail.tamperedRequest(null, authentication.getUser(), action, request)__                final String message = "Attempt to authorize action [" + action + "] for [" + authentication.getUser().principal()_                    + "] without an existing request-id"__                assert false : message__                throw new ElasticsearchSecurityException(message)__            }_        }__        if (request instanceof ConcreteShardRequest) {_            request = ((ConcreteShardRequest<?>) request).getRequest()__            assert TransportActionProxy.isProxyRequest(request) == false : "expected non-proxy request for action: " + action__        } else {_            request = TransportActionProxy.unwrapRequest(request)__            if (TransportActionProxy.isProxyRequest(originalRequest) && TransportActionProxy.isProxyAction(action) == false) {_                throw new IllegalStateException("originalRequest is a proxy request for: [" + request + "] but action: ["_                    + action + "] isn't")__            }_        }_        _        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action)___        _        if (SystemUser.is(authentication.getUser())) {_            if (SystemUser.isAuthorized(action)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                putTransientIfNonExisting(ROLE_NAMES_KEY, new String[] { SystemUser.ROLE_NAME })__                auditTrail.accessGranted(auditId, authentication, action, request, new String[] { SystemUser.ROLE_NAME })__                return__            }_            throw denial(auditId, authentication, action, request, new String[] { SystemUser.ROLE_NAME })__        }__        _        Role permission = userRole___        _        final boolean isRunAs = authentication.getUser().isRunAs()__        if (isRunAs) {_            _            _            if (authentication.getLookedUpBy() == null) {_                throw denyRunAs(auditId, authentication, action, request, permission.names())__            } else if (permission.runAs().check(authentication.getUser().principal())) {_                auditTrail.runAsGranted(auditId, authentication, action, request, permission.names())__                permission = runAsRole__            } else {_                throw denyRunAs(auditId, authentication, action, request, permission.names())__            }_        }_        putTransientIfNonExisting(ROLE_NAMES_KEY, permission.names())___        _        if (ClusterPrivilege.ACTION_MATCHER.test(action)) {_            if (permission.checkClusterAction(action, request) || checkSameUserPermissions(action, request, authentication)) {_                putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL)__                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (!IndexPrivilege.ACTION_MATCHER.test(action)) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (isCompositeAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Composite actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                    + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.checkIndicesAction(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (isTranslatedToBulkAction(action)) {_            if (request instanceof CompositeIndicesRequest == false) {_                throw new IllegalStateException("Bulk translated actions must implement " + CompositeIndicesRequest.class.getSimpleName()_                    + ", " + request.getClass().getSimpleName() + " doesn't")__            }_            _            if (permission.checkIndicesAction(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            }_            throw denial(auditId, authentication, action, request, permission.names())__        } else if (TransportActionProxy.isProxyAction(action)) {_            _            if (TransportActionProxy.isProxyRequest(originalRequest) == false) {_                throw new IllegalStateException("originalRequest is not a proxy request: [" + originalRequest + "] but action: ["_                    + action + "] is a proxy action")__            }_            if (permission.checkIndicesAction(action)) {_                auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                return__            } else {_                _                _                throw denial(auditId, authentication, action, request, permission.names())__            }_        }__        _        _        _        _        _        _        if (request instanceof IndicesRequest == false && request instanceof IndicesAliasesRequest == false) {_            _            _            _            if (isScrollRelatedAction(action)) {_                _                _                _                if (SearchScrollAction.NAME.equals(action) && permission.checkIndicesAction(action) == false) {_                    throw denial(auditId, authentication, action, request, permission.names())__                } else {_                    _                    _                    _                    auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__                    return__                }_            } else {_                assert false :_                    "only scroll related requests are known indices api that don't support retrieving the indices they relate to"__                throw denial(auditId, authentication, action, request, permission.names())__            }_        }__        final boolean allowsRemoteIndices = request instanceof IndicesRequest_            && IndicesAndAliasesResolver.allowsRemoteIndices((IndicesRequest) request)___        _        _        if (allowsRemoteIndices == false && permission.checkIndicesAction(action) == false) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        final MetaData metaData = clusterService.state().metaData()__        final AuthorizedIndices authorizedIndices = new AuthorizedIndices(permission, action, metaData)__        final ResolvedIndices resolvedIndices = resolveIndexNames(auditId, authentication, action, request, metaData,_            authorizedIndices, permission)__        assert !resolvedIndices.isEmpty()_            : "every indices request needs to have its indices set thus the resolved indices must not be empty"___        _        _        if (resolvedIndices.getRemote().isEmpty() && permission.checkIndicesAction(action) == false) {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        _        if (resolvedIndices.isNoIndicesPlaceholder()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_NO_INDICES)__            auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__            return__        }__        final Set<String> localIndices = new HashSet<>(resolvedIndices.getLocal())__        IndicesAccessControl indicesAccessControl = permission.authorize(action, localIndices, metaData, fieldPermissionsCache)__        if (indicesAccessControl.isGranted()) {_            putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl)__        } else {_            throw denial(auditId, authentication, action, request, permission.names())__        }__        _        if (IndexPrivilege.CREATE_INDEX_MATCHER.test(action)) {_            assert request instanceof CreateIndexRequest__            Set<Alias> aliases = ((CreateIndexRequest) request).aliases()__            if (!aliases.isEmpty()) {_                Set<String> aliasesAndIndices = Sets.newHashSet(localIndices)__                for (Alias alias : aliases) {_                    aliasesAndIndices.add(alias.name())__                }_                indicesAccessControl = permission.authorize("indices:admin/aliases", aliasesAndIndices, metaData, fieldPermissionsCache)__                if (!indicesAccessControl.isGranted()) {_                    throw denial(auditId, authentication, "indices:admin/aliases", request, permission.names())__                }_                _                _            }_        }__        if (action.equals(TransportShardBulkAction.ACTION_NAME)) {_            _            assert request instanceof BulkShardRequest_                : "Action " + action + " requires " + BulkShardRequest.class + " but was " + request.getClass()___            authorizeBulkItems(auditId, authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices)__        }__        auditTrail.accessGranted(auditId, authentication, action, request, permission.names())__    };verifies,that,the,given,user,can,execute,the,given,request,and,action,if,the,user,doesn,t,have,the,appropriate,privileges,for,this,action,request,an,link,elasticsearch,security,exception,will,be,thrown,param,authentication,the,authentication,information,param,action,the,action,param,request,the,request,throws,elasticsearch,security,exception,if,the,given,user,is,no,allowed,to,execute,the,given,request;public,void,authorize,authentication,authentication,string,action,transport,request,request,role,user,role,role,run,as,role,throws,elasticsearch,security,exception,final,transport,request,original,request,request,string,audit,id,audit,util,extract,request,id,thread,context,if,audit,id,null,if,is,internal,user,authentication,get,user,false,audit,id,audit,util,get,or,generate,request,id,thread,context,else,audit,trail,tampered,request,null,authentication,get,user,action,request,final,string,message,attempt,to,authorize,action,action,for,authentication,get,user,principal,without,an,existing,request,id,assert,false,message,throw,new,elasticsearch,security,exception,message,if,request,instanceof,concrete,shard,request,request,concrete,shard,request,request,get,request,assert,transport,action,proxy,is,proxy,request,request,false,expected,non,proxy,request,for,action,action,else,request,transport,action,proxy,unwrap,request,request,if,transport,action,proxy,is,proxy,request,original,request,transport,action,proxy,is,proxy,action,action,false,throw,new,illegal,state,exception,original,request,is,a,proxy,request,for,request,but,action,action,isn,t,put,transient,if,non,existing,action,if,system,user,is,authentication,get,user,if,system,user,is,authorized,action,put,transient,if,non,existing,authorization,service,field,indices,access,control,put,transient,if,non,existing,new,string,system,user,audit,trail,access,granted,audit,id,authentication,action,request,new,string,system,user,return,throw,denial,audit,id,authentication,action,request,new,string,system,user,role,permission,user,role,final,boolean,is,run,as,authentication,get,user,is,run,as,if,is,run,as,if,authentication,get,looked,up,by,null,throw,deny,run,as,audit,id,authentication,action,request,permission,names,else,if,permission,run,as,check,authentication,get,user,principal,audit,trail,run,as,granted,audit,id,authentication,action,request,permission,names,permission,run,as,role,else,throw,deny,run,as,audit,id,authentication,action,request,permission,names,put,transient,if,non,existing,permission,names,if,cluster,privilege,test,action,if,permission,check,cluster,action,action,request,check,same,user,permissions,action,request,authentication,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,if,index,privilege,test,action,throw,denial,audit,id,authentication,action,request,permission,names,if,is,composite,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,composite,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,check,indices,action,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,else,if,is,translated,to,bulk,action,action,if,request,instanceof,composite,indices,request,false,throw,new,illegal,state,exception,bulk,translated,actions,must,implement,composite,indices,request,class,get,simple,name,request,get,class,get,simple,name,doesn,t,if,permission,check,indices,action,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,throw,denial,audit,id,authentication,action,request,permission,names,else,if,transport,action,proxy,is,proxy,action,action,if,transport,action,proxy,is,proxy,request,original,request,false,throw,new,illegal,state,exception,original,request,is,not,a,proxy,request,original,request,but,action,action,is,a,proxy,action,if,permission,check,indices,action,action,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,else,throw,denial,audit,id,authentication,action,request,permission,names,if,request,instanceof,indices,request,false,request,instanceof,indices,aliases,request,false,if,is,scroll,related,action,action,if,search,scroll,action,name,equals,action,permission,check,indices,action,action,false,throw,denial,audit,id,authentication,action,request,permission,names,else,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,else,assert,false,only,scroll,related,requests,are,known,indices,api,that,don,t,support,retrieving,the,indices,they,relate,to,throw,denial,audit,id,authentication,action,request,permission,names,final,boolean,allows,remote,indices,request,instanceof,indices,request,indices,and,aliases,resolver,allows,remote,indices,indices,request,request,if,allows,remote,indices,false,permission,check,indices,action,action,false,throw,denial,audit,id,authentication,action,request,permission,names,final,meta,data,meta,data,cluster,service,state,meta,data,final,authorized,indices,authorized,indices,new,authorized,indices,permission,action,meta,data,final,resolved,indices,resolved,indices,resolve,index,names,audit,id,authentication,action,request,meta,data,authorized,indices,permission,assert,resolved,indices,is,empty,every,indices,request,needs,to,have,its,indices,set,thus,the,resolved,indices,must,not,be,empty,if,resolved,indices,get,remote,is,empty,permission,check,indices,action,action,false,throw,denial,audit,id,authentication,action,request,permission,names,if,resolved,indices,is,no,indices,placeholder,put,transient,if,non,existing,authorization,service,field,indices,access,control,audit,trail,access,granted,audit,id,authentication,action,request,permission,names,return,final,set,string,local,indices,new,hash,set,resolved,indices,get,local,indices,access,control,indices,access,control,permission,authorize,action,local,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,put,transient,if,non,existing,authorization,service,field,indices,access,control,else,throw,denial,audit,id,authentication,action,request,permission,names,if,index,privilege,test,action,assert,request,instanceof,create,index,request,set,alias,aliases,create,index,request,request,aliases,if,aliases,is,empty,set,string,aliases,and,indices,sets,new,hash,set,local,indices,for,alias,alias,aliases,aliases,and,indices,add,alias,name,indices,access,control,permission,authorize,indices,admin,aliases,aliases,and,indices,meta,data,field,permissions,cache,if,indices,access,control,is,granted,throw,denial,audit,id,authentication,indices,admin,aliases,request,permission,names,if,action,equals,transport,shard,bulk,action,assert,request,instanceof,bulk,shard,request,action,action,requires,bulk,shard,request,class,but,was,request,get,class,authorize,bulk,items,audit,id,authentication,bulk,shard,request,request,permission,meta,data,local,indices,authorized,indices,audit,trail,access,granted,audit,id,authentication,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1524684173;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1526449283;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1531179852;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1532456624;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1533295538;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1535552903;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1539615817;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1539951844;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1541092382;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1541169206;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                        authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                            + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                            + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                        metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(String auditRequestId, Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1543292387;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(String, Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(String auditRequestId, Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                    authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                        + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                        + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                    metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(auditRequestId, authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,string,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,string,audit,request,id,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,audit,request,id,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(String auditRequestId, Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1548019180;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(String, Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(String auditRequestId, Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                    authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                        + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                        + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                    metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(auditRequestId, authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,string,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,string,audit,request,id,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,audit,request,id,authentication,item,action,request,permission,names
AuthorizationService -> private void authorizeBulkItems(String auditRequestId, Authentication authentication, BulkShardRequest request, Role permission,                                     MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices);1549336917;Performs authorization checks on the items within a {@link BulkShardRequest}._This inspects the {@link BulkItemRequest items} within the request, computes_an <em>implied</em> action for each item's {@link DocWriteRequest#opType()},_and then checks whether that action is allowed on the targeted index. Items_that fail this checks are {@link BulkItemRequest#abort(String, Exception)_aborted}, with an_{@link #denial(String, Authentication, String, TransportRequest, String[]) access_denied} exception. Because a shard level request is for exactly 1 index, and_there are a small number of possible item {@link DocWriteRequest.OpType_types}, the number of distinct authorization checks that need to be performed_is very small, but the results must be cached, to avoid adding a high_overhead to each bulk request.;private void authorizeBulkItems(String auditRequestId, Authentication authentication, BulkShardRequest request, Role permission,_                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {_        _        final Map<String, String> resolvedIndexNames = new HashMap<>()__        _        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>()__        for (BulkItemRequest item : request.items()) {_            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {_                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,_                    authorizedIndices)__                if (resolvedIndices.getRemote().size() != 0) {_                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to "_                        + String.join(",", resolvedIndices.getRemote()))__                }_                if (resolvedIndices.getLocal().size() != 1) {_                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to "_                        + String.join(",", resolvedIndices.getLocal()))__                }_                final String resolved = resolvedIndices.getLocal().get(0)__                if (indices.contains(resolved) == false) {_                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices)__                }_                return resolved__            })__            final String itemAction = getAction(item)__            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction)__            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {_                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),_                    metaData, fieldPermissionsCache)__                return itemAccessControl.isGranted()__            })__            if (granted == false) {_                item.abort(resolvedIndex, denial(auditRequestId, authentication, itemAction, request, permission.names()))__            }_        }_    };performs,authorization,checks,on,the,items,within,a,link,bulk,shard,request,this,inspects,the,link,bulk,item,request,items,within,the,request,computes,an,em,implied,em,action,for,each,item,s,link,doc,write,request,op,type,and,then,checks,whether,that,action,is,allowed,on,the,targeted,index,items,that,fail,this,checks,are,link,bulk,item,request,abort,string,exception,aborted,with,an,link,denial,string,authentication,string,transport,request,string,access,denied,exception,because,a,shard,level,request,is,for,exactly,1,index,and,there,are,a,small,number,of,possible,item,link,doc,write,request,op,type,types,the,number,of,distinct,authorization,checks,that,need,to,be,performed,is,very,small,but,the,results,must,be,cached,to,avoid,adding,a,high,overhead,to,each,bulk,request;private,void,authorize,bulk,items,string,audit,request,id,authentication,authentication,bulk,shard,request,request,role,permission,meta,data,meta,data,set,string,indices,authorized,indices,authorized,indices,final,map,string,string,resolved,index,names,new,hash,map,final,map,tuple,string,string,boolean,index,action,authority,new,hash,map,for,bulk,item,request,item,request,items,string,resolved,index,resolved,index,names,compute,if,absent,item,index,key,final,resolved,indices,resolved,indices,indices,and,aliases,resolver,resolve,indices,and,aliases,item,request,meta,data,authorized,indices,if,resolved,indices,get,remote,size,0,throw,illegal,argument,bulk,item,should,not,write,to,remote,indices,but,request,writes,to,string,join,resolved,indices,get,remote,if,resolved,indices,get,local,size,1,throw,illegal,argument,bulk,item,should,write,to,exactly,1,index,but,request,writes,to,string,join,resolved,indices,get,local,final,string,resolved,resolved,indices,get,local,get,0,if,indices,contains,resolved,false,throw,illegal,argument,found,bulk,item,that,writes,to,index,resolved,but,the,request,writes,to,indices,return,resolved,final,string,item,action,get,action,item,final,tuple,string,string,index,and,action,new,tuple,resolved,index,item,action,final,boolean,granted,index,action,authority,compute,if,absent,index,and,action,key,final,indices,access,control,item,access,control,permission,authorize,item,action,collections,singleton,resolved,index,meta,data,field,permissions,cache,return,item,access,control,is,granted,if,granted,false,item,abort,resolved,index,denial,audit,request,id,authentication,item,action,request,permission,names
