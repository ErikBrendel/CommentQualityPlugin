commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void accept(Set<String> names, ActionListener<RoleRetrievalResult> listener) {     listener.onResponse(RoleRetrievalResult.success(roleDescriptors(names))). }
false;;1;11;;Set<RoleDescriptor> roleDescriptors(Set<String> roleNames) {     final Map<String, RoleDescriptor> localPermissions = permissions.     Set<RoleDescriptor> descriptors = new HashSet<>().     roleNames.forEach((name) -> {         RoleDescriptor descriptor = localPermissions.get(name).         if (descriptor != null) {             descriptors.add(descriptor).         }     }).     return descriptors. }
false;public;0;21;;public Map<String, Object> usageStats() {     final Map<String, RoleDescriptor> localPermissions = permissions.     Map<String, Object> usageStats = new HashMap<>(3).     usageStats.put("size", localPermissions.size()).     boolean dls = false.     boolean fls = false.     for (RoleDescriptor descriptor : localPermissions.values()) {         for (IndicesPrivileges indicesPrivileges : descriptor.getIndicesPrivileges()) {             fls = fls || indicesPrivileges.getGrantedFields() != null || indicesPrivileges.getDeniedFields() != null.             dls = dls || indicesPrivileges.getQuery() != null.         }         if (fls && dls) {             break.         }     }     usageStats.put("fls", fls).     usageStats.put("dls", dls).     return usageStats. }
false;public;1;6;;public void addListener(Consumer<Set<String>> consumer) {     Objects.requireNonNull(consumer).     synchronized (this) {         listeners.add(consumer).     } }
false;public;0;3;;public Path getFile() {     return file. }
true;;0;3;// package private for testing ;// package private for testing Set<String> getAllRoleNames() {     return permissions.keySet(). }
false;public;0;4;;@Override public String toString() {     return "file roles store (" + file + ")". }
false;public,static;1;3;;public static Path resolveFile(Environment env) {     return XPackPlugin.resolveConfigFile(env, "roles.yml"). }
false;public,static;2;3;;public static Set<String> parseFileForRoleNames(Path path, Logger logger) {     return parseRoleDescriptors(path, logger, false, Settings.EMPTY).keySet(). }
false;public,static;4;3;;public static Map<String, RoleDescriptor> parseFile(Path path, Logger logger, Settings settings, XPackLicenseState licenseState) {     return parseFile(path, logger, true, settings, licenseState). }
false;public,static;5;44;;public static Map<String, RoleDescriptor> parseFile(Path path, Logger logger, boolean resolvePermission, Settings settings, XPackLicenseState licenseState) {     if (logger == null) {         logger = NoOpLogger.INSTANCE.     }     Map<String, RoleDescriptor> roles = new HashMap<>().     logger.debug("attempting to read roles file located at [{}]", path.toAbsolutePath()).     if (Files.exists(path)) {         try {             List<String> roleSegments = roleSegments(path).             final boolean flsDlsLicensed = licenseState.isDocumentAndFieldLevelSecurityAllowed().             for (String segment : roleSegments) {                 RoleDescriptor descriptor = parseRoleDescriptor(segment, path, logger, resolvePermission, settings).                 if (descriptor != null) {                     if (ReservedRolesStore.isReserved(descriptor.getName())) {                         logger.warn("role [{}] is reserved. the relevant role definition in the mapping file will be ignored", descriptor.getName()).                     } else if (flsDlsLicensed == false && descriptor.isUsingDocumentOrFieldLevelSecurity()) {                         logger.warn("role [{}] uses document and/or field level security, which is not enabled by the current license" + ". this role will be ignored", descriptor.getName()).                         // we still put the role in the map to avoid unnecessary negative lookups                         roles.put(descriptor.getName(), descriptor).                     } else {                         roles.put(descriptor.getName(), descriptor).                     }                 }             }         } catch (IOException ioe) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to read roles file [{}]. skipping all roles...", path.toAbsolutePath()), ioe).             return emptyMap().         }     } else {         logger.debug("roles file does not exist").         return emptyMap().     }     logger.info("parsed [{}] roles from file [{}]", roles.size(), path.toAbsolutePath()).     return unmodifiableMap(roles). }
false;public,static;4;27;;public static Map<String, RoleDescriptor> parseRoleDescriptors(Path path, Logger logger, boolean resolvePermission, Settings settings) {     if (logger == null) {         logger = NoOpLogger.INSTANCE.     }     Map<String, RoleDescriptor> roles = new HashMap<>().     logger.trace("attempting to read roles file located at [{}]", path.toAbsolutePath()).     if (Files.exists(path)) {         try {             List<String> roleSegments = roleSegments(path).             for (String segment : roleSegments) {                 RoleDescriptor rd = parseRoleDescriptor(segment, path, logger, resolvePermission, settings).                 if (rd != null) {                     roles.put(rd.getName(), rd).                 }             }         } catch (IOException ioe) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("failed to read roles file [{}]. skipping all roles...", path.toAbsolutePath()), ioe).             return emptyMap().         }     }     return unmodifiableMap(roles). }
false;static;5;63;;@Nullable static RoleDescriptor parseRoleDescriptor(String segment, Path path, Logger logger, boolean resolvePermissions, Settings settings) {     String roleName = null.     try {         // EMPTY is safe here because we never use namedObject         XContentParser parser = YamlXContent.yamlXContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, segment).         XContentParser.Token token = parser.nextToken().         if (token == XContentParser.Token.START_OBJECT) {             token = parser.nextToken().             if (token == XContentParser.Token.FIELD_NAME) {                 roleName = parser.currentName().                 Validation.Error validationError = Validation.Roles.validateRoleName(roleName).                 if (validationError != null) {                     logger.error("invalid role definition [{}] in roles file [{}]. invalid role name - {}. skipping role... ", roleName, path.toAbsolutePath(), validationError).                     return null.                 }                 if (resolvePermissions == false) {                     return new RoleDescriptor(roleName, null, null, null).                 }                 token = parser.nextToken().                 if (token == XContentParser.Token.START_OBJECT) {                     // we pass true as last parameter because we do not want to reject files if field permissions                     // are given in 2.x syntax                     RoleDescriptor descriptor = RoleDescriptor.parse(roleName, parser, true).                     return checkDescriptor(descriptor, path, logger, settings).                 } else {                     logger.error("invalid role definition [{}] in roles file [{}]. skipping role...", roleName, path.toAbsolutePath()).                     return null.                 }             }         }         logger.error("invalid role definition [{}] in roles file [{}]. skipping role...", roleName, path.toAbsolutePath()).     } catch (ElasticsearchParseException e) {         assert roleName != null.         if (logger.isDebugEnabled()) {             final String finalRoleName = roleName.             logger.debug((Supplier<?>) () -> new ParameterizedMessage("parsing exception for role [{}]", finalRoleName), e).         } else {             logger.error(e.getMessage() + ". skipping role...").         }     } catch (IOException e) {         if (roleName != null) {             final String finalRoleName = roleName.             logger.error((Supplier<?>) () -> new ParameterizedMessage("invalid role definition [{}] in roles file [{}]. skipping role...", finalRoleName, path), e).         } else {             logger.error((Supplier<?>) () -> new ParameterizedMessage("invalid role definition in roles file [{}]. skipping role...", path), e).         }     }     return null. }
false;private,static;4;15;;@Nullable private static RoleDescriptor checkDescriptor(RoleDescriptor descriptor, Path path, Logger logger, Settings settings) {     String roleName = descriptor.getName().     // first check if FLS/DLS is enabled on the role...     for (RoleDescriptor.IndicesPrivileges privilege : descriptor.getIndicesPrivileges()) {         if ((privilege.getQuery() != null || privilege.getGrantedFields() != null || privilege.getDeniedFields() != null) && XPackSettings.DLS_FLS_ENABLED.get(settings) == false) {             logger.error("invalid role definition [{}] in roles file [{}]. document and field level security is not " + "enabled. set [{}] to [true] in the configuration file. skipping role...", roleName, path.toAbsolutePath(), XPackSettings.DLS_FLS_ENABLED.getKey()).             return null.         }     }     return descriptor. }
false;private,static;1;22;;private static List<String> roleSegments(Path path) throws IOException {     List<String> segments = new ArrayList<>().     StringBuilder builder = null.     for (String line : Files.readAllLines(path, StandardCharsets.UTF_8)) {         if (!SKIP_LINE.matcher(line).matches()) {             if (IN_SEGMENT_LINE.matcher(line).matches()) {                 if (builder != null) {                     builder.append(line).append("\n").                 }             } else {                 if (builder != null) {                     segments.add(builder.toString()).                 }                 builder = new StringBuilder(line).append("\n").             }         }     }     if (builder != null) {         segments.add(builder.toString()).     }     return segments. }
false;public;1;4;;@Override public void onFileCreated(Path file) {     onFileChanged(file). }
false;public;1;4;;@Override public void onFileDeleted(Path file) {     onFileChanged(file). }
false;public,synchronized;1;24;;@Override public synchronized void onFileChanged(Path file) {     if (file.equals(FileRolesStore.this.file)) {         final Map<String, RoleDescriptor> previousPermissions = permissions.         try {             permissions = parseFile(file, logger, settings, licenseState).             logger.info("updated roles (roles file [{}] {})", file.toAbsolutePath(), Files.exists(file) ? "changed" : "removed").         } catch (Exception e) {             logger.error((Supplier<?>) () -> new ParameterizedMessage("could not reload roles file [{}]. Current roles remain unmodified", file.toAbsolutePath()), e).             return.         }         final Set<String> changedOrMissingRoles = Sets.difference(previousPermissions.entrySet(), permissions.entrySet()).stream().map(Map.Entry::getKey).collect(Collectors.toSet()).         final Set<String> addedRoles = Sets.difference(permissions.keySet(), previousPermissions.keySet()).         final Set<String> changedRoles = Collections.unmodifiableSet(Sets.union(changedOrMissingRoles, addedRoles)).         listeners.forEach(c -> c.accept(changedRoles)).     } }
