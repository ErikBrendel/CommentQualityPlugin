# id;timestamp;commentText;codeText;commentWords;codeWords
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1524684173;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1527207653;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1528304883;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1533295538;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1535552903;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1535723122;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        assert delegatedRealms != null : "Realm has not been initialized correctly"__        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,assert,delegated,realms,null,realm,has,not,been,initialized,correctly,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1541476610;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        assert delegatedRealms != null : "Realm has not been initialized correctly"__        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,assert,delegated,realms,null,realm,has,not,been,initialized,correctly,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,execution,timeout,names,same,cancellable,ldap,runnable,maybe,timeout
LdapRealm -> @Override     protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1548953505;Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user._This user will then be passed to the listener;@Override_    protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        assert delegatedRealms != null : "Realm has not been initialized correctly"__        _        _        final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener,_                ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex),_                () -> sessionFactory.session(token.principal(), token.credentials(),_                        contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger_        )__        threadPool.generic().execute(cancellableLdapRunnable)__        threadPool.schedule(cancellableLdapRunnable::maybeTimeout, executionTimeout, Names.SAME)__    };given,a,username,and,password,open,a,connection,to,ldap,bind,to,authenticate,retrieve,groups,map,to,roles,and,build,the,user,this,user,will,then,be,passed,to,the,listener;override,protected,void,do,authenticate,username,password,token,token,action,listener,authentication,result,listener,assert,delegated,realms,null,realm,has,not,been,initialized,correctly,final,cancellable,ldap,runnable,authentication,result,cancellable,ldap,runnable,new,cancellable,ldap,runnable,listener,ex,authentication,result,unsuccessful,authentication,against,realm,this,to,string,failed,ex,session,factory,session,token,principal,token,credentials,context,preserving,listener,new,ldap,session,action,listener,authenticate,token,principal,listener,logger,thread,pool,generic,execute,cancellable,ldap,runnable,thread,pool,schedule,cancellable,ldap,runnable,maybe,timeout,execution,timeout,names,same
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1524684173;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1527207653;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1528304883;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1533295538;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1535552903;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1535723122;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1541476610;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> CancellableLdapRunnable -> void maybeTimeout();1548953505;If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user_listener;void maybeTimeout() {_            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {_                logger.warn("skipping execution of ldap runnable as it has been waiting for " +_                        "execution too long")__                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +_                        "execution of ldap runnable"))__            }_        };if,the,execution,of,this,runnable,has,not,already,started,the,runnable,is,cancelled,and,we,pass,an,exception,to,the,user,listener;void,maybe,timeout,if,state,compare,and,set,ldap,runnable,state,ldap,runnable,state,logger,warn,skipping,execution,of,ldap,runnable,as,it,has,been,waiting,for,execution,too,long,listener,on,failure,new,elasticsearch,timeout,exception,timed,out,waiting,for,execution,of,ldap,runnable
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1524684173;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1527207653;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1528304883;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1533295538;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1535552903;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1535723122;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1541476610;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
LdapRealm -> private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener);1548953505;Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the_current thread._Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should_any be produced within the realm/ldap-session.;private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {_        final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false)__        return new ContextPreservingActionListener<>(toRestore,_                sessionListener)__    };wraps,the,provided,code,session,listener,code,to,preserve,the,link,thread,context,associated,with,the,current,thread,responses,headers,are,not,preserved,as,they,are,not,needed,response,output,should,not,yet,exist,nor,should,any,be,produced,within,the,realm,ldap,session;private,context,preserving,action,listener,ldap,session,context,preserving,listener,ldap,session,action,listener,session,listener,final,supplier,thread,context,stored,context,to,restore,config,thread,context,new,restorable,context,false,return,new,context,preserving,action,listener,to,restore,session,listener
