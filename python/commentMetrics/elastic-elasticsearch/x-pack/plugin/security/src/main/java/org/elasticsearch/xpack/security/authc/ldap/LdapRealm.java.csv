commented;modifiers;parameterAmount;loc;comment;code
false;static;3;36;;static SessionFactory sessionFactory(RealmConfig config, SSLService sslService, ThreadPool threadPool) throws LDAPException {     final SessionFactory sessionFactory.     if (LdapRealmSettings.AD_TYPE.equals(config.type())) {         sessionFactory = new ActiveDirectorySessionFactory(config, sslService, threadPool).     } else {         assert LdapRealmSettings.LDAP_TYPE.equals(config.type()) : "type [" + config.type() + "] is unknown. expected one of [" + LdapRealmSettings.AD_TYPE + ", " + LdapRealmSettings.LDAP_TYPE + "]".         final boolean hasSearchSettings = LdapUserSearchSessionFactory.hasUserSearchSettings(config).         final boolean hasTemplates = config.hasSetting(LdapSessionFactorySettings.USER_DN_TEMPLATES_SETTING).         if (hasSearchSettings == false) {             if (hasTemplates == false) {                 throw new IllegalArgumentException("settings were not found for either user search [" + RealmSettings.getFullSettingKey(config, LdapUserSearchSessionFactorySettings.SEARCH_BASE_DN) + "] or user template [" + RealmSettings.getFullSettingKey(config, LdapSessionFactorySettings.USER_DN_TEMPLATES_SETTING) + "] modes of operation. " + "Please provide the settings for the mode you wish to use. For more details refer to the ldap " + "authentication section of the X-Pack guide.").             }             sessionFactory = new LdapSessionFactory(config, sslService, threadPool).         } else if (hasTemplates) {             throw new IllegalArgumentException("settings were found for both user search [" + RealmSettings.getFullSettingKey(config, LdapUserSearchSessionFactorySettings.SEARCH_BASE_DN) + "] and user template [" + RealmSettings.getFullSettingKey(config, LdapSessionFactorySettings.USER_DN_TEMPLATES_SETTING) + "] modes of operation. " + "Please remove the settings for the mode you do not wish to use. For more details refer to the ldap " + "authentication section of the X-Pack guide.").         } else {             sessionFactory = new LdapUserSearchSessionFactory(config, sslService, threadPool).         }     }     return sessionFactory. }
true;protected;2;13;/**  * Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user.  * This user will then be passed to the listener  */ ;/**  * Given a username and password, open a connection to ldap, bind to authenticate, retrieve groups, map to roles and build the user.  * This user will then be passed to the listener  */ @Override protected void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {     assert delegatedRealms != null : "Realm has not been initialized correctly".     // we submit to the threadpool because authentication using LDAP will execute blocking I/O for a bind request and we don't want     // network threads stuck waiting for a socket to connect. After the bind, then all interaction with LDAP should be async     final CancellableLdapRunnable<AuthenticationResult> cancellableLdapRunnable = new CancellableLdapRunnable<>(listener, ex -> AuthenticationResult.unsuccessful("Authentication against realm [" + this.toString() + "] failed", ex), () -> sessionFactory.session(token.principal(), token.credentials(), contextPreservingListener(new LdapSessionActionListener("authenticate", token.principal(), listener))), logger).     threadPool.generic().execute(cancellableLdapRunnable).     threadPool.schedule(cancellableLdapRunnable::maybeTimeout, executionTimeout, Names.SAME). }
false;protected;2;17;;@Override protected void doLookupUser(String username, ActionListener<User> userActionListener) {     if (sessionFactory.supportsUnauthenticatedSession()) {         // we submit to the threadpool because authentication using LDAP will execute blocking I/O for a bind request and we don't want         // network threads stuck waiting for a socket to connect. After the bind, then all interaction with LDAP should be async         final ActionListener<AuthenticationResult> sessionListener = ActionListener.wrap(result -> userActionListener.onResponse(result.getUser()), userActionListener::onFailure).         final CancellableLdapRunnable<User> cancellableLdapRunnable = new CancellableLdapRunnable<>(userActionListener, e -> null, () -> sessionFactory.unauthenticatedSession(username, contextPreservingListener(new LdapSessionActionListener("lookup", username, sessionListener))), logger).         threadPool.generic().execute(cancellableLdapRunnable).         threadPool.schedule(cancellableLdapRunnable::maybeTimeout, executionTimeout, Names.SAME).     } else {         userActionListener.onResponse(null).     } }
true;private;1;5;/**  * Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the  * current thread.  * Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should  * any be produced within the realm/ldap-session.  */ ;/**  * Wraps the provided <code>sessionListener</code> to preserve the {@link ThreadContext} associated with the  * current thread.  * Responses headers are not preserved, as they are not needed. Response output should not yet exist, nor should  * any be produced within the realm/ldap-session.  */ private ContextPreservingActionListener<LdapSession> contextPreservingListener(LdapSessionActionListener sessionListener) {     final Supplier<ThreadContext.StoredContext> toRestore = config.threadContext().newRestorableContext(false).     return new ContextPreservingActionListener<>(toRestore, sessionListener). }
false;public;2;7;;@Override public void initialize(Iterable<Realm> realms, XPackLicenseState licenseState) {     if (delegatedRealms != null) {         throw new IllegalStateException("Realm has already been initialized").     }     delegatedRealms = new DelegatedAuthorizationSupport(realms, config, licenseState). }
false;public;1;10;;@Override public void usageStats(ActionListener<Map<String, Object>> listener) {     super.usageStats(ActionListener.wrap(usage -> {         usage.put("size", getCacheSize()).         usage.put("load_balance_type", LdapLoadBalancing.resolve(config).toString()).         usage.put("ssl", sessionFactory.isSslUsed()).         usage.put("user_search", LdapUserSearchSessionFactory.hasUserSearchSettings(config)).         listener.onResponse(usage).     }, listener::onFailure)). }
false;private,static;5;11;;private static void buildUser(LdapSession session, String username, ActionListener<AuthenticationResult> listener, UserRoleMapper roleMapper, DelegatedAuthorizationSupport delegatedAuthz) {     assert delegatedAuthz != null : "DelegatedAuthorizationSupport is null".     if (session == null) {         listener.onResponse(AuthenticationResult.notHandled()).     } else if (delegatedAuthz.hasDelegation()) {         delegatedAuthz.resolve(username, listener).     } else {         lookupUserFromSession(username, session, roleMapper, listener).     } }
false;protected;2;8;;@Override protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {     if (delegatedRealms.hasDelegation()) {         delegatedRealms.resolve(user.principal(), listener).     } else {         super.handleCachedAuthentication(user, listener).     } }
false;private,static;4;33;;private static void lookupUserFromSession(String username, LdapSession session, UserRoleMapper roleMapper, ActionListener<AuthenticationResult> listener) {     boolean loadingGroups = false.     try {         final Consumer<Exception> onFailure = e -> {             IOUtils.closeWhileHandlingException(session).             listener.onFailure(e).         }.         session.resolve(ActionListener.wrap((ldapData) -> {             final Map<String, Object> metadata = MapBuilder.<String, Object>newMapBuilder().put("ldap_dn", session.userDn()).put("ldap_groups", ldapData.groups).putAll(ldapData.metaData).map().             final UserData user = new UserData(username, session.userDn(), ldapData.groups, metadata, session.realm()).             roleMapper.resolveRoles(user, ActionListener.wrap(roles -> {                 IOUtils.close(session).                 String[] rolesArray = roles.toArray(new String[roles.size()]).                 listener.onResponse(AuthenticationResult.success(new User(username, rolesArray, null, null, metadata, true))).             }, onFailure)).         }, onFailure)).         loadingGroups = true.     } finally {         if (loadingGroups == false) {             session.close().         }     } }
false;public;1;9;;@Override public void onResponse(LdapSession session) {     if (session == null) {         resultListener.onResponse(AuthenticationResult.notHandled()).     } else {         ldapSessionAtomicReference.set(session).         buildUser(session, username, resultListener, roleMapper, delegatedRealms).     } }
false;public;1;10;;@Override public void onFailure(Exception e) {     if (ldapSessionAtomicReference.get() != null) {         IOUtils.closeWhileHandlingException(ldapSessionAtomicReference.get()).     }     if (logger.isDebugEnabled()) {         logger.debug(new ParameterizedMessage("Exception occurred during {} for {}", action, LdapRealm.this), e).     }     resultListener.onResponse(AuthenticationResult.unsuccessful(action + " failed", e)). }
false;public;1;6;;@Override public void onFailure(Exception e) {     logger.error("execution of ldap runnable failed", e).     final T result = defaultValue.apply(e).     listener.onResponse(result). }
false;protected;0;8;;@Override protected void doRun() throws Exception {     if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.EXECUTING)) {         in.run().     } else {         logger.trace("skipping execution of ldap runnable as the current state is [{}]", state.get()).     } }
false;public;1;4;;@Override public void onRejection(Exception e) {     listener.onFailure(e). }
true;;0;8;/**  * If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user  * listener  */ ;/**  * If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user  * listener  */ void maybeTimeout() {     if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {         logger.warn("skipping execution of ldap runnable as it has been waiting for " + "execution too long").         listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " + "execution of ldap runnable")).     } }
