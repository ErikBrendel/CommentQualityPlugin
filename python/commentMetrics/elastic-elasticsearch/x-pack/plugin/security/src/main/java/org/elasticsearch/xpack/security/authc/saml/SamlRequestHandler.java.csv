commented;modifiers;parameterAmount;loc;comment;code
false;private;0;8;;private KeyInfoCredentialResolver createResolverForEncryptionKeys() {     final CollectionKeyInfoCredentialResolver collectionKeyInfoCredentialResolver = new CollectionKeyInfoCredentialResolver(Collections.unmodifiableCollection(sp.getEncryptionCredentials())).     final LocalKeyInfoCredentialResolver localKeyInfoCredentialResolver = new LocalKeyInfoCredentialResolver(Arrays.asList(new InlineX509DataProvider(), new KeyInfoReferenceProvider(), new RSAKeyValueProvider(), new DEREncodedKeyValueProvider()), collectionKeyInfoCredentialResolver).     return new ChainingKeyInfoCredentialResolver(Arrays.asList(localKeyInfoCredentialResolver, collectionKeyInfoCredentialResolver)). }
false;private;0;4;;private EncryptedKeyResolver createResolverForEncryptedKeyElements() {     return new ChainingEncryptedKeyResolver(Arrays.asList(new InlineEncryptedKeyResolver(), new SimpleRetrievalMethodEncryptedKeyResolver(), new SimpleKeyInfoReferenceEncryptedKeyResolver())). }
false;protected;0;3;;protected SpConfiguration getSpConfiguration() {     return sp. }
false;protected;1;4;;protected String describe(X509Certificate certificate) {     return "X509Certificate{Subject=" + certificate.getSubjectDN() + ". SerialNo=" + certificate.getSerialNumber().toString(16) + "}". }
false;protected;1;3;;protected String describe(Collection<X509Credential> credentials) {     return credentials.stream().map(credential -> describe(credential.getEntityCertificate())).collect(Collectors.joining(",")). }
false;;1;21;;void validateSignature(Signature signature) {     final String signatureText = text(signature, 32).     SAMLSignatureProfileValidator profileValidator = new SAMLSignatureProfileValidator().     try {         profileValidator.validate(signature).     } catch (SignatureException e) {         throw samlSignatureException(idp.getSigningCredentials(), signatureText, e).     }     checkIdpSignature(credential -> {         try (RestorableContextClassLoader ignore = new RestorableContextClassLoader(SignatureValidator.class)) {             SignatureValidator.validate(signature, credential).             logger.debug(() -> new ParameterizedMessage("SAML Signature [{}] matches credentials [{}] [{}]", signatureText, credential.getEntityId(), credential.getPublicKey())).             return true.         } catch (PrivilegedActionException e) {             logger.warn("SecurityException while attempting to validate SAML signature", e).             return false.         }     }, signatureText). }
true;protected;2;19;/**  * Tests whether the provided function returns {@code true} for any of the IdP's signing credentials.  * @throws ElasticsearchSecurityException - A SAML exception if not matching credential is found.  */ ;/**  * Tests whether the provided function returns {@code true} for any of the IdP's signing credentials.  * @throws ElasticsearchSecurityException - A SAML exception if not matching credential is found.  */ protected void checkIdpSignature(CheckedFunction<Credential, Boolean, Exception> check, String signatureText) {     final Predicate<Credential> predicate = credential -> {         try {             return check.apply(credential).         } catch (SignatureException | SecurityException e) {             logger.debug(() -> new ParameterizedMessage("SAML Signature [{}] does not match credentials [{}] [{}] -- {}", signatureText, credential.getEntityId(), credential.getPublicKey(), e)).             logger.trace("SAML Signature failure caused by", e).             return false.         } catch (Exception e) {             logger.warn("Exception while attempting to validate SAML Signature", e).             return false.         }     }.     final List<Credential> credentials = idp.getSigningCredentials().     if (credentials.stream().anyMatch(predicate) == false) {         throw samlSignatureException(credentials, signatureText).     } }
true;private;3;6;/**  * Constructs a SAML specific exception with a consistent message regarding SAML Signature validation failures  */ ;/**  * Constructs a SAML specific exception with a consistent message regarding SAML Signature validation failures  */ private ElasticsearchSecurityException samlSignatureException(List<Credential> credentials, String signature, Exception cause) {     logger.warn("The XML Signature of this SAML message cannot be validated. Please verify that the saml realm uses the correct SAML" + "metadata file/URL for this Identity Provider").     final String msg = "SAML Signature [{}] could not be validated against [{}]".     return samlException(msg, cause, signature, describeCredentials(credentials)). }
false;private;2;6;;private ElasticsearchSecurityException samlSignatureException(List<Credential> credentials, String signature) {     logger.warn("The XML Signature of this SAML message cannot be validated. Please verify that the saml realm uses the correct SAML" + "metadata file/URL for this Identity Provider").     final String msg = "SAML Signature [{}] could not be validated against [{}]".     return samlException(msg, signature, describeCredentials(credentials)). }
false;private;1;21;;private String describeCredentials(List<Credential> credentials) {     return credentials.stream().map(c -> {         if (c == null) {             return "<null>".         }         byte[] encoded.         if (c instanceof X509Credential) {             X509Credential x = (X509Credential) c.             try {                 encoded = x.getEntityCertificate().getEncoded().             } catch (CertificateEncodingException e) {                 encoded = c.getPublicKey().getEncoded().             }         } else {             encoded = c.getPublicKey().getEncoded().         }         return Base64.getEncoder().encodeToString(encoded).substring(0, 64) + "...".     }).collect(Collectors.joining(",")). }
false;protected;2;9;;protected void checkIssuer(Issuer issuer, XMLObject parent) {     if (issuer == null) {         throw samlException("Element {} ({}) has no issuer, but expected {}", parent.getElementQName(), text(parent, 16), idp.getEntityId()).     }     if (idp.getEntityId().equals(issuer.getValue()) == false) {         throw samlException("SAML Issuer {} does not match expected value {}", issuer.getValue(), idp.getEntityId()).     } }
false;protected;0;3;;protected long maxSkewInMillis() {     return this.maxSkew.millis(). }
false;protected;0;3;;protected java.time.Instant now() {     return clock.instant(). }
true;protected;1;6;/**  * Converts a Joda DateTime into a Java Instant  */ ;/**  * Converts a Joda DateTime into a Java Instant  */ protected Instant toInstant(DateTime dateTime) {     if (dateTime == null) {         return null.     }     return Instant.ofEpochMilli(dateTime.getMillis()). }
true;;2;17;// Package private for testing ;// Package private for testing <T extends XMLObject> T buildXmlObject(Element element, Class<T> type) {     try {         Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element).         if (unmarshaller == null) {             throw samlException("XML element [{}] cannot be unmarshalled to SAML type [{}] (no unmarshaller)", element.getTagName(), type).         }         final XMLObject object = unmarshaller.unmarshall(element).         if (type.isInstance(object)) {             return type.cast(object).         }         Object[] args = new Object[] { element.getTagName(), type.getName(), object == null ? "<null>" : object.getClass().getName() }.         throw samlException("SAML object [{}] is incorrect type. Expected [{}] but was [{}]", args).     } catch (UnmarshallingException e) {         throw samlException("Failed to unmarshall SAML content [{}", e, element.getTagName()).     } }
false;protected;2;12;;protected String text(XMLObject xml, int length) {     final Element dom = xml.getDOM().     if (dom == null) {         return null.     }     final String text = dom.getTextContent().trim().     if (text.length() >= length) {         return Strings.cleanTruncate(text, length) + "...".     } else {         return text.     } }
false;protected;1;14;;protected Element parseSamlMessage(byte[] content) {     final Element root.     try (ByteArrayInputStream input = new ByteArrayInputStream(content)) {         // This will parse and validate the input         final Document doc = THREAD_LOCAL_DOCUMENT_BUILDER.get().parse(input).         root = doc.getDocumentElement().         if (logger.isTraceEnabled()) {             logger.trace("Received SAML Message: {} \n", SamlUtils.toString(root, true)).         }     } catch (SAXException | IOException e) {         throw samlException("Failed to parse SAML message", e).     }     return root. }
false;protected;1;10;;protected void validateNotOnOrAfter(DateTime notOnOrAfter) {     if (notOnOrAfter == null) {         return.     }     final Instant now = now().     final Instant pastNow = now.minusMillis(this.maxSkew.millis()).     if (pastNow.isBefore(toInstant(notOnOrAfter)) == false) {         throw samlException("Rejecting SAML assertion because [{}] is on/after [{}]", pastNow, notOnOrAfter).     } }
