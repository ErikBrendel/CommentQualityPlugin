commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected List<String> getDefaultLdapUrls(RealmConfig config) {     return Collections.singletonList("ldap://" + config.getSetting(ActiveDirectorySessionFactorySettings.AD_DOMAIN_NAME_SETTING) + ":" + config.getSetting(ActiveDirectorySessionFactorySettings.AD_LDAP_PORT_SETTING)). }
false;public;0;6;;@Override public boolean supportsUnauthenticatedSession() {     // getUnauthenticatedSession... methods handle the situations correctly, so it's OK to always return true here.     return true. }
false;;4;4;;@Override void getSessionWithPool(LDAPConnectionPool connectionPool, String user, SecureString password, ActionListener<LdapSession> listener) {     getADAuthenticator(user).authenticate(connectionPool, user, password, threadPool, listener). }
false;;3;12;;@Override void getSessionWithoutPool(String username, SecureString password, ActionListener<LdapSession> listener) {     try {         final LDAPConnection connection = LdapUtils.privilegedConnect(serverSet::getConnection).         getADAuthenticator(username).authenticate(connection, username, password, ActionListener.wrap(listener::onResponse, e -> {             IOUtils.closeWhileHandlingException(connection).             listener.onFailure(e).         })).     } catch (LDAPException e) {         listener.onFailure(e).     } }
false;;3;11;;@Override void getUnauthenticatedSessionWithPool(LDAPConnectionPool connectionPool, String user, ActionListener<LdapSession> listener) {     getADAuthenticator(user).searchForDN(connectionPool, user, null, Math.toIntExact(timeout.seconds()), ActionListener.wrap(entry -> {         if (entry == null) {             listener.onResponse(null).         } else {             final String dn = entry.getDN().             listener.onResponse(new LdapSession(logger, config, connectionPool, dn, groupResolver, metaDataResolver, timeout, null)).         }     }, listener::onFailure)). }
false;public;1;5;;@Override public void onFailure(Exception e) {     IOUtils.closeWhileHandlingException(connection).     listener.onFailure(e). }
false;protected;0;17;;@Override protected void doRun() throws Exception {     getADAuthenticator(user).searchForDN(connection, user, null, Math.toIntExact(timeout.getSeconds()), ActionListener.wrap(entry -> {         if (entry == null) {             IOUtils.close(connection).             listener.onResponse(null).         } else {             listener.onResponse(new LdapSession(logger, config, connection, entry.getDN(), groupResolver, metaDataResolver, timeout, null)).         }     }, e -> {         IOUtils.closeWhileHandlingException(connection).         listener.onFailure(e).     })). }
false;;2;38;;@Override void getUnauthenticatedSessionWithoutPool(String user, ActionListener<LdapSession> listener) {     if (config.hasSetting(PoolingSessionFactorySettings.BIND_DN) == false) {         listener.onResponse(null).         return.     }     try {         final LDAPConnection connection = LdapUtils.privilegedConnect(serverSet::getConnection).         LdapUtils.maybeForkThenBind(connection, bindCredentials, threadPool, new AbstractRunnable() {              @Override             public void onFailure(Exception e) {                 IOUtils.closeWhileHandlingException(connection).                 listener.onFailure(e).             }              @Override             protected void doRun() throws Exception {                 getADAuthenticator(user).searchForDN(connection, user, null, Math.toIntExact(timeout.getSeconds()), ActionListener.wrap(entry -> {                     if (entry == null) {                         IOUtils.close(connection).                         listener.onResponse(null).                     } else {                         listener.onResponse(new LdapSession(logger, config, connection, entry.getDN(), groupResolver, metaDataResolver, timeout, null)).                     }                 }, e -> {                     IOUtils.closeWhileHandlingException(connection).                     listener.onFailure(e).                 })).             }         }).     } catch (LDAPException e) {         listener.onFailure(e).     } }
true;static;1;3;/**  * @param domain active directory domain name  * @return LDAP DN, distinguished name, of the root of the domain  */ ;/**  * @param domain active directory domain name  * @return LDAP DN, distinguished name, of the root of the domain  */ static String buildDnFromDomain(String domain) {     return "DC=" + domain.replace(".", ",DC="). }
false;static;1;7;;static String getBindDN(RealmConfig config) {     String bindDN = config.getSetting(PoolingSessionFactorySettings.BIND_DN).     if (bindDN.isEmpty() == false && bindDN.indexOf('\\') < 0 && bindDN.indexOf('@') < 0 && bindDN.indexOf('=') < 0) {         bindDN = bindDN + "@" + config.getSetting(ActiveDirectorySessionFactorySettings.AD_DOMAIN_NAME_SETTING).     }     return bindDN. }
true;;0;3;// Exposed for testing ;// Exposed for testing ServerSet getServerSet() {     return super.serverSet. }
false;;1;8;;ADAuthenticator getADAuthenticator(String username) {     if (username.indexOf('\\') > 0) {         return downLevelADAuthenticator.     } else if (username.indexOf("@") > 0) {         return upnADAuthenticator.     }     return defaultADAuthenticator. }
false;protected;0;15;;@Override protected void doRun() throws Exception {     searchForDN(connection, username, password, Math.toIntExact(timeout.seconds()), ActionListener.wrap((entry) -> {         if (entry == null) {             // we did not find the user, cannot authenticate in this realm             listener.onFailure(new ElasticsearchSecurityException("search for user [" + username + "] by principal name yielded no results")).         } else {             listener.onResponse(new LdapSession(logger, realm, connection, entry.getDN(), groupsResolver, metaDataResolver, timeout, null)).         }     }, e -> {         listener.onFailure(e).     })). }
false;protected;0;26;;@Override protected void doRun() throws Exception {     final ActionRunnable<LdapSession> searchRunnable = new ActionRunnable<LdapSession>(listener) {          @Override         protected void doRun() throws Exception {             searchForDN(connection, username, password, Math.toIntExact(timeout.seconds()), ActionListener.wrap((entry) -> {                 if (entry == null) {                     // we did not find the user, cannot authenticate in this realm                     listener.onFailure(new ElasticsearchSecurityException("search for user [" + username + "] by principal name yielded no results")).                 } else {                     listener.onResponse(new LdapSession(logger, realm, connection, entry.getDN(), groupsResolver, metaDataResolver, timeout, null)).                 }             }, e -> {                 listener.onFailure(e).             })).         }     }.     if (bindDN.isEmpty()) {         searchRunnable.run().     } else {         final SimpleBindRequest bind = new SimpleBindRequest(bindDN, CharArrays.toUtf8Bytes(bindPassword.getChars())).         LdapUtils.maybeForkThenBind(connection, bind, threadPool, searchRunnable).     } }
false;final;4;33;;final void authenticate(LDAPConnection connection, String username, SecureString password, ActionListener<LdapSession> listener) {     final byte[] passwordBytes = CharArrays.toUtf8Bytes(password.getChars()).     final SimpleBindRequest userBind = new SimpleBindRequest(bindUsername(username), passwordBytes, new AuthorizationIdentityRequestControl()).     LdapUtils.maybeForkThenBind(connection, userBind, threadPool, new ActionRunnable<LdapSession>(listener) {          @Override         protected void doRun() throws Exception {             final ActionRunnable<LdapSession> searchRunnable = new ActionRunnable<LdapSession>(listener) {                  @Override                 protected void doRun() throws Exception {                     searchForDN(connection, username, password, Math.toIntExact(timeout.seconds()), ActionListener.wrap((entry) -> {                         if (entry == null) {                             // we did not find the user, cannot authenticate in this realm                             listener.onFailure(new ElasticsearchSecurityException("search for user [" + username + "] by principal name yielded no results")).                         } else {                             listener.onResponse(new LdapSession(logger, realm, connection, entry.getDN(), groupsResolver, metaDataResolver, timeout, null)).                         }                     }, e -> {                         listener.onFailure(e).                     })).                 }             }.             if (bindDN.isEmpty()) {                 searchRunnable.run().             } else {                 final SimpleBindRequest bind = new SimpleBindRequest(bindDN, CharArrays.toUtf8Bytes(bindPassword.getChars())).                 LdapUtils.maybeForkThenBind(connection, bind, threadPool, searchRunnable).             }         }     }). }
false;protected;0;15;;@Override protected void doRun() throws Exception {     searchForDN(pool, username, password, Math.toIntExact(timeout.seconds()), ActionListener.wrap((entry) -> {         if (entry == null) {             // we did not find the user, cannot authenticate in this realm             listener.onFailure(new ElasticsearchSecurityException("search for user [" + username + "] by principal name yielded no results")).         } else {             listener.onResponse(new LdapSession(logger, realm, pool, entry.getDN(), groupsResolver, metaDataResolver, timeout, null)).         }     }, e -> {         listener.onFailure(e).     })). }
false;final;5;22;;final void authenticate(LDAPConnectionPool pool, String username, SecureString password, ThreadPool threadPool, ActionListener<LdapSession> listener) {     final byte[] passwordBytes = CharArrays.toUtf8Bytes(password.getChars()).     final SimpleBindRequest bind = new SimpleBindRequest(bindUsername(username), passwordBytes).     LdapUtils.maybeForkThenBindAndRevert(pool, bind, threadPool, new ActionRunnable<LdapSession>(listener) {          @Override         protected void doRun() throws Exception {             searchForDN(pool, username, password, Math.toIntExact(timeout.seconds()), ActionListener.wrap((entry) -> {                 if (entry == null) {                     // we did not find the user, cannot authenticate in this realm                     listener.onFailure(new ElasticsearchSecurityException("search for user [" + username + "] by principal name yielded no results")).                 } else {                     listener.onResponse(new LdapSession(logger, realm, pool, entry.getDN(), groupsResolver, metaDataResolver, timeout, null)).                 }             }, e -> {                 listener.onFailure(e).             })).         }     }). }
false;;1;3;;String bindUsername(String username) {     return username. }
true;final;0;3;// pkg-private for testing ;// pkg-private for testing final String getUserSearchFilter() {     return userSearchFilter. }
false;abstract;5;2;;abstract void searchForDN(LDAPInterface connection, String username, SecureString password, int timeLimitSeconds, ActionListener<SearchResultEntry> listener).
false;private,static;1;3;;private static String domainName(RealmConfig realm) {     return realm.getSetting(ActiveDirectorySessionFactorySettings.AD_DOMAIN_NAME_SETTING). }
false;;5;12;;@Override void searchForDN(LDAPInterface connection, String username, SecureString password, int timeLimitSeconds, ActionListener<SearchResultEntry> listener) {     try {         searchForEntry(connection, userSearchDN, userSearchScope.scope(), createFilter(userSearchFilter, username), timeLimitSeconds, ignoreReferralErrors, listener, attributesToSearchFor(groupsResolver.attributes())).     } catch (LDAPException e) {         listener.onFailure(e).     } }
false;;1;4;;@Override String bindUsername(String username) {     return username + "@" + domainName. }
false;;5;17;;@Override void searchForDN(LDAPInterface connection, String username, SecureString password, int timeLimitSeconds, ActionListener<SearchResultEntry> listener) {     String[] parts = username.split("\\\\").     assert parts.length == 2.     final String netBiosDomainName = parts[0].     final String accountName = parts[1].     netBiosDomainNameToDn(connection, netBiosDomainName, username, password, timeLimitSeconds, ActionListener.wrap((domainDN) -> {         if (domainDN == null) {             listener.onResponse(null).         } else {             searchForEntry(connection, domainDN, LdapSearchScope.SUB_TREE.scope(), createFilter(userSearchFilter, accountName), timeLimitSeconds, ignoreReferralErrors, listener, attributesToSearchFor(groupsResolver.attributes())).         }     }, listener::onFailure)). }
false;protected;0;14;;@Override protected void doRun() throws Exception {     search(searchConnection, "CN=Configuration," + domainDN, LdapSearchScope.SUB_TREE.scope(), filter, timeLimitSeconds, ignoreReferralErrors, ActionListener.wrap(results -> {         IOUtils.close(searchConnection).         handleSearchResults(results, netBiosDomainName, domainNameCache, listener).     }, e -> {         IOUtils.closeWhileHandlingException(searchConnection).         listener.onFailure(e).     }), "ncname"). }
false;public;1;5;;@Override public void onFailure(Exception e) {     IOUtils.closeWhileHandlingException(searchConnection).     listener.onFailure(e). }
false;;6;64;;void netBiosDomainNameToDn(LDAPInterface ldapInterface, String netBiosDomainName, String username, SecureString password, int timeLimitSeconds, ActionListener<String> listener) {     LDAPConnection ldapConnection = null.     try {         final Filter filter = createFilter(NETBIOS_NAME_FILTER_TEMPLATE, netBiosDomainName).         final String cachedName = domainNameCache.get(netBiosDomainName).         if (cachedName != null) {             listener.onResponse(cachedName).         } else if (usingGlobalCatalog(ldapInterface) == false) {             search(ldapInterface, "CN=Configuration," + domainDN, LdapSearchScope.SUB_TREE.scope(), filter, timeLimitSeconds, ignoreReferralErrors, ActionListener.wrap((results) -> handleSearchResults(results, netBiosDomainName, domainNameCache, listener), listener::onFailure), "ncname").         } else {             // probably ok as most AD users do not use non-standard ports             if (ldapInterface instanceof LDAPConnection) {                 ldapConnection = (LDAPConnection) ldapInterface.             } else {                 ldapConnection = LdapUtils.privilegedConnect(((LDAPConnectionPool) ldapInterface)::getConnection).             }             final LDAPConnection finalLdapConnection = ldapConnection.             final LDAPConnection searchConnection = LdapUtils.privilegedConnect(() -> new LDAPConnection(finalLdapConnection.getSocketFactory(), connectionOptions(config, sslService, logger), finalLdapConnection.getConnectedAddress(), finalLdapConnection.getSSLSession() != null ? ldapsPort : ldapPort)).             final byte[] passwordBytes = CharArrays.toUtf8Bytes(password.getChars()).             final SimpleBindRequest bind = bindDN.isEmpty() ? new SimpleBindRequest(username, passwordBytes) : new SimpleBindRequest(bindDN, CharArrays.toUtf8Bytes(bindPassword.getChars())).             LdapUtils.maybeForkThenBind(searchConnection, bind, threadPool, new ActionRunnable<String>(listener) {                  @Override                 protected void doRun() throws Exception {                     search(searchConnection, "CN=Configuration," + domainDN, LdapSearchScope.SUB_TREE.scope(), filter, timeLimitSeconds, ignoreReferralErrors, ActionListener.wrap(results -> {                         IOUtils.close(searchConnection).                         handleSearchResults(results, netBiosDomainName, domainNameCache, listener).                     }, e -> {                         IOUtils.closeWhileHandlingException(searchConnection).                         listener.onFailure(e).                     }), "ncname").                 }                  @Override                 public void onFailure(Exception e) {                     IOUtils.closeWhileHandlingException(searchConnection).                     listener.onFailure(e).                 }             }).         }     } catch (LDAPException e) {         listener.onFailure(e).     } finally {         if (ldapInterface instanceof LDAPConnectionPool && ldapConnection != null) {             ((LDAPConnectionPool) ldapInterface).releaseConnection(ldapConnection).         }     } }
false;static;4;18;;static void handleSearchResults(List<SearchResultEntry> results, String netBiosDomainName, Cache<String, String> domainNameCache, ActionListener<String> listener) {     Optional<SearchResultEntry> entry = results.stream().filter((r) -> r.hasAttribute("ncname")).findFirst().     if (entry.isPresent()) {         final String value = entry.get().getAttributeValue("ncname").         try {             domainNameCache.computeIfAbsent(netBiosDomainName, (s) -> value).         } catch (ExecutionException e) {             throw new AssertionError("failed to load constant non-null value", e).         }         listener.onResponse(value).     } else {         listener.onResponse(null).     } }
false;;1;16;;boolean usingGlobalCatalog(LDAPInterface ldap) throws LDAPException {     if (ldap instanceof LDAPConnection) {         return usingGlobalCatalog((LDAPConnection) ldap).     } else {         LDAPConnectionPool pool = (LDAPConnectionPool) ldap.         LDAPConnection connection = null.         try {             connection = LdapUtils.privilegedConnect(pool::getConnection).             return usingGlobalCatalog(connection).         } finally {             if (connection != null) {                 pool.releaseConnection(connection).             }         }     } }
false;private;1;3;;private boolean usingGlobalCatalog(LDAPConnection ldapConnection) {     return ldapConnection.getConnectedPort() == gcLdapPort || ldapConnection.getConnectedPort() == gcLdapsPort. }
false;;5;15;;@Override void searchForDN(LDAPInterface connection, String username, SecureString password, int timeLimitSeconds, ActionListener<SearchResultEntry> listener) {     String[] parts = username.split("@").     assert parts.length == 2 : "there should have only been two values for " + username + " after splitting on '@'".     final String accountName = parts[0].     try {         Filter filter = createFilter(userSearchFilter, accountName, username).         searchForEntry(connection, userSearchDN, LdapSearchScope.SUB_TREE.scope(), filter, timeLimitSeconds, ignoreReferralErrors, listener, attributesToSearchFor(groupsResolver.attributes())).     } catch (LDAPException e) {         listener.onFailure(e).     } }
