commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void register() throws IOException {     super.register().     sslDriver.init(). }
false;public;1;11;;@Override public void queueWriteOperation(WriteOperation writeOperation) {     getSelector().assertOnSelectorThread().     if (writeOperation instanceof CloseNotifyOperation) {         sslDriver.initiateClose().         long relativeNanos = CLOSE_TIMEOUT_NANOS + System.nanoTime().         closeTimeoutCanceller = getSelector().getTaskScheduler().scheduleAtRelativeTime(this::channelCloseTimeout, relativeNanos).     } else {         super.queueWriteOperation(writeOperation).     } }
false;public;0;52;;@Override public void flushChannel() throws IOException {     if (closeNow()) {         return.     }     // If there is currently data in the outbound write buffer, flush the buffer.     if (sslDriver.hasFlushPending()) {         // If the data is not completely flushed, exit. We cannot produce new write data until the         // existing data has been fully flushed.         flushToChannel(sslDriver.getNetworkWriteBuffer()).         if (sslDriver.hasFlushPending()) {             return.         }     }     // If the driver is ready for application writes, we can attempt to proceed with any queued writes.     if (sslDriver.readyForApplicationWrites()) {         FlushOperation currentFlush.         while (sslDriver.hasFlushPending() == false && (currentFlush = getPendingFlush()) != null) {             // sent (as we only get to this point if the write buffer has been fully flushed).             if (currentFlush.isFullyFlushed()) {                 currentFlushOperationComplete().             } else {                 try {                     // Attempt to encrypt application write data. The encrypted data ends up in the                     // outbound write buffer.                     int bytesEncrypted = sslDriver.applicationWrite(currentFlush.getBuffersToWrite()).                     if (bytesEncrypted == 0) {                         break.                     }                     currentFlush.incrementIndex(bytesEncrypted).                     // Flush the write buffer to the channel                     flushToChannel(sslDriver.getNetworkWriteBuffer()).                 } catch (IOException e) {                     currentFlushOperationFailed(e).                     throw e.                 }             }         }     } else {         // only want to continue producing new writes if the outbound write buffer is fully flushed.         while (sslDriver.hasFlushPending() == false && sslDriver.needsNonApplicationWrite()) {             sslDriver.nonApplicationWrite().             // If non-application writes were produced, flush the outbound write buffer.             if (sslDriver.hasFlushPending()) {                 flushToChannel(sslDriver.getNetworkWriteBuffer()).             }         }     } }
false;public;0;9;;@Override public boolean readyForFlush() {     getSelector().assertOnSelectorThread().     if (sslDriver.readyForApplicationWrites()) {         return sslDriver.hasFlushPending() || super.readyForFlush().     } else {         return sslDriver.hasFlushPending() || sslDriver.needsNonApplicationWrite().     } }
false;public;0;17;;@Override public int read() throws IOException {     int bytesRead = 0.     if (closeNow()) {         return bytesRead.     }     bytesRead = readFromChannel(sslDriver.getNetworkReadBuffer()).     if (bytesRead == 0) {         return bytesRead.     }     sslDriver.read(channelBuffer).     handleReadBytes().     return bytesRead. }
false;public;0;4;;@Override public boolean selectorShouldClose() {     return closeNow() || sslDriver.isClosed(). }
false;public;0;12;;@Override public void closeChannel() {     if (isClosing.compareAndSet(false, true)) {         WriteOperation writeOperation = new CloseNotifyOperation(this).         NioSelector selector = getSelector().         if (selector.isOnCurrentThread() == false) {             selector.queueWrite(writeOperation).             return.         }         selector.writeToChannel(writeOperation).     } }
false;public;0;8;;@Override public void closeFromSelector() throws IOException {     getSelector().assertOnSelectorThread().     if (channel.isOpen()) {         closeTimeoutCanceller.run().         IOUtils.close(super::closeFromSelector, sslDriver::close).     } }
false;public;0;3;;public SSLEngine getSSLEngine() {     return sslDriver.getSSLEngine(). }
false;private;0;5;;private void channelCloseTimeout() {     closeTimeoutCanceller = DEFAULT_TIMEOUT_CANCELLER.     setCloseNow().     getSelector().queueChannelClose(channel). }
false;public;0;4;;@Override public BiConsumer<Void, Exception> getListener() {     return LISTENER. }
false;public;0;4;;@Override public SocketChannelContext getChannel() {     return channelContext. }
false;public;0;4;;@Override public Object getObject() {     return WRITE_OBJECT. }
