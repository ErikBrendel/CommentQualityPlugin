# id;timestamp;commentText;codeText;commentWords;codeWords
IndicesAndAliasesResolver -> public ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1524684173;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;public ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices indices = ResolvedIndices.empty()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                indices = ResolvedIndices.add(indices, resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices))__            }_            return indices__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;public,resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,indices,resolved,indices,empty,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,indices,resolved,indices,add,indices,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,return,indices,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> public ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1525645056;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;public ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;public,resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1525645056;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1527207653;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1531179852;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1532353780;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1534755962;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1535046779;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1535383145;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1539615817;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1540313026;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1541092382;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String index);1543959410;add a local index name;private void addLocal(String index) {_                local.add(index)__            };add,a,local,index,name;private,void,add,local,string,index,local,add,index
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1524684173;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return Collections.unmodifiableList(local)__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,collections,unmodifiable,list,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1525645056;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1527207653;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1531179852;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1532353780;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1534755962;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1535046779;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1535383145;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1539615817;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1540313026;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1541092382;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getLocal();1543959410;Returns the collection of index names that have been stored as "local" indices._This is a <code>List</code> because order may be important. For example <code>[ "a*" , "-a1" ]</code> is interpreted differently_to <code>[ "-a1", "a*" ]</code>. As a consequence, this list <em>may contain duplicates</em>.;public List<String> getLocal() {_            return local__        };returns,the,collection,of,index,names,that,have,been,stored,as,local,indices,this,is,a,code,list,code,because,order,may,be,important,for,example,code,a,a1,code,is,interpreted,differently,to,code,a1,a,code,as,a,consequence,this,list,em,may,contain,duplicates,em;public,list,string,get,local,return,local
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1524684173;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return Collections.unmodifiableList(remote)__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,collections,unmodifiable,list,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1525645056;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1527207653;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1531179852;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1532353780;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1534755962;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1535046779;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1535383145;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1539615817;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1540313026;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1541092382;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices -> public List<String> getRemote();1543959410;Returns the collection of index names that have been stored as "remote" indices.;public List<String> getRemote() {_            return remote__        };returns,the,collection,of,index,names,that,have,been,stored,as,remote,indices;public,list,string,get,remote,return,remote
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, List<String> authorizedIndices);1549399169;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, List<String> authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,list,string,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, List<String> authorizedIndices);1550601141;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, List<String> authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,list,string,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, List<String> authorizedIndicesList, MetaData metaData);1549399169;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, List<String> authorizedIndicesList, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,list,string,authorized,indices,list,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, List<String> authorizedIndicesList, MetaData metaData);1550601141;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, List<String> authorizedIndicesList, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,list,string,authorized,indices,list,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1525645056;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1527207653;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1531179852;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1532353780;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1534755962;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1535046779;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1535383145;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1539615817;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1540313026;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1541092382;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(List<String> indices);1543959410;adds the list of local index names;private void addLocal(List<String> indices) {_                local.addAll(indices)__            };adds,the,list,of,local,index,names;private,void,add,local,list,string,indices,local,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1524684173;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(IndicesAndAliasesResolverField.NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains,indices,and,aliases,resolver,field
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1525645056;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1527207653;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1531179852;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1532353780;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1534755962;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1535046779;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1535383145;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1539615817;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1540313026;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1541092382;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isNoIndicesPlaceholder();1543959410;@return <code>true</code> if the {@link #getRemote() remote} index lists is empty, and the local index list contains the_{@link IndicesAndAliasesResolverField#NO_INDEX_PLACEHOLDER no-index-placeholder} and nothing else.;public boolean isNoIndicesPlaceholder() {_            return remote.isEmpty() && local.size() == 1 && local.contains(NO_INDEX_PLACEHOLDER)__        };return,code,true,code,if,the,link,get,remote,remote,index,lists,is,empty,and,the,local,index,list,contains,the,link,indices,and,aliases,resolver,field,no,index,placeholder,and,nothing,else;public,boolean,is,no,indices,placeholder,return,remote,is,empty,local,size,1,local,contains
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1527207653;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases =_                metaData.findAliases(Strings.EMPTY_ARRAY, new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,aliases,strings,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1531179852;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases =_                metaData.findAliases(Strings.EMPTY_ARRAY, new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,aliases,strings,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1532353780;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1534755962;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1535046779;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1535383145;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1539615817;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1540313026;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1541092382;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData);1543959410;Special handling of the value to authorize for a put mapping request. Dynamic put mapping_requests use a concrete index, but we allow permissions to be defined on aliases so if the_request's concrete index is not in the list of authorized indices, then we need to look to_see if this can be authorized against an alias;static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {_        final String concreteIndexName = request.getConcreteIndex().getName()__        final List<String> authorizedIndicesList = authorizedIndices.get()___        _        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName)__        final String resolvedAliasOrIndex__        if (aliasOrIndex == null) {_            resolvedAliasOrIndex = concreteIndexName__        } else if (aliasOrIndex.isAlias()) {_            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be")__        } else if (authorizedIndicesList.contains(concreteIndexName)) {_            _            resolvedAliasOrIndex = concreteIndexName__        } else {_            _            _            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases = metaData.findAllAliases(new String[] { concreteIndexName })__            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName)__            if (aliasMetaData != null) {_                Optional<String> foundAlias = aliasMetaData.stream()_                    .map(AliasMetaData::alias)_                    .filter(authorizedIndicesList::contains)_                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1)_                    .findFirst()__                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName)__            } else {_                resolvedAliasOrIndex = concreteIndexName__            }_        }__        return resolvedAliasOrIndex__    };special,handling,of,the,value,to,authorize,for,a,put,mapping,request,dynamic,put,mapping,requests,use,a,concrete,index,but,we,allow,permissions,to,be,defined,on,aliases,so,if,the,request,s,concrete,index,is,not,in,the,list,of,authorized,indices,then,we,need,to,look,to,see,if,this,can,be,authorized,against,an,alias;static,string,get,put,mapping,index,or,alias,put,mapping,request,request,authorized,indices,authorized,indices,meta,data,meta,data,final,string,concrete,index,name,request,get,concrete,index,get,name,final,list,string,authorized,indices,list,authorized,indices,get,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,concrete,index,name,final,string,resolved,alias,or,index,if,alias,or,index,null,resolved,alias,or,index,concrete,index,name,else,if,alias,or,index,is,alias,throw,new,illegal,state,exception,concrete,index,concrete,index,name,is,an,alias,but,should,not,be,else,if,authorized,indices,list,contains,concrete,index,name,resolved,alias,or,index,concrete,index,name,else,immutable,open,map,string,list,alias,meta,data,found,aliases,meta,data,find,all,aliases,new,string,concrete,index,name,list,alias,meta,data,alias,meta,data,found,aliases,get,concrete,index,name,if,alias,meta,data,null,optional,string,found,alias,alias,meta,data,stream,map,alias,meta,data,alias,filter,authorized,indices,list,contains,filter,alias,name,meta,data,get,alias,and,index,lookup,get,alias,name,get,indices,size,1,find,first,resolved,alias,or,index,found,alias,or,else,concrete,index,name,else,resolved,alias,or,index,concrete,index,name,return,resolved,alias,or,index
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1525645056;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1527207653;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1531179852;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1532353780;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1534755962;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1535046779;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1535383145;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1539615817;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1540313026;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1541092382;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addRemote(List<String> indices);1543959410;adds the list of remote index names;private void addRemote(List<String> indices) {_                remote.addAll(indices)__            };adds,the,list,of,remote,index,names;private,void,add,remote,list,string,indices,remote,add,all,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1525645056;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1527207653;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1531179852;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1532353780;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1534755962;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1535046779;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1535383145;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1539615817;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1540313026;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1541092382;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private boolean isEmpty();1543959410;@return <code>true</code> if both the local and remote index lists are empty.;private boolean isEmpty() {_                return local.isEmpty() && remote.isEmpty()__            };return,code,true,code,if,both,the,local,and,remote,index,lists,are,empty;private,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1524684173;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1525645056;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1527207653;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1531179852;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1532353780;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1534755962;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1535046779;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1535383145;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1539615817;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1540313026;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1541092382;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> public boolean isEmpty();1543959410;@return <code>true</code> if both the {@link #getLocal() local} and {@link #getRemote() remote} index lists are empty.;public boolean isEmpty() {_            return local.isEmpty() && remote.isEmpty()__        };return,code,true,code,if,both,the,link,get,local,local,and,link,get,remote,remote,index,lists,are,empty;public,boolean,is,empty,return,local,is,empty,remote,is,empty
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1525645056;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1527207653;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1531179852;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1532353780;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1534755962;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1535046779;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1535383145;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1539615817;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1540313026;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1541092382;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private void addLocal(String[] indices);1543959410;adds the array of local index names;private void addLocal(String[] indices) {_                local.addAll(Arrays.asList(indices))__            };adds,the,array,of,local,index,names;private,void,add,local,string,indices,local,add,all,arrays,as,list,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1527207653;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1531179852;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1532353780;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1534755962;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1535046779;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1535383145;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1539615817;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1540313026;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1541092382;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_{@link RemoteClusterAware#getRemoteClusterNames() remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,link,remote,cluster,aware,get,remote,cluster,names,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices);1543959410;Resolves, and if necessary updates, the list of index names in the provided <code>request</code> in accordance with the user's_<code>authorizedIndices</code>._<p>_Wildcards are expanded at this phase to ensure that all security and execution decisions are made against a fixed set of index names_that is consistent and does not change during the life of the request._</p>_<p>_If the provided <code>request</code> is of a type that {@link #allowsRemoteIndices(IndicesRequest) allows remote indices},_then the index names will be categorized into those that refer to {@link ResolvedIndices#getLocal() local indices}, and those that_refer to {@link ResolvedIndices#getRemote() remote indices}. This categorization follows the standard_{@link RemoteClusterAware#buildRemoteIndexName(String, String) remote index-name format} and also respects the currently defined_remote clusters}._</p><br>_Thus an index name <em>N</em> will considered to be <em>remote</em> if-and-only-if all of the following are true_<ul>_<li><code>request</code> supports remote indices</li>_<li>_<em>N</em> is in the format <i>cluster</i><code>:</code><i>index</i>._It is allowable for <i>cluster</i> and <i>index</i> to contain wildcards, but the separator (<code>:</code>) must be explicit._</li>_<li><i>cluster</i> matches one or more remote cluster names that are registered within this cluster.</li>_</ul>_In which case, any wildcards in the <i>cluster</i> portion of the name will be expanded and the resulting remote-index-name(s) will_be added to the <em>remote</em> index list._<br>_Otherwise, <em>N</em> will be added to the <em>local</em> index list.;ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {_        if (request instanceof IndicesAliasesRequest) {_            ResolvedIndices.Builder resolvedIndicesBuilder = new ResolvedIndices.Builder()__            IndicesAliasesRequest indicesAliasesRequest = (IndicesAliasesRequest) request__            for (IndicesRequest indicesRequest : indicesAliasesRequest.getAliasActions()) {_                final ResolvedIndices resolved = resolveIndicesAndAliases(indicesRequest, metaData, authorizedIndices)__                resolvedIndicesBuilder.addLocal(resolved.getLocal())__                resolvedIndicesBuilder.addRemote(resolved.getRemote())__            }_            return resolvedIndicesBuilder.build()__        }__        _        if (request instanceof IndicesRequest == false) {_            throw new IllegalStateException("Request [" + request + "] is not an Indices request, but should be.")__        }_        return resolveIndicesAndAliases((IndicesRequest) request, metaData, authorizedIndices)__    };resolves,and,if,necessary,updates,the,list,of,index,names,in,the,provided,code,request,code,in,accordance,with,the,user,s,code,authorized,indices,code,p,wildcards,are,expanded,at,this,phase,to,ensure,that,all,security,and,execution,decisions,are,made,against,a,fixed,set,of,index,names,that,is,consistent,and,does,not,change,during,the,life,of,the,request,p,p,if,the,provided,code,request,code,is,of,a,type,that,link,allows,remote,indices,indices,request,allows,remote,indices,then,the,index,names,will,be,categorized,into,those,that,refer,to,link,resolved,indices,get,local,local,indices,and,those,that,refer,to,link,resolved,indices,get,remote,remote,indices,this,categorization,follows,the,standard,link,remote,cluster,aware,build,remote,index,name,string,string,remote,index,name,format,and,also,respects,the,currently,defined,remote,clusters,p,br,thus,an,index,name,em,n,em,will,considered,to,be,em,remote,em,if,and,only,if,all,of,the,following,are,true,ul,li,code,request,code,supports,remote,indices,li,li,em,n,em,is,in,the,format,i,cluster,i,code,code,i,index,i,it,is,allowable,for,i,cluster,i,and,i,index,i,to,contain,wildcards,but,the,separator,code,code,must,be,explicit,li,li,i,cluster,i,matches,one,or,more,remote,cluster,names,that,are,registered,within,this,cluster,li,ul,in,which,case,any,wildcards,in,the,i,cluster,i,portion,of,the,name,will,be,expanded,and,the,resulting,remote,index,name,s,will,be,added,to,the,em,remote,em,index,list,br,otherwise,em,n,em,will,be,added,to,the,em,local,em,index,list;resolved,indices,resolve,transport,request,request,meta,data,meta,data,authorized,indices,authorized,indices,if,request,instanceof,indices,aliases,request,resolved,indices,builder,resolved,indices,builder,new,resolved,indices,builder,indices,aliases,request,indices,aliases,request,indices,aliases,request,request,for,indices,request,indices,request,indices,aliases,request,get,alias,actions,final,resolved,indices,resolved,resolve,indices,and,aliases,indices,request,meta,data,authorized,indices,resolved,indices,builder,add,local,resolved,get,local,resolved,indices,builder,add,remote,resolved,get,remote,return,resolved,indices,builder,build,if,request,instanceof,indices,request,false,throw,new,illegal,state,exception,request,request,is,not,an,indices,request,but,should,be,return,resolve,indices,and,aliases,indices,request,request,meta,data,authorized,indices
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1525645056;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1527207653;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1531179852;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1532353780;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1534755962;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1535046779;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1535383145;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1539615817;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1540313026;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1541092382;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
IndicesAndAliasesResolver -> ResolvedIndices -> Builder -> private ResolvedIndices build();1543959410;@return a immutable ResolvedIndices instance with the local and remote index lists;private ResolvedIndices build() {_                return new ResolvedIndices(local, remote)__            };return,a,immutable,resolved,indices,instance,with,the,local,and,remote,index,lists;private,resolved,indices,build,return,new,resolved,indices,local,remote
