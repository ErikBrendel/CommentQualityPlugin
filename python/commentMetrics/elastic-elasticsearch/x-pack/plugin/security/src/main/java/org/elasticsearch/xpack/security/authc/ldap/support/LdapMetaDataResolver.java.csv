commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String[] attributeNames() {     return attributeNames. }
false;public;6;19;;public void resolve(LDAPInterface connection, String userDn, TimeValue timeout, Logger logger, Collection<Attribute> attributes, ActionListener<Map<String, Object>> listener) {     if (this.attributeNames.length == 0) {         listener.onResponse(Collections.emptyMap()).     } else if (attributes != null) {         listener.onResponse(toMap(name -> findAttribute(attributes, name))).     } else {         searchForEntry(connection, userDn, SearchScope.BASE, OBJECT_CLASS_PRESENCE_FILTER, Math.toIntExact(timeout.seconds()), ignoreReferralErrors, ActionListener.wrap((SearchResultEntry entry) -> {             if (entry == null) {                 listener.onResponse(Collections.emptyMap()).             } else {                 listener.onResponse(toMap(entry::getAttribute)).             }         }, listener::onFailure), this.attributeNames).     } }
false;private;2;5;;private Attribute findAttribute(Collection<Attribute> attributes, String name) {     return attributes.stream().filter(attr -> attr.getName().equals(name)).findFirst().orElse(null). }
false;private;1;12;;private Map<String, Object> toMap(Function<String, Attribute> attributes) {     return Collections.unmodifiableMap(Arrays.stream(this.attributeNames).map(attributes).filter(Objects::nonNull).collect(Collectors.toMap(attr -> attr.getName(), attr -> {         final String[] values = attr.getValues().         return values.length == 1 ? values[0] : Arrays.asList(values).     }))). }
