commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean matches(InetSocketAddress remoteAddress) {     return true. }
false;public;0;4;;@Override public IpFilterRuleType ruleType() {     return IpFilterRuleType.ACCEPT. }
false;public;0;9;;public Map<String, Object> usageStats() {     Map<String, Object> map = new HashMap<>(2).     final boolean httpFilterEnabled = isHttpFilterEnabled && (httpAllowFilter.isEmpty() == false || httpDenyFilter.isEmpty() == false).     final boolean transportFilterEnabled = isIpFilterEnabled && (transportAllowFilter.isEmpty() == false || transportDenyFilter.isEmpty() == false).     map.put("http", httpFilterEnabled).     map.put("transport", transportFilterEnabled).     return map. }
false;private;2;4;;private void setProfileAllowRules(String profile, List<String> rules) {     profileAllowRules.put(profile, rules).     updateRules(). }
false;private;2;4;;private void setProfileDenyRules(String profile, List<String> rules) {     profileDenyRules.put(profile, rules).     updateRules(). }
false;private;1;4;;private void setHttpDenyFilter(List<String> filter) {     this.httpDenyFilter = filter.     updateRules(). }
false;private;1;4;;private void setHttpAllowFilter(List<String> filter) {     this.httpAllowFilter = filter.     updateRules(). }
false;private;1;4;;private void setTransportDenyFilter(List<String> filter) {     this.transportDenyFilter = filter.     updateRules(). }
false;private;1;4;;private void setTransportAllowFilter(List<String> filter) {     this.transportAllowFilter = filter.     updateRules(). }
false;private;1;4;;private void setTransportFiltering(boolean enabled) {     this.isIpFilterEnabled = enabled.     updateRules(). }
false;private;1;4;;private void setHttpFiltering(boolean enabled) {     this.isHttpFilterEnabled = enabled.     updateRules(). }
false;public;2;25;;public boolean accept(String profile, InetSocketAddress peerAddress) {     if (licenseState.isIpFilteringAllowed() == false) {         return true.     }     if (!rules.containsKey(profile)) {         // FIXME we need to audit here         return true.     }     for (SecurityIpFilterRule rule : rules.get(profile)) {         if (rule.matches(peerAddress)) {             boolean isAllowed = rule.ruleType() == IpFilterRuleType.ACCEPT.             if (isAllowed) {                 auditTrail.connectionGranted(peerAddress.getAddress(), profile, rule).             } else {                 auditTrail.connectionDenied(peerAddress.getAddress(), profile, rule).             }             return isAllowed.         }     }     auditTrail.connectionGranted(peerAddress.getAddress(), profile, DEFAULT_PROFILE_ACCEPT_ALL).     return true. }
false;private,synchronized;0;3;;private synchronized void updateRules() {     this.rules = parseSettings(). }
false;private;0;31;;private Map<String, SecurityIpFilterRule[]> parseSettings() {     if (isIpFilterEnabled || isHttpFilterEnabled) {         Map<String, SecurityIpFilterRule[]> profileRules = new HashMap<>().         if (isHttpFilterEnabled && boundHttpTransportAddress.get() != null) {             TransportAddress[] localAddresses = boundHttpTransportAddress.get().boundAddresses().             profileRules.put(HTTP_PROFILE_NAME, createRules(httpAllowFilter, httpDenyFilter, localAddresses)).         }         if (isIpFilterEnabled && boundTransportAddress.get() != null) {             TransportAddress[] localAddresses = boundTransportAddress.get().boundAddresses().             profileRules.put(TransportSettings.DEFAULT_PROFILE, createRules(transportAllowFilter, transportDenyFilter, localAddresses)).             for (String profile : profiles) {                 BoundTransportAddress profileBoundTransportAddress = profileBoundAddress.get().get(profile).                 if (profileBoundTransportAddress == null) {                     // this could happen if a user updates the settings dynamically with a new profile                     logger.warn("skipping ip filter rules for profile [{}] since the profile is not bound to any addresses", profile).                     continue.                 }                 final List<String> allowRules = this.profileAllowRules.getOrDefault(profile, Collections.emptyList()).                 final List<String> denyRules = this.profileDenyRules.getOrDefault(profile, Collections.emptyList()).                 profileRules.put(profile, createRules(allowRules, denyRules, profileBoundTransportAddress.boundAddresses())).             }         }         logger.debug("loaded ip filtering profiles: {}", profileRules.keySet()).         return unmodifiableMap(profileRules).     } else {         return Collections.emptyMap().     } }
false;private;3;18;;private SecurityIpFilterRule[] createRules(List<String> allow, List<String> deny, TransportAddress[] boundAddresses) {     List<SecurityIpFilterRule> rules = new ArrayList<>().     // if we are always going to allow the bound addresses, then the rule for them should be the first rule in the list     if (alwaysAllowBoundAddresses) {         assert boundAddresses != null && boundAddresses.length > 0.         rules.add(new SecurityIpFilterRule(true, boundAddresses)).     }     // add all rules to the same list. Allow takes precedence so they must come first!     for (String value : allow) {         rules.add(new SecurityIpFilterRule(true, value)).     }     for (String value : deny) {         rules.add(new SecurityIpFilterRule(false, value)).     }     return rules.toArray(new SecurityIpFilterRule[rules.size()]). }
false;public;2;6;;public void setBoundTransportAddress(BoundTransportAddress boundTransportAddress, Map<String, BoundTransportAddress> profileBoundAddress) {     this.boundTransportAddress.set(boundTransportAddress).     this.profileBoundAddress.set(profileBoundAddress).     updateRules(). }
false;public;1;4;;public void setBoundHttpTransportAddress(BoundTransportAddress boundHttpTransportAddress) {     this.boundHttpTransportAddress.set(boundHttpTransportAddress).     updateRules(). }
false;public,static;1;11;;public static void addSettings(List<Setting<?>> settings) {     settings.add(ALLOW_BOUND_ADDRESSES_SETTING).     settings.add(IP_FILTER_ENABLED_SETTING).     settings.add(IP_FILTER_ENABLED_HTTP_SETTING).     settings.add(HTTP_FILTER_ALLOW_SETTING).     settings.add(HTTP_FILTER_DENY_SETTING).     settings.add(TRANSPORT_FILTER_ALLOW_SETTING).     settings.add(TRANSPORT_FILTER_DENY_SETTING).     settings.add(PROFILE_FILTER_ALLOW_SETTING).     settings.add(PROFILE_FILTER_DENY_SETTING). }
