commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Adds the {@link Authentication} to the {@link ScrollContext}  */ ;/**  * Adds the {@link Authentication} to the {@link ScrollContext}  */ @Override public void onNewScrollContext(SearchContext searchContext) {     if (licenseState.isAuthAllowed()) {         searchContext.scrollContext().putInContext(AuthenticationField.AUTHENTICATION_KEY, Authentication.getAuthentication(threadContext)).     } }
true;public;2;12;/**  * Checks for the {@link ScrollContext} if it exists and compares the {@link Authentication}  * object from the scroll context with the current authentication context  */ ;/**  * Checks for the {@link ScrollContext} if it exists and compares the {@link Authentication}  * object from the scroll context with the current authentication context  */ @Override public void validateSearchContext(SearchContext searchContext, TransportRequest request) {     if (licenseState.isAuthAllowed()) {         if (searchContext.scrollContext() != null) {             final Authentication originalAuth = searchContext.scrollContext().getFromContext(AuthenticationField.AUTHENTICATION_KEY).             final Authentication current = Authentication.getAuthentication(threadContext).             final String action = threadContext.getTransient(ORIGINATING_ACTION_KEY).             ensureAuthenticatedUserIsSame(originalAuth, current, auditTrailService, searchContext.id(), action, request, AuditUtil.extractRequestId(threadContext), threadContext.getTransient(AUTHORIZATION_INFO_KEY)).         }     } }
true;static;8;25;/**  * Compares the {@link Authentication} that was stored in the {@link ScrollContext} with the  * current authentication. We cannot guarantee that all of the details of the authentication will  * be the same. Some things that could differ include the roles, the name of the authenticating  * (or lookup) realm. To work around this we compare the username and the originating realm type.  */ ;/**  * Compares the {@link Authentication} that was stored in the {@link ScrollContext} with the  * current authentication. We cannot guarantee that all of the details of the authentication will  * be the same. Some things that could differ include the roles, the name of the authenticating  * (or lookup) realm. To work around this we compare the username and the originating realm type.  */ static void ensureAuthenticatedUserIsSame(Authentication original, Authentication current, AuditTrailService auditTrailService, long id, String action, TransportRequest request, String requestId, AuthorizationInfo authorizationInfo) {     // this is really a best effort attempt since we cannot guarantee principal uniqueness     // and realm names can change between nodes.     final boolean samePrincipal = original.getUser().principal().equals(current.getUser().principal()).     final boolean sameRealmType.     if (original.getUser().isRunAs()) {         if (current.getUser().isRunAs()) {             sameRealmType = original.getLookedUpBy().getType().equals(current.getLookedUpBy().getType()).         } else {             sameRealmType = original.getLookedUpBy().getType().equals(current.getAuthenticatedBy().getType()).         }     } else if (current.getUser().isRunAs()) {         sameRealmType = original.getAuthenticatedBy().getType().equals(current.getLookedUpBy().getType()).     } else {         sameRealmType = original.getAuthenticatedBy().getType().equals(current.getAuthenticatedBy().getType()).     }     final boolean sameUser = samePrincipal && sameRealmType.     if (sameUser == false) {         auditTrailService.accessDenied(requestId, current, action, request, authorizationInfo).         throw new SearchContextMissingException(id).     } }
