# id;timestamp;commentText;codeText;commentWords;codeWords
SecurityIndexManager -> public boolean isIndexUpToDate();1525859433;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1526029249;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1526449283;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1534362961;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1539723533;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1539796943;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1540238977;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> public boolean isIndexUpToDate();1551160396;Returns whether the index is on the current format if it exists. If the index does not exist_we treat the index as up to date as we expect it to be created with the current format.;public boolean isIndexUpToDate() {_        return this.indexState.isIndexUpToDate__    };returns,whether,the,index,is,on,the,current,format,if,it,exists,if,the,index,does,not,exist,we,treat,the,index,as,up,to,date,as,we,expect,it,to,be,created,with,the,current,format;public,boolean,is,index,up,to,date,return,this,index,state,is,index,up,to,date
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1525859433;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1526029249;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1526449283;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1534362961;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1539723533;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1539796943;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1540238977;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData);1551160396;Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires_that if supplied with an alias, the alias resolves to at most one concrete index.;private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {_        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName)__        if (aliasOrIndex != null) {_            final List<IndexMetaData> indices = aliasOrIndex.getIndices()__            if (aliasOrIndex.isAlias() && indices.size() > 1) {_                throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " +_                        indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList()))__            }_            return indices.get(0)__        }_        return null__    };resolves,a,concrete,index,name,or,alias,to,a,link,index,meta,data,instance,requires,that,if,supplied,with,an,alias,the,alias,resolves,to,at,most,one,concrete,index;private,static,index,meta,data,resolve,concrete,index,final,string,index,or,alias,name,final,meta,data,meta,data,final,alias,or,index,alias,or,index,meta,data,get,alias,and,index,lookup,get,index,or,alias,name,if,alias,or,index,null,final,list,index,meta,data,indices,alias,or,index,get,indices,if,alias,or,index,is,alias,indices,size,1,throw,new,illegal,state,exception,alias,index,or,alias,name,points,to,more,than,one,index,indices,stream,map,imd,imd,get,index,get,name,collect,collectors,to,list,return,indices,get,0,return,null
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1526029249;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1526449283;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1534362961;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1539723533;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1539796943;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1540238977;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> public static boolean isMoveFromRedToNonRed(State previousState, State currentState);1551160396;Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.;public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {_        return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED)_                && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED__    };return,true,if,the,state,moves,from,an,unhealthy,red,index,state,to,a,healthy,non,red,state;public,static,boolean,is,move,from,red,to,non,red,state,previous,state,state,current,state,return,previous,state,index,status,null,previous,state,index,status,cluster,health,status,red,current,state,index,status,null,current,state,index,status,cluster,health,status,red
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1525859433;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1526029249;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1526449283;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1534362961;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1539723533;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1539796943;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1540238977;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState);1551160396;Returns the routing-table for this index, or <code>null</code> if the index does not exist.;private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {_        IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData())__        if (metaData == null) {_            return null__        } else {_            return clusterState.routingTable().index(metaData.getIndex())__        }_    };returns,the,routing,table,for,this,index,or,code,null,code,if,the,index,does,not,exist;private,index,routing,table,get,index,routing,table,cluster,state,cluster,state,index,meta,data,meta,data,resolve,concrete,index,index,name,cluster,state,meta,data,if,meta,data,null,return,null,else,return,cluster,state,routing,table,index,meta,data,get,index
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1525859433;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<PutMappingResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,put,mapping,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1526029249;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<PutMappingResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,put,mapping,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1526449283;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<PutMappingResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,put,mapping,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1534362961;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<AcknowledgedResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,acknowledged,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1539723533;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<AcknowledgedResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,acknowledged,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1539796943;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<AcknowledgedResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,acknowledged,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1540238977;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            PutMappingRequest request = new PutMappingRequest(INTERNAL_SECURITY_INDEX)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<AcknowledgedResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,put,mapping,request,request,new,put,mapping,request,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,acknowledged,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1551160396;Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are_out of date. After any tasks have been executed, the runnable is then executed.;public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                    "Security index is not on the current version. Security features relying on the index will not be available until " +_                            "the upgrade API is run on the security index"))__        } else if (indexState.indexExists == false) {_            LOGGER.info("security index does not exist. Creating [{}] with alias [{}]", INTERNAL_SECURITY_INDEX, SECURITY_INDEX_NAME)__            Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate()__            CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX)_                    .alias(new Alias(SECURITY_INDEX_NAME))_                    .mapping("doc", mappingAndSettings.v1(), XContentType.JSON)_                    .waitForActiveShards(ActiveShardCount.ALL)_                    .settings(mappingAndSettings.v2())__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    new ActionListener<CreateIndexResponse>() {_                        @Override_                        public void onResponse(CreateIndexResponse createIndexResponse) {_                            if (createIndexResponse.isAcknowledged()) {_                                andThen.run()__                            } else {_                                consumer.accept(new ElasticsearchException("Failed to create security index"))__                            }_                        }__                        @Override_                        public void onFailure(Exception e) {_                            final Throwable cause = ExceptionsHelper.unwrapCause(e)__                            if (cause instanceof ResourceAlreadyExistsException) {_                                _                                _                                andThen.run()__                            } else {_                                consumer.accept(e)__                            }_                        }_                    }, client.admin().indices()::create)__        } else if (indexState.mappingUpToDate == false) {_            LOGGER.info(_                "security index [{}] (alias [{}]) is not up to date. Updating mapping", indexState.concreteIndexName, SECURITY_INDEX_NAME)__            PutMappingRequest request = new PutMappingRequest(indexState.concreteIndexName)_                    .source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON)_                    .type("doc")__            executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,_                    ActionListener.<AcknowledgedResponse>wrap(putMappingResponse -> {_                        if (putMappingResponse.isAcknowledged()) {_                            andThen.run()__                        } else {_                            consumer.accept(new IllegalStateException("put mapping request was not acknowledged"))__                        }_                    }, consumer), client.admin().indices()::putMapping)__        } else {_            andThen.run()__        }_    };prepares,the,index,by,creating,it,if,it,doesn,t,exist,or,updating,the,mappings,if,the,mappings,are,out,of,date,after,any,tasks,have,been,executed,the,runnable,is,then,executed;public,void,prepare,index,if,needed,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,if,index,state,index,exists,false,logger,info,security,index,does,not,exist,creating,with,alias,tuple,string,settings,mapping,and,settings,load,mapping,and,settings,source,from,template,create,index,request,request,new,create,index,request,alias,new,alias,mapping,doc,mapping,and,settings,v1,xcontent,type,json,wait,for,active,shards,active,shard,count,all,settings,mapping,and,settings,v2,execute,async,with,origin,client,thread,pool,get,thread,context,request,new,action,listener,create,index,response,override,public,void,on,response,create,index,response,create,index,response,if,create,index,response,is,acknowledged,and,then,run,else,consumer,accept,new,elasticsearch,exception,failed,to,create,security,index,override,public,void,on,failure,exception,e,final,throwable,cause,exceptions,helper,unwrap,cause,e,if,cause,instanceof,resource,already,exists,exception,and,then,run,else,consumer,accept,e,client,admin,indices,create,else,if,index,state,mapping,up,to,date,false,logger,info,security,index,alias,is,not,up,to,date,updating,mapping,index,state,concrete,index,name,put,mapping,request,request,new,put,mapping,request,index,state,concrete,index,name,source,load,mapping,and,settings,source,from,template,v1,xcontent,type,json,type,doc,execute,async,with,origin,client,thread,pool,get,thread,context,request,action,listener,acknowledged,response,wrap,put,mapping,response,if,put,mapping,response,is,acknowledged,and,then,run,else,consumer,accept,new,illegal,state,exception,put,mapping,request,was,not,acknowledged,consumer,client,admin,indices,put,mapping,else,and,then,run
SecurityIndexManager -> public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1539723533;Validates the security index is up to date and does not need to migrated. If it is not, the_consumer is called with an exception. If the security index is up to date, the runnable will_be executed. <b>NOTE:</b> this method does not check the availability of the index_ this check_is left to the caller so that this condition can be handled appropriately.;public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                "Security index is not on the current version. Security features relying on the index will not be available until " +_                    "the upgrade API is run on the security index"))__        } else {_            andThen.run()__        }_    };validates,the,security,index,is,up,to,date,and,does,not,need,to,migrated,if,it,is,not,the,consumer,is,called,with,an,exception,if,the,security,index,is,up,to,date,the,runnable,will,be,executed,b,note,b,this,method,does,not,check,the,availability,of,the,index,this,check,is,left,to,the,caller,so,that,this,condition,can,be,handled,appropriately;public,void,check,index,version,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,and,then,run
SecurityIndexManager -> public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1540238977;Validates the security index is up to date and does not need to migrated. If it is not, the_consumer is called with an exception. If the security index is up to date, the runnable will_be executed. <b>NOTE:</b> this method does not check the availability of the index_ this check_is left to the caller so that this condition can be handled appropriately.;public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                "Security index is not on the current version. Security features relying on the index will not be available until " +_                    "the upgrade API is run on the security index"))__        } else {_            andThen.run()__        }_    };validates,the,security,index,is,up,to,date,and,does,not,need,to,migrated,if,it,is,not,the,consumer,is,called,with,an,exception,if,the,security,index,is,up,to,date,the,runnable,will,be,executed,b,note,b,this,method,does,not,check,the,availability,of,the,index,this,check,is,left,to,the,caller,so,that,this,condition,can,be,handled,appropriately;public,void,check,index,version,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,and,then,run
SecurityIndexManager -> public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen);1551160396;Validates the security index is up to date and does not need to migrated. If it is not, the_consumer is called with an exception. If the security index is up to date, the runnable will_be executed. <b>NOTE:</b> this method does not check the availability of the index_ this check_is left to the caller so that this condition can be handled appropriately.;public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {_        final State indexState = this.indexState_ _        if (indexState.indexExists && indexState.isIndexUpToDate == false) {_            consumer.accept(new IllegalStateException(_                "Security index is not on the current version. Security features relying on the index will not be available until " +_                    "the upgrade API is run on the security index"))__        } else {_            andThen.run()__        }_    };validates,the,security,index,is,up,to,date,and,does,not,need,to,migrated,if,it,is,not,the,consumer,is,called,with,an,exception,if,the,security,index,is,up,to,date,the,runnable,will,be,executed,b,note,b,this,method,does,not,check,the,availability,of,the,index,this,check,is,left,to,the,caller,so,that,this,condition,can,be,handled,appropriately;public,void,check,index,version,then,execute,final,consumer,exception,consumer,final,runnable,and,then,final,state,index,state,this,index,state,if,index,state,index,exists,index,state,is,index,up,to,date,false,consumer,accept,new,illegal,state,exception,security,index,is,not,on,the,current,version,security,features,relying,on,the,index,will,not,be,available,until,the,upgrade,api,is,run,on,the,security,index,else,and,then,run
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1526029249;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1526449283;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1534362961;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1539723533;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1539796943;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1540238977;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public void addIndexStateListener(BiConsumer<State, State> listener);1551160396;Add a listener for notifications on state changes to the configured index.__The previous and current state are provided.;public void addIndexStateListener(BiConsumer<State, State> listener) {_        stateChangeListeners.add(listener)__    };add,a,listener,for,notifications,on,state,changes,to,the,configured,index,the,previous,and,current,state,are,provided;public,void,add,index,state,listener,bi,consumer,state,state,listener,state,change,listeners,add,listener
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1526029249;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1526449283;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1534362961;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1539723533;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1539796943;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1540238977;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
SecurityIndexManager -> public static boolean isIndexDeleted(State previousState, State currentState);1551160396;Return true if the state moves from the index existing to the index not existing.;public static boolean isIndexDeleted(State previousState, State currentState) {_        return previousState.indexStatus != null && currentState.indexStatus == null__    };return,true,if,the,state,moves,from,the,index,existing,to,the,index,not,existing;public,static,boolean,is,index,deleted,state,previous,state,state,current,state,return,previous,state,index,status,null,current,state,index,status,null
