commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public SecurityIndexManager freeze() {     return new SecurityIndexManager(null, indexName, indexState). }
false;public;1;5;;public boolean checkMappingVersion(Predicate<Version> requiredVersion) {     // pull value into local variable for consistent view     final State currentIndexState = this.indexState.     return currentIndexState.mappingVersion == null || requiredVersion.test(currentIndexState.mappingVersion). }
false;public;0;3;;public boolean indexExists() {     return this.indexState.indexExists. }
true;public;0;3;/**  * Returns whether the index is on the current format if it exists. If the index does not exist  * we treat the index as up to date as we expect it to be created with the current format.  */ ;/**  * Returns whether the index is on the current format if it exists. If the index does not exist  * we treat the index as up to date as we expect it to be created with the current format.  */ public boolean isIndexUpToDate() {     return this.indexState.isIndexUpToDate. }
false;public;0;3;;public boolean isAvailable() {     return this.indexState.indexAvailable. }
false;public;0;3;;public boolean isMappingUpToDate() {     return this.indexState.mappingUpToDate. }
false;public;0;12;;public ElasticsearchException getUnavailableReason() {     final State localState = this.indexState.     if (localState.indexAvailable) {         throw new IllegalStateException("caller must make sure to use a frozen state and check indexAvailable").     }     if (localState.indexExists) {         return new UnavailableShardsException(null, "at least one primary shard for the security index is unavailable").     } else {         return new IndexNotFoundException(SECURITY_INDEX_NAME).     } }
true;public;1;3;/**  * Add a listener for notifications on state changes to the configured index.  *  * The previous and current state are provided.  */ ;/**  * Add a listener for notifications on state changes to the configured index.  *  * The previous and current state are provided.  */ public void addIndexStateListener(BiConsumer<State, State> listener) {     stateChangeListeners.add(listener). }
false;public;1;29;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {         // wait until the gateway has recovered from disk, otherwise we think we don't have the         // .security index but they may not have been restored from the cluster state on disk         LOGGER.debug("security index manager waiting until state has been recovered").         return.     }     final State previousState = indexState.     final IndexMetaData indexMetaData = resolveConcreteIndex(indexName, event.state().metaData()).     final boolean indexExists = indexMetaData != null.     final boolean isIndexUpToDate = indexExists == false || INDEX_FORMAT_SETTING.get(indexMetaData.getSettings()).intValue() == INTERNAL_INDEX_FORMAT.     final boolean indexAvailable = checkIndexAvailable(event.state()).     final boolean mappingIsUpToDate = indexExists == false || checkIndexMappingUpToDate(event.state()).     final Version mappingVersion = oldestIndexMappingVersion(event.state()).     final ClusterHealthStatus indexStatus = indexMetaData == null ? null : new ClusterIndexHealth(indexMetaData, event.state().getRoutingTable().index(indexMetaData.getIndex())).getStatus().     final String concreteIndexName = indexMetaData == null ? INTERNAL_SECURITY_INDEX : indexMetaData.getIndex().getName().     final State newState = new State(indexExists, isIndexUpToDate, indexAvailable, mappingIsUpToDate, mappingVersion, concreteIndexName, indexStatus).     this.indexState = newState.     if (newState.equals(previousState) == false) {         for (BiConsumer<State, State> listener : stateChangeListeners) {             listener.accept(previousState, newState).         }     } }
false;private;1;8;;private boolean checkIndexAvailable(ClusterState state) {     final IndexRoutingTable routingTable = getIndexRoutingTable(state).     if (routingTable != null && routingTable.allPrimaryShardsActive()) {         return true.     }     LOGGER.debug("Security index [{}] is not yet active", indexName).     return false. }
true;private;1;8;/**  * Returns the routing-table for this index, or <code>null</code> if the index does not exist.  */ ;/**  * Returns the routing-table for this index, or <code>null</code> if the index does not exist.  */ private IndexRoutingTable getIndexRoutingTable(ClusterState clusterState) {     IndexMetaData metaData = resolveConcreteIndex(indexName, clusterState.metaData()).     if (metaData == null) {         return null.     } else {         return clusterState.routingTable().index(metaData.getIndex()).     } }
false;public,static;4;6;;public static boolean checkTemplateExistsAndVersionMatches(String templateName, ClusterState state, Logger logger, Predicate<Version> predicate) {     return TemplateUtils.checkTemplateExistsAndVersionMatches(templateName, SECURITY_VERSION_STRING, state, logger, predicate). }
false;private;1;3;;private boolean checkIndexMappingUpToDate(ClusterState clusterState) {     return checkIndexMappingVersionMatches(clusterState, Version.CURRENT::equals). }
false;private;2;4;;private boolean checkIndexMappingVersionMatches(ClusterState clusterState, Predicate<Version> predicate) {     return checkIndexMappingVersionMatches(indexName, clusterState, LOGGER, predicate). }
false;public,static;4;6;;public static boolean checkIndexMappingVersionMatches(String indexName, ClusterState clusterState, Logger logger, Predicate<Version> predicate) {     return loadIndexMappingVersions(indexName, clusterState, logger).stream().allMatch(predicate). }
false;private;1;4;;private Version oldestIndexMappingVersion(ClusterState clusterState) {     final Set<Version> versions = loadIndexMappingVersions(indexName, clusterState, LOGGER).     return versions.stream().min(Version::compareTo).orElse(null). }
false;private,static;3;15;;private static Set<Version> loadIndexMappingVersions(String indexName, ClusterState clusterState, Logger logger) {     Set<Version> versions = new HashSet<>().     IndexMetaData indexMetaData = resolveConcreteIndex(indexName, clusterState.metaData()).     if (indexMetaData != null) {         for (Object object : indexMetaData.getMappings().values().toArray()) {             MappingMetaData mappingMetaData = (MappingMetaData) object.             if (mappingMetaData.type().equals(MapperService.DEFAULT_MAPPING)) {                 continue.             }             versions.add(readMappingVersion(indexName, mappingMetaData, logger)).         }     }     return versions. }
true;private,static;2;12;/**  * Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires  * that if supplied with an alias, the alias resolves to at most one concrete index.  */ ;/**  * Resolves a concrete index name or alias to a {@link IndexMetaData} instance.  Requires  * that if supplied with an alias, the alias resolves to at most one concrete index.  */ private static IndexMetaData resolveConcreteIndex(final String indexOrAliasName, final MetaData metaData) {     final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(indexOrAliasName).     if (aliasOrIndex != null) {         final List<IndexMetaData> indices = aliasOrIndex.getIndices().         if (aliasOrIndex.isAlias() && indices.size() > 1) {             throw new IllegalStateException("Alias [" + indexOrAliasName + "] points to more than one index: " + indices.stream().map(imd -> imd.getIndex().getName()).collect(Collectors.toList())).         }         return indices.get(0).     }     return null. }
false;private,static;3;17;;private static Version readMappingVersion(String indexName, MappingMetaData mappingMetaData, Logger logger) {     try {         Map<String, Object> meta = (Map<String, Object>) mappingMetaData.sourceAsMap().get("_meta").         if (meta == null) {             logger.info("Missing _meta field in mapping [{}] of index [{}]", mappingMetaData.type(), indexName).             throw new IllegalStateException("Cannot read security-version string in index " + indexName).         }         return Version.fromString((String) meta.get(SECURITY_VERSION_STRING)).     } catch (ElasticsearchParseException e) {         logger.error(new ParameterizedMessage("Cannot parse the mapping for index [{}]", indexName), e).         throw new ElasticsearchException("Cannot parse the mapping for index [{}]", e, indexName).     } }
true;public;2;10;/**  * Validates the security index is up to date and does not need to migrated. If it is not, the  * consumer is called with an exception. If the security index is up to date, the runnable will  * be executed. <b>NOTE:</b> this method does not check the availability of the index. this check  * is left to the caller so that this condition can be handled appropriately.  */ ;/**  * Validates the security index is up to date and does not need to migrated. If it is not, the  * consumer is called with an exception. If the security index is up to date, the runnable will  * be executed. <b>NOTE:</b> this method does not check the availability of the index. this check  * is left to the caller so that this condition can be handled appropriately.  */ public void checkIndexVersionThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {     // use a local copy so all checks execute against the same state!     final State indexState = this.indexState.     if (indexState.indexExists && indexState.isIndexUpToDate == false) {         consumer.accept(new IllegalStateException("Security index is not on the current version. Security features relying on the index will not be available until " + "the upgrade API is run on the security index")).     } else {         andThen.run().     } }
false;public;1;8;;@Override public void onResponse(CreateIndexResponse createIndexResponse) {     if (createIndexResponse.isAcknowledged()) {         andThen.run().     } else {         consumer.accept(new ElasticsearchException("Failed to create security index")).     } }
false;public;1;11;;@Override public void onFailure(Exception e) {     final Throwable cause = ExceptionsHelper.unwrapCause(e).     if (cause instanceof ResourceAlreadyExistsException) {         // the index already exists - it was probably just created so this         // node hasn't yet received the cluster state update with the index         andThen.run().     } else {         consumer.accept(e).     } }
true;public;2;56;/**  * Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are  * out of date. After any tasks have been executed, the runnable is then executed.  */ ;/**  * Prepares the index by creating it if it doesn't exist or updating the mappings if the mappings are  * out of date. After any tasks have been executed, the runnable is then executed.  */ public void prepareIndexIfNeededThenExecute(final Consumer<Exception> consumer, final Runnable andThen) {     // use a local copy so all checks execute against the same state!     final State indexState = this.indexState.     // TODO we should improve this so we don't fire off a bunch of requests to do the same thing (create or update mappings)     if (indexState.indexExists && indexState.isIndexUpToDate == false) {         consumer.accept(new IllegalStateException("Security index is not on the current version. Security features relying on the index will not be available until " + "the upgrade API is run on the security index")).     } else if (indexState.indexExists == false) {         LOGGER.info("security index does not exist. Creating [{}] with alias [{}]", INTERNAL_SECURITY_INDEX, SECURITY_INDEX_NAME).         Tuple<String, Settings> mappingAndSettings = loadMappingAndSettingsSourceFromTemplate().         CreateIndexRequest request = new CreateIndexRequest(INTERNAL_SECURITY_INDEX).alias(new Alias(SECURITY_INDEX_NAME)).mapping("doc", mappingAndSettings.v1(), XContentType.JSON).waitForActiveShards(ActiveShardCount.ALL).settings(mappingAndSettings.v2()).         executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request, new ActionListener<CreateIndexResponse>() {              @Override             public void onResponse(CreateIndexResponse createIndexResponse) {                 if (createIndexResponse.isAcknowledged()) {                     andThen.run().                 } else {                     consumer.accept(new ElasticsearchException("Failed to create security index")).                 }             }              @Override             public void onFailure(Exception e) {                 final Throwable cause = ExceptionsHelper.unwrapCause(e).                 if (cause instanceof ResourceAlreadyExistsException) {                     // the index already exists - it was probably just created so this                     // node hasn't yet received the cluster state update with the index                     andThen.run().                 } else {                     consumer.accept(e).                 }             }         }, client.admin().indices()::create).     } else if (indexState.mappingUpToDate == false) {         LOGGER.info("security index [{}] (alias [{}]) is not up to date. Updating mapping", indexState.concreteIndexName, SECURITY_INDEX_NAME).         PutMappingRequest request = new PutMappingRequest(indexState.concreteIndexName).source(loadMappingAndSettingsSourceFromTemplate().v1(), XContentType.JSON).type("doc").         executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request, ActionListener.<AcknowledgedResponse>wrap(putMappingResponse -> {             if (putMappingResponse.isAcknowledged()) {                 andThen.run().             } else {                 consumer.accept(new IllegalStateException("put mapping request was not acknowledged")).             }         }, consumer), client.admin().indices()::putMapping).     } else {         andThen.run().     } }
false;private;0;6;;private Tuple<String, Settings> loadMappingAndSettingsSourceFromTemplate() {     final byte[] template = TemplateUtils.loadTemplate("/" + SECURITY_TEMPLATE_NAME + ".json", Version.CURRENT.toString(), SecurityIndexManager.TEMPLATE_VERSION_PATTERN).getBytes(StandardCharsets.UTF_8).     PutIndexTemplateRequest request = new PutIndexTemplateRequest(SECURITY_TEMPLATE_NAME).source(template, XContentType.JSON).     return new Tuple<>(request.mappings().get("doc"), request.settings()). }
true;public,static;2;4;/**  * Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.  */ ;/**  * Return true if the state moves from an unhealthy ("RED") index state to a healthy ("non-RED") state.  */ public static boolean isMoveFromRedToNonRed(State previousState, State currentState) {     return (previousState.indexStatus == null || previousState.indexStatus == ClusterHealthStatus.RED) && currentState.indexStatus != null && currentState.indexStatus != ClusterHealthStatus.RED. }
true;public,static;2;3;/**  * Return true if the state moves from the index existing to the index not existing.  */ ;/**  * Return true if the state moves from the index existing to the index not existing.  */ public static boolean isIndexDeleted(State previousState, State currentState) {     return previousState.indexStatus != null && currentState.indexStatus == null. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     State state = (State) o.     return indexExists == state.indexExists && isIndexUpToDate == state.isIndexUpToDate && indexAvailable == state.indexAvailable && mappingUpToDate == state.mappingUpToDate && Objects.equals(mappingVersion, state.mappingVersion) && Objects.equals(concreteIndexName, state.concreteIndexName) && indexStatus == state.indexStatus. }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(indexExists, isIndexUpToDate, indexAvailable, mappingUpToDate, mappingVersion, concreteIndexName, indexStatus). }
