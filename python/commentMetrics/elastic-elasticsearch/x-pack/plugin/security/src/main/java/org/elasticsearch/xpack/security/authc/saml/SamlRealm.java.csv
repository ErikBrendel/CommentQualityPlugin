commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;30;/**  * Factory for SAML realm.  * This is not a constructor as it needs to initialise a number of components before delegating to  * {@link #SamlRealm}  */ ;/**  * Factory for SAML realm.  * This is not a constructor as it needs to initialise a number of components before delegating to  * {@link #SamlRealm}  */ public static SamlRealm create(RealmConfig config, SSLService sslService, ResourceWatcherService watcherService, UserRoleMapper roleMapper) throws Exception {     SamlUtils.initialize(logger).     if (TokenService.isTokenServiceEnabled(config.settings()) == false) {         throw new IllegalStateException("SAML requires that the token service be enabled (" + XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey() + ")").     }     final Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = initializeResolver(logger, config, sslService, watcherService).     final AbstractReloadingMetadataResolver metadataResolver = tuple.v1().     final Supplier<EntityDescriptor> idpDescriptor = tuple.v2().     final SpConfiguration serviceProvider = getSpConfiguration(config).     final Clock clock = Clock.systemUTC().     final IdpConfiguration idpConfiguration = getIdpConfiguration(config, metadataResolver, idpDescriptor).     final TimeValue maxSkew = config.getSetting(CLOCK_SKEW).     final SamlAuthenticator authenticator = new SamlAuthenticator(clock, idpConfiguration, serviceProvider, maxSkew).     final SamlLogoutRequestHandler logoutHandler = new SamlLogoutRequestHandler(clock, idpConfiguration, serviceProvider, maxSkew).     final SamlRealm realm = new SamlRealm(config, roleMapper, authenticator, logoutHandler, idpDescriptor, serviceProvider).     // the metadata resolver needs to be destroyed since it runs a timer task in the background and destroying stops it!     realm.releasables.add(() -> metadataResolver.destroy()).     return realm. }
false;public;2;7;;@Override public void initialize(Iterable<Realm> realms, XPackLicenseState licenseState) {     if (delegatedRealms != null) {         throw new IllegalStateException("Realm has already been initialized").     }     delegatedRealms = new DelegatedAuthorizationSupport(realms, config, licenseState). }
false;static;2;8;;static String require(RealmConfig config, Setting.AffixSetting<String> setting) {     final String value = config.getSetting(setting).     if (value.isEmpty()) {         throw new IllegalArgumentException("The configuration setting [" + RealmSettings.getFullSettingKey(config, setting) + "] is required").     }     return value. }
false;private,static;3;30;;private static IdpConfiguration getIdpConfiguration(RealmConfig config, MetadataResolver metadataResolver, Supplier<EntityDescriptor> idpDescriptor) {     final MetadataCredentialResolver resolver = new MetadataCredentialResolver().     final PredicateRoleDescriptorResolver roleDescriptorResolver = new PredicateRoleDescriptorResolver(metadataResolver).     resolver.setRoleDescriptorResolver(roleDescriptorResolver).     final InlineX509DataProvider keyInfoProvider = new InlineX509DataProvider().     resolver.setKeyInfoCredentialResolver(new BasicProviderKeyInfoCredentialResolver(Collections.singletonList(keyInfoProvider))).     try {         roleDescriptorResolver.initialize().         resolver.initialize().     } catch (ComponentInitializationException e) {         throw new IllegalStateException("Cannot initialise SAML IDP resolvers for realm " + config.name(), e).     }     final String entityID = idpDescriptor.get().getEntityID().     return new IdpConfiguration(entityID, () -> {         try {             final Iterable<Credential> credentials = resolver.resolve(new CriteriaSet(new EntityIdCriterion(entityID), new EntityRoleCriterion(IDPSSODescriptor.DEFAULT_ELEMENT_NAME), new UsageCriterion(UsageType.SIGNING))).             return CollectionUtils.iterableAsArrayList(credentials).         } catch (ResolverException e) {             throw new IllegalStateException("Cannot resolve SAML IDP credentials resolver for realm " + config.name(), e).         }     }). }
false;static;1;8;;static SpConfiguration getSpConfiguration(RealmConfig config) throws IOException, GeneralSecurityException {     final String serviceProviderId = require(config, SP_ENTITY_ID).     final String assertionConsumerServiceURL = require(config, SP_ACS).     final String logoutUrl = config.getSetting(SP_LOGOUT).     final List<String> reqAuthnCtxClassRef = config.getSetting(REQUESTED_AUTHN_CONTEXT_CLASS_REF).     return new SpConfiguration(serviceProviderId, assertionConsumerServiceURL, logoutUrl, buildSigningConfiguration(config), buildEncryptionCredential(config), reqAuthnCtxClassRef). }
true;static;1;5;// Package-private for testing ;// Package-private for testing static List<X509Credential> buildEncryptionCredential(RealmConfig config) throws IOException, GeneralSecurityException {     return buildCredential(config, RealmSettings.realmSettingPrefix(config.identifier()) + ENCRYPTION_SETTING_KEY, ENCRYPTION_KEY_ALIAS, true). }
false;static;1;15;;static SigningConfiguration buildSigningConfiguration(RealmConfig config) throws IOException, GeneralSecurityException {     final List<X509Credential> credentials = buildCredential(config, RealmSettings.realmSettingPrefix(config.identifier()) + SIGNING_SETTING_KEY, SIGNING_KEY_ALIAS, false).     if (credentials == null || credentials.isEmpty()) {         if (config.hasSetting(SIGNING_MESSAGE_TYPES)) {             throw new IllegalArgumentException("The setting [" + RealmSettings.getFullSettingKey(config, SIGNING_MESSAGE_TYPES) + "] cannot be specified if there are no signing credentials").         } else {             return new SigningConfiguration(Collections.emptySet(), null).         }     } else {         final List<String> types = config.getSetting(SIGNING_MESSAGE_TYPES).         return new SigningConfiguration(Sets.newHashSet(types), credentials.get(0)).     } }
false;private,static;4;53;;private static List<X509Credential> buildCredential(RealmConfig config, String prefix, Setting.AffixSetting<String> aliasSetting, boolean allowMultiple) {     final X509KeyPairSettings keyPairSettings = X509KeyPairSettings.withPrefix(prefix, false).     final X509KeyManager keyManager = CertParsingUtils.getKeyManager(keyPairSettings, config.settings(), null, config.env()).     if (keyManager == null) {         return null.     }     final Set<String> aliases = new HashSet<>().     final String configuredAlias = config.getSetting(aliasSetting).     if (Strings.isNullOrEmpty(configuredAlias)) {         final String[] serverAliases = keyManager.getServerAliases("RSA", null).         if (serverAliases != null) {             aliases.addAll(Arrays.asList(serverAliases)).         }         if (aliases.isEmpty()) {             throw new IllegalArgumentException("The configured key store for " + prefix + " does not contain any RSA key pairs").         } else if (allowMultiple == false && aliases.size() > 1) {             throw new IllegalArgumentException("The configured key store for " + prefix + " has multiple keys but no alias has been specified (from setting " + RealmSettings.getFullSettingKey(config, aliasSetting) + ")").         }     } else {         aliases.add(configuredAlias).     }     final List<X509Credential> credentials = new ArrayList<>().     for (String alias : aliases) {         if (keyManager.getPrivateKey(alias) == null) {             throw new IllegalArgumentException("The configured key store for " + prefix + " does not have a key associated with alias [" + alias + "] " + ((Strings.isNullOrEmpty(configuredAlias) == false) ? "(from setting " + RealmSettings.getFullSettingKey(config, aliasSetting) + ")" : "")).         }         final String keyType = keyManager.getPrivateKey(alias).getAlgorithm().         if (keyType.equals("RSA") == false) {             throw new IllegalArgumentException("The key associated with alias [" + alias + "] " + "(from setting " + RealmSettings.getFullSettingKey(config, aliasSetting) + ") uses unsupported key algorithm type [" + keyType + "], only RSA is supported").         }         credentials.add(new X509KeyManagerX509CredentialAdapter(keyManager, alias)).     }     return credentials. }
false;public,static;3;10;;public static List<SamlRealm> findSamlRealms(Realms realms, String realmName, String acsUrl) {     Stream<SamlRealm> stream = realms.stream().filter(r -> r instanceof SamlRealm).map(r -> (SamlRealm) r).     if (Strings.hasText(realmName)) {         stream = stream.filter(r -> realmName.equals(r.name())).     }     if (Strings.hasText(acsUrl)) {         stream = stream.filter(r -> acsUrl.equals(r.assertionConsumerServiceURL())).     }     return stream.collect(Collectors.toList()). }
false;public;1;4;;@Override public boolean supports(AuthenticationToken token) {     return token instanceof SamlToken. }
true;public;1;4;/**  * Always returns {@code null} as there is no support for reading a SAML token out of a request  *  * @see org.elasticsearch.xpack.security.action.saml.TransportSamlAuthenticateAction  */ ;/**  * Always returns {@code null} as there is no support for reading a SAML token out of a request  *  * @see org.elasticsearch.xpack.security.action.saml.TransportSamlAuthenticateAction  */ @Override public AuthenticationToken token(ThreadContext threadContext) {     return null. }
false;public;2;19;;@Override public void authenticate(AuthenticationToken authenticationToken, ActionListener<AuthenticationResult> listener) {     if (authenticationToken instanceof SamlToken) {         try {             final SamlToken token = (SamlToken) authenticationToken.             final SamlAttributes attributes = authenticator.authenticate(token).             logger.debug("Parsed token [{}] to attributes [{}]", token, attributes).             buildUser(attributes, listener).         } catch (ElasticsearchSecurityException e) {             if (SamlUtils.isSamlException(e)) {                 listener.onResponse(AuthenticationResult.unsuccessful("Provided SAML response is not valid for realm " + this, e)).             } else {                 listener.onFailure(e).             }         }     } else {         listener.onResponse(AuthenticationResult.notHandled()).     } }
false;private;2;50;;private void buildUser(SamlAttributes attributes, ActionListener<AuthenticationResult> baseListener) {     final String principal = resolveSingleValueAttribute(attributes, principalAttribute, PRINCIPAL_ATTRIBUTE.name(config)).     if (Strings.isNullOrEmpty(principal)) {         final String msg = principalAttribute + " not found in saml attributes" + attributes.attributes() + " or NameID [" + attributes.name() + "]".         baseListener.onResponse(AuthenticationResult.unsuccessful(msg, null)).         return.     }     final Map<String, Object> tokenMetadata = createTokenMetadata(attributes.name(), attributes.session()).     ActionListener<AuthenticationResult> wrappedListener = ActionListener.wrap(auth -> {         if (auth.isAuthenticated()) {             // Add the SAML token details as metadata on the authentication             Map<String, Object> metadata = new HashMap<>(auth.getMetadata()).             metadata.put(CONTEXT_TOKEN_DATA, tokenMetadata).             auth = AuthenticationResult.success(auth.getUser(), metadata).         }         baseListener.onResponse(auth).     }, baseListener::onFailure).     if (delegatedRealms.hasDelegation()) {         delegatedRealms.resolve(principal, wrappedListener).         return.     }     final Map<String, Object> userMeta = new HashMap<>().     if (populateUserMetadata) {         for (SamlAttributes.SamlAttribute a : attributes.attributes()) {             userMeta.put("saml(" + a.name + ")", a.values).             if (Strings.hasText(a.friendlyName)) {                 userMeta.put("saml_" + a.friendlyName, a.values).             }         }     }     if (attributes.name() != null) {         userMeta.put(USER_METADATA_NAMEID_VALUE, attributes.name().value).         userMeta.put(USER_METADATA_NAMEID_FORMAT, attributes.name().format).     }     final List<String> groups = groupsAttribute.getAttribute(attributes).     final String dn = resolveSingleValueAttribute(attributes, dnAttribute, DN_ATTRIBUTE.name(config)).     final String name = resolveSingleValueAttribute(attributes, nameAttribute, NAME_ATTRIBUTE.name(config)).     final String mail = resolveSingleValueAttribute(attributes, mailAttribute, MAIL_ATTRIBUTE.name(config)).     UserRoleMapper.UserData userData = new UserRoleMapper.UserData(principal, dn, groups, userMeta, config).     roleMapper.resolveRoles(userData, ActionListener.wrap(roles -> {         final User user = new User(principal, roles.toArray(new String[roles.size()]), name, mail, userMeta, true).         wrappedListener.onResponse(AuthenticationResult.success(user)).     }, wrappedListener::onFailure)). }
false;public;2;19;;public Map<String, Object> createTokenMetadata(SamlNameId nameId, String session) {     final Map<String, Object> tokenMeta = new HashMap<>().     if (nameId != null) {         tokenMeta.put(TOKEN_METADATA_NAMEID_VALUE, nameId.value).         tokenMeta.put(TOKEN_METADATA_NAMEID_FORMAT, nameId.format).         tokenMeta.put(TOKEN_METADATA_NAMEID_QUALIFIER, nameId.idpNameQualifier).         tokenMeta.put(TOKEN_METADATA_NAMEID_SP_QUALIFIER, nameId.spNameQualifier).         tokenMeta.put(TOKEN_METADATA_NAMEID_SP_PROVIDED_ID, nameId.spProvidedId).     } else {         tokenMeta.put(TOKEN_METADATA_NAMEID_VALUE, null).         tokenMeta.put(TOKEN_METADATA_NAMEID_FORMAT, null).         tokenMeta.put(TOKEN_METADATA_NAMEID_QUALIFIER, null).         tokenMeta.put(TOKEN_METADATA_NAMEID_SP_QUALIFIER, null).         tokenMeta.put(TOKEN_METADATA_NAMEID_SP_PROVIDED_ID, null).     }     tokenMeta.put(TOKEN_METADATA_SESSION, session).     tokenMeta.put(TOKEN_METADATA_REALM, name()).     return tokenMeta. }
false;private;3;12;;private String resolveSingleValueAttribute(SamlAttributes attributes, AttributeParser parser, String name) {     final List<String> list = parser.getAttribute(attributes).     switch(list.size()) {         case 0:             return null.         case 1:             return list.get(0).         default:             logger.info("SAML assertion contains multiple values for attribute [{}] returning first one", name).             return list.get(0).     } }
false;public;2;5;;@Override public void lookupUser(String username, ActionListener<User> listener) {     // saml will not support user lookup initially     listener.onResponse(null). }
false;static;4;13;;static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> initializeResolver(Logger logger, RealmConfig config, SSLService sslService, ResourceWatcherService watcherService) throws ResolverException, ComponentInitializationException, PrivilegedActionException, IOException {     final String metadataUrl = require(config, IDP_METADATA_PATH).     if (metadataUrl.startsWith("http://")) {         throw new IllegalArgumentException("The [http] protocol is not supported as it is insecure. Use [https] instead").     } else if (metadataUrl.startsWith("https://")) {         return parseHttpMetadata(metadataUrl, config, sslService).     } else {         return parseFileSystemMetadata(logger, metadataUrl, config, watcherService).     } }
false;private,static;3;33;;private static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> parseHttpMetadata(String metadataUrl, RealmConfig config, SSLService sslService) throws ResolverException, ComponentInitializationException, PrivilegedActionException {     final String entityId = require(config, IDP_ENTITY_ID).     HttpClientBuilder builder = HttpClientBuilder.create().     // ssl setup     final String sslKey = RealmSettings.realmSslPrefix(config.identifier()).     final SSLConfiguration sslConfiguration = sslService.getSSLConfiguration(sslKey).     boolean isHostnameVerificationEnabled = sslConfiguration.verificationMode().isHostnameVerificationEnabled().     HostnameVerifier verifier = isHostnameVerificationEnabled ? new DefaultHostnameVerifier() : NoopHostnameVerifier.INSTANCE.     SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslService.sslSocketFactory(sslConfiguration), verifier).     builder.setSSLSocketFactory(factory).     HTTPMetadataResolver resolver = new PrivilegedHTTPMetadataResolver(builder.build(), metadataUrl).     TimeValue refresh = config.getSetting(IDP_METADATA_HTTP_REFRESH).     resolver.setMinRefreshDelay(refresh.millis()).     resolver.setMaxRefreshDelay(refresh.millis()).     initialiseResolver(resolver, config).     return new Tuple<>(resolver, () -> {         // for some reason the resolver supports its own trust engine and custom socket factories.         // we do not use these as we'd rather rely on the JDK versions for TLS security!         SpecialPermission.check().         try {             return AccessController.doPrivileged((PrivilegedExceptionAction<EntityDescriptor>) () -> resolveEntityDescriptor(resolver, entityId, metadataUrl)).         } catch (PrivilegedActionException e) {             throw ExceptionsHelper.convertToRuntime((Exception) ExceptionsHelper.unwrapCause(e)).         }     }). }
false;protected;0;9;;@Override protected byte[] fetchMetadata() throws ResolverException {     try {         return AccessController.doPrivileged((PrivilegedExceptionAction<byte[]>) () -> PrivilegedHTTPMetadataResolver.super.fetchMetadata()).     } catch (final PrivilegedActionException e) {         throw (ResolverException) e.getCause().     } }
false;private,static;4;26;;@SuppressForbidden(reason = "uses toFile") private static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> parseFileSystemMetadata(Logger logger, String metadataPath, RealmConfig config, ResourceWatcherService watcherService) throws ResolverException, ComponentInitializationException, IOException, PrivilegedActionException {     final String entityId = require(config, IDP_ENTITY_ID).     final Path path = config.env().configFile().resolve(metadataPath).     final FilesystemMetadataResolver resolver = new FilesystemMetadataResolver(path.toFile()).     if (config.hasSetting(IDP_METADATA_HTTP_REFRESH)) {         logger.info("Ignoring setting [{}] because the IdP metadata is being loaded from a file", RealmSettings.getFullSettingKey(config, IDP_METADATA_HTTP_REFRESH)).     }     // We don't want to rely on the internal OpenSAML refresh timer, but we can't turn it off, so just set it to run once a day.     // @TODO : Submit a patch to OpenSAML to optionally disable the timer     final long oneDayMs = TimeValue.timeValueHours(24).millis().     resolver.setMinRefreshDelay(oneDayMs).     resolver.setMaxRefreshDelay(oneDayMs).     initialiseResolver(resolver, config).     FileWatcher watcher = new FileWatcher(path).     watcher.addListener(new FileListener(logger, resolver::refresh)).     watcherService.add(watcher, ResourceWatcherService.Frequency.MEDIUM).     return new Tuple<>(resolver, () -> resolveEntityDescriptor(resolver, entityId, path.toString())). }
false;private,static;3;12;;private static EntityDescriptor resolveEntityDescriptor(AbstractReloadingMetadataResolver resolver, String entityId, String sourceLocation) {     try {         final EntityDescriptor descriptor = resolver.resolveSingle(new CriteriaSet(new EntityIdCriterion(entityId))).         if (descriptor == null) {             throw SamlUtils.samlException("Cannot find metadata for entity [{}] in [{}]", entityId, sourceLocation).         }         return descriptor.     } catch (ResolverException e) {         throw SamlUtils.samlException("Cannot resolve entity metadata", e).     } }
false;public;0;4;;@Override public void close() {     Releasables.close(releasables). }
false;private,static;2;13;;private static void initialiseResolver(AbstractReloadingMetadataResolver resolver, RealmConfig config) throws ComponentInitializationException, PrivilegedActionException {     resolver.setRequireValidMetadata(true).     BasicParserPool pool = new BasicParserPool().     pool.initialize().     resolver.setParserPool(pool).     resolver.setId(config.name()).     SpecialPermission.check().     AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {         resolver.initialize().         return null.     }). }
false;public;0;3;;public String serviceProviderEntityId() {     return this.serviceProvider.getEntityId(). }
false;public;0;3;;public String assertionConsumerServiceURL() {     return this.serviceProvider.getAscUrl(). }
false;public;0;15;;public AuthnRequest buildAuthenticationRequest() {     final AuthnRequest authnRequest = new SamlAuthnRequestBuilder(serviceProvider, SAMLConstants.SAML2_POST_BINDING_URI, idpDescriptor.get(), SAMLConstants.SAML2_REDIRECT_BINDING_URI, Clock.systemUTC()).nameIDPolicy(nameIdPolicy).forceAuthn(forceAuthn).build().     if (logger.isTraceEnabled()) {         logger.trace("Constructed SAML Authentication Request: {}", SamlUtils.samlObjectToString(authnRequest)).     }     return authnRequest. }
true;public;2;13;/**  * Creates a SAML {@link LogoutRequest Single LogOut request} for the provided session, if the  * realm and IdP configuration support SLO. Otherwise returns {@code null}  *  * @see SamlRealmSettings#IDP_SINGLE_LOGOUT  */ ;/**  * Creates a SAML {@link LogoutRequest Single LogOut request} for the provided session, if the  * realm and IdP configuration support SLO. Otherwise returns {@code null}  *  * @see SamlRealmSettings#IDP_SINGLE_LOGOUT  */ public LogoutRequest buildLogoutRequest(NameID nameId, String session) {     if (useSingleLogout) {         final LogoutRequest logoutRequest = new SamlLogoutRequestMessageBuilder(Clock.systemUTC(), serviceProvider, idpDescriptor.get(), nameId, session).build().         if (logoutRequest != null && logger.isTraceEnabled()) {             logger.trace("Constructed SAML Logout Request: {}", SamlUtils.samlObjectToString(logoutRequest)).         }         return logoutRequest.     } else {         return null.     } }
true;public;1;8;/**  * Creates a SAML {@link org.opensaml.saml.saml2.core.LogoutResponse} to the provided requestID  */ ;/**  * Creates a SAML {@link org.opensaml.saml.saml2.core.LogoutResponse} to the provided requestID  */ public LogoutResponse buildLogoutResponse(String inResponseTo) {     final LogoutResponse logoutResponse = new SamlLogoutResponseBuilder(Clock.systemUTC(), serviceProvider, idpDescriptor.get(), inResponseTo, StatusCode.SUCCESS).build().     if (logoutResponse != null && logger.isTraceEnabled()) {         logger.trace("Constructed SAML Logout Response: {}", SamlUtils.samlObjectToString(logoutResponse)).     }     return logoutResponse. }
false;public;0;3;;public SigningConfiguration getSigningConfiguration() {     return serviceProvider.getSigningConfiguration(). }
false;public;0;3;;public SamlLogoutRequestHandler getLogoutHandler() {     return this.logoutHandler. }
false;public;1;4;;@Override public void onFileCreated(Path file) {     onFileChanged(file). }
false;public;1;4;;@Override public void onFileDeleted(Path file) {     onFileChanged(file). }
false;public;1;8;;@Override public void onFileChanged(Path file) {     try {         onChange.run().     } catch (Exception e) {         logger.warn(new ParameterizedMessage("An error occurred while reloading file {}", file), e).     } }
false;;1;3;;List<String> getAttribute(SamlAttributes attributes) {     return parser.apply(attributes). }
false;public;0;4;;@Override public String toString() {     return name. }
false;static;4;41;;static AttributeParser forSetting(Logger logger, SamlRealmSettings.AttributeSetting setting, RealmConfig realmConfig, boolean required) {     if (realmConfig.hasSetting(setting.getAttribute())) {         String attributeName = realmConfig.getSetting(setting.getAttribute()).         if (realmConfig.hasSetting(setting.getPattern())) {             Pattern regex = Pattern.compile(realmConfig.getSetting(setting.getPattern())).             return new AttributeParser("SAML Attribute [" + attributeName + "] with pattern [" + regex.pattern() + "] for [" + setting.name(realmConfig) + "]", attributes -> attributes.getAttributeValues(attributeName).stream().map(s -> {                 final Matcher matcher = regex.matcher(s).                 if (matcher.find() == false) {                     logger.debug("Attribute [{}] is [{}], which does not match [{}]", attributeName, s, regex.pattern()).                     return null.                 }                 final String value = matcher.group(1).                 if (Strings.isNullOrEmpty(value)) {                     logger.debug("Attribute [{}] is [{}], which does match [{}] but group(1) is empty", attributeName, s, regex.pattern()).                     return null.                 }                 return value.             }).filter(Objects::nonNull).collect(Collectors.toList())).         } else {             return new AttributeParser("SAML Attribute [" + attributeName + "] for [" + setting.name(realmConfig) + "]", attributes -> attributes.getAttributeValues(attributeName)).         }     } else if (required) {         throw new SettingsException("Setting [" + RealmSettings.getFullSettingKey(realmConfig, setting.getAttribute()) + "] is required").     } else if (realmConfig.hasSetting(setting.getPattern())) {         throw new SettingsException("Setting [" + RealmSettings.getFullSettingKey(realmConfig, setting.getPattern()) + "] cannot be set unless [" + RealmSettings.getFullSettingKey(realmConfig, setting.getAttribute()) + "] is also set").     } else {         return new AttributeParser("No SAML attribute for [" + setting.name(realmConfig) + "]", attributes -> Collections.emptyList()).     } }
