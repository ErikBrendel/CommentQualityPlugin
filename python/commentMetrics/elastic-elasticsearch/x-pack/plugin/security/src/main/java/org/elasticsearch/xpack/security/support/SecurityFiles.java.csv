commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;32;/**  * Atomically writes to the specified file a line per entry in the specified map using the specified transform to convert each entry to  * a line. The writing is done atomically in the following sense: first the lines are written to a temporary file and if the writing  * succeeds then the temporary file is moved to the specified path, replacing the file if it exists. If a failure occurs, any existing  * file is preserved, and the temporary file is cleaned up.  *  * @param <K>       the key type of the map entries  * @param <V>       the value type of the map entries  * @param path      the path  * @param map       the map whose entries to transform into lines  * @param transform the transform to convert each map entry to a line  */ ;/**  * Atomically writes to the specified file a line per entry in the specified map using the specified transform to convert each entry to  * a line. The writing is done atomically in the following sense: first the lines are written to a temporary file and if the writing  * succeeds then the temporary file is moved to the specified path, replacing the file if it exists. If a failure occurs, any existing  * file is preserved, and the temporary file is cleaned up.  *  * @param <K>       the key type of the map entries  * @param <V>       the value type of the map entries  * @param path      the path  * @param map       the map whose entries to transform into lines  * @param transform the transform to convert each map entry to a line  */ public static <K, V> void writeFileAtomically(final Path path, final Map<K, V> map, final Function<Map.Entry<K, V>, String> transform) {     Path tempFile = null.     try {         tempFile = Files.createTempFile(path.getParent(), path.getFileName().toString(), "tmp").         try (Writer writer = Files.newBufferedWriter(tempFile, StandardCharsets.UTF_8, CREATE, TRUNCATE_EXISTING, WRITE)) {             for (final Map.Entry<K, V> entry : map.entrySet()) {                 final StringBuilder sb = new StringBuilder().                 final String line = sb.append(transform.apply(entry)).append(System.lineSeparator()).toString().                 writer.write(line).             }         }         // get original permissions         if (Files.exists(path)) {             boolean supportsPosixAttributes = Environment.getFileStore(path).supportsFileAttributeView(PosixFileAttributeView.class).             if (supportsPosixAttributes) {                 setPosixAttributesOnTempFile(path, tempFile).             }         }         try {             Files.move(tempFile, path, REPLACE_EXISTING, ATOMIC_MOVE).         } catch (final AtomicMoveNotSupportedException e) {             Files.move(tempFile, path, REPLACE_EXISTING).         }     } catch (final IOException e) {         throw new UncheckedIOException(String.format(Locale.ROOT, "could not write file [%s]", path.toAbsolutePath()), e).     } finally {         // we are ignoring exceptions here, so we do not need handle whether or not tempFile was initialized nor if the file exists         IOUtils.deleteFilesIgnoringExceptions(tempFile).     } }
false;static;2;18;;static void setPosixAttributesOnTempFile(Path path, Path tempFile) throws IOException {     PosixFileAttributes attributes = Files.getFileAttributeView(path, PosixFileAttributeView.class).readAttributes().     PosixFileAttributeView tempFileView = Files.getFileAttributeView(tempFile, PosixFileAttributeView.class).     tempFileView.setPermissions(attributes.permissions()).     // will be notified by the FileAttributeChecker that the ownership has changed and needs to be corrected     try {         tempFileView.setOwner(attributes.owner()).     } catch (Exception e) {     }     try {         tempFileView.setGroup(attributes.group()).     } catch (Exception e) {     } }
