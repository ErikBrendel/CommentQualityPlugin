# id;timestamp;commentText;codeText;commentWords;codeWords
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1535383145;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<UserWithHash> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(authenticatedUserWithHash -> {_                    if (authenticatedUserWithHash != null && authenticatedUserWithHash.verify(token.credentials())) {_                        _                        final User user = authenticatedUserWithHash.user__                        logger.debug("realm [{}] authenticated user [{}], with roles [{}], from cache", name(), token.principal(),_                                user.roles())__                        listener.onResponse(AuthenticationResult.success(user))__                    } else {_                        _                        _                        _                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, e -> {_                    _                    _                    cache.invalidate(token.principal(), listenableCacheEntry)__                    authenticateWithCache(token, listener)__                }), threadPool.executor(ThreadPool.Names.GENERIC))__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() && authResult.getUser().enabled()) {_                        _                        final UserWithHash userWithHash = new UserWithHash(authResult.getUser(), token.credentials(), cacheHasher)__                        _                        _                        listenableCacheEntry.onResponse(userWithHash)__                    } else {_                        _                        listenableCacheEntry.onResponse(null)__                    }_                    _                    listener.onResponse(authResult)__                }, e -> {_                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,user,with,hash,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,authenticated,user,with,hash,if,authenticated,user,with,hash,null,authenticated,user,with,hash,verify,token,credentials,final,user,user,authenticated,user,with,hash,user,logger,debug,realm,authenticated,user,with,roles,from,cache,name,token,principal,user,roles,listener,on,response,authentication,result,success,user,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,e,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,thread,pool,executor,thread,pool,names,generic,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,auth,result,get,user,enabled,final,user,with,hash,user,with,hash,new,user,with,hash,auth,result,get,user,token,credentials,cache,hasher,listenable,cache,entry,on,response,user,with,hash,else,listenable,cache,entry,on,response,null,listener,on,response,auth,result,e,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1535552903;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<UserWithHash> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(authenticatedUserWithHash -> {_                    if (authenticatedUserWithHash != null && authenticatedUserWithHash.verify(token.credentials())) {_                        _                        final User user = authenticatedUserWithHash.user__                        logger.debug("realm [{}] authenticated user [{}], with roles [{}], from cache", name(), token.principal(),_                                user.roles())__                        listener.onResponse(AuthenticationResult.success(user))__                    } else {_                        _                        _                        _                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, e -> {_                    _                    _                    cache.invalidate(token.principal(), listenableCacheEntry)__                    authenticateWithCache(token, listener)__                }), threadPool.executor(ThreadPool.Names.GENERIC))__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() && authResult.getUser().enabled()) {_                        _                        final UserWithHash userWithHash = new UserWithHash(authResult.getUser(), token.credentials(), cacheHasher)__                        _                        _                        listenableCacheEntry.onResponse(userWithHash)__                    } else {_                        _                        listenableCacheEntry.onResponse(null)__                    }_                    _                    listener.onResponse(authResult)__                }, e -> {_                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,user,with,hash,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,authenticated,user,with,hash,if,authenticated,user,with,hash,null,authenticated,user,with,hash,verify,token,credentials,final,user,user,authenticated,user,with,hash,user,logger,debug,realm,authenticated,user,with,roles,from,cache,name,token,principal,user,roles,listener,on,response,authentication,result,success,user,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,e,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,thread,pool,executor,thread,pool,names,generic,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,auth,result,get,user,enabled,final,user,with,hash,user,with,hash,new,user,with,hash,auth,result,get,user,token,credentials,cache,hasher,listenable,cache,entry,on,response,user,with,hash,else,listenable,cache,entry,on,response,null,listener,on,response,auth,result,e,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1535723122;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<UserWithHash> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(authenticatedUserWithHash -> {_                    if (authenticatedUserWithHash != null && authenticatedUserWithHash.verify(token.credentials())) {_                        _                        handleCachedAuthentication(authenticatedUserWithHash.user, ActionListener.wrap(cacheResult -> {_                            if (cacheResult.isAuthenticated()) {_                                logger.debug("realm [{}] authenticated user [{}], with roles [{}]",_                                    name(), token.principal(), cacheResult.getUser().roles())__                            } else {_                                logger.debug("realm [{}] authenticated user [{}] from cache, but then failed [{}]",_                                    name(), token.principal(), cacheResult.getMessage())__                            }_                            listener.onResponse(cacheResult)__                        }, listener::onFailure))__                    } else {_                        _                        _                        _                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, e -> {_                    _                    _                    cache.invalidate(token.principal(), listenableCacheEntry)__                    authenticateWithCache(token, listener)__                }), threadPool.executor(ThreadPool.Names.GENERIC))__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() && authResult.getUser().enabled()) {_                        _                        final UserWithHash userWithHash = new UserWithHash(authResult.getUser(), token.credentials(), cacheHasher)__                        _                        _                        listenableCacheEntry.onResponse(userWithHash)__                    } else {_                        _                        listenableCacheEntry.onResponse(null)__                    }_                    _                    listener.onResponse(authResult)__                }, e -> {_                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,user,with,hash,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,authenticated,user,with,hash,if,authenticated,user,with,hash,null,authenticated,user,with,hash,verify,token,credentials,handle,cached,authentication,authenticated,user,with,hash,user,action,listener,wrap,cache,result,if,cache,result,is,authenticated,logger,debug,realm,authenticated,user,with,roles,name,token,principal,cache,result,get,user,roles,else,logger,debug,realm,authenticated,user,from,cache,but,then,failed,name,token,principal,cache,result,get,message,listener,on,response,cache,result,listener,on,failure,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,e,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,thread,pool,executor,thread,pool,names,generic,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,auth,result,get,user,enabled,final,user,with,hash,user,with,hash,new,user,with,hash,auth,result,get,user,token,credentials,cache,hasher,listenable,cache,entry,on,response,user,with,hash,else,listenable,cache,entry,on,response,null,listener,on,response,auth,result,e,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1539615817;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<UserWithHash> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(authenticatedUserWithHash -> {_                    if (authenticatedUserWithHash != null && authenticatedUserWithHash.verify(token.credentials())) {_                        _                        handleCachedAuthentication(authenticatedUserWithHash.user, ActionListener.wrap(cacheResult -> {_                            if (cacheResult.isAuthenticated()) {_                                logger.debug("realm [{}] authenticated user [{}], with roles [{}]",_                                    name(), token.principal(), cacheResult.getUser().roles())__                            } else {_                                logger.debug("realm [{}] authenticated user [{}] from cache, but then failed [{}]",_                                    name(), token.principal(), cacheResult.getMessage())__                            }_                            listener.onResponse(cacheResult)__                        }, listener::onFailure))__                    } else {_                        _                        _                        _                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, e -> {_                    _                    _                    cache.invalidate(token.principal(), listenableCacheEntry)__                    authenticateWithCache(token, listener)__                }), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext())__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() && authResult.getUser().enabled()) {_                        _                        final UserWithHash userWithHash = new UserWithHash(authResult.getUser(), token.credentials(), cacheHasher)__                        _                        _                        listenableCacheEntry.onResponse(userWithHash)__                    } else {_                        _                        listenableCacheEntry.onResponse(null)__                    }_                    _                    listener.onResponse(authResult)__                }, e -> {_                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,user,with,hash,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,authenticated,user,with,hash,if,authenticated,user,with,hash,null,authenticated,user,with,hash,verify,token,credentials,handle,cached,authentication,authenticated,user,with,hash,user,action,listener,wrap,cache,result,if,cache,result,is,authenticated,logger,debug,realm,authenticated,user,with,roles,name,token,principal,cache,result,get,user,roles,else,logger,debug,realm,authenticated,user,from,cache,but,then,failed,name,token,principal,cache,result,get,message,listener,on,response,cache,result,listener,on,failure,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,e,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,thread,pool,executor,thread,pool,names,generic,thread,pool,get,thread,context,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,auth,result,get,user,enabled,final,user,with,hash,user,with,hash,new,user,with,hash,auth,result,get,user,token,credentials,cache,hasher,listenable,cache,entry,on,response,user,with,hash,else,listenable,cache,entry,on,response,null,listener,on,response,auth,result,e,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1541476610;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<UserWithHash> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(authenticatedUserWithHash -> {_                    if (authenticatedUserWithHash != null && authenticatedUserWithHash.verify(token.credentials())) {_                        _                        handleCachedAuthentication(authenticatedUserWithHash.user, ActionListener.wrap(cacheResult -> {_                            if (cacheResult.isAuthenticated()) {_                                logger.debug("realm [{}] authenticated user [{}], with roles [{}]",_                                    name(), token.principal(), cacheResult.getUser().roles())__                            } else {_                                logger.debug("realm [{}] authenticated user [{}] from cache, but then failed [{}]",_                                    name(), token.principal(), cacheResult.getMessage())__                            }_                            listener.onResponse(cacheResult)__                        }, listener::onFailure))__                    } else {_                        _                        _                        _                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, e -> {_                    _                    _                    cache.invalidate(token.principal(), listenableCacheEntry)__                    authenticateWithCache(token, listener)__                }), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext())__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() && authResult.getUser().enabled()) {_                        _                        final UserWithHash userWithHash = new UserWithHash(authResult.getUser(), token.credentials(), cacheHasher)__                        _                        _                        listenableCacheEntry.onResponse(userWithHash)__                    } else {_                        _                        listenableCacheEntry.onResponse(null)__                    }_                    _                    listener.onResponse(authResult)__                }, e -> {_                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,user,with,hash,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,authenticated,user,with,hash,if,authenticated,user,with,hash,null,authenticated,user,with,hash,verify,token,credentials,handle,cached,authentication,authenticated,user,with,hash,user,action,listener,wrap,cache,result,if,cache,result,is,authenticated,logger,debug,realm,authenticated,user,with,roles,name,token,principal,cache,result,get,user,roles,else,logger,debug,realm,authenticated,user,from,cache,but,then,failed,name,token,principal,cache,result,get,message,listener,on,response,cache,result,listener,on,failure,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,e,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,thread,pool,executor,thread,pool,names,generic,thread,pool,get,thread,context,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,auth,result,get,user,enabled,final,user,with,hash,user,with,hash,new,user,with,hash,auth,result,get,user,token,credentials,cache,hasher,listenable,cache,entry,on,response,user,with,hash,else,listenable,cache,entry,on,response,null,listener,on,response,auth,result,e,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1545482054;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        assert cache != null__        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<UserWithHash> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(authenticatedUserWithHash -> {_                    if (authenticatedUserWithHash != null && authenticatedUserWithHash.verify(token.credentials())) {_                        _                        handleCachedAuthentication(authenticatedUserWithHash.user, ActionListener.wrap(cacheResult -> {_                            if (cacheResult.isAuthenticated()) {_                                logger.debug("realm [{}] authenticated user [{}], with roles [{}]",_                                    name(), token.principal(), cacheResult.getUser().roles())__                            } else {_                                logger.debug("realm [{}] authenticated user [{}] from cache, but then failed [{}]",_                                    name(), token.principal(), cacheResult.getMessage())__                            }_                            listener.onResponse(cacheResult)__                        }, listener::onFailure))__                    } else {_                        _                        _                        _                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, e -> {_                    _                    _                    cache.invalidate(token.principal(), listenableCacheEntry)__                    authenticateWithCache(token, listener)__                }), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext())__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() && authResult.getUser().enabled()) {_                        _                        final UserWithHash userWithHash = new UserWithHash(authResult.getUser(), token.credentials(), cacheHasher)__                        _                        _                        listenableCacheEntry.onResponse(userWithHash)__                    } else {_                        _                        listenableCacheEntry.onResponse(null)__                    }_                    _                    listener.onResponse(authResult)__                }, e -> {_                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,assert,cache,null,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,user,with,hash,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,authenticated,user,with,hash,if,authenticated,user,with,hash,null,authenticated,user,with,hash,verify,token,credentials,handle,cached,authentication,authenticated,user,with,hash,user,action,listener,wrap,cache,result,if,cache,result,is,authenticated,logger,debug,realm,authenticated,user,with,roles,name,token,principal,cache,result,get,user,roles,else,logger,debug,realm,authenticated,user,from,cache,but,then,failed,name,token,principal,cache,result,get,message,listener,on,response,cache,result,listener,on,failure,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,e,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,thread,pool,executor,thread,pool,names,generic,thread,pool,get,thread,context,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,auth,result,get,user,enabled,final,user,with,hash,user,with,hash,new,user,with,hash,auth,result,get,user,token,credentials,cache,hasher,listenable,cache,entry,on,response,user,with,hash,else,listenable,cache,entry,on,response,null,listener,on,response,auth,result,e,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener);1546962732;This validates the {@code token} while making sure there is only one inflight_request to the authentication source. Only successful responses are cached_and any subsequent requests, bearing the <b>same</b> password, will succeed_without reaching to the authentication source. A different password in a_subsequent request, however, will clear the cache and <b>try</b> to reach to_the authentication source.__@param token The authentication token_@param listener to be called at completion;private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {_        assert cache != null__        try {_            final AtomicBoolean authenticationInCache = new AtomicBoolean(true)__            final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {_                authenticationInCache.set(false)__                return new ListenableFuture<>()__            })__            if (authenticationInCache.get()) {_                _                listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {_                    final boolean credsMatch = cachedResult.verify(token.credentials())__                    if (cachedResult.authenticationResult.isAuthenticated()) {_                        if (credsMatch) {_                            _                            handleCachedAuthentication(cachedResult.user, ActionListener.wrap(cacheResult -> {_                                if (cacheResult.isAuthenticated()) {_                                    logger.debug("realm [{}] authenticated user [{}], with roles [{}]",_                                        name(), token.principal(), cacheResult.getUser().roles())__                                } else {_                                    logger.debug("realm [{}] authenticated user [{}] from cache, but then failed [{}]",_                                        name(), token.principal(), cacheResult.getMessage())__                                }_                                listener.onResponse(cacheResult)__                            }, listener::onFailure))__                        } else {_                            _                            _                            _                            _                            cache.invalidate(token.principal(), listenableCacheEntry)__                            authenticateWithCache(token, listener)__                        }_                    } else if (credsMatch) {_                        _                        _                        listener.onResponse(cachedResult.authenticationResult)__                    } else {_                        cache.invalidate(token.principal(), listenableCacheEntry)__                        authenticateWithCache(token, listener)__                    }_                }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext())__            } else {_                _                doAuthenticate(token, ActionListener.wrap(authResult -> {_                    if (authResult.isAuthenticated() == false || authResult.getUser().enabled() == false) {_                        _                        cache.invalidate(token.principal(), listenableCacheEntry)__                    }_                    _                    _                    _                    listenableCacheEntry.onResponse(new CachedResult(authResult, cacheHasher, authResult.getUser(), token.credentials()))__                    listener.onResponse(authResult)__                }, e -> {_                    cache.invalidate(token.principal(), listenableCacheEntry)__                    _                    listenableCacheEntry.onFailure(e)__                    _                    listener.onFailure(e)__                }))__            }_        } catch (final ExecutionException e) {_            listener.onFailure(e)__        }_    };this,validates,the,code,token,while,making,sure,there,is,only,one,inflight,request,to,the,authentication,source,only,successful,responses,are,cached,and,any,subsequent,requests,bearing,the,b,same,b,password,will,succeed,without,reaching,to,the,authentication,source,a,different,password,in,a,subsequent,request,however,will,clear,the,cache,and,b,try,b,to,reach,to,the,authentication,source,param,token,the,authentication,token,param,listener,to,be,called,at,completion;private,void,authenticate,with,cache,username,password,token,token,action,listener,authentication,result,listener,assert,cache,null,try,final,atomic,boolean,authentication,in,cache,new,atomic,boolean,true,final,listenable,future,cached,result,listenable,cache,entry,cache,compute,if,absent,token,principal,k,authentication,in,cache,set,false,return,new,listenable,future,if,authentication,in,cache,get,listenable,cache,entry,add,listener,action,listener,wrap,cached,result,final,boolean,creds,match,cached,result,verify,token,credentials,if,cached,result,authentication,result,is,authenticated,if,creds,match,handle,cached,authentication,cached,result,user,action,listener,wrap,cache,result,if,cache,result,is,authenticated,logger,debug,realm,authenticated,user,with,roles,name,token,principal,cache,result,get,user,roles,else,logger,debug,realm,authenticated,user,from,cache,but,then,failed,name,token,principal,cache,result,get,message,listener,on,response,cache,result,listener,on,failure,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,else,if,creds,match,listener,on,response,cached,result,authentication,result,else,cache,invalidate,token,principal,listenable,cache,entry,authenticate,with,cache,token,listener,listener,on,failure,thread,pool,executor,thread,pool,names,generic,thread,pool,get,thread,context,else,do,authenticate,token,action,listener,wrap,auth,result,if,auth,result,is,authenticated,false,auth,result,get,user,enabled,false,cache,invalidate,token,principal,listenable,cache,entry,listenable,cache,entry,on,response,new,cached,result,auth,result,cache,hasher,auth,result,get,user,token,credentials,listener,on,response,auth,result,e,cache,invalidate,token,principal,listenable,cache,entry,listenable,cache,entry,on,failure,e,listener,on,failure,e,catch,final,execution,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1524684173;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1527207653;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1528304883;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1531179852;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1533295538;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1535383145;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1535552903;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1535723122;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate_@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1539615817;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate._This method will respond with {@link AuthenticationResult#notHandled()} if_{@link CachingUsernamePasswordRealmSettings#AUTHC_ENABLED_SETTING authentication is not enabled}._@param authToken The authentication token_@param listener to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        if (authenticationEnabled == false) {_            listener.onResponse(AuthenticationResult.notHandled())__            return__        }_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,this,method,will,respond,with,link,authentication,result,not,handled,if,link,caching,username,password,realm,settings,authentication,is,not,enabled,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,if,authentication,enabled,false,listener,on,response,authentication,result,not,handled,return,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1541476610;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate._This method will respond with {@link AuthenticationResult#notHandled()} if_{@link CachingUsernamePasswordRealmSettings#AUTHC_ENABLED_SETTING authentication is not enabled}._@param authToken The authentication token_@param listener  to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        if (authenticationEnabled == false) {_            listener.onResponse(AuthenticationResult.notHandled())__            return__        }_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,this,method,will,respond,with,link,authentication,result,not,handled,if,link,caching,username,password,realm,settings,authentication,is,not,enabled,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,if,authentication,enabled,false,listener,on,response,authentication,result,not,handled,return,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1545482054;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate._This method will respond with {@link AuthenticationResult#notHandled()} if_{@link CachingUsernamePasswordRealmSettings#AUTHC_ENABLED_SETTING authentication is not enabled}._@param authToken The authentication token_@param listener  to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        if (authenticationEnabled == false) {_            listener.onResponse(AuthenticationResult.notHandled())__            return__        }_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,this,method,will,respond,with,link,authentication,result,not,handled,if,link,caching,username,password,realm,settings,authentication,is,not,enabled,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,if,authentication,enabled,false,listener,on,response,authentication,result,not,handled,return,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> @Override     public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener);1546962732;If the user exists in the cache (keyed by the principle name), then the password is validated_against a hash also stored in the cache.  Otherwise the subclass authenticates the user via_doAuthenticate._This method will respond with {@link AuthenticationResult#notHandled()} if_{@link CachingUsernamePasswordRealmSettings#AUTHC_ENABLED_SETTING authentication is not enabled}._@param authToken The authentication token_@param listener  to be called at completion;@Override_    public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {_        if (authenticationEnabled == false) {_            listener.onResponse(AuthenticationResult.notHandled())__            return__        }_        final UsernamePasswordToken token = (UsernamePasswordToken) authToken__        try {_            if (cache == null) {_                doAuthenticate(token, listener)__            } else {_                authenticateWithCache(token, listener)__            }_        } catch (final Exception e) {_            _            listener.onFailure(e)__        }_    };if,the,user,exists,in,the,cache,keyed,by,the,principle,name,then,the,password,is,validated,against,a,hash,also,stored,in,the,cache,otherwise,the,subclass,authenticates,the,user,via,do,authenticate,this,method,will,respond,with,link,authentication,result,not,handled,if,link,caching,username,password,realm,settings,authentication,is,not,enabled,param,auth,token,the,authentication,token,param,listener,to,be,called,at,completion;override,public,final,void,authenticate,authentication,token,auth,token,action,listener,authentication,result,listener,if,authentication,enabled,false,listener,on,response,authentication,result,not,handled,return,final,username,password,token,token,username,password,token,auth,token,try,if,cache,null,do,authenticate,token,listener,else,authenticate,with,cache,token,listener,catch,final,exception,e,listener,on,failure,e
CachingUsernamePasswordRealm -> protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener);1535723122;{@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache._The first {@code user} parameter is the user object that was found in the cache._The default implementation returns a {@link AuthenticationResult#success(User) success result} with the_provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.;protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {_        listener.onResponse(AuthenticationResult.success(user))__    };code,handle,cached,authentication,is,called,when,a,link,user,is,retrieved,from,the,cache,the,first,code,user,parameter,is,the,user,object,that,was,found,in,the,cache,the,default,implementation,returns,a,link,authentication,result,success,user,success,result,with,the,provided,user,but,sub,classes,can,return,a,different,code,user,object,or,an,unsuccessful,result;protected,void,handle,cached,authentication,user,user,action,listener,authentication,result,listener,listener,on,response,authentication,result,success,user
CachingUsernamePasswordRealm -> protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener);1539615817;{@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache._The first {@code user} parameter is the user object that was found in the cache._The default implementation returns a {@link AuthenticationResult#success(User) success result} with the_provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.;protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {_        listener.onResponse(AuthenticationResult.success(user))__    };code,handle,cached,authentication,is,called,when,a,link,user,is,retrieved,from,the,cache,the,first,code,user,parameter,is,the,user,object,that,was,found,in,the,cache,the,default,implementation,returns,a,link,authentication,result,success,user,success,result,with,the,provided,user,but,sub,classes,can,return,a,different,code,user,object,or,an,unsuccessful,result;protected,void,handle,cached,authentication,user,user,action,listener,authentication,result,listener,listener,on,response,authentication,result,success,user
CachingUsernamePasswordRealm -> protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener);1541476610;{@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache._The first {@code user} parameter is the user object that was found in the cache._The default implementation returns a {@link AuthenticationResult#success(User) success result} with the_provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.;protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {_        listener.onResponse(AuthenticationResult.success(user))__    };code,handle,cached,authentication,is,called,when,a,link,user,is,retrieved,from,the,cache,the,first,code,user,parameter,is,the,user,object,that,was,found,in,the,cache,the,default,implementation,returns,a,link,authentication,result,success,user,success,result,with,the,provided,user,but,sub,classes,can,return,a,different,code,user,object,or,an,unsuccessful,result;protected,void,handle,cached,authentication,user,user,action,listener,authentication,result,listener,listener,on,response,authentication,result,success,user
CachingUsernamePasswordRealm -> protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener);1545482054;{@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache._The first {@code user} parameter is the user object that was found in the cache._The default implementation returns a {@link AuthenticationResult#success(User) success result} with the_provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.;protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {_        listener.onResponse(AuthenticationResult.success(user))__    };code,handle,cached,authentication,is,called,when,a,link,user,is,retrieved,from,the,cache,the,first,code,user,parameter,is,the,user,object,that,was,found,in,the,cache,the,default,implementation,returns,a,link,authentication,result,success,user,success,result,with,the,provided,user,but,sub,classes,can,return,a,different,code,user,object,or,an,unsuccessful,result;protected,void,handle,cached,authentication,user,user,action,listener,authentication,result,listener,listener,on,response,authentication,result,success,user
CachingUsernamePasswordRealm -> protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener);1546962732;{@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache._The first {@code user} parameter is the user object that was found in the cache._The default implementation returns a {@link AuthenticationResult#success(User) success result} with the_provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.;protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {_        listener.onResponse(AuthenticationResult.success(user))__    };code,handle,cached,authentication,is,called,when,a,link,user,is,retrieved,from,the,cache,the,first,code,user,parameter,is,the,user,object,that,was,found,in,the,cache,the,default,implementation,returns,a,link,authentication,result,success,user,success,result,with,the,provided,user,but,sub,classes,can,return,a,different,code,user,object,or,an,unsuccessful,result;protected,void,handle,cached,authentication,user,user,action,listener,authentication,result,listener,listener,on,response,authentication,result,success,user
