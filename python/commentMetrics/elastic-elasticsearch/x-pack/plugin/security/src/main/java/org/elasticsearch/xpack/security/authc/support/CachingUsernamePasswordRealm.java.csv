commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;7;;@Override public final void expire(String username) {     if (cache != null) {         logger.trace("invalidating cache for user [{}] in realm [{}]", username, name()).         cache.invalidate(username).     } }
false;public,final;0;7;;@Override public final void expireAll() {     if (cache != null) {         logger.trace("invalidating cache for all users in realm [{}]", name()).         cache.invalidateAll().     } }
false;public;1;7;;@Override public UsernamePasswordToken token(ThreadContext threadContext) {     if (authenticationEnabled == false) {         return null.     }     return super.token(threadContext). }
false;public;1;4;;@Override public boolean supports(AuthenticationToken token) {     return authenticationEnabled && super.supports(token). }
true;public,final;2;18;/**  * If the user exists in the cache (keyed by the principle name), then the password is validated  * against a hash also stored in the cache.  Otherwise the subclass authenticates the user via  * doAuthenticate.  * This method will respond with {@link AuthenticationResult#notHandled()} if  * {@link CachingUsernamePasswordRealmSettings#AUTHC_ENABLED_SETTING authentication is not enabled}.  * @param authToken The authentication token  * @param listener  to be called at completion  */ ;/**  * If the user exists in the cache (keyed by the principle name), then the password is validated  * against a hash also stored in the cache.  Otherwise the subclass authenticates the user via  * doAuthenticate.  * This method will respond with {@link AuthenticationResult#notHandled()} if  * {@link CachingUsernamePasswordRealmSettings#AUTHC_ENABLED_SETTING authentication is not enabled}.  * @param authToken The authentication token  * @param listener  to be called at completion  */ @Override public final void authenticate(AuthenticationToken authToken, ActionListener<AuthenticationResult> listener) {     if (authenticationEnabled == false) {         listener.onResponse(AuthenticationResult.notHandled()).         return.     }     final UsernamePasswordToken token = (UsernamePasswordToken) authToken.     try {         if (cache == null) {             doAuthenticate(token, listener).         } else {             authenticateWithCache(token, listener).         }     } catch (final Exception e) {         // each realm should handle exceptions, if we get one here it should be considered fatal         listener.onFailure(e).     } }
true;private;2;66;/**  * This validates the {@code token} while making sure there is only one inflight  * request to the authentication source. Only successful responses are cached  * and any subsequent requests, bearing the <b>same</b> password, will succeed  * without reaching to the authentication source. A different password in a  * subsequent request, however, will clear the cache and <b>try</b> to reach to  * the authentication source.  *  * @param token The authentication token  * @param listener to be called at completion  */ ;/**  * This validates the {@code token} while making sure there is only one inflight  * request to the authentication source. Only successful responses are cached  * and any subsequent requests, bearing the <b>same</b> password, will succeed  * without reaching to the authentication source. A different password in a  * subsequent request, however, will clear the cache and <b>try</b> to reach to  * the authentication source.  *  * @param token The authentication token  * @param listener to be called at completion  */ private void authenticateWithCache(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener) {     assert cache != null.     try {         final AtomicBoolean authenticationInCache = new AtomicBoolean(true).         final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {             authenticationInCache.set(false).             return new ListenableFuture<>().         }).         if (authenticationInCache.get()) {             // there is a cached or an inflight authenticate request             listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {                 final boolean credsMatch = cachedResult.verify(token.credentials()).                 if (cachedResult.authenticationResult.isAuthenticated()) {                     if (credsMatch) {                         // cached credential hash matches the credential hash for this forestalled request                         handleCachedAuthentication(cachedResult.user, ActionListener.wrap(cacheResult -> {                             if (cacheResult.isAuthenticated()) {                                 logger.debug("realm [{}] authenticated user [{}], with roles [{}]", name(), token.principal(), cacheResult.getUser().roles()).                             } else {                                 logger.debug("realm [{}] authenticated user [{}] from cache, but then failed [{}]", name(), token.principal(), cacheResult.getMessage()).                             }                             listener.onResponse(cacheResult).                         }, listener::onFailure)).                     } else {                         // its credential hash does not match the                         // hash of the credential for this forestalled request.                         // clear cache and try to reach the authentication source again because password                         // might have changed there and the local cached hash got stale                         cache.invalidate(token.principal(), listenableCacheEntry).                         authenticateWithCache(token, listener).                     }                 } else if (credsMatch) {                     // not authenticated but instead of hammering reuse the result. a new                     // request will trigger a retried auth                     listener.onResponse(cachedResult.authenticationResult).                 } else {                     cache.invalidate(token.principal(), listenableCacheEntry).                     authenticateWithCache(token, listener).                 }             }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext()).         } else {             // attempt authentication against the authentication source             doAuthenticate(token, ActionListener.wrap(authResult -> {                 if (authResult.isAuthenticated() == false || authResult.getUser().enabled() == false) {                     // a new request should trigger a new authentication                     cache.invalidate(token.principal(), listenableCacheEntry).                 }                 // notify any forestalled request listeners. they will not reach to the                 // authentication request and instead will use this result if they contain                 // the same credentials                 listenableCacheEntry.onResponse(new CachedResult(authResult, cacheHasher, authResult.getUser(), token.credentials())).                 listener.onResponse(authResult).             }, e -> {                 cache.invalidate(token.principal(), listenableCacheEntry).                 // notify any staved off listeners. they will propagate this error                 listenableCacheEntry.onFailure(e).                 // notify the listener of the inflight authentication request                 listener.onFailure(e).             })).         }     } catch (final ExecutionException e) {         listener.onFailure(e).     } }
true;protected;2;3;/**  * {@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache.  * The first {@code user} parameter is the user object that was found in the cache.  * The default implementation returns a {@link AuthenticationResult#success(User) success result} with the  * provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.  */ ;/**  * {@code handleCachedAuthentication} is called when a {@link User} is retrieved from the cache.  * The first {@code user} parameter is the user object that was found in the cache.  * The default implementation returns a {@link AuthenticationResult#success(User) success result} with the  * provided user, but sub-classes can return a different {@code User} object, or an unsuccessful result.  */ protected void handleCachedAuthentication(User user, ActionListener<AuthenticationResult> listener) {     listener.onResponse(AuthenticationResult.success(user)). }
false;public;1;7;;@Override public void usageStats(ActionListener<Map<String, Object>> listener) {     super.usageStats(ActionListener.wrap(stats -> {         stats.put("cache", Collections.singletonMap("size", getCacheSize())).         listener.onResponse(stats).     }, listener::onFailure)). }
false;protected;0;3;;protected int getCacheSize() {     return cache == null ? -1 : cache.count(). }
false;protected,abstract;2;1;;protected abstract void doAuthenticate(UsernamePasswordToken token, ActionListener<AuthenticationResult> listener).
false;public,final;2;14;;@Override public final void lookupUser(String username, ActionListener<User> listener) {     try {         if (cache == null) {             doLookupUser(username, listener).         } else {             lookupWithCache(username, listener).         }     } catch (final Exception e) {         // each realm should handle exceptions, if we get one here it should be         // considered fatal         listener.onFailure(e).     } }
false;private;2;37;;private void lookupWithCache(String username, ActionListener<User> listener) {     assert cache != null.     try {         final AtomicBoolean lookupInCache = new AtomicBoolean(true).         final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(username, key -> {             lookupInCache.set(false).             return new ListenableFuture<>().         }).         if (false == lookupInCache.get()) {             // attempt lookup against the user directory             doLookupUser(username, ActionListener.wrap(user -> {                 final CachedResult result = new CachedResult(AuthenticationResult.notHandled(), cacheHasher, user, null).                 if (user == null) {                     // user not found, invalidate cache so that subsequent requests are forwarded to                     // the user directory                     cache.invalidate(username, listenableCacheEntry).                 }                 // notify forestalled request listeners                 listenableCacheEntry.onResponse(result).             }, e -> {                 // the next request should be forwarded, not halted by a failed lookup attempt                 cache.invalidate(username, listenableCacheEntry).                 // notify forestalled listeners                 listenableCacheEntry.onFailure(e).             })).         }         listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {             if (cachedResult.user != null) {                 listener.onResponse(cachedResult.user).             } else {                 listener.onResponse(null).             }         }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext()).     } catch (final ExecutionException e) {         listener.onFailure(e).     } }
false;protected,abstract;2;1;;protected abstract void doLookupUser(String username, ActionListener<User> listener).
false;private;1;3;;private boolean verify(SecureString password) {     return hash != null && Hasher.verifyHash(password, hash). }
