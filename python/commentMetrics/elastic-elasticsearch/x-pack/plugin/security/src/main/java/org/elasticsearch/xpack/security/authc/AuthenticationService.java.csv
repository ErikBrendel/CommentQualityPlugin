# id;timestamp;commentText;codeText;commentWords;codeWords
AuthenticationService -> Authenticator -> private void authenticateAsync();1524684173;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1532353780;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1532456624;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1533295538;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1535552903;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1535723122;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1539615817;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1541092382;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1541169206;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1543292387;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1547136376;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            extractToken(this::consumeToken)__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,extract,token,this,consume,token,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1549336917;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            checkForApiKey()__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,check,for,api,key,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1549399169;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            lookForExistingAuthentication((authentication) -> {_                if (authentication != null) {_                    listener.onResponse(authentication)__                } else {_                    tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                        if (userToken != null) {_                            writeAuthToContext(userToken.getAuthentication())__                        } else {_                            checkForApiKey()__                        }_                    }, e -> {_                        if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                            _                            _                            request.tamperedRequest()__                        }_                        listener.onFailure(e)__                    }))__                }_            })__        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,check,for,api,key,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> Authenticator -> private void authenticateAsync();1550154869;This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,_these operations are:__<ol>_<li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>_<li>look for a user token</li>_<li>token extraction {@link #extractToken(Consumer)}</li>_<li>token authentication {@link #consumeToken(AuthenticationToken)}</li>_<li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and_{@link #lookupRunAsUser(User, String, Consumer)}</li>_<li>write authentication into the context {@link #finishAuthentication(User)}</li>_</ol>;private void authenticateAsync() {_            if (defaultOrderedRealmList.isEmpty()) {_                _                _                listener.onResponse(null)__            } else {_                lookForExistingAuthentication((authentication) -> {_                    if (authentication != null) {_                        listener.onResponse(authentication)__                    } else {_                        tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {_                            if (userToken != null) {_                                writeAuthToContext(userToken.getAuthentication())__                            } else {_                                checkForApiKey()__                            }_                        }, e -> {_                            if (e instanceof ElasticsearchSecurityException &&_                                tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {_                                _                                _                                request.tamperedRequest()__                            }_                            listener.onFailure(e)__                        }))__                    }_                })__            }_        };this,method,starts,the,authentication,process,the,authentication,process,can,be,broken,down,into,distinct,operations,in,order,these,operations,are,ol,li,look,for,existing,authentication,link,look,for,existing,authentication,consumer,li,li,look,for,a,user,token,li,li,token,extraction,link,extract,token,consumer,li,li,token,authentication,link,consume,token,authentication,token,li,li,user,lookup,for,run,as,if,necessary,link,consume,user,user,map,and,link,lookup,run,as,user,user,string,consumer,li,li,write,authentication,into,the,context,link,finish,authentication,user,li,ol;private,void,authenticate,async,if,default,ordered,realm,list,is,empty,listener,on,response,null,else,look,for,existing,authentication,authentication,if,authentication,null,listener,on,response,authentication,else,token,service,get,and,validate,token,thread,context,action,listener,wrap,user,token,if,user,token,null,write,auth,to,context,user,token,get,authentication,else,check,for,api,key,e,if,e,instanceof,elasticsearch,security,exception,token,service,is,expired,token,exception,elasticsearch,security,exception,e,false,request,tampered,request,listener,on,failure,e
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1524684173;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1532353780;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1532456624;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1533295538;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1535552903;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1535723122;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1539615817;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1541092382;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1541169206;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1543292387;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1547136376;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1549336917;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1549399169;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener);1550154869;Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the request's context.__@param request   The request to be authenticated;public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {_        createAuthenticator(request, authenticationListener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,request,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,request,s,context,param,request,the,request,to,be,authenticated;public,void,authenticate,rest,request,request,action,listener,authentication,authentication,listener,create,authenticator,request,authentication,listener,authenticate,async
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1524684173;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1532353780;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1532456624;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1533295538;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1535552903;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1535723122;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1539615817;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1541092382;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1541169206;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1543292387;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1547136376;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1549336917;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1549399169;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer);1550154869;Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The_consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}_value;private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {_            Runnable action__            try {_                final Authentication authentication = Authentication.readFromContext(threadContext)__                if (authentication != null && request instanceof AuditableRestRequest) {_                    action = () -> listener.onFailure(request.tamperedRequest())__                } else {_                    action = () -> authenticationConsumer.accept(authentication)__                }_            } catch (Exception e) {_                logger.error((Supplier<?>)_                        () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request),_                        e)__                action = () -> listener.onFailure(request.tamperedRequest())__            }__            _            _            action.run()__        };looks,to,see,if,the,request,contains,an,existing,link,authentication,and,if,so,that,authentication,will,be,used,the,consumer,is,called,if,no,exception,was,thrown,while,trying,to,read,the,authentication,and,may,be,called,with,a,code,null,value;private,void,look,for,existing,authentication,consumer,authentication,authentication,consumer,runnable,action,try,final,authentication,authentication,authentication,read,from,context,thread,context,if,authentication,null,request,instanceof,auditable,rest,request,action,listener,on,failure,request,tampered,request,else,action,authentication,consumer,accept,authentication,catch,exception,e,logger,error,supplier,new,parameterized,message,caught,exception,while,trying,to,read,authentication,from,request,request,e,action,listener,on,failure,request,tampered,request,action,run
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1524684173;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    userListener.onFailure(Exceptions.authenticationError(result.getMessage(), result.getException()))__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                        new IteratingActionListener<>(ActionListener.wrap(_                                (user) -> consumeUser(user, messages),_                                (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,user,listener,on,failure,exceptions,authentication,error,result,get,message,result,get,exception,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1532353780;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    userListener.onFailure(Exceptions.authenticationError(result.getMessage(), result.getException()))__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                        new IteratingActionListener<>(ActionListener.wrap(_                                (user) -> consumeUser(user, messages),_                                (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,user,listener,on,failure,exceptions,authentication,error,result,get,message,result,get,exception,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1532456624;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                        new IteratingActionListener<>(ActionListener.wrap(_                                (user) -> consumeUser(user, messages),_                                (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1533295538;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                        new IteratingActionListener<>(ActionListener.wrap(_                                (user) -> consumeUser(user, messages),_                                (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1535552903;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                        new IteratingActionListener<>(ActionListener.wrap(_                                (user) -> consumeUser(user, messages),_                                (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1535723122;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                        new IteratingActionListener<>(ActionListener.wrap(_                                (user) -> consumeUser(user, messages),_                                (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1539615817;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1541092382;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1541169206;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1543292387;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = realms.asList()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,realms,as,list,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1547136376;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = getRealmList(authenticationToken.principal())__                final long startInvalidation = numInvalidation.get()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                if (lastSuccessfulAuthCache != null && startInvalidation == numInvalidation.get()) {_                                    lastSuccessfulAuthCache.put(authenticationToken.principal(), realm)__                                }_                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,get,realm,list,authentication,token,principal,final,long,start,invalidation,num,invalidation,get,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,if,last,successful,auth,cache,null,start,invalidation,num,invalidation,get,last,successful,auth,cache,put,authentication,token,principal,realm,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1549336917;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = getRealmList(authenticationToken.principal())__                final long startInvalidation = numInvalidation.get()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                if (lastSuccessfulAuthCache != null && startInvalidation == numInvalidation.get()) {_                                    lastSuccessfulAuthCache.put(authenticationToken.principal(), realm)__                                }_                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,get,realm,list,authentication,token,principal,final,long,start,invalidation,num,invalidation,get,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,if,last,successful,auth,cache,null,start,invalidation,num,invalidation,get,last,successful,auth,cache,put,authentication,token,principal,realm,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1549399169;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = getRealmList(authenticationToken.principal())__                final long startInvalidation = numInvalidation.get()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                if (lastSuccessfulAuthCache != null && startInvalidation == numInvalidation.get()) {_                                    lastSuccessfulAuthCache.put(authenticationToken.principal(), realm)__                                }_                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }__                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,get,realm,list,authentication,token,principal,final,long,start,invalidation,num,invalidation,get,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,if,last,successful,auth,cache,null,start,invalidation,num,invalidation,get,last,successful,auth,cache,put,authentication,token,principal,realm,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> private void consumeToken(AuthenticationToken token);1550154869;Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}_is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null_{@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}_if no exception was caught while trying to authenticate the token;private void consumeToken(AuthenticationToken token) {_            if (token == null) {_                handleNullToken()__            } else {_                authenticationToken = token__                final List<Realm> realmsList = getRealmList(authenticationToken.principal())__                final long startInvalidation = numInvalidation.get()__                final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>()__                final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {_                    if (realm.supports(authenticationToken)) {_                        realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {_                            assert result != null : "Realm " + realm + " produced a null authentication result"__                            if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {_                                _                                authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName)__                                authenticationResult = result__                                if (lastSuccessfulAuthCache != null && startInvalidation == numInvalidation.get()) {_                                    lastSuccessfulAuthCache.put(authenticationToken.principal(), realm)__                                }_                                userListener.onResponse(result.getUser())__                            } else {_                                _                                request.realmAuthenticationFailed(authenticationToken, realm.name())__                                if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {_                                    logger.info("Authentication of [{}] was terminated by realm [{}] - {}",_                                            authenticationToken.principal(), realm.name(), result.getMessage())__                                    Exception e = (result.getException() != null) ? result.getException()_                                            : Exceptions.authenticationError(result.getMessage())__                                    userListener.onFailure(e)__                                } else {_                                    if (result.getMessage() != null) {_                                        messages.put(realm, new Tuple<>(result.getMessage(), result.getException()))__                                    }_                                    userListener.onResponse(null)__                                }_                            }_                        }, (ex) -> {_                            logger.warn(new ParameterizedMessage(_                                    "An error occurred while attempting to authenticate [{}] against realm [{}]",_                                    authenticationToken.principal(), realm.name()), ex)__                            userListener.onFailure(ex)__                        }))__                    } else {_                        userListener.onResponse(null)__                    }_                }___                final IteratingActionListener<User, Realm> authenticatingListener =_                    new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap(_                        (user) -> consumeUser(user, messages),_                        (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext),_                        realmAuthenticatingConsumer, realmsList, threadContext)__                try {_                    authenticatingListener.run()__                } catch (Exception e) {_                    listener.onFailure(request.exceptionProcessingRequest(e, token))__                }_            }_        };consumes,the,link,authentication,token,provided,by,the,caller,in,the,case,of,a,code,null,token,link,handle,null,token,is,called,in,the,case,of,a,code,non,null,token,the,realms,are,iterated,over,and,the,first,realm,that,returns,a,non,null,link,user,is,the,authenticating,realm,and,iteration,is,stopped,this,user,is,then,passed,to,link,consume,user,user,map,if,no,exception,was,caught,while,trying,to,authenticate,the,token;private,void,consume,token,authentication,token,token,if,token,null,handle,null,token,else,authentication,token,token,final,list,realm,realms,list,get,realm,list,authentication,token,principal,final,long,start,invalidation,num,invalidation,get,final,map,realm,tuple,string,exception,messages,new,linked,hash,map,final,bi,consumer,realm,action,listener,user,realm,authenticating,consumer,realm,user,listener,if,realm,supports,authentication,token,realm,authenticate,authentication,token,action,listener,wrap,result,assert,result,null,realm,realm,produced,a,null,authentication,result,if,result,get,status,authentication,result,status,success,authenticated,by,new,realm,ref,realm,name,realm,type,node,name,authentication,result,result,if,last,successful,auth,cache,null,start,invalidation,num,invalidation,get,last,successful,auth,cache,put,authentication,token,principal,realm,user,listener,on,response,result,get,user,else,request,realm,authentication,failed,authentication,token,realm,name,if,result,get,status,authentication,result,status,terminate,logger,info,authentication,of,was,terminated,by,realm,authentication,token,principal,realm,name,result,get,message,exception,e,result,get,exception,null,result,get,exception,exceptions,authentication,error,result,get,message,user,listener,on,failure,e,else,if,result,get,message,null,messages,put,realm,new,tuple,result,get,message,result,get,exception,user,listener,on,response,null,ex,logger,warn,new,parameterized,message,an,error,occurred,while,attempting,to,authenticate,against,realm,authentication,token,principal,realm,name,ex,user,listener,on,failure,ex,else,user,listener,on,response,null,final,iterating,action,listener,user,realm,authenticating,listener,new,iterating,action,listener,context,preserving,action,listener,wrap,preserving,context,action,listener,wrap,user,consume,user,user,messages,e,listener,on,failure,request,exception,processing,request,e,token,thread,context,realm,authenticating,consumer,realms,list,thread,context,try,authenticating,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,token
AuthenticationService -> Authenticator -> void handleNullToken();1524684173;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1532353780;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1532456624;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1533295538;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1535552903;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1535723122;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1539615817;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1541092382;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1541169206;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1543292387;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1547136376;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null)__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null)__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1549336917;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.INTERNAL,_                    Collections.emptyMap())__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.ANONYMOUS,_                    Collections.emptyMap())__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,version,current,authentication,type,internal,collections,empty,map,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,version,current,authentication,type,anonymous,collections,empty,map,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1549399169;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.INTERNAL,_                    Collections.emptyMap())__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.ANONYMOUS,_                    Collections.emptyMap())__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,version,current,authentication,type,internal,collections,empty,map,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,version,current,authentication,type,anonymous,collections,empty,map,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void handleNullToken();1550154869;Handles failed extraction of an authentication token. This can happen in a few different scenarios:__<ul>_<li>this is an initial request from a client without preemptive authentication, so we must return an authentication_challenge</li>_<li>this is a request made internally within a node and there is a fallback user, which is typically the_{@link SystemUser}</li>_<li>anonymous access is enabled and this will be considered an anonymous request</li>_</ul>__Regardless of the scenario, this method will call the listener with either failure or success.;void handleNullToken() {_            final Authentication authentication__            if (fallbackUser != null) {_                RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName)__                authentication = new Authentication(fallbackUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.INTERNAL,_                    Collections.emptyMap())__            } else if (isAnonymousUserEnabled) {_                RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName)__                authentication = new Authentication(anonymousUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.ANONYMOUS,_                    Collections.emptyMap())__            } else {_                authentication = null__            }__            Runnable action__            if (authentication != null) {_                action = () -> writeAuthToContext(authentication)__            } else {_                action = () -> listener.onFailure(request.anonymousAccessDenied())__            }__            _            _            action.run()__        };handles,failed,extraction,of,an,authentication,token,this,can,happen,in,a,few,different,scenarios,ul,li,this,is,an,initial,request,from,a,client,without,preemptive,authentication,so,we,must,return,an,authentication,challenge,li,li,this,is,a,request,made,internally,within,a,node,and,there,is,a,fallback,user,which,is,typically,the,link,system,user,li,li,anonymous,access,is,enabled,and,this,will,be,considered,an,anonymous,request,li,ul,regardless,of,the,scenario,this,method,will,call,the,listener,with,either,failure,or,success;void,handle,null,token,final,authentication,authentication,if,fallback,user,null,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,fallback,user,authenticated,by,null,version,current,authentication,type,internal,collections,empty,map,else,if,is,anonymous,user,enabled,realm,ref,authenticated,by,new,realm,ref,node,name,authentication,new,authentication,anonymous,user,authenticated,by,null,version,current,authentication,type,anonymous,collections,empty,map,else,authentication,null,runnable,action,if,authentication,null,action,write,auth,to,context,authentication,else,action,listener,on,failure,request,anonymous,access,denied,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1524684173;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1532353780;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1532456624;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1533295538;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1535552903;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1535723122;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1539615817;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1541092382;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1541169206;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1543292387;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1547136376;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1549336917;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1549399169;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void writeAuthToContext(Authentication authentication);1550154869;Writes the authentication to the {@link ThreadContext} and then calls the listener if_successful;void writeAuthToContext(Authentication authentication) {_            request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser())__            Runnable action = () -> listener.onResponse(authentication)__            try {_                authentication.writeToContext(threadContext)__            } catch (Exception e) {_                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }__            _            _            action.run()__        };writes,the,authentication,to,the,link,thread,context,and,then,calls,the,listener,if,successful;void,write,auth,to,context,authentication,authentication,request,authentication,success,authentication,get,authenticated,by,get,name,authentication,get,user,runnable,action,listener,on,response,authentication,try,authentication,write,to,context,thread,context,catch,exception,e,action,listener,on,failure,request,exception,processing,request,e,authentication,token,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1524684173;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1532353780;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1532456624;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1533295538;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1535552903;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1535723122;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1539615817;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1541092382;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1541169206;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1543292387;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1547136376;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1549336917;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1549399169;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : realms) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,realms,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> void extractToken(Consumer<AuthenticationToken> consumer);1550154869;Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling_{@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if_no exception was caught during the extraction process and may be called with a {@code null} token.;void extractToken(Consumer<AuthenticationToken> consumer) {_            Runnable action = () -> consumer.accept(null)__            try {_                if (authenticationToken != null) {_                    action = () -> consumer.accept(authenticationToken)__                } else {_                    for (Realm realm : defaultOrderedRealmList) {_                        final AuthenticationToken token = realm.token(threadContext)__                        if (token != null) {_                            action = () -> consumer.accept(token)__                            break__                        }_                    }_                }_            } catch (Exception e) {_                logger.warn("An exception occurred while attempting to find authentication credentials", e)__                action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null))__            }__            action.run()__        };attempts,to,extract,an,link,authentication,token,from,the,request,by,iterating,over,the,link,realms,and,calling,link,realm,token,thread,context,the,first,non,null,token,that,is,returned,will,be,used,the,consumer,is,only,called,if,no,exception,was,caught,during,the,extraction,process,and,may,be,called,with,a,code,null,token;void,extract,token,consumer,authentication,token,consumer,runnable,action,consumer,accept,null,try,if,authentication,token,null,action,consumer,accept,authentication,token,else,for,realm,realm,default,ordered,realm,list,final,authentication,token,token,realm,token,thread,context,if,token,null,action,consumer,accept,token,break,catch,exception,e,logger,warn,an,exception,occurred,while,attempting,to,find,authentication,credentials,e,action,listener,on,failure,request,exception,processing,request,e,null,action,run
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1524684173;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1532353780;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1532456624;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1533295538;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1535552903;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1535723122;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1539615817;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1541092382;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1541169206;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1543292387;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1547136376;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1549336917;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1549399169;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages);1550154869;Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is_{@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as_functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup_the run as user in {@link #lookupRunAsUser(User, String, Consumer)};private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {_            if (user == null) {_                messages.forEach((realm, tuple) -> {_                    final String message = tuple.v1()__                    final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")"__                    logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause)__                })__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult)__                if (runAsEnabled) {_                    final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER)__                    if (runAsUsername != null && runAsUsername.isEmpty() == false) {_                        lookupRunAsUser(user, runAsUsername, this::finishAuthentication)__                    } else if (runAsUsername == null) {_                        finishAuthentication(user)__                    } else {_                        assert runAsUsername.isEmpty() : "the run as username may not be empty"__                        logger.debug("user [{}] attempted to runAs with an empty username", user.principal())__                        listener.onFailure(request.runAsDenied(_                                new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken))__                    }_                } else {_                    finishAuthentication(user)__                }_            }_        };consumes,the,link,user,that,resulted,from,attempting,to,authenticate,a,token,against,the,link,realms,when,the,user,is,code,null,authentication,fails,and,does,not,proceed,when,there,is,a,user,the,request,is,inspected,to,see,if,the,run,as,functionality,is,in,use,when,run,as,is,not,in,use,link,finish,authentication,user,is,called,otherwise,we,try,to,lookup,the,run,as,user,in,link,lookup,run,as,user,user,string,consumer;private,void,consume,user,user,user,map,realm,tuple,string,exception,messages,if,user,null,messages,for,each,realm,tuple,final,string,message,tuple,v1,final,string,cause,tuple,v2,null,caused,by,tuple,v2,logger,warn,authentication,to,realm,failed,realm,name,message,cause,listener,on,failure,request,authentication,failed,authentication,token,else,thread,context,put,transient,authentication,result,authentication,result,if,run,as,enabled,final,string,run,as,username,thread,context,get,header,authentication,service,field,if,run,as,username,null,run,as,username,is,empty,false,lookup,run,as,user,user,run,as,username,this,finish,authentication,else,if,run,as,username,null,finish,authentication,user,else,assert,run,as,username,is,empty,the,run,as,username,may,not,be,empty,logger,debug,user,attempted,to,run,as,with,an,empty,username,user,principal,listener,on,failure,request,run,as,denied,new,authentication,new,user,run,as,username,null,user,authenticated,by,lookedup,by,authentication,token,else,finish,authentication,user
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1524684173;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1532353780;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1532456624;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1533295538;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1535552903;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1535723122;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1539615817;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1541092382;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1541169206;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1543292387;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1547136376;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1549336917;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1549399169;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> void finishAuthentication(User finalUser);1550154869;Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is_one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext;void finishAuthentication(User finalUser) {_            if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {_                _                logger.debug("user [{}] is disabled. failing authentication", finalUser)__                listener.onFailure(request.authenticationFailed(authenticationToken))__            } else {_                final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy)__                writeAuthToContext(finalAuth)__            }_        };finishes,the,authentication,process,by,ensuring,the,returned,user,is,enabled,and,that,the,run,as,user,is,enabled,if,there,is,one,if,authentication,is,successful,this,method,also,ensures,that,the,authentication,is,written,to,the,thread,context;void,finish,authentication,user,final,user,if,final,user,enabled,false,final,user,authenticated,user,enabled,false,logger,debug,user,is,disabled,failing,authentication,final,user,listener,on,failure,request,authentication,failed,authentication,token,else,final,authentication,final,auth,new,authentication,final,user,authenticated,by,lookedup,by,write,auth,to,context,final,auth
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1524684173;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final List<Realm> realmsList = realms.asList()__            final BiConsumer<Realm, ActionListener<User>> realmLookupConsumer = (realm, lookupUserListener) ->_                    realm.lookupUser(runAsUsername, ActionListener.wrap((lookedupUser) -> {_                        if (lookedupUser != null) {_                            lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                            lookupUserListener.onResponse(lookedupUser)__                        } else {_                            lookupUserListener.onResponse(null)__                        }_                    }, lookupUserListener::onFailure))___            final IteratingActionListener<User, Realm> userLookupListener =_                    new IteratingActionListener<>(ActionListener.wrap((lookupUser) -> {_                                if (lookupUser == null) {_                                    _                                    userConsumer.accept(new User(runAsUsername, null, user))__                                } else {_                                    userConsumer.accept(new User(lookupUser, user))__                                }_                            },_                            (e) -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))),_                            realmLookupConsumer, realmsList, threadContext)__            try {_                userLookupListener.run()__            } catch (Exception e) {_                listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }_        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,list,realm,realms,list,realms,as,list,final,bi,consumer,realm,action,listener,user,realm,lookup,consumer,realm,lookup,user,listener,realm,lookup,user,run,as,username,action,listener,wrap,lookedup,user,if,lookedup,user,null,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,lookup,user,listener,on,response,lookedup,user,else,lookup,user,listener,on,response,null,lookup,user,listener,on,failure,final,iterating,action,listener,user,realm,user,lookup,listener,new,iterating,action,listener,action,listener,wrap,lookup,user,if,lookup,user,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,consumer,accept,new,user,lookup,user,user,e,listener,on,failure,request,exception,processing,request,e,authentication,token,realm,lookup,consumer,realms,list,thread,context,try,user,lookup,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1532353780;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final List<Realm> realmsList = realms.asList()__            final BiConsumer<Realm, ActionListener<User>> realmLookupConsumer = (realm, lookupUserListener) ->_                    realm.lookupUser(runAsUsername, ActionListener.wrap((lookedupUser) -> {_                        if (lookedupUser != null) {_                            lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                            lookupUserListener.onResponse(lookedupUser)__                        } else {_                            lookupUserListener.onResponse(null)__                        }_                    }, lookupUserListener::onFailure))___            final IteratingActionListener<User, Realm> userLookupListener =_                    new IteratingActionListener<>(ActionListener.wrap((lookupUser) -> {_                                if (lookupUser == null) {_                                    _                                    userConsumer.accept(new User(runAsUsername, null, user))__                                } else {_                                    userConsumer.accept(new User(lookupUser, user))__                                }_                            },_                            (e) -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))),_                            realmLookupConsumer, realmsList, threadContext)__            try {_                userLookupListener.run()__            } catch (Exception e) {_                listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }_        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,list,realm,realms,list,realms,as,list,final,bi,consumer,realm,action,listener,user,realm,lookup,consumer,realm,lookup,user,listener,realm,lookup,user,run,as,username,action,listener,wrap,lookedup,user,if,lookedup,user,null,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,lookup,user,listener,on,response,lookedup,user,else,lookup,user,listener,on,response,null,lookup,user,listener,on,failure,final,iterating,action,listener,user,realm,user,lookup,listener,new,iterating,action,listener,action,listener,wrap,lookup,user,if,lookup,user,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,consumer,accept,new,user,lookup,user,user,e,listener,on,failure,request,exception,processing,request,e,authentication,token,realm,lookup,consumer,realms,list,thread,context,try,user,lookup,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1532456624;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final List<Realm> realmsList = realms.asList()__            final BiConsumer<Realm, ActionListener<User>> realmLookupConsumer = (realm, lookupUserListener) ->_                    realm.lookupUser(runAsUsername, ActionListener.wrap((lookedupUser) -> {_                        if (lookedupUser != null) {_                            lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                            lookupUserListener.onResponse(lookedupUser)__                        } else {_                            lookupUserListener.onResponse(null)__                        }_                    }, lookupUserListener::onFailure))___            final IteratingActionListener<User, Realm> userLookupListener =_                    new IteratingActionListener<>(ActionListener.wrap((lookupUser) -> {_                                if (lookupUser == null) {_                                    _                                    userConsumer.accept(new User(runAsUsername, null, user))__                                } else {_                                    userConsumer.accept(new User(lookupUser, user))__                                }_                            },_                            (e) -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))),_                            realmLookupConsumer, realmsList, threadContext)__            try {_                userLookupListener.run()__            } catch (Exception e) {_                listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }_        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,list,realm,realms,list,realms,as,list,final,bi,consumer,realm,action,listener,user,realm,lookup,consumer,realm,lookup,user,listener,realm,lookup,user,run,as,username,action,listener,wrap,lookedup,user,if,lookedup,user,null,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,lookup,user,listener,on,response,lookedup,user,else,lookup,user,listener,on,response,null,lookup,user,listener,on,failure,final,iterating,action,listener,user,realm,user,lookup,listener,new,iterating,action,listener,action,listener,wrap,lookup,user,if,lookup,user,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,consumer,accept,new,user,lookup,user,user,e,listener,on,failure,request,exception,processing,request,e,authentication,token,realm,lookup,consumer,realms,list,thread,context,try,user,lookup,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1533295538;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final List<Realm> realmsList = realms.asList()__            final BiConsumer<Realm, ActionListener<User>> realmLookupConsumer = (realm, lookupUserListener) ->_                    realm.lookupUser(runAsUsername, ActionListener.wrap((lookedupUser) -> {_                        if (lookedupUser != null) {_                            lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                            lookupUserListener.onResponse(lookedupUser)__                        } else {_                            lookupUserListener.onResponse(null)__                        }_                    }, lookupUserListener::onFailure))___            final IteratingActionListener<User, Realm> userLookupListener =_                    new IteratingActionListener<>(ActionListener.wrap((lookupUser) -> {_                                if (lookupUser == null) {_                                    _                                    userConsumer.accept(new User(runAsUsername, null, user))__                                } else {_                                    userConsumer.accept(new User(lookupUser, user))__                                }_                            },_                            (e) -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))),_                            realmLookupConsumer, realmsList, threadContext)__            try {_                userLookupListener.run()__            } catch (Exception e) {_                listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }_        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,list,realm,realms,list,realms,as,list,final,bi,consumer,realm,action,listener,user,realm,lookup,consumer,realm,lookup,user,listener,realm,lookup,user,run,as,username,action,listener,wrap,lookedup,user,if,lookedup,user,null,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,lookup,user,listener,on,response,lookedup,user,else,lookup,user,listener,on,response,null,lookup,user,listener,on,failure,final,iterating,action,listener,user,realm,user,lookup,listener,new,iterating,action,listener,action,listener,wrap,lookup,user,if,lookup,user,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,consumer,accept,new,user,lookup,user,user,e,listener,on,failure,request,exception,processing,request,e,authentication,token,realm,lookup,consumer,realms,list,thread,context,try,user,lookup,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1535552903;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final List<Realm> realmsList = realms.asList()__            final BiConsumer<Realm, ActionListener<User>> realmLookupConsumer = (realm, lookupUserListener) ->_                    realm.lookupUser(runAsUsername, ActionListener.wrap((lookedupUser) -> {_                        if (lookedupUser != null) {_                            lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                            lookupUserListener.onResponse(lookedupUser)__                        } else {_                            lookupUserListener.onResponse(null)__                        }_                    }, lookupUserListener::onFailure))___            final IteratingActionListener<User, Realm> userLookupListener =_                    new IteratingActionListener<>(ActionListener.wrap((lookupUser) -> {_                                if (lookupUser == null) {_                                    _                                    userConsumer.accept(new User(runAsUsername, null, user))__                                } else {_                                    userConsumer.accept(new User(lookupUser, user))__                                }_                            },_                            (e) -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))),_                            realmLookupConsumer, realmsList, threadContext)__            try {_                userLookupListener.run()__            } catch (Exception e) {_                listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken))__            }_        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,list,realm,realms,list,realms,as,list,final,bi,consumer,realm,action,listener,user,realm,lookup,consumer,realm,lookup,user,listener,realm,lookup,user,run,as,username,action,listener,wrap,lookedup,user,if,lookedup,user,null,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,lookup,user,listener,on,response,lookedup,user,else,lookup,user,listener,on,response,null,lookup,user,listener,on,failure,final,iterating,action,listener,user,realm,user,lookup,listener,new,iterating,action,listener,action,listener,wrap,lookup,user,if,lookup,user,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,consumer,accept,new,user,lookup,user,user,e,listener,on,failure,request,exception,processing,request,e,authentication,token,realm,lookup,consumer,realms,list,thread,context,try,user,lookup,listener,run,catch,exception,e,listener,on,failure,request,exception,processing,request,e,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1535723122;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(realms.asList(), threadContext)__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,realms,as,list,thread,context,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1539615817;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(realms.asList(), threadContext)__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,realms,as,list,thread,context,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1541092382;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(realms.asList(), threadContext)__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,realms,as,list,thread,context,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1541169206;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(realms.asList(), threadContext)__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,realms,as,list,thread,context,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1543292387;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(realms.asList(), threadContext)__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,realms,as,list,thread,context,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1547136376;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(getRealmList(runAsUsername), threadContext)__            final long startInvalidationNum = numInvalidation.get()__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    if (lastSuccessfulAuthCache != null && startInvalidationNum == numInvalidation.get()) {_                        _                        _                        lastSuccessfulAuthCache.computeIfAbsent(runAsUsername, s -> realm)__                    }_                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,get,realm,list,run,as,username,thread,context,final,long,start,invalidation,num,num,invalidation,get,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,if,last,successful,auth,cache,null,start,invalidation,num,num,invalidation,get,last,successful,auth,cache,compute,if,absent,run,as,username,s,realm,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1549336917;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(getRealmList(runAsUsername), threadContext)__            final long startInvalidationNum = numInvalidation.get()__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    if (lastSuccessfulAuthCache != null && startInvalidationNum == numInvalidation.get()) {_                        _                        _                        lastSuccessfulAuthCache.computeIfAbsent(runAsUsername, s -> realm)__                    }_                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,get,realm,list,run,as,username,thread,context,final,long,start,invalidation,num,num,invalidation,get,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,if,last,successful,auth,cache,null,start,invalidation,num,num,invalidation,get,last,successful,auth,cache,compute,if,absent,run,as,username,s,realm,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1549399169;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(getRealmList(runAsUsername), threadContext)__            final long startInvalidationNum = numInvalidation.get()__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    if (lastSuccessfulAuthCache != null && startInvalidationNum == numInvalidation.get()) {_                        _                        _                        lastSuccessfulAuthCache.computeIfAbsent(runAsUsername, s -> realm)__                    }_                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,get,realm,list,run,as,username,thread,context,final,long,start,invalidation,num,num,invalidation,get,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,if,last,successful,auth,cache,null,start,invalidation,num,num,invalidation,get,last,successful,auth,cache,compute,if,absent,run,as,username,s,realm,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> Authenticator -> private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer);1550154869;Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of_if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the_names of users that exist using a timing attack;private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {_            final RealmUserLookup lookup = new RealmUserLookup(getRealmList(runAsUsername), threadContext)__            final long startInvalidationNum = numInvalidation.get()__            lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {_                if (tuple == null) {_                    _                    userConsumer.accept(new User(runAsUsername, null, user))__                } else {_                    User foundUser = Objects.requireNonNull(tuple.v1())__                    Realm realm = Objects.requireNonNull(tuple.v2())__                    lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName)__                    if (lastSuccessfulAuthCache != null && startInvalidationNum == numInvalidation.get()) {_                        _                        _                        lastSuccessfulAuthCache.computeIfAbsent(runAsUsername, s -> realm)__                    }_                    userConsumer.accept(new User(foundUser, user))__                }_            }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken))))__        };iterates,over,the,realms,and,attempts,to,lookup,the,run,as,user,by,the,given,username,the,consumer,will,be,called,regardless,of,if,the,user,is,found,or,not,with,a,non,null,user,we,do,not,fail,requests,if,the,run,as,user,is,not,found,as,that,can,leak,the,names,of,users,that,exist,using,a,timing,attack;private,void,lookup,run,as,user,final,user,user,string,run,as,username,consumer,user,user,consumer,final,realm,user,lookup,lookup,new,realm,user,lookup,get,realm,list,run,as,username,thread,context,final,long,start,invalidation,num,num,invalidation,get,lookup,lookup,run,as,username,action,listener,wrap,tuple,if,tuple,null,user,consumer,accept,new,user,run,as,username,null,user,else,user,found,user,objects,require,non,null,tuple,v1,realm,realm,objects,require,non,null,tuple,v2,lookedup,by,new,realm,ref,realm,name,realm,type,node,name,if,last,successful,auth,cache,null,start,invalidation,num,num,invalidation,get,last,successful,auth,cache,compute,if,absent,run,as,username,s,realm,user,consumer,accept,new,user,found,user,user,exception,listener,on,failure,request,exception,processing,request,exception,authentication,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1524684173;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1532353780;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1532456624;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1533295538;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1535552903;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1535723122;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1539615817;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1541092382;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1541169206;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1543292387;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1547136376;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1549336917;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1549399169;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message,                              AuthenticationToken token, ActionListener<Authentication> listener);1550154869;Authenticates the username and password that are provided as parameters. This will not look_at the values in the ThreadContext for Authentication.__@param action  The action of the message_@param message The message that resulted in this authenticate call_@param token   The token (credentials) to be authenticated;public void authenticate(String action, TransportMessage message,_                             AuthenticationToken token, ActionListener<Authentication> listener) {_        new Authenticator(action, message, null, listener).authenticateToken(token)__    };authenticates,the,username,and,password,that,are,provided,as,parameters,this,will,not,look,at,the,values,in,the,thread,context,for,authentication,param,action,the,action,of,the,message,param,message,the,message,that,resulted,in,this,authenticate,call,param,token,the,token,credentials,to,be,authenticated;public,void,authenticate,string,action,transport,message,message,authentication,token,token,action,listener,authentication,listener,new,authenticator,action,message,null,listener,authenticate,token,token
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1524684173;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1532353780;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1532456624;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1533295538;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1535552903;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1535723122;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1539615817;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1541092382;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1541169206;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1543292387;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1547136376;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1549336917;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1549399169;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
AuthenticationService -> public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener);1550154869;Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e._a user was indeed associated with the request and the credentials were verified to be valid), the method returns_the user and that user is then "attached" to the message's context. If no user was found to be attached to the given_message, then the given fallback user will be returned instead.__@param action        The action of the message_@param message       The message to be authenticated_@param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be_{@code null}, in which case there will be no fallback user and the success/failure of the_authentication will be based on the whether there's an attached user to in the message and_if there is, whether its credentials are valid.;public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {_        createAuthenticator(action, message, fallbackUser, listener).authenticateAsync()__    };authenticates,the,user,that,is,associated,with,the,given,message,if,the,user,was,authenticated,successfully,i,e,a,user,was,indeed,associated,with,the,request,and,the,credentials,were,verified,to,be,valid,the,method,returns,the,user,and,that,user,is,then,attached,to,the,message,s,context,if,no,user,was,found,to,be,attached,to,the,given,message,then,the,given,fallback,user,will,be,returned,instead,param,action,the,action,of,the,message,param,message,the,message,to,be,authenticated,param,fallback,user,the,default,user,that,will,be,assumed,if,no,other,user,is,attached,to,the,message,can,be,code,null,in,which,case,there,will,be,no,fallback,user,and,the,success,failure,of,the,authentication,will,be,based,on,the,whether,there,s,an,attached,user,to,in,the,message,and,if,there,is,whether,its,credentials,are,valid;public,void,authenticate,string,action,transport,message,message,user,fallback,user,action,listener,authentication,listener,create,authenticator,action,message,fallback,user,listener,authenticate,async
