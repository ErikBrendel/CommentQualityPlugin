commented;modifiers;parameterAmount;loc;comment;code
true;public;2;3;/**  * Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e.  * a user was indeed associated with the request and the credentials were verified to be valid), the method returns  * the user and that user is then "attached" to the request's context.  *  * @param request   The request to be authenticated  */ ;/**  * Authenticates the user that is associated with the given request. If the user was authenticated successfully (i.e.  * a user was indeed associated with the request and the credentials were verified to be valid), the method returns  * the user and that user is then "attached" to the request's context.  *  * @param request   The request to be authenticated  */ public void authenticate(RestRequest request, ActionListener<Authentication> authenticationListener) {     createAuthenticator(request, authenticationListener).authenticateAsync(). }
true;public;4;3;/**  * Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e.  * a user was indeed associated with the request and the credentials were verified to be valid), the method returns  * the user and that user is then "attached" to the message's context. If no user was found to be attached to the given  * message, then the given fallback user will be returned instead.  *  * @param action        The action of the message  * @param message       The message to be authenticated  * @param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be  *                      {@code null}, in which case there will be no fallback user and the success/failure of the  *                      authentication will be based on the whether there's an attached user to in the message and  *                      if there is, whether its credentials are valid.  */ ;/**  * Authenticates the user that is associated with the given message. If the user was authenticated successfully (i.e.  * a user was indeed associated with the request and the credentials were verified to be valid), the method returns  * the user and that user is then "attached" to the message's context. If no user was found to be attached to the given  * message, then the given fallback user will be returned instead.  *  * @param action        The action of the message  * @param message       The message to be authenticated  * @param fallbackUser  The default user that will be assumed if no other user is attached to the message. Can be  *                      {@code null}, in which case there will be no fallback user and the success/failure of the  *                      authentication will be based on the whether there's an attached user to in the message and  *                      if there is, whether its credentials are valid.  */ public void authenticate(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {     createAuthenticator(action, message, fallbackUser, listener).authenticateAsync(). }
true;public;4;4;/**  * Authenticates the username and password that are provided as parameters. This will not look  * at the values in the ThreadContext for Authentication.  *  * @param action  The action of the message  * @param message The message that resulted in this authenticate call  * @param token   The token (credentials) to be authenticated  */ ;/**  * Authenticates the username and password that are provided as parameters. This will not look  * at the values in the ThreadContext for Authentication.  *  * @param action  The action of the message  * @param message The message that resulted in this authenticate call  * @param token   The token (credentials) to be authenticated  */ public void authenticate(String action, TransportMessage message, AuthenticationToken token, ActionListener<Authentication> listener) {     new Authenticator(action, message, null, listener).authenticateToken(token). }
false;public;1;6;;public void expire(String principal) {     if (lastSuccessfulAuthCache != null) {         numInvalidation.incrementAndGet().         lastSuccessfulAuthCache.invalidate(principal).     } }
false;public;0;6;;public void expireAll() {     if (lastSuccessfulAuthCache != null) {         numInvalidation.incrementAndGet().         lastSuccessfulAuthCache.invalidateAll().     } }
false;public;2;7;;public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {     if (lastSuccessfulAuthCache != null) {         if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState)) {             expireAll().         }     } }
true;;2;3;// pkg private method for testing ;// pkg private method for testing Authenticator createAuthenticator(RestRequest request, ActionListener<Authentication> listener) {     return new Authenticator(request, listener). }
true;;4;3;// pkg private method for testing ;// pkg private method for testing Authenticator createAuthenticator(String action, TransportMessage message, User fallbackUser, ActionListener<Authentication> listener) {     return new Authenticator(action, message, fallbackUser, listener). }
true;;0;3;// pkg private method for testing ;// pkg private method for testing long getNumInvalidation() {     return numInvalidation.get(). }
true;private;0;29;/**  * This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,  * these operations are:  *  * <ol>  *     <li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>  *     <li>look for a user token</li>  *     <li>token extraction {@link #extractToken(Consumer)}</li>  *     <li>token authentication {@link #consumeToken(AuthenticationToken)}</li>  *     <li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and  *     {@link #lookupRunAsUser(User, String, Consumer)}</li>  *     <li>write authentication into the context {@link #finishAuthentication(User)}</li>  * </ol>  */ ;/**  * This method starts the authentication process. The authentication process can be broken down into distinct operations. In order,  * these operations are:  *  * <ol>  *     <li>look for existing authentication {@link #lookForExistingAuthentication(Consumer)}</li>  *     <li>look for a user token</li>  *     <li>token extraction {@link #extractToken(Consumer)}</li>  *     <li>token authentication {@link #consumeToken(AuthenticationToken)}</li>  *     <li>user lookup for run as if necessary {@link #consumeUser(User, Map)} and  *     {@link #lookupRunAsUser(User, String, Consumer)}</li>  *     <li>write authentication into the context {@link #finishAuthentication(User)}</li>  * </ol>  */ private void authenticateAsync() {     if (defaultOrderedRealmList.isEmpty()) {         // this happens when the license state changes between the call to authenticate and the actual invocation         // to get the realm list         listener.onResponse(null).     } else {         lookForExistingAuthentication((authentication) -> {             if (authentication != null) {                 listener.onResponse(authentication).             } else {                 tokenService.getAndValidateToken(threadContext, ActionListener.wrap(userToken -> {                     if (userToken != null) {                         writeAuthToContext(userToken.getAuthentication()).                     } else {                         checkForApiKey().                     }                 }, e -> {                     if (e instanceof ElasticsearchSecurityException && tokenService.isExpiredTokenException((ElasticsearchSecurityException) e) == false) {                         // intentionally ignore the returned exception. we call this primarily                         // for the auditing as we already have a purpose built exception                         request.tamperedRequest().                     }                     listener.onFailure(e).                 })).             }         }).     } }
false;private;0;25;;private void checkForApiKey() {     apiKeyService.authenticateWithApiKeyIfPresent(threadContext, ActionListener.wrap(authResult -> {         if (authResult.isAuthenticated()) {             final User user = authResult.getUser().             authenticatedBy = new RealmRef("_es_api_key", "_es_api_key", nodeName).             writeAuthToContext(new Authentication(user, authenticatedBy, null, Version.CURRENT, Authentication.AuthenticationType.API_KEY, authResult.getMetadata())).         } else if (authResult.getStatus() == AuthenticationResult.Status.TERMINATE) {             Exception e = (authResult.getException() != null) ? authResult.getException() : Exceptions.authenticationError(authResult.getMessage()).             listener.onFailure(e).         } else {             if (authResult.getMessage() != null) {                 if (authResult.getException() != null) {                     logger.warn(new ParameterizedMessage("Authentication using apikey failed - {}", authResult.getMessage()), authResult.getException()).                 } else {                     logger.warn("Authentication using apikey failed - {}", authResult.getMessage()).                 }             }             extractToken(this::consumeToken).         }     }, e -> listener.onFailure(request.exceptionProcessingRequest(e, null)))). }
true;private;1;20;/**  * Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The  * consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}  * value  */ ;/**  * Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The  * consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}  * value  */ private void lookForExistingAuthentication(Consumer<Authentication> authenticationConsumer) {     Runnable action.     try {         final Authentication authentication = Authentication.readFromContext(threadContext).         if (authentication != null && request instanceof AuditableRestRequest) {             action = () -> listener.onFailure(request.tamperedRequest()).         } else {             action = () -> authenticationConsumer.accept(authentication).         }     } catch (Exception e) {         logger.error((Supplier<?>) () -> new ParameterizedMessage("caught exception while trying to read authentication from request [{}]", request), e).         action = () -> listener.onFailure(request.tamperedRequest()).     }     // While we could place this call in the try block, the issue is that we catch all exceptions and could catch exceptions that     // have nothing to do with a tampered request.     action.run(). }
true;;1;21;// pkg-private accessor testing token extraction with a consumer ;/**  * Attempts to extract an {@link AuthenticationToken} from the request by iterating over the {@link Realms} and calling  * {@link Realm#token(ThreadContext)}. The first non-null token that is returned will be used. The consumer is only called if  * no exception was caught during the extraction process and may be called with a {@code null} token.  */ // pkg-private accessor testing token extraction with a consumer void extractToken(Consumer<AuthenticationToken> consumer) {     Runnable action = () -> consumer.accept(null).     try {         if (authenticationToken != null) {             action = () -> consumer.accept(authenticationToken).         } else {             for (Realm realm : defaultOrderedRealmList) {                 final AuthenticationToken token = realm.token(threadContext).                 if (token != null) {                     action = () -> consumer.accept(token).                     break.                 }             }         }     } catch (Exception e) {         logger.warn("An exception occurred while attempting to find authentication credentials", e).         action = () -> listener.onFailure(request.exceptionProcessingRequest(e, null)).     }     action.run(). }
true;private;1;59;/**  * Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}  * is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null  * {@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}  * if no exception was caught while trying to authenticate the token  */ ;/**  * Consumes the {@link AuthenticationToken} provided by the caller. In the case of a {@code null} token, {@link #handleNullToken()}  * is called. In the case of a {@code non-null} token, the realms are iterated over and the first realm that returns a non-null  * {@link User} is the authenticating realm and iteration is stopped. This user is then passed to {@link #consumeUser(User, Map)}  * if no exception was caught while trying to authenticate the token  */ private void consumeToken(AuthenticationToken token) {     if (token == null) {         handleNullToken().     } else {         authenticationToken = token.         final List<Realm> realmsList = getRealmList(authenticationToken.principal()).         final long startInvalidation = numInvalidation.get().         final Map<Realm, Tuple<String, Exception>> messages = new LinkedHashMap<>().         final BiConsumer<Realm, ActionListener<User>> realmAuthenticatingConsumer = (realm, userListener) -> {             if (realm.supports(authenticationToken)) {                 realm.authenticate(authenticationToken, ActionListener.wrap((result) -> {                     assert result != null : "Realm " + realm + " produced a null authentication result".                     if (result.getStatus() == AuthenticationResult.Status.SUCCESS) {                         // user was authenticated, populate the authenticated by information                         authenticatedBy = new RealmRef(realm.name(), realm.type(), nodeName).                         authenticationResult = result.                         if (lastSuccessfulAuthCache != null && startInvalidation == numInvalidation.get()) {                             lastSuccessfulAuthCache.put(authenticationToken.principal(), realm).                         }                         userListener.onResponse(result.getUser()).                     } else {                         // the user was not authenticated, call this so we can audit the correct event                         request.realmAuthenticationFailed(authenticationToken, realm.name()).                         if (result.getStatus() == AuthenticationResult.Status.TERMINATE) {                             logger.info("Authentication of [{}] was terminated by realm [{}] - {}", authenticationToken.principal(), realm.name(), result.getMessage()).                             Exception e = (result.getException() != null) ? result.getException() : Exceptions.authenticationError(result.getMessage()).                             userListener.onFailure(e).                         } else {                             if (result.getMessage() != null) {                                 messages.put(realm, new Tuple<>(result.getMessage(), result.getException())).                             }                             userListener.onResponse(null).                         }                     }                 }, (ex) -> {                     logger.warn(new ParameterizedMessage("An error occurred while attempting to authenticate [{}] against realm [{}]", authenticationToken.principal(), realm.name()), ex).                     userListener.onFailure(ex).                 })).             } else {                 userListener.onResponse(null).             }         }.         final IteratingActionListener<User, Realm> authenticatingListener = new IteratingActionListener<>(ContextPreservingActionListener.wrapPreservingContext(ActionListener.wrap((user) -> consumeUser(user, messages), (e) -> listener.onFailure(request.exceptionProcessingRequest(e, token))), threadContext), realmAuthenticatingConsumer, realmsList, threadContext).         try {             authenticatingListener.run().         } catch (Exception e) {             listener.onFailure(request.exceptionProcessingRequest(e, token)).         }     } }
false;private;1;20;;private List<Realm> getRealmList(String principal) {     final List<Realm> orderedRealmList = this.defaultOrderedRealmList.     if (lastSuccessfulAuthCache != null) {         final Realm lastSuccess = lastSuccessfulAuthCache.get(principal).         if (lastSuccess != null) {             final int index = orderedRealmList.indexOf(lastSuccess).             if (index > 0) {                 final List<Realm> smartOrder = new ArrayList<>(orderedRealmList.size()).                 smartOrder.add(lastSuccess).                 for (int i = 1. i < orderedRealmList.size(). i++) {                     if (i != index) {                         smartOrder.add(orderedRealmList.get(i)).                     }                 }                 return Collections.unmodifiableList(smartOrder).             }         }     }     return orderedRealmList. }
true;;0;25;// pkg-private for tests ;/**  * Handles failed extraction of an authentication token. This can happen in a few different scenarios:  *  * <ul>  *     <li>this is an initial request from a client without preemptive authentication, so we must return an authentication  *     challenge</li>  *     <li>this is a request made internally within a node and there is a fallback user, which is typically the  *     {@link SystemUser}</li>  *     <li>anonymous access is enabled and this will be considered an anonymous request</li>  * </ul>  *  * Regardless of the scenario, this method will call the listener with either failure or success.  */ // pkg-private for tests void handleNullToken() {     final Authentication authentication.     if (fallbackUser != null) {         RealmRef authenticatedBy = new RealmRef("__fallback", "__fallback", nodeName).         authentication = new Authentication(fallbackUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.INTERNAL, Collections.emptyMap()).     } else if (isAnonymousUserEnabled) {         RealmRef authenticatedBy = new RealmRef("__anonymous", "__anonymous", nodeName).         authentication = new Authentication(anonymousUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.ANONYMOUS, Collections.emptyMap()).     } else {         authentication = null.     }     Runnable action.     if (authentication != null) {         action = () -> writeAuthToContext(authentication).     } else {         action = () -> listener.onFailure(request.anonymousAccessDenied()).     }     // we assign the listener call to an action to avoid calling the listener within a try block and auditing the wrong thing when     // an exception bubbles up even after successful authentication     action.run(). }
true;private;2;27;/**  * Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is  * {@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as  * functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup  * the run as user in {@link #lookupRunAsUser(User, String, Consumer)}  */ ;/**  * Consumes the {@link User} that resulted from attempting to authenticate a token against the {@link Realms}. When the user is  * {@code null}, authentication fails and does not proceed. When there is a user, the request is inspected to see if the run as  * functionality is in use. When run as is not in use, {@link #finishAuthentication(User)} is called, otherwise we try to lookup  * the run as user in {@link #lookupRunAsUser(User, String, Consumer)}  */ private void consumeUser(User user, Map<Realm, Tuple<String, Exception>> messages) {     if (user == null) {         messages.forEach((realm, tuple) -> {             final String message = tuple.v1().             final String cause = tuple.v2() == null ? "" : " (Caused by " + tuple.v2() + ")".             logger.warn("Authentication to realm {} failed - {}{}", realm.name(), message, cause).         }).         listener.onFailure(request.authenticationFailed(authenticationToken)).     } else {         threadContext.putTransient(AuthenticationResult.THREAD_CONTEXT_KEY, authenticationResult).         if (runAsEnabled) {             final String runAsUsername = threadContext.getHeader(AuthenticationServiceField.RUN_AS_USER_HEADER).             if (runAsUsername != null && runAsUsername.isEmpty() == false) {                 lookupRunAsUser(user, runAsUsername, this::finishAuthentication).             } else if (runAsUsername == null) {                 finishAuthentication(user).             } else {                 assert runAsUsername.isEmpty() : "the run as username may not be empty".                 logger.debug("user [{}] attempted to runAs with an empty username", user.principal()).                 listener.onFailure(request.runAsDenied(new Authentication(new User(runAsUsername, null, user), authenticatedBy, lookedupBy), authenticationToken)).             }         } else {             finishAuthentication(user).         }     } }
true;private;3;20;/**  * Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of  * if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the  * names of users that exist using a timing attack  */ ;/**  * Iterates over the realms and attempts to lookup the run as user by the given username. The consumer will be called regardless of  * if the user is found or not, with a non-null user. We do not fail requests if the run as user is not found as that can leak the  * names of users that exist using a timing attack  */ private void lookupRunAsUser(final User user, String runAsUsername, Consumer<User> userConsumer) {     final RealmUserLookup lookup = new RealmUserLookup(getRealmList(runAsUsername), threadContext).     final long startInvalidationNum = numInvalidation.get().     lookup.lookup(runAsUsername, ActionListener.wrap(tuple -> {         if (tuple == null) {             // the user does not exist, but we still create a User object, which will later be rejected by authz             userConsumer.accept(new User(runAsUsername, null, user)).         } else {             User foundUser = Objects.requireNonNull(tuple.v1()).             Realm realm = Objects.requireNonNull(tuple.v2()).             lookedupBy = new RealmRef(realm.name(), realm.type(), nodeName).             if (lastSuccessfulAuthCache != null && startInvalidationNum == numInvalidation.get()) {                 // only cache this as last success if it doesn't exist since this really isn't an auth attempt but                 // this might provide a valid hint                 lastSuccessfulAuthCache.computeIfAbsent(runAsUsername, s -> realm).             }             userConsumer.accept(new User(foundUser, user)).         }     }, exception -> listener.onFailure(request.exceptionProcessingRequest(exception, authenticationToken)))). }
true;;1;10;/**  * Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is  * one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext  */ ;/**  * Finishes the authentication process by ensuring the returned user is enabled and that the run as user is enabled if there is  * one. If authentication is successful, this method also ensures that the authentication is written to the ThreadContext  */ void finishAuthentication(User finalUser) {     if (finalUser.enabled() == false || finalUser.authenticatedUser().enabled() == false) {         // TODO: these should be different log messages if the runas vs auth user is disabled?         logger.debug("user [{}] is disabled. failing authentication", finalUser).         listener.onFailure(request.authenticationFailed(authenticationToken)).     } else {         final Authentication finalAuth = new Authentication(finalUser, authenticatedBy, lookedupBy).         writeAuthToContext(finalAuth).     } }
true;;1;13;/**  * Writes the authentication to the {@link ThreadContext} and then calls the listener if  * successful  */ ;/**  * Writes the authentication to the {@link ThreadContext} and then calls the listener if  * successful  */ void writeAuthToContext(Authentication authentication) {     request.authenticationSuccess(authentication.getAuthenticatedBy().getName(), authentication.getUser()).     Runnable action = () -> listener.onResponse(authentication).     try {         authentication.writeToContext(threadContext).     } catch (Exception e) {         action = () -> listener.onFailure(request.exceptionProcessingRequest(e, authenticationToken)).     }     // we assign the listener call to an action to avoid calling the listener within a try block and auditing the wrong thing     // when an exception bubbles up even after successful authentication     action.run(). }
false;private;1;3;;private void authenticateToken(AuthenticationToken token) {     this.consumeToken(token). }
false;abstract;2;1;;abstract void realmAuthenticationFailed(AuthenticationToken token, String realm).
false;abstract;0;1;;abstract ElasticsearchSecurityException tamperedRequest().
false;abstract;2;1;;abstract ElasticsearchSecurityException exceptionProcessingRequest(Exception e, @Nullable AuthenticationToken token).
false;abstract;1;1;;abstract ElasticsearchSecurityException authenticationFailed(AuthenticationToken token).
false;abstract;0;1;;abstract ElasticsearchSecurityException anonymousAccessDenied().
false;abstract;2;1;;abstract ElasticsearchSecurityException runAsDenied(Authentication authentication, AuthenticationToken token).
false;abstract;2;1;;abstract void authenticationSuccess(String realm, User user).
false;;2;4;;@Override void authenticationSuccess(String realm, User user) {     auditTrail.authenticationSuccess(requestId, realm, user, action, message). }
false;;2;4;;@Override void realmAuthenticationFailed(AuthenticationToken token, String realm) {     auditTrail.authenticationFailed(requestId, realm, token, action, message). }
false;;0;5;;@Override ElasticsearchSecurityException tamperedRequest() {     auditTrail.tamperedRequest(requestId, action, message).     return new ElasticsearchSecurityException("failed to verify signed authentication information"). }
false;;2;9;;@Override ElasticsearchSecurityException exceptionProcessingRequest(Exception e, @Nullable AuthenticationToken token) {     if (token != null) {         auditTrail.authenticationFailed(requestId, token, action, message).     } else {         auditTrail.authenticationFailed(requestId, action, message).     }     return failureHandler.exceptionProcessingRequest(message, action, e, threadContext). }
false;;1;5;;@Override ElasticsearchSecurityException authenticationFailed(AuthenticationToken token) {     auditTrail.authenticationFailed(requestId, token, action, message).     return failureHandler.failedAuthentication(message, token, action, threadContext). }
false;;0;5;;@Override ElasticsearchSecurityException anonymousAccessDenied() {     auditTrail.anonymousAccessDenied(requestId, action, message).     return failureHandler.missingToken(message, action, threadContext). }
false;;2;5;;@Override ElasticsearchSecurityException runAsDenied(Authentication authentication, AuthenticationToken token) {     auditTrail.runAsDenied(requestId, authentication, action, message, EmptyAuthorizationInfo.INSTANCE).     return failureHandler.failedAuthentication(message, token, action, threadContext). }
false;public;0;4;;@Override public String toString() {     return "transport request action [" + action + "]". }
false;;2;4;;@Override void authenticationSuccess(String realm, User user) {     auditTrail.authenticationSuccess(requestId, realm, user, request). }
false;;2;4;;@Override void realmAuthenticationFailed(AuthenticationToken token, String realm) {     auditTrail.authenticationFailed(requestId, realm, token, request). }
false;;0;5;;@Override ElasticsearchSecurityException tamperedRequest() {     auditTrail.tamperedRequest(requestId, request).     return new ElasticsearchSecurityException("rest request attempted to inject a user"). }
false;;2;9;;@Override ElasticsearchSecurityException exceptionProcessingRequest(Exception e, @Nullable AuthenticationToken token) {     if (token != null) {         auditTrail.authenticationFailed(requestId, token, request).     } else {         auditTrail.authenticationFailed(requestId, request).     }     return failureHandler.exceptionProcessingRequest(request, e, threadContext). }
false;;1;5;;@Override ElasticsearchSecurityException authenticationFailed(AuthenticationToken token) {     auditTrail.authenticationFailed(requestId, token, request).     return failureHandler.failedAuthentication(request, token, threadContext). }
false;;0;5;;@Override ElasticsearchSecurityException anonymousAccessDenied() {     auditTrail.anonymousAccessDenied(requestId, request).     return failureHandler.missingToken(request, threadContext). }
false;;2;5;;@Override ElasticsearchSecurityException runAsDenied(Authentication authentication, AuthenticationToken token) {     auditTrail.runAsDenied(requestId, authentication, request, EmptyAuthorizationInfo.INSTANCE).     return failureHandler.failedAuthentication(request, token, threadContext). }
false;public;0;4;;@Override public String toString() {     return "rest request uri [" + request.uri() + "]". }
false;public,static;1;6;;public static void addSettings(List<Setting<?>> settings) {     settings.add(AuthenticationServiceField.RUN_AS_ENABLED).     settings.add(SUCCESS_AUTH_CACHE_ENABLED).     settings.add(SUCCESS_AUTH_CACHE_MAX_SIZE).     settings.add(SUCCESS_AUTH_CACHE_EXPIRE_AFTER_ACCESS). }
