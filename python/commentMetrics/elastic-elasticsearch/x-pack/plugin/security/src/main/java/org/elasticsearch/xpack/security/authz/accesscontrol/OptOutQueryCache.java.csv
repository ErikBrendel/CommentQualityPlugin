commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void close() throws ElasticsearchException {     licenseState.removeListener(this).     clear("close"). }
false;public;0;4;;@Override public void licenseStateChanged() {     clear("license state changed"). }
false;public;1;5;;@Override public void clear(String reason) {     logger.debug("full cache clear, reason [{}]", reason).     indicesQueryCache.clearIndex(index().getName()). }
false;public;2;28;;@Override public Weight doCache(Weight weight, QueryCachingPolicy policy) {     if (licenseState.isAuthAllowed() == false) {         logger.debug("not opting out of the query cache. authorization is not allowed").         return indicesQueryCache.doCache(weight, policy).     }     IndicesAccessControl indicesAccessControl = context.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY).     if (indicesAccessControl == null) {         logger.debug("opting out of the query cache. current request doesn't hold indices permissions").         return weight.     }     IndicesAccessControl.IndexAccessControl indexAccessControl = indicesAccessControl.getIndexPermissions(indexName).     if (indexAccessControl != null && indexAccessControl.getFieldPermissions().hasFieldLevelSecurity()) {         if (cachingIsSafe(weight, indexAccessControl)) {             logger.trace("not opting out of the query cache. request for index [{}] is safe to cache", indexName).             return indicesQueryCache.doCache(weight, policy).         } else {             logger.trace("opting out of the query cache. request for index [{}] is unsafe to cache", indexName).             return weight.         }     } else {         logger.trace("not opting out of the query cache. request for index [{}] has field level security disabled", indexName).         return indicesQueryCache.doCache(weight, policy).     } }
true;static;2;21;/**  * Returns true if its safe to use the query cache for this query.  */ ;/**  * Returns true if its safe to use the query cache for this query.  */ static boolean cachingIsSafe(Weight weight, IndicesAccessControl.IndexAccessControl permissions) {     // support caching for common queries, by inspecting the field     // TODO: If in the future there is a Query#extractFields() then we can do a better job     Set<String> fields = new HashSet<>().     try {         FieldExtractor.extractFields(weight.getQuery(), fields).     } catch (UnsupportedOperationException ok) {         // we don't know how to safely extract the fields of this query, don't cache.         return false.     }     // we successfully extracted the set of fields: check each one     for (String field : fields) {         // don't cache any internal fields (e.g. _field_names), these are complicated.         if (field.startsWith("_") || permissions.getFieldPermissions().grantsAccessTo(field) == false) {             return false.         }     }     // we can cache, all fields are ok     return true. }
