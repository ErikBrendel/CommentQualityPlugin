commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static void main(String[] args) throws Exception {     exit(new SamlMetadataCommand().main(args, Terminal.DEFAULT)). }
false;public;0;7;;@Override public void close() throws IOException {     super.close().     if (keyStoreWrapper != null) {         keyStoreWrapper.close().     } }
false;protected;3;14;;@Override protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {     // OpenSAML prints a lot of _stuff_ at info level, that really isn't needed in a command line tool.     Loggers.setLevel(LogManager.getLogger("org.opensaml"), Level.WARN).     final Logger logger = LogManager.getLogger(getClass()).     SamlUtils.initialize(logger).     final EntityDescriptor descriptor = buildEntityDescriptor(terminal, options, env).     Element element = possiblySignDescriptor(terminal, options, descriptor, env).     final Path xml = writeOutput(terminal, options, element).     validateXml(terminal, xml). }
true;;3;81;// package-protected for testing ;// package-protected for testing EntityDescriptor buildEntityDescriptor(Terminal terminal, OptionSet options, Environment env) throws Exception {     final boolean batch = options.has(batchSpec).     final RealmConfig realm = findRealm(terminal, options, env).     final Settings realmSettings = realm.settings().getByPrefix(RealmSettings.realmSettingPrefix(realm.identifier())).     terminal.println(Terminal.Verbosity.VERBOSE, "Using realm configuration\n=====\n" + realmSettings.toDelimitedString('\n') + "=====").     final Locale locale = findLocale(options).     terminal.println(Terminal.Verbosity.VERBOSE, "Using locale: " + locale.toLanguageTag()).     final SpConfiguration spConfig = SamlRealm.getSpConfiguration(realm).     final SamlSpMetadataBuilder builder = new SamlSpMetadataBuilder(locale, spConfig.getEntityId()).assertionConsumerServiceUrl(spConfig.getAscUrl()).singleLogoutServiceUrl(spConfig.getLogoutUrl()).encryptionCredentials(spConfig.getEncryptionCredentials()).signingCredential(spConfig.getSigningConfiguration().getCredential()).authnRequestsSigned(spConfig.getSigningConfiguration().shouldSign(AuthnRequest.DEFAULT_ELEMENT_LOCAL_NAME)).nameIdFormat(realm.getSetting(SamlRealmSettings.NAMEID_FORMAT)).serviceName(option(serviceNameSpec, options, env.settings().get("cluster.name"))).     Map<String, String> attributes = getAttributeNames(options, realm).     for (String attr : attributes.keySet()) {         final String name.         String friendlyName.         final String settingName = attributes.get(attr).         final String attributeSource = settingName == null ? "command line" : '"' + settingName + '"'.         if (attr.contains(":")) {             name = attr.             if (batch) {                 friendlyName = settingName.             } else {                 friendlyName = terminal.readText("What is the friendly name for " + attributeSource + " attribute \"" + attr + "\" [default: " + (settingName == null ? "none" : settingName) + "] ").                 if (Strings.isNullOrEmpty(friendlyName)) {                     friendlyName = settingName.                 }             }         } else {             if (batch) {                 throw new UserException(ExitCodes.CONFIG, "Option " + batchSpec.toString() + " is specified, but attribute " + attr + " appears to be a FriendlyName value").             }             friendlyName = attr.             name = requireText(terminal, "What is the standard (urn) name for " + attributeSource + " attribute \"" + attr + "\" (required): ").         }         terminal.println(Terminal.Verbosity.VERBOSE, "Requesting attribute '" + name + "' (FriendlyName: '" + friendlyName + "')").         builder.withAttribute(friendlyName, name).     }     if (options.has(orgNameSpec) && options.has(orgUrlSpec)) {         String name = orgNameSpec.value(options).         builder.organization(name, option(orgDisplayNameSpec, options, name), orgUrlSpec.value(options)).     }     if (options.has(contactsSpec)) {         terminal.println("\nPlease enter the personal details for each contact to be included in the metadata").         do {             final String givenName = requireText(terminal, "What is the given name for the contact: ").             final String surName = requireText(terminal, "What is the surname for the contact: ").             final String displayName = givenName + ' ' + surName.             final String email = requireText(terminal, "What is the email address for " + displayName + ": ").             String type.             while (true) {                 type = requireText(terminal, "What is the contact type for " + displayName + ": ").                 if (ContactInfo.TYPES.containsKey(type)) {                     break.                 } else {                     terminal.println("Type '" + type + "' is not valid. Valid values are " + Strings.collectionToCommaDelimitedString(ContactInfo.TYPES.keySet())).                 }             }             builder.withContact(type, givenName, surName, email).         } while (terminal.promptYesNo("Enter details for another contact", true)).     }     return builder.build(). }
true;;4;33;// package-protected for testing ;// package-protected for testing Element possiblySignDescriptor(Terminal terminal, OptionSet options, EntityDescriptor descriptor, Environment env) throws UserException {     try {         final EntityDescriptorMarshaller marshaller = new EntityDescriptorMarshaller().         if (options.has(signingPkcs12PathSpec) || (options.has(signingCertPathSpec) && options.has(signingKeyPathSpec))) {             Signature signature = (Signature) XMLObjectProviderRegistrySupport.getBuilderFactory().getBuilder(Signature.DEFAULT_ELEMENT_NAME).buildObject(Signature.DEFAULT_ELEMENT_NAME).             signature.setSigningCredential(buildSigningCredential(terminal, options, env)).             signature.setSignatureAlgorithm(SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA256).             signature.setCanonicalizationAlgorithm(SignatureConstants.ALGO_ID_C14N_EXCL_OMIT_COMMENTS).             descriptor.setSignature(signature).             Element element = marshaller.marshall(descriptor).             Signer.signObject(signature).             return element.         } else {             return marshaller.marshall(descriptor).         }     } catch (Exception e) {         String errorMessage.         if (e instanceof MarshallingException) {             errorMessage = "Error serializing Metadata to file".         } else if (e instanceof org.opensaml.xmlsec.signature.support.SignatureException) {             errorMessage = "Error attempting to sign Metadata".         } else {             errorMessage = "Error building signing credentials from provided keyPair".         }         terminal.println(Terminal.Verbosity.SILENT, errorMessage).         terminal.println("The following errors were found:").         printExceptions(terminal, e).         throw new UserException(ExitCodes.CANT_CREATE, "Unable to create metadata document").     } }
false;private;3;7;;private Path writeOutput(Terminal terminal, OptionSet options, Element element) throws Exception {     final Path outputFile = resolvePath(option(outputPathSpec, options, "saml-elasticsearch-metadata.xml")).     final Writer writer = Files.newBufferedWriter(outputFile).     SamlUtils.print(element, writer, true).     terminal.println("\nWrote SAML metadata to " + outputFile).     return outputFile. }
false;private;3;31;;private Credential buildSigningCredential(Terminal terminal, OptionSet options, Environment env) throws Exception {     X509Certificate signingCertificate.     PrivateKey signingKey.     char[] password = getChars(keyPasswordSpec.value(options)).     if (options.has(signingPkcs12PathSpec)) {         Path p12Path = resolvePath(signingPkcs12PathSpec.value(options)).         Map<Certificate, Key> keys = withPassword("certificate bundle (" + p12Path + ")", password, terminal, keyPassword -> CertParsingUtils.readPkcs12KeyPairs(p12Path, keyPassword, a -> keyPassword)).         if (keys.size() != 1) {             throw new IllegalArgumentException("expected a single key in file [" + p12Path.toAbsolutePath() + "] but found [" + keys.size() + "]").         }         final Map.Entry<Certificate, Key> pair = keys.entrySet().iterator().next().         signingCertificate = (X509Certificate) pair.getKey().         signingKey = (PrivateKey) pair.getValue().     } else {         Path cert = resolvePath(signingCertPathSpec.value(options)).         Path key = resolvePath(signingKeyPathSpec.value(options)).         final String resolvedSigningCertPath = cert.toAbsolutePath().toString().         Certificate[] certificates = CertParsingUtils.readCertificates(Collections.singletonList(resolvedSigningCertPath), env).         if (certificates.length != 1) {             throw new IllegalArgumentException("expected a single certificate in file [" + resolvedSigningCertPath + "] but found [" + certificates.length + "]").         }         signingCertificate = (X509Certificate) certificates[0].         signingKey = readSigningKey(key, password, terminal).     }     return new BasicX509Credential(signingCertificate, signingKey). }
false;private,static;4;13;;private static <T, E extends Exception> T withPassword(String description, char[] password, Terminal terminal, CheckedFunction<char[], T, E> body) throws E {     if (password == null) {         char[] promptedValue = terminal.readSecret("Enter password for " + description + " : ").         try {             return body.apply(promptedValue).         } finally {             Arrays.fill(promptedValue, (char) 0).         }     } else {         return body.apply(password).     } }
false;private,static;1;3;;private static char[] getChars(String password) {     return password == null ? null : password.toCharArray(). }
false;private,static;3;18;;private static PrivateKey readSigningKey(Path path, char[] password, Terminal terminal) throws Exception {     AtomicReference<char[]> passwordReference = new AtomicReference<>(password).     try {         return PemUtils.readPrivateKey(path, () -> {             if (password != null) {                 return password.             }             char[] promptedValue = terminal.readSecret("Enter password for the signing key (" + path.getFileName() + ") : ").             passwordReference.set(promptedValue).             return promptedValue.         }).     } finally {         if (passwordReference.get() != null) {             Arrays.fill(passwordReference.get(), (char) 0).         }     } }
false;private;2;11;;private void validateXml(Terminal terminal, Path xml) throws Exception {     try (InputStream xmlInput = Files.newInputStream(xml)) {         SamlUtils.validate(xmlInput, METADATA_SCHEMA).         terminal.println(Terminal.Verbosity.VERBOSE, "The generated metadata file conforms to the SAML metadata schema").     } catch (SAXException e) {         terminal.println(Terminal.Verbosity.SILENT, "Error - The generated metadata file does not conform to the SAML metadata schema").         terminal.println("While validating " + xml.toString() + " the follow errors were found:").         printExceptions(terminal, e).         throw new UserException(ExitCodes.CODE_ERROR, "Generated metadata is not valid").     } }
false;private;2;9;;private void printExceptions(Terminal terminal, Throwable throwable) {     terminal.println(" - " + throwable.getMessage()).     for (Throwable sup : throwable.getSuppressed()) {         printExceptions(terminal, sup).     }     if (throwable.getCause() != null && throwable.getCause() != throwable) {         printExceptions(terminal, throwable.getCause()).     } }
false;private;1;4;;@SuppressForbidden(reason = "CLI tool working from current directory") private Path resolvePath(String name) {     return PathUtils.get(name).normalize(). }
false;private;2;7;;private String requireText(Terminal terminal, String prompt) {     String value = null.     while (Strings.isNullOrEmpty(value)) {         value = terminal.readText(prompt).     }     return value. }
false;private;3;7;;private <T> T option(OptionSpec<T> spec, OptionSet options, T defaultValue) {     if (options.has(spec)) {         return spec.value(options).     } else {         return defaultValue.     } }
true;private;2;13;/**  * Map of saml-attribute name to configuration-setting name  */ ;/**  * Map of saml-attribute name to configuration-setting name  */ private Map<String, String> getAttributeNames(OptionSet options, RealmConfig realm) {     Map<String, String> attributes = new LinkedHashMap<>().     for (String a : attributeSpec.values(options)) {         attributes.put(a, null).     }     final String prefix = RealmSettings.realmSettingPrefix(realm.identifier()) + SamlRealmSettings.AttributeSetting.ATTRIBUTES_PREFIX.     final Settings attributeSettings = realm.settings().getByPrefix(prefix).     for (String key : sorted(attributeSettings.keySet())) {         final String attr = attributeSettings.get(key).         attributes.put(attr, key).     }     return attributes. }
true;private;1;3;// We sort this Set so that it is deterministic for testing ;// We sort this Set so that it is deterministic for testing private SortedSet<String> sorted(Set<String> strings) {     return new TreeSet<>(strings). }
true;private;3;51;/**  * @TODO REALM-SETTINGS[TIM] This can be redone a lot now the realm settings are keyed by type  */ ;/**  * @TODO REALM-SETTINGS[TIM] This can be redone a lot now the realm settings are keyed by type  */ private RealmConfig findRealm(Terminal terminal, OptionSet options, Environment env) throws UserException, IOException, Exception {     keyStoreWrapper = keyStoreFunction.apply(env).     final Settings settings.     if (keyStoreWrapper != null) {         // TODO: We currently do not support keystore passwords         keyStoreWrapper.decrypt(new char[0]).         final Settings.Builder settingsBuilder = Settings.builder().         settingsBuilder.put(env.settings(), true).         if (settingsBuilder.getSecureSettings() == null) {             settingsBuilder.setSecureSettings(keyStoreWrapper).         }         settings = settingsBuilder.build().     } else {         settings = env.settings().     }     final Map<RealmConfig.RealmIdentifier, Settings> realms = RealmSettings.getRealmSettings(settings).     if (options.has(realmSpec)) {         final String name = realmSpec.value(options).         final RealmConfig.RealmIdentifier identifier = new RealmConfig.RealmIdentifier(SamlRealmSettings.TYPE, name).         final Settings realmSettings = realms.get(identifier).         if (realmSettings == null) {             throw new UserException(ExitCodes.CONFIG, "No such realm '" + name + "' defined in " + env.configFile()).         }         if (isSamlRealm(identifier)) {             return buildRealm(identifier, env, settings).         } else {             throw new UserException(ExitCodes.CONFIG, "Realm '" + name + "' is not a SAML realm (is '" + identifier.getType() + "')").         }     } else {         final List<Map.Entry<RealmConfig.RealmIdentifier, Settings>> saml = realms.entrySet().stream().filter(entry -> isSamlRealm(entry.getKey())).collect(Collectors.toList()).         if (saml.isEmpty()) {             throw new UserException(ExitCodes.CONFIG, "There is no SAML realm configured in " + env.configFile()).         }         if (saml.size() > 1) {             terminal.println("Using configuration in " + env.configFile()).             terminal.println("Found multiple SAML realms: " + saml.stream().map(Map.Entry::getKey).map(Object::toString).collect(Collectors.joining(", "))).             terminal.println("Use the -" + optionName(realmSpec) + " option to specify an explicit realm").             throw new UserException(ExitCodes.CONFIG, "Found multiple SAML realms, please specify one with '-" + optionName(realmSpec) + "'").         }         final Map.Entry<RealmConfig.RealmIdentifier, Settings> entry = saml.get(0).         terminal.println("Building metadata for SAML realm " + entry.getKey()).         return buildRealm(entry.getKey(), env, settings).     } }
false;private;1;3;;private String optionName(OptionSpec<?> spec) {     return spec.options().get(0). }
false;private;3;3;;private RealmConfig buildRealm(RealmConfig.RealmIdentifier identifier, Environment env, Settings globalSettings) {     return new RealmConfig(identifier, globalSettings, env, new ThreadContext(globalSettings)). }
false;private;1;3;;private boolean isSamlRealm(RealmConfig.RealmIdentifier realmIdentifier) {     return SamlRealmSettings.TYPE.equals(realmIdentifier.getType()). }
false;private;1;7;;private Locale findLocale(OptionSet options) {     if (options.has(localeSpec)) {         return LocaleUtils.parse(localeSpec.value(options)).     } else {         return Locale.getDefault().     } }
true;;0;3;// For testing ;// For testing OptionParser getParser() {     return parser. }
