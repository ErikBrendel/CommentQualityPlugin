commented;modifiers;parameterAmount;loc;comment;code
true;;0;3;/**  * returns the pattern.  *  * @return the pattern  */ ;/**  * returns the pattern.  *  * @return the pattern  */ String getPattern() {     return pattern. }
false;private,static;2;13;;private static String addRule(String pattern, String rule) {     if (rule == null || rule.length() == 0) {         return pattern.     }     if (pattern.length() != 0) {         pattern += "|".     }     rule = rule.replaceAll("\\.", "\\\\.").     rule = rule.replaceAll("\\*", ".*").     rule = rule.replaceAll("\\?", ".").     pattern += '(' + rule + ')'.     return pattern. }
false;private;1;8;;private boolean isLocalhost(InetAddress address) {     try {         return address.isAnyLocalAddress() || address.isLoopbackAddress() || NetworkInterface.getByInetAddress(address) != null.     } catch (SocketException e) {         // not defined - ie. it's not a local address         return false.     } }
false;public;1;17;;@Override public boolean matches(InetSocketAddress remoteAddress) {     InetAddress inetAddress = remoteAddress.getAddress().     if (localhost) {         if (isLocalhost(inetAddress)) {             return true.         }     }     if (ipPattern != null) {         String format = NetworkAddress.format(inetAddress).         if (ipPattern.matcher(format).matches()) {             return true.         }     }     return checkHostName(inetAddress). }
false;private;1;9;;@SuppressForbidden(reason = "we compare the hostname of the address this is how netty3 did it and we keep it for BWC") private boolean checkHostName(InetAddress address) {     if (namePattern != null) {         if (namePattern.matcher(address.getHostName()).matches()) {             return true.         }     }     return false. }
false;public;0;4;;@Override public IpFilterRuleType ruleType() {     return ruleType. }
false;;0;3;;boolean isLocalhost() {     return localhost. }
