commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected Settings restClientSettings() {     String token = basicAuthHeaderValue("test_ilm", new SecureString("x-pack-test-password".toCharArray())).     return Settings.builder().put(ThreadContext.PREFIX + ".Authorization", token).build(). }
false;protected;0;7;;@Override protected Settings restAdminSettings() {     String token = basicAuthHeaderValue("test_admin", new SecureString("x-pack-test-password".toCharArray())).     return Settings.builder().put(ThreadContext.PREFIX + ".Authorization", token).build(). }
false;public;0;18;;@Before public void init() throws Exception {     Request request = new Request("PUT", "/_cluster/settings").     XContentBuilder pollIntervalEntity = JsonXContent.contentBuilder().     pollIntervalEntity.startObject().     pollIntervalEntity.startObject("transient").     pollIntervalEntity.field(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, "1s").     pollIntervalEntity.endObject().     pollIntervalEntity.endObject().     request.setJsonEntity(Strings.toString(pollIntervalEntity)).     assertOK(adminClient().performRequest(request)).     indexSettingsWithPolicy = Settings.builder().put(LifecycleSettings.LIFECYCLE_NAME, deletePolicy).put("number_of_shards", 1).put("number_of_replicas", 0).build().     createNewSingletonPolicy(deletePolicy, "delete", new DeleteAction()). }
true;public;0;5;/**  * Tests that a policy that simply deletes an index after 0s succeeds when an index  * with user `test_admin` is created referencing a policy created by `test_ilm` when both  * users have read/write permissions on the the index. The goal is to verify that one  * does not need to be the same user who created both the policy and the index to have the  * index be properly managed by ILM.  */ ;/**  * Tests that a policy that simply deletes an index after 0s succeeds when an index  * with user `test_admin` is created referencing a policy created by `test_ilm` when both  * users have read/write permissions on the the index. The goal is to verify that one  * does not need to be the same user who created both the policy and the index to have the  * index be properly managed by ILM.  */ public void testCanManageIndexAndPolicyDifferentUsers() throws Exception {     String index = "ilm-00001".     createIndexAsAdmin(index, indexSettingsWithPolicy, "").     assertBusy(() -> assertFalse(indexExists(index))). }
true;public;0;23;/**  * This tests the awkward behavior where an admin can have permissions to create a policy,  * but then not have permissions to operate on an index that was later associated with that policy by another  * user  */ ;/**  * This tests the awkward behavior where an admin can have permissions to create a policy,  * but then not have permissions to operate on an index that was later associated with that policy by another  * user  */ @SuppressWarnings("unchecked") public void testCanManageIndexWithNoPermissions() throws Exception {     createIndexAsAdmin("not-ilm", indexSettingsWithPolicy, "").     Request request = new Request("GET", "/not-ilm/_ilm/explain").     // test_ilm user does not have permissions on this index     ResponseException exception = expectThrows(ResponseException.class, () -> client().performRequest(request)).     assertThat(exception.getResponse().getStatusLine().getStatusCode(), equalTo(RestStatus.FORBIDDEN.getStatus())).     assertBusy(() -> {         Response response = adminClient().performRequest(request).         assertOK(response).         try (InputStream is = response.getEntity().getContent()) {             Map<String, Object> mapResponse = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true).             Map<String, Object> indexExplain = (Map<String, Object>) ((Map<String, Object>) mapResponse.get("indices")).get("not-ilm").             assertThat(indexExplain.get("managed"), equalTo(true)).             assertThat(indexExplain.get("step"), equalTo("ERROR")).             assertThat(indexExplain.get("failed_step"), equalTo("wait-for-shard-history-leases")).             Map<String, String> stepInfo = (Map<String, String>) indexExplain.get("step_info").             assertThat(stepInfo.get("type"), equalTo("security_exception")).             assertThat(stepInfo.get("reason"), equalTo("action [indices:monitor/stats] is unauthorized for user [test_ilm]")).         }     }). }
false;public;0;6;;public void testCanViewExplainOnUnmanagedIndex() throws Exception {     createIndexAsAdmin("view-only-ilm", indexSettingsWithPolicy, "").     Request request = new Request("GET", "/view-only-ilm/_ilm/explain").     // test_ilm user has permissions to view     assertOK(client().performRequest(request)). }
false;private;3;11;;private void createNewSingletonPolicy(String policy, String phaseName, LifecycleAction action) throws IOException {     Phase phase = new Phase(phaseName, TimeValue.ZERO, singletonMap(action.getWriteableName(), action)).     LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, singletonMap(phase.getName(), phase)).     XContentBuilder builder = jsonBuilder().     lifecyclePolicy.toXContent(builder, null).     final StringEntity entity = new StringEntity("{ \"policy\":" + Strings.toString(builder) + "}", ContentType.APPLICATION_JSON).     Request request = new Request("PUT", "_ilm/policy/" + policy).     request.setEntity(entity).     client().performRequest(request). }
false;private;3;6;;private void createIndexAsAdmin(String name, Settings settings, String mapping) throws IOException {     Request request = new Request("PUT", "/" + name).     request.setJsonEntity("{\n \"settings\": " + Strings.toString(settings) + ", \"mappings\" : {" + mapping + "} }").     assertOK(adminClient().performRequest(request)). }
