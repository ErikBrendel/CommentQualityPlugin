commented;modifiers;parameterAmount;loc;comment;code
false;public;3;4;;public void maybeRunAsyncAction(ClusterState clusterState, IndexMetaData indexMetaData, StepKey nextStepKey) {     String policyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(indexMetaData.getSettings()).     lifecycleRunner.maybeRunAsyncAction(clusterState, indexMetaData, policyName, nextStepKey). }
false;public;4;4;;public ClusterState moveClusterStateToStep(ClusterState currentState, String indexName, StepKey currentStepKey, StepKey nextStepKey) {     return IndexLifecycleRunner.moveClusterStateToStep(indexName, currentState, currentStepKey, nextStepKey, nowSupplier, policyRegistry, false). }
false;public;2;3;;public ClusterState moveClusterStateToFailedStep(ClusterState currentState, String[] indices) {     return lifecycleRunner.moveClusterStateToFailedStep(currentState, indices). }
false;public;0;38;;@Override public void onMaster() {     this.isMaster = true.     maybeScheduleJob().     ClusterState clusterState = clusterService.state().     IndexLifecycleMetadata currentMetadata = clusterState.metaData().custom(IndexLifecycleMetadata.TYPE).     if (currentMetadata != null) {         OperationMode currentMode = currentMetadata.getOperationMode().         if (OperationMode.STOPPED.equals(currentMode)) {             return.         }         // true until proven false by a run policy         boolean safeToStop = true.         // may have not been run due to master rollover         for (ObjectCursor<IndexMetaData> cursor : clusterState.metaData().indices().values()) {             IndexMetaData idxMeta = cursor.value.             String policyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(idxMeta.getSettings()).             if (Strings.isNullOrEmpty(policyName) == false) {                 StepKey stepKey = IndexLifecycleRunner.getCurrentStepKey(LifecycleExecutionState.fromIndexMetadata(idxMeta)).                 if (OperationMode.STOPPING == currentMode && stepKey != null && IGNORE_ACTIONS_MAINTENANCE_REQUESTED.contains(stepKey.getAction()) == false) {                     logger.info("skipping policy [{}] for index [{}]. stopping Index Lifecycle execution", policyName, idxMeta.getIndex().getName()).                     continue.                 }                 lifecycleRunner.maybeRunAsyncAction(clusterState, idxMeta, policyName, stepKey).                 // proven false!                 safeToStop = false.             }         }         if (safeToStop && OperationMode.STOPPING == currentMode) {             submitOperationModeUpdate(OperationMode.STOPPED).         }     } }
false;public;0;5;;@Override public void offMaster() {     this.isMaster = false.     cancelJob(). }
false;public;0;4;;@Override public String executorName() {     return ThreadPool.Names.MANAGEMENT. }
false;private;1;4;;private void updatePollInterval(TimeValue newInterval) {     this.pollInterval = newInterval.     maybeScheduleJob(). }
true;;0;3;// pkg-private for testing ;// pkg-private for testing SchedulerEngine getScheduler() {     return scheduler.get(). }
true;;0;3;// pkg-private for testing ;// pkg-private for testing SchedulerEngine.Job getScheduledJob() {     return scheduledJob. }
false;private,synchronized;0;17;;private synchronized void maybeScheduleJob() {     if (this.isMaster) {         if (scheduler.get() == null) {             // don't create scheduler if the node is shutting down             if (isClusterServiceStoppedOrClosed() == false) {                 scheduler.set(new SchedulerEngine(settings, clock)).                 scheduler.get().register(this).             }         }         // scheduler could be null if the node might be shutting down         if (scheduler.get() != null) {             scheduledJob = new SchedulerEngine.Job(XPackField.INDEX_LIFECYCLE, new TimeValueSchedule(pollInterval)).             scheduler.get().add(scheduledJob).         }     } }
false;public;1;7;;@Override public void clusterChanged(ClusterChangedEvent event) {     IndexLifecycleMetadata lifecycleMetadata = event.state().metaData().custom(IndexLifecycleMetadata.TYPE).     if (this.isMaster && lifecycleMetadata != null) {         triggerPolicies(event.state(), true).     } }
false;public;1;9;;@Override public void applyClusterState(ClusterChangedEvent event) {     if (event.localNodeMaster()) {         // keep idle until elected         if (event.state().metaData().custom(IndexLifecycleMetadata.TYPE) != null) {             policyRegistry.update(event.state()).         }     } }
false;private;0;6;;private void cancelJob() {     if (scheduler.get() != null) {         scheduler.get().remove(XPackField.INDEX_LIFECYCLE).         scheduledJob = null.     } }
false;public;1;7;;@Override public void triggered(SchedulerEngine.Event event) {     if (event.getJobName().equals(XPackField.INDEX_LIFECYCLE)) {         logger.trace("job triggered: " + event.getJobName() + ", " + event.getScheduledTime() + ", " + event.getTriggeredTime()).         triggerPolicies(clusterService.state(), false).     } }
true;;2;41;/**  * executes the policy execution on the appropriate indices by running cluster-state tasks per index.  *  * If stopping ILM was requested, and it is safe to stop, this will also be done here  * when possible after no policies are executed.  *  * @param clusterState the current cluster state  * @param fromClusterStateChange whether things are triggered from the cluster-state-listener or the scheduler  */ ;/**  * executes the policy execution on the appropriate indices by running cluster-state tasks per index.  *  * If stopping ILM was requested, and it is safe to stop, this will also be done here  * when possible after no policies are executed.  *  * @param clusterState the current cluster state  * @param fromClusterStateChange whether things are triggered from the cluster-state-listener or the scheduler  */ void triggerPolicies(ClusterState clusterState, boolean fromClusterStateChange) {     IndexLifecycleMetadata currentMetadata = clusterState.metaData().custom(IndexLifecycleMetadata.TYPE).     if (currentMetadata == null) {         return.     }     OperationMode currentMode = currentMetadata.getOperationMode().     if (OperationMode.STOPPED.equals(currentMode)) {         return.     }     // true until proven false by a run policy     boolean safeToStop = true.     // associated to a policy     for (ObjectCursor<IndexMetaData> cursor : clusterState.metaData().indices().values()) {         IndexMetaData idxMeta = cursor.value.         String policyName = LifecycleSettings.LIFECYCLE_NAME_SETTING.get(idxMeta.getSettings()).         if (Strings.isNullOrEmpty(policyName) == false) {             StepKey stepKey = IndexLifecycleRunner.getCurrentStepKey(LifecycleExecutionState.fromIndexMetadata(idxMeta)).             if (OperationMode.STOPPING == currentMode && stepKey != null && IGNORE_ACTIONS_MAINTENANCE_REQUESTED.contains(stepKey.getAction()) == false) {                 logger.info("skipping policy [" + policyName + "] for index [" + idxMeta.getIndex().getName() + "]. stopping Index Lifecycle execution").                 continue.             }             if (fromClusterStateChange) {                 lifecycleRunner.runPolicyAfterStateChange(policyName, idxMeta).             } else {                 lifecycleRunner.runPeriodicStep(policyName, idxMeta).             }             // proven false!             safeToStop = false.         }     }     if (safeToStop && OperationMode.STOPPING == currentMode) {         submitOperationModeUpdate(OperationMode.STOPPED).     } }
false;public,synchronized;0;11;;@Override public synchronized void close() {     // progress, which is that the cluster service is stopped and closed at some point prior to closing plugins     assert isClusterServiceStoppedOrClosed() : "close is called by closing the plugin, which is expected to happen after " + "the cluster service is stopped".     SchedulerEngine engine = scheduler.get().     if (engine != null) {         engine.stop().     } }
false;public;1;4;;public void submitOperationModeUpdate(OperationMode mode) {     clusterService.submitStateUpdateTask("ilm_operation_mode_update", new OperationModeUpdateTask(mode)). }
true;private;0;4;/**  * Method that checks if the lifecycle state of the cluster service is stopped or closed. This  * enhances the readability of the code.  */ ;/**  * Method that checks if the lifecycle state of the cluster service is stopped or closed. This  * enhances the readability of the code.  */ private boolean isClusterServiceStoppedOrClosed() {     final State state = clusterService.lifecycleState().     return state == State.STOPPED || state == State.CLOSED. }
