commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;SortedMap<String, LifecyclePolicyMetadata> getLifecyclePolicyMap() {     return lifecyclePolicyMap. }
false;;0;3;;Map<String, Step> getFirstStepMap() {     return firstStepMap. }
false;;0;3;;Map<String, Map<Step.StepKey, Step>> getStepMap() {     return stepMap. }
false;public;2;5;;@Override public void write(LifecyclePolicyMetadata value, StreamOutput out) {     // This is never called     throw new UnsupportedOperationException("should never be called"). }
false;public;2;5;;@Override public LifecyclePolicyMetadata read(StreamInput in, String key) {     // This is never called     throw new UnsupportedOperationException("should never be called"). }
false;public;1;53;;@SuppressWarnings({ "unchecked", "rawtypes" }) public void update(ClusterState clusterState) {     final IndexLifecycleMetadata meta = clusterState.metaData().custom(IndexLifecycleMetadata.TYPE).     assert meta != null : "IndexLifecycleMetadata cannot be null when updating the policy steps registry".     Diff<Map<String, LifecyclePolicyMetadata>> diff = DiffableUtils.diff(lifecyclePolicyMap, meta.getPolicyMetadatas(), DiffableUtils.getStringKeySerializer(), // correctly rebuilt     new DiffableUtils.NonDiffableValueSerializer<String, LifecyclePolicyMetadata>() {          @Override         public void write(LifecyclePolicyMetadata value, StreamOutput out) {             // This is never called             throw new UnsupportedOperationException("should never be called").         }          @Override         public LifecyclePolicyMetadata read(StreamInput in, String key) {             // This is never called             throw new UnsupportedOperationException("should never be called").         }     }).     DiffableUtils.MapDiff<String, LifecyclePolicyMetadata, DiffableUtils.KeySerializer<String>> mapDiff = (DiffableUtils.MapDiff) diff.     for (String deletedPolicyName : mapDiff.getDeletes()) {         lifecyclePolicyMap.remove(deletedPolicyName).         firstStepMap.remove(deletedPolicyName).         stepMap.remove(deletedPolicyName).     }     if (mapDiff.getUpserts().isEmpty() == false) {         for (LifecyclePolicyMetadata policyMetadata : mapDiff.getUpserts().values()) {             LifecyclePolicySecurityClient policyClient = new LifecyclePolicySecurityClient(client, ClientHelper.INDEX_LIFECYCLE_ORIGIN, policyMetadata.getHeaders()).             lifecyclePolicyMap.put(policyMetadata.getName(), policyMetadata).             List<Step> policyAsSteps = policyMetadata.getPolicy().toSteps(policyClient).             if (policyAsSteps.isEmpty() == false) {                 firstStepMap.put(policyMetadata.getName(), policyAsSteps.get(0)).                 final Map<Step.StepKey, Step> stepMapForPolicy = new HashMap<>().                 for (Step step : policyAsSteps) {                     assert ErrorStep.NAME.equals(step.getKey().getName()) == false : "unexpected error step in policy".                     stepMapForPolicy.put(step.getKey(), step).                 }                 logger.trace("updating cached steps for [{}] policy, new steps: {}", policyMetadata.getName(), stepMapForPolicy.keySet()).                 stepMap.put(policyMetadata.getName(), stepMapForPolicy).             }         }     } }
false;private;3;40;;private List<Step> parseStepsFromPhase(String policy, String currentPhase, String phaseDef) throws IOException {     final PhaseExecutionInfo phaseExecutionInfo.     LifecyclePolicyMetadata policyMetadata = lifecyclePolicyMap.get(policy).     if (policyMetadata == null) {         throw new IllegalStateException("unable to parse steps for policy [" + policy + "] as it doesn't exist").     }     LifecyclePolicy currentPolicy = policyMetadata.getPolicy().     final LifecyclePolicy policyToExecute.     if (InitializePolicyContextStep.INITIALIZATION_PHASE.equals(phaseDef) || TerminalPolicyStep.COMPLETED_PHASE.equals(phaseDef)) {         // It is ok to re-use potentially modified policy here since we are in an initialization or completed phase         policyToExecute = currentPolicy.     } else {         // if the current phase definition describes an internal step/phase, do not parse         try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {             phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase).         }         Map<String, Phase> phaseMap = new HashMap<>(currentPolicy.getPhases()).         if (phaseExecutionInfo.getPhase() != null) {             phaseMap.put(currentPhase, phaseExecutionInfo.getPhase()).         }         policyToExecute = new LifecyclePolicy(currentPolicy.getType(), currentPolicy.getName(), phaseMap).     }     LifecyclePolicySecurityClient policyClient = new LifecyclePolicySecurityClient(client, ClientHelper.INDEX_LIFECYCLE_ORIGIN, lifecyclePolicyMap.get(policy).getHeaders()).     final List<Step> steps = policyToExecute.toSteps(policyClient).     // Build a list of steps that correspond with the phase the index is currently in     final List<Step> phaseSteps.     if (steps == null) {         phaseSteps = new ArrayList<>().     } else {         phaseSteps = steps.stream().filter(e -> e.getKey().getPhase().equals(currentPhase)).collect(Collectors.toList()).     }     logger.trace("parsed steps for policy [{}] in phase [{}], definition: [{}], steps: [{}]", policy, currentPhase, phaseDef, phaseSteps).     return phaseSteps. }
false;public;2;35;;@Nullable public Step getStep(final IndexMetaData indexMetaData, final Step.StepKey stepKey) {     if (ErrorStep.NAME.equals(stepKey.getName())) {         return new ErrorStep(new Step.StepKey(stepKey.getPhase(), stepKey.getAction(), ErrorStep.NAME)).     }     final String phase = stepKey.getPhase().     final String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME).     final Index index = indexMetaData.getIndex().     if (policyName == null) {         throw new IllegalArgumentException("failed to retrieve step " + stepKey + " as index [" + index.getName() + "] has no policy").     }     // parse phase steps from the phase definition in the index settings     final String phaseJson = Optional.ofNullable(LifecycleExecutionState.fromIndexMetadata(indexMetaData).getPhaseDefinition()).orElse(InitializePolicyContextStep.INITIALIZATION_PHASE).     final List<Step> phaseSteps.     try {         phaseSteps = parseStepsFromPhase(policyName, phase, phaseJson).     } catch (IOException e) {         throw new ElasticsearchException("failed to load cached steps for " + stepKey, e).     } catch (XContentParseException parseErr) {         throw new XContentParseException(parseErr.getLocation(), "failed to load steps for " + stepKey + " from [" + phaseJson + "]", parseErr).     }     assert phaseSteps.stream().allMatch(step -> step.getKey().getPhase().equals(phase)) : "expected phase steps loaded from phase definition for [" + index.getName() + "] to be in phase [" + phase + "] but they were not, steps: " + phaseSteps.     // Return the step that matches the given stepKey or else null if we couldn't find it     return phaseSteps.stream().filter(step -> step.getKey().equals(stepKey)).findFirst().orElse(null). }
true;public;2;8;/**  * Given a policy and stepkey, return true if a step exists, false otherwise  */ ;/**  * Given a policy and stepkey, return true if a step exists, false otherwise  */ public boolean stepExists(final String policy, final Step.StepKey stepKey) {     Map<Step.StepKey, Step> steps = stepMap.get(policy).     if (steps == null) {         return false.     } else {         return steps.containsKey(stepKey).     } }
false;public;1;3;;public boolean policyExists(final String policy) {     return lifecyclePolicyMap.containsKey(policy). }
false;public;1;3;;public Step getFirstStep(String policy) {     return firstStepMap.get(policy). }
false;public;2;18;;public TimeValue getIndexAgeForPhase(final String policy, final String phase) {     // These built in phases should never wait     if (InitializePolicyContextStep.INITIALIZATION_PHASE.equals(phase) || TerminalPolicyStep.COMPLETED_PHASE.equals(phase)) {         return TimeValue.ZERO.     }     final LifecyclePolicyMetadata meta = lifecyclePolicyMap.get(policy).     if (meta == null) {         throw new IllegalArgumentException("no policy found with name \"" + policy + "\"").     } else {         final Phase retrievedPhase = meta.getPolicy().getPhases().get(phase).         if (retrievedPhase == null) {             // We don't have that phase registered, proceed right through it             return TimeValue.ZERO.         } else {             return retrievedPhase.getMinimumAge().         }     } }
