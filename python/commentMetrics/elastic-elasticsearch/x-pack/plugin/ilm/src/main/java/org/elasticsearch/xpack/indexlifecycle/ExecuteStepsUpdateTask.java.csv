commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;String getPolicy() {     return policy. }
false;;0;3;;Index getIndex() {     return index. }
false;;0;3;;Step getStartStep() {     return startStep. }
false;;0;3;;Step.StepKey getNextStepKey() {     return nextStepKey. }
true;public;1;97;/**  * {@link Step}s for the current index and policy are executed in succession until the next step to be  * executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not  * belong to the same phase as the executed step. All other types of steps are executed outside of this  * {@link ClusterStateUpdateTask}, so they are of no concern here.  *  * @param currentState The current state to execute the <code>startStep</code> with  * @return the new cluster state after cluster-state operations and step transitions are applied  * @throws IOException if any exceptions occur  */ ;/**  * {@link Step}s for the current index and policy are executed in succession until the next step to be  * executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not  * belong to the same phase as the executed step. All other types of steps are executed outside of this  * {@link ClusterStateUpdateTask}, so they are of no concern here.  *  * @param currentState The current state to execute the <code>startStep</code> with  * @return the new cluster state after cluster-state operations and step transitions are applied  * @throws IOException if any exceptions occur  */ @Override public ClusterState execute(final ClusterState currentState) throws IOException {     Step currentStep = startStep.     IndexMetaData indexMetaData = currentState.metaData().index(index).     if (indexMetaData == null) {         logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName()).         // This index doesn't exist any more, there's nothing to execute currently         return currentState.     }     Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData, LifecycleExecutionState.fromIndexMetadata(indexMetaData)).     if (currentStep.equals(registeredCurrentStep)) {         ClusterState state = currentState.         // cluster state wait step returns not completed         while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {             if (currentStep instanceof ClusterStateActionStep) {                 // cluster state action step so do the action and                 // move the cluster state to the next step                 logger.trace("[{}] performing cluster state action ({}) [{}]", index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey()).                 try {                     state = ((ClusterStateActionStep) currentStep).performAction(index, state).                 } catch (Exception exception) {                     return moveToErrorStep(state, currentStep.getKey(), exception).                 }                 // set here to make sure that the clusterProcessed knows to execute the                 // correct step if it an async action                 nextStepKey = currentStep.getNextStepKey().                 if (nextStepKey == null) {                     return state.                 } else {                     logger.trace("[{}] moving cluster state to next step [{}]", index.getName(), nextStepKey).                     state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(), nextStepKey, nowSupplier, false).                 }             } else {                 // set here to make sure that the clusterProcessed knows to execute the                 // correct step if it an async action                 nextStepKey = currentStep.getNextStepKey().                 // cluster state wait step so evaluate the                 // condition, if the condition is met move to the                 // next step, if its not met return the current                 // cluster state so it can be applied and we will                 // wait for the next trigger to evaluate the                 // condition again                 logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]", index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey()).                 ClusterStateWaitStep.Result result.                 try {                     result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, state).                 } catch (Exception exception) {                     return moveToErrorStep(state, currentStep.getKey(), exception).                 }                 if (result.isComplete()) {                     logger.trace("[{}] cluster state step condition met successfully ({}) [{}], moving to next step {}", index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey()).                     if (currentStep.getNextStepKey() == null) {                         return state.                     } else {                         state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(), currentStep.getNextStepKey(), nowSupplier, false).                     }                 } else {                     logger.trace("[{}] condition not met ({}) [{}], returning existing state", index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey()).                     // We may have executed a step and set "nextStepKey" to                     // a value, but in this case, since the condition was                     // not met, we can't advance any way, so don't attempt                     // to run the current step                     nextStepKey = null.                     ToXContentObject stepInfo = result.getInfomationContext().                     if (stepInfo == null) {                         return state.                     } else {                         return IndexLifecycleRunner.addStepInfoToClusterState(index, state, stepInfo).                     }                 }             }             // other processing can occur             if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {                 return state.             }             currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey()).         }         return state.     } else {         // either case we don't want to do anything now         return currentState.     } }
false;public;3;14;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     if (oldState.equals(newState) == false) {         IndexMetaData indexMetaData = newState.metaData().index(index).         if (nextStepKey != null && nextStepKey != TerminalPolicyStep.KEY && indexMetaData != null) {             logger.trace("[{}] step sequence starting with {} has completed, running next step {} if it is an async action", index.getName(), startStep.getKey(), nextStepKey).             // After the cluster state has been processed and we have moved             // to a new step, we need to conditionally execute the step iff             // it is an `AsyncAction` so that it is executed exactly once.             lifecycleRunner.maybeRunAsyncAction(newState, indexMetaData, policy, nextStepKey).         }     } }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     throw new ElasticsearchException("policy [" + policy + "] for index [" + index.getName() + "] failed on step [" + startStep.getKey() + "].", e). }
false;private;3;7;;private ClusterState moveToErrorStep(final ClusterState state, Step.StepKey currentStepKey, Exception cause) throws IOException {     logger.error("policy [{}] for index [{}] failed on cluster state step [{}]. Moving to ERROR step", policy, index.getName(), currentStepKey).     MoveToErrorStepUpdateTask moveToErrorStepUpdateTask = new MoveToErrorStepUpdateTask(index, policy, currentStepKey, cause, nowSupplier).     return moveToErrorStepUpdateTask.execute(state). }
