# id;timestamp;commentText;codeText;commentWords;codeWords
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(final ClusterState currentState) throws IOException;1538532170;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(final ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            LifecycleExecutionState.fromIndexMetadata(indexMetaData))__        if (currentStep.equals(registeredCurrentStep)) {_            ClusterState state = currentState__            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                nextStepKey = currentStep.getNextStepKey()__                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    state = ((ClusterStateActionStep) currentStep).performAction(index, state)__                    if (currentStep.getNextStepKey() == null) {_                        return state__                    } else {_                        state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                    }_                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, state)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return state__                        } else {_                            state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                        }_                    } else {_                        logger.debug("[{}] condition not met ({}), returning existing state", index.getName(), currentStep.getKey())__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return state__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, state, stepInfo)__                        }_                    }_                }_                _                _                _                _                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return state__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return state__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,final,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,lifecycle,execution,state,from,index,metadata,index,meta,data,if,current,step,equals,registered,current,step,cluster,state,state,current,state,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,next,step,key,current,step,get,next,step,key,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,state,cluster,state,action,step,current,step,perform,action,index,state,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,index,get,name,current,step,get,key,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(final ClusterState currentState) throws IOException;1539019518;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(final ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            LifecycleExecutionState.fromIndexMetadata(indexMetaData))__        if (currentStep.equals(registeredCurrentStep)) {_            ClusterState state = currentState__            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                nextStepKey = currentStep.getNextStepKey()__                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    state = ((ClusterStateActionStep) currentStep).performAction(index, state)__                    if (currentStep.getNextStepKey() == null) {_                        return state__                    } else {_                        state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                    }_                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, state)__                    if (result.isComplete()) {_                        logger.trace("[{}] cluster state step condition met successfully ({}) [{}], moving to next step {}",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                        if (currentStep.getNextStepKey() == null) {_                            return state__                        } else {_                            state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                        }_                    } else {_                        logger.trace("[{}] condition not met ({}) [{}], returning existing state",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey())__                        _                        _                        _                        _                        nextStepKey = null__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return state__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, state, stepInfo)__                        }_                    }_                }_                _                _                _                _                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return state__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return state__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,final,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,lifecycle,execution,state,from,index,metadata,index,meta,data,if,current,step,equals,registered,current,step,cluster,state,state,current,state,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,next,step,key,current,step,get,next,step,key,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,state,cluster,state,action,step,current,step,perform,action,index,state,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,state,if,result,is,complete,logger,trace,cluster,state,step,condition,met,successfully,moving,to,next,step,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,condition,not,met,returning,existing,state,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,next,step,key,null,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(final ClusterState currentState) throws IOException;1540928012;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(final ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            LifecycleExecutionState.fromIndexMetadata(indexMetaData))__        if (currentStep.equals(registeredCurrentStep)) {_            ClusterState state = currentState__            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                nextStepKey = currentStep.getNextStepKey()__                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    try {_                        state = ((ClusterStateActionStep) currentStep).performAction(index, state)__                    } catch (Exception exception) {_                        return moveToErrorStep(state, currentStep.getKey(), exception)__                    }_                    if (currentStep.getNextStepKey() == null) {_                        return state__                    } else {_                        state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                    }_                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result__                    try {_                        result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, state)__                    } catch (Exception exception) {_                        return moveToErrorStep(state, currentStep.getKey(), exception)__                    }_                    if (result.isComplete()) {_                        logger.trace("[{}] cluster state step condition met successfully ({}) [{}], moving to next step {}",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                        if (currentStep.getNextStepKey() == null) {_                            return state__                        } else {_                            state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                        }_                    } else {_                        logger.trace("[{}] condition not met ({}) [{}], returning existing state",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey())__                        _                        _                        _                        _                        nextStepKey = null__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return state__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, state, stepInfo)__                        }_                    }_                }_                _                _                _                _                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return state__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return state__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,final,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,lifecycle,execution,state,from,index,metadata,index,meta,data,if,current,step,equals,registered,current,step,cluster,state,state,current,state,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,next,step,key,current,step,get,next,step,key,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,try,state,cluster,state,action,step,current,step,perform,action,index,state,catch,exception,exception,return,move,to,error,step,state,current,step,get,key,exception,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,try,result,cluster,state,wait,step,current,step,is,condition,met,index,state,catch,exception,exception,return,move,to,error,step,state,current,step,get,key,exception,if,result,is,complete,logger,trace,cluster,state,step,condition,met,successfully,moving,to,next,step,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,condition,not,met,returning,existing,state,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,next,step,key,null,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(final ClusterState currentState) throws IOException;1542051179;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(final ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            LifecycleExecutionState.fromIndexMetadata(indexMetaData))__        if (currentStep.equals(registeredCurrentStep)) {_            ClusterState state = currentState__            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                nextStepKey = currentStep.getNextStepKey()__                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    try {_                        state = ((ClusterStateActionStep) currentStep).performAction(index, state)__                    } catch (Exception exception) {_                        return moveToErrorStep(state, currentStep.getKey(), exception)__                    }_                    if (currentStep.getNextStepKey() == null) {_                        return state__                    } else {_                        state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier, false)__                    }_                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result__                    try {_                        result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, state)__                    } catch (Exception exception) {_                        return moveToErrorStep(state, currentStep.getKey(), exception)__                    }_                    if (result.isComplete()) {_                        logger.trace("[{}] cluster state step condition met successfully ({}) [{}], moving to next step {}",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                        if (currentStep.getNextStepKey() == null) {_                            return state__                        } else {_                            state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier, false)__                        }_                    } else {_                        logger.trace("[{}] condition not met ({}) [{}], returning existing state",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey())__                        _                        _                        _                        _                        nextStepKey = null__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return state__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, state, stepInfo)__                        }_                    }_                }_                _                _                _                _                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return state__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return state__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,final,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,lifecycle,execution,state,from,index,metadata,index,meta,data,if,current,step,equals,registered,current,step,cluster,state,state,current,state,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,next,step,key,current,step,get,next,step,key,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,try,state,cluster,state,action,step,current,step,perform,action,index,state,catch,exception,exception,return,move,to,error,step,state,current,step,get,key,exception,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,false,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,try,result,cluster,state,wait,step,current,step,is,condition,met,index,state,catch,exception,exception,return,move,to,error,step,state,current,step,get,key,exception,if,result,is,complete,logger,trace,cluster,state,step,condition,met,successfully,moving,to,next,step,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,false,else,logger,trace,condition,not,met,returning,existing,state,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,next,step,key,null,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(final ClusterState currentState) throws IOException;1548889757;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(final ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            LifecycleExecutionState.fromIndexMetadata(indexMetaData))__        if (currentStep.equals(registeredCurrentStep)) {_            ClusterState state = currentState__            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey())__                    try {_                        state = ((ClusterStateActionStep) currentStep).performAction(index, state)__                    } catch (Exception exception) {_                        return moveToErrorStep(state, currentStep.getKey(), exception)__                    }_                    _                    _                    nextStepKey = currentStep.getNextStepKey()__                    if (nextStepKey == null) {_                        return state__                    } else {_                        logger.trace("[{}] moving cluster state to next step [{}]", index.getName(), nextStepKey)__                        state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                            nextStepKey, nowSupplier, false)__                    }_                } else {_                    _                    _                    nextStepKey = currentStep.getNextStepKey()__                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result__                    try {_                        result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, state)__                    } catch (Exception exception) {_                        return moveToErrorStep(state, currentStep.getKey(), exception)__                    }_                    if (result.isComplete()) {_                        logger.trace("[{}] cluster state step condition met successfully ({}) [{}], moving to next step {}",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                        if (currentStep.getNextStepKey() == null) {_                            return state__                        } else {_                            state = IndexLifecycleRunner.moveClusterStateToNextStep(index, state, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier, false)__                        }_                    } else {_                        logger.trace("[{}] condition not met ({}) [{}], returning existing state",_                            index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey())__                        _                        _                        _                        _                        nextStepKey = null__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return state__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, state, stepInfo)__                        }_                    }_                }_                _                _                _                _                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return state__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return state__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,final,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,lifecycle,execution,state,from,index,metadata,index,meta,data,if,current,step,equals,registered,current,step,cluster,state,state,current,state,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,try,state,cluster,state,action,step,current,step,perform,action,index,state,catch,exception,exception,return,move,to,error,step,state,current,step,get,key,exception,next,step,key,current,step,get,next,step,key,if,next,step,key,null,return,state,else,logger,trace,moving,cluster,state,to,next,step,index,get,name,next,step,key,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,next,step,key,now,supplier,false,else,next,step,key,current,step,get,next,step,key,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,try,result,cluster,state,wait,step,current,step,is,condition,met,index,state,catch,exception,exception,return,move,to,error,step,state,current,step,get,key,exception,if,result,is,complete,logger,trace,cluster,state,step,condition,met,successfully,moving,to,next,step,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,if,current,step,get,next,step,key,null,return,state,else,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,state,current,step,get,key,current,step,get,next,step,key,now,supplier,false,else,logger,trace,condition,not,met,returning,existing,state,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,next,step,key,null,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(ClusterState currentState) throws IOException;1534386621;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(ClusterState currentState) throws IOException {_        Step currentStep = startStep__        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy,_            currentState.metaData().index(index).getSettings())__        if (currentStep.equals(registeredCurrentStep)) {_            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    _                    currentState = ((ClusterStateActionStep) currentStep).performAction(index, currentState)__                    if (currentStep.getNextStepKey() == null) {_                        return currentState__                    }_                    currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                } else {_                    _                    _                    _                    _                    _                    _                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, currentState)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return currentState__                        }_                        currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                    } else {_                        logger.debug("condition not met, returning existing state")__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return currentState__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, currentState, stepInfo)__                        }_                    }_                }_                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return currentState__                }_                currentStep = policyStepsRegistry.getStep(policy, currentStep.getNextStepKey())__            }_            return currentState__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,cluster,state,current,state,throws,ioexception,step,current,step,start,step,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,current,state,meta,data,index,index,get,settings,if,current,step,equals,registered,current,step,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,current,state,cluster,state,action,step,current,step,perform,action,index,current,state,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,current,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,current,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,current,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,current,state,current,step,policy,steps,registry,get,step,policy,current,step,get,next,step,key,return,current,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(ClusterState currentState) throws IOException;1534567515;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,_            indexMetaData.getSettings())__        if (currentStep.equals(registeredCurrentStep)) {_            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    currentState = ((ClusterStateActionStep) currentStep).performAction(index, currentState)__                    if (currentStep.getNextStepKey() == null) {_                        return currentState__                    }_                    currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, currentState)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return currentState__                        }_                        currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                    } else {_                        logger.debug("condition not met, returning existing state")__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return currentState__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, currentState, stepInfo)__                        }_                    }_                }_                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return currentState__                }_                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey())__            }_            return currentState__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,index,meta,data,get,settings,if,current,step,equals,registered,current,step,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,current,state,cluster,state,action,step,current,step,perform,action,index,current,state,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,current,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,current,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,current,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,current,state,current,step,policy,steps,registry,get,step,index,current,step,get,next,step,key,return,current,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(ClusterState currentState) throws IOException;1534899572;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,_            indexMetaData.getSettings())__        if (currentStep.equals(registeredCurrentStep)) {_            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    currentState = ((ClusterStateActionStep) currentStep).performAction(index, currentState)__                    if (currentStep.getNextStepKey() == null) {_                        return currentState__                    }_                    currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, currentState)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return currentState__                        }_                        currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                    } else {_                        logger.debug("condition not met, returning existing state")__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return currentState__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, currentState, stepInfo)__                        }_                    }_                }_                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return currentState__                }_                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey())__            }_            return currentState__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,index,meta,data,get,settings,if,current,step,equals,registered,current,step,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,current,state,cluster,state,action,step,current,step,perform,action,index,current,state,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,current,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,current,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,current,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,current,state,current,step,policy,steps,registry,get,step,index,current,step,get,next,step,key,return,current,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(ClusterState currentState) throws IOException;1536322011;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, index,_            indexMetaData.getSettings())__        if (currentStep.equals(registeredCurrentStep)) {_            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    currentState = ((ClusterStateActionStep) currentStep).performAction(index, currentState)__                    if (currentStep.getNextStepKey() == null) {_                        return currentState__                    }_                    currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, currentState)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return currentState__                        }_                        currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                    } else {_                        logger.debug("condition not met, returning existing state")__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return currentState__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, currentState, stepInfo)__                        }_                    }_                }_                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return currentState__                }_                currentStep = policyStepsRegistry.getStep(index, currentStep.getNextStepKey())__            }_            return currentState__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,index,meta,data,get,settings,if,current,step,equals,registered,current,step,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,current,state,cluster,state,action,step,current,step,perform,action,index,current,state,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,current,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,current,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,current,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,current,state,current,step,policy,steps,registry,get,step,index,current,step,get,next,step,key,return,current,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(ClusterState currentState) throws IOException;1537312077;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            indexMetaData.getSettings())__        if (currentStep.equals(registeredCurrentStep)) {_            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    currentState = ((ClusterStateActionStep) currentStep).performAction(index, currentState)__                    if (currentStep.getNextStepKey() == null) {_                        return currentState__                    }_                    currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, currentState)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return currentState__                        }_                        currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                    } else {_                        logger.debug("condition not met, returning existing state")__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return currentState__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, currentState, stepInfo)__                        }_                    }_                }_                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return currentState__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return currentState__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,index,meta,data,get,settings,if,current,step,equals,registered,current,step,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,current,state,cluster,state,action,step,current,step,perform,action,index,current,state,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,current,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,current,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,current,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,current,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,current,state,else,return,current,state
ExecuteStepsUpdateTask -> @Override     public ClusterState execute(ClusterState currentState) throws IOException;1537390248;{@link Step}s for the current index and policy are executed in succession until the next step to be_executed is not a {@link ClusterStateActionStep}, or not a {@link ClusterStateWaitStep}, or does not_belong to the same phase as the executed step. All other types of steps are executed outside of this_{@link ClusterStateUpdateTask}, so they are of no concern here.__@param currentState The current state to execute the <code>startStep</code> with_@return the new cluster state after cluster-state operations and step transitions are applied_@throws IOException if any exceptions occur;@Override_    public ClusterState execute(ClusterState currentState) throws IOException {_        Step currentStep = startStep__        IndexMetaData indexMetaData = currentState.metaData().index(index)__        if (indexMetaData == null) {_            logger.debug("lifecycle for index [{}] executed but index no longer exists", index.getName())__            _            return currentState__        }_        Step registeredCurrentStep = IndexLifecycleRunner.getCurrentStep(policyStepsRegistry, policy, indexMetaData,_            LifecycleExecutionState.fromIndexMetadata(indexMetaData))__        if (currentStep.equals(registeredCurrentStep)) {_            _            _            _            while (currentStep instanceof ClusterStateActionStep || currentStep instanceof ClusterStateWaitStep) {_                if (currentStep instanceof ClusterStateActionStep) {_                    _                    _                    _                    logger.trace("[{}] performing cluster state action ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    currentState = ((ClusterStateActionStep) currentStep).performAction(index, currentState)__                    if (currentStep.getNextStepKey() == null) {_                        return currentState__                    }_                    currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                            currentStep.getNextStepKey(), nowSupplier)__                } else {_                    _                    _                    _                    _                    _                    _                    logger.trace("[{}] waiting for cluster state step condition ({}) [{}], next: [{}]",_                        index.getName(), currentStep.getClass().getSimpleName(), currentStep.getKey(), currentStep.getNextStepKey())__                    ClusterStateWaitStep.Result result = ((ClusterStateWaitStep) currentStep).isConditionMet(index, currentState)__                    if (result.isComplete()) {_                        if (currentStep.getNextStepKey() == null) {_                            return currentState__                        }_                        currentState = IndexLifecycleRunner.moveClusterStateToNextStep(index, currentState, currentStep.getKey(),_                                currentStep.getNextStepKey(), nowSupplier)__                    } else {_                        logger.debug("condition not met, returning existing state")__                        ToXContentObject stepInfo = result.getInfomationContext()__                        if (stepInfo == null) {_                            return currentState__                        } else {_                            return IndexLifecycleRunner.addStepInfoToClusterState(index, currentState, stepInfo)__                        }_                    }_                }_                if (currentStep.getKey().getPhase().equals(currentStep.getNextStepKey().getPhase()) == false) {_                    return currentState__                }_                currentStep = policyStepsRegistry.getStep(indexMetaData, currentStep.getNextStepKey())__            }_            return currentState__        } else {_            _            _            _            return currentState__        }_    };link,step,s,for,the,current,index,and,policy,are,executed,in,succession,until,the,next,step,to,be,executed,is,not,a,link,cluster,state,action,step,or,not,a,link,cluster,state,wait,step,or,does,not,belong,to,the,same,phase,as,the,executed,step,all,other,types,of,steps,are,executed,outside,of,this,link,cluster,state,update,task,so,they,are,of,no,concern,here,param,current,state,the,current,state,to,execute,the,code,start,step,code,with,return,the,new,cluster,state,after,cluster,state,operations,and,step,transitions,are,applied,throws,ioexception,if,any,exceptions,occur;override,public,cluster,state,execute,cluster,state,current,state,throws,ioexception,step,current,step,start,step,index,meta,data,index,meta,data,current,state,meta,data,index,index,if,index,meta,data,null,logger,debug,lifecycle,for,index,executed,but,index,no,longer,exists,index,get,name,return,current,state,step,registered,current,step,index,lifecycle,runner,get,current,step,policy,steps,registry,policy,index,meta,data,lifecycle,execution,state,from,index,metadata,index,meta,data,if,current,step,equals,registered,current,step,while,current,step,instanceof,cluster,state,action,step,current,step,instanceof,cluster,state,wait,step,if,current,step,instanceof,cluster,state,action,step,logger,trace,performing,cluster,state,action,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,current,state,cluster,state,action,step,current,step,perform,action,index,current,state,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,trace,waiting,for,cluster,state,step,condition,next,index,get,name,current,step,get,class,get,simple,name,current,step,get,key,current,step,get,next,step,key,cluster,state,wait,step,result,result,cluster,state,wait,step,current,step,is,condition,met,index,current,state,if,result,is,complete,if,current,step,get,next,step,key,null,return,current,state,current,state,index,lifecycle,runner,move,cluster,state,to,next,step,index,current,state,current,step,get,key,current,step,get,next,step,key,now,supplier,else,logger,debug,condition,not,met,returning,existing,state,to,xcontent,object,step,info,result,get,infomation,context,if,step,info,null,return,current,state,else,return,index,lifecycle,runner,add,step,info,to,cluster,state,index,current,state,step,info,if,current,step,get,key,get,phase,equals,current,step,get,next,step,key,get,phase,false,return,current,state,current,step,policy,steps,registry,get,step,index,meta,data,current,step,get,next,step,key,return,current,state,else,return,current,state
